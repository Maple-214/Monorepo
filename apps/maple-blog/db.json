{
  "meta": { "version": 1, "warehouse": "5.0.1" },
  "models": {
    "Asset": [
      { "_id": "source/CNAME", "path": "CNAME", "modified": 0, "renderable": 0 },
      { "_id": "themes/butterfly/source/CNAME", "path": "CNAME", "modified": 0, "renderable": 1 },
      {
        "_id": "themes/butterfly/source/ads.txt",
        "path": "ads.txt",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/robots.txt",
        "path": "robots.txt",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/css/index.styl",
        "path": "css/index.styl",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/css/var.styl",
        "path": "css/var.styl",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/404.jpg",
        "path": "img/404.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/avatar.jpg",
        "path": "img/avatar.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/favicon.png",
        "path": "img/favicon.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/friend_404.gif",
        "path": "img/friend_404.gif",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/main.js",
        "path": "js/main.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/tw_cn.js",
        "path": "js/tw_cn.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/utils.js",
        "path": "js/utils.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-01.png",
        "path": "img/TypeScript/01-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-02.png",
        "path": "img/TypeScript/01-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-03.png",
        "path": "img/TypeScript/01-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-04.png",
        "path": "img/TypeScript/01-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-05.png",
        "path": "img/TypeScript/01-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-07.png",
        "path": "img/TypeScript/01-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-01.png",
        "path": "img/TypeScript/02-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-02.png",
        "path": "img/TypeScript/02-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-03.png",
        "path": "img/TypeScript/02-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-04.png",
        "path": "img/TypeScript/02-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-05.png",
        "path": "img/TypeScript/02-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-06.png",
        "path": "img/TypeScript/02-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-07.png",
        "path": "img/TypeScript/02-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-08.png",
        "path": "img/TypeScript/02-08.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-09.png",
        "path": "img/TypeScript/02-09.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-10.png",
        "path": "img/TypeScript/02-10.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-11.png",
        "path": "img/TypeScript/02-11.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-12.png",
        "path": "img/TypeScript/02-12.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-13.png",
        "path": "img/TypeScript/02-13.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-01.png",
        "path": "img/TypeScript/03-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-02.png",
        "path": "img/TypeScript/03-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-03.png",
        "path": "img/TypeScript/03-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-04.png",
        "path": "img/TypeScript/03-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-05.png",
        "path": "img/TypeScript/03-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-06.png",
        "path": "img/TypeScript/03-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-07.png",
        "path": "img/TypeScript/03-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-08.png",
        "path": "img/TypeScript/03-08.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-09.png",
        "path": "img/TypeScript/03-09.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-10.png",
        "path": "img/TypeScript/03-10.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-11.png",
        "path": "img/TypeScript/03-11.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-12.png",
        "path": "img/TypeScript/03-12.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-13.png",
        "path": "img/TypeScript/03-13.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-14.png",
        "path": "img/TypeScript/03-14.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-002.png",
        "path": "img/TypeScript/04-002.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-01.png",
        "path": "img/TypeScript/04-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-03.png",
        "path": "img/TypeScript/04-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-04.png",
        "path": "img/TypeScript/04-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-05.png",
        "path": "img/TypeScript/04-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-06.png",
        "path": "img/TypeScript/04-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-07.png",
        "path": "img/TypeScript/04-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-08.png",
        "path": "img/TypeScript/04-08.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-09.png",
        "path": "img/TypeScript/04-09.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-10.png",
        "path": "img/TypeScript/04-10.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-11.png",
        "path": "img/TypeScript/04-11.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-12.png",
        "path": "img/TypeScript/04-12.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-13.png",
        "path": "img/TypeScript/04-13.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-14.png",
        "path": "img/TypeScript/04-14.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-15.png",
        "path": "img/TypeScript/04-15.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-16.png",
        "path": "img/TypeScript/04-16.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-01.png",
        "path": "img/TypeScript/05-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-02.png",
        "path": "img/TypeScript/05-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-03.png",
        "path": "img/TypeScript/05-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-04.png",
        "path": "img/TypeScript/05-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-05.png",
        "path": "img/TypeScript/05-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-06.png",
        "path": "img/TypeScript/05-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-07.png",
        "path": "img/TypeScript/05-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-01.png",
        "path": "img/TypeScript/06-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-06.png",
        "path": "img/TypeScript/01-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-02.png",
        "path": "img/TypeScript/06-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-04.png",
        "path": "img/TypeScript/06-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-05.png",
        "path": "img/TypeScript/06-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-06.png",
        "path": "img/TypeScript/06-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-07.png",
        "path": "img/TypeScript/06-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-03.png",
        "path": "img/TypeScript/06-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-08.png",
        "path": "img/TypeScript/06-08.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-09.png",
        "path": "img/TypeScript/06-09.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-10.png",
        "path": "img/TypeScript/06-10.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-11.png",
        "path": "img/TypeScript/06-11.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-12.png",
        "path": "img/TypeScript/06-12.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-13.png",
        "path": "img/TypeScript/06-13.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-14.png",
        "path": "img/TypeScript/06-14.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-15.png",
        "path": "img/TypeScript/06-15.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-16.png",
        "path": "img/TypeScript/06-16.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-17.png",
        "path": "img/TypeScript/06-17.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-18.png",
        "path": "img/TypeScript/06-18.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-01.png",
        "path": "img/TypeScript/07-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-02.png",
        "path": "img/TypeScript/07-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-03.png",
        "path": "img/TypeScript/07-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-04.png",
        "path": "img/TypeScript/07-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-05.png",
        "path": "img/TypeScript/07-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-06.png",
        "path": "img/TypeScript/07-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-07.png",
        "path": "img/TypeScript/07-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-08.png",
        "path": "img/TypeScript/07-08.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-01.png",
        "path": "img/TypeScript/08-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-02.png",
        "path": "img/TypeScript/08-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-03.png",
        "path": "img/TypeScript/08-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-04.png",
        "path": "img/TypeScript/08-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-05.png",
        "path": "img/TypeScript/08-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-01.png",
        "path": "img/TypeScript/09-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-02.png",
        "path": "img/TypeScript/09-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-04.png",
        "path": "img/TypeScript/09-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-05.png",
        "path": "img/TypeScript/09-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-06.png",
        "path": "img/TypeScript/09-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-07.png",
        "path": "img/TypeScript/09-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-08.png",
        "path": "img/TypeScript/09-08.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-09.png",
        "path": "img/TypeScript/09-09.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-10.png",
        "path": "img/TypeScript/09-10.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-11.png",
        "path": "img/TypeScript/09-11.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-12.png",
        "path": "img/TypeScript/09-12.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-13.png",
        "path": "img/TypeScript/09-13.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-14.png",
        "path": "img/TypeScript/09-14.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-15.png",
        "path": "img/TypeScript/09-15.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-16.png",
        "path": "img/TypeScript/09-16.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-17.png",
        "path": "img/TypeScript/09-17.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-18.png",
        "path": "img/TypeScript/09-18.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-19.png",
        "path": "img/TypeScript/09-19.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-20.png",
        "path": "img/TypeScript/09-20.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-22.png",
        "path": "img/TypeScript/09-22.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-21.png",
        "path": "img/TypeScript/09-21.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-23.png",
        "path": "img/TypeScript/09-23.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-24.png",
        "path": "img/TypeScript/09-24.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-25.png",
        "path": "img/TypeScript/09-25.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-01.png",
        "path": "img/TypeScript/10-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-02.png",
        "path": "img/TypeScript/10-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-03.png",
        "path": "img/TypeScript/10-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-04.png",
        "path": "img/TypeScript/10-04.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-05.png",
        "path": "img/TypeScript/10-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-06.png",
        "path": "img/TypeScript/10-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-01.png",
        "path": "img/TypeScript/11-01.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-02.png",
        "path": "img/TypeScript/11-02.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-03.png",
        "path": "img/TypeScript/11-03.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-05.png",
        "path": "img/TypeScript/11-05.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-06.png",
        "path": "img/TypeScript/11-06.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-07.png",
        "path": "img/TypeScript/11-07.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-08.png",
        "path": "img/TypeScript/11-08.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-4.png",
        "path": "img/TypeScript/11-4.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/目录（基础篇）.png",
        "path": "img/TypeScript/目录（基础篇）.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/目录（高级篇）.png",
        "path": "img/TypeScript/目录（高级篇）.png",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/banner/banner_01.jpg",
        "path": "img/banner/banner_01.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/cover/cover_01.jpg",
        "path": "img/cover/cover_01.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/cover/cover_02.jpeg",
        "path": "img/cover/cover_02.jpeg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/cover/cover_03.jpg",
        "path": "img/cover/cover_03.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/qrCode/alipay.jpg",
        "path": "img/qrCode/alipay.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/qrCode/wechat.jpg",
        "path": "img/qrCode/wechat.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_01.jpg",
        "path": "img/recommend/recommend_01.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_02.jpg",
        "path": "img/recommend/recommend_02.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_03.jpg",
        "path": "img/recommend/recommend_03.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_04.jpg",
        "path": "img/recommend/recommend_04.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_05.jpg",
        "path": "img/recommend/recommend_05.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_06.jpg",
        "path": "img/recommend/recommend_06.jpg",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/search/local-search.js",
        "path": "js/search/local-search.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/search/algolia.js",
        "path": "js/search/algolia.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/src/jquery.js",
        "path": "js/src/jquery.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/src/nav.js",
        "path": "js/src/nav.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/src/sakura.js",
        "path": "js/src/sakura.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/src/vue.js",
        "path": "js/src/vue.js",
        "modified": 0,
        "renderable": 1
      },
      {
        "_id": "themes/butterfly/source/js/src/vue_js.js",
        "path": "js/src/vue_js.js",
        "modified": 0,
        "renderable": 1
      }
    ],
    "Cache": [
      {
        "_id": "source/baidu_verify_codeva-JddVaE5CKl.html",
        "hash": "668f450c4fa1057023286b596c34c411744e372b",
        "modified": 1706335522497
      },
      {
        "_id": "source/categories/index.md",
        "hash": "97e77508177a3e1d6d5f13dfbd1506e9270792ee",
        "modified": 1706439589540
      },
      {
        "_id": "source/_posts/日本語/TypeScript/1-1、基本：TypeScriptの概要.md",
        "hash": "38bf77dcf7a8b6dce3e5791907be0661574d549b",
        "modified": 1707919422489
      },
      {
        "_id": "source/_posts/日本語/TypeScript/1-4、基本：TypeScriptの型削減.md",
        "hash": "1def11c5f0362cebcfaf3e94a2a02b6ee0277240",
        "modified": 1707985458086
      },
      {
        "_id": "source/_posts/日本語/TypeScript/1-2、基本：TypeScriptの概要.md",
        "hash": "52f5cf8d4b61ce70e89f6ed5071ee782032477a0",
        "modified": 1707919421936
      },
      {
        "_id": "source/CNAME",
        "hash": "0b0154a92c4d0287ecfffd8dc5ddf165350840da",
        "modified": 1706162931232
      },
      {
        "_id": "source/_posts/日本語/TypeScript/1-3、基本：TypeScriptのよくある種類.md",
        "hash": "a4a0ebadc0528a3e5a07913c9b4d706ac46e55e2",
        "modified": 1707984128453
      },
      {
        "_id": "source/_posts/日本語/Css/1-1、ホバリング時のジッターの原因と解決策.md",
        "hash": "81bbb710d2824a0ddd1e23b7ea7c21e2701221ef",
        "modified": 1707983247068
      },
      {
        "_id": "source/tags/index.md",
        "hash": "34fdf6957ae09e6b151ab23e29d39ccc4ad334a2",
        "modified": 1706435728508
      },
      {
        "_id": "source/_posts/简体中文/Css/1-1、CSS中hover时出现抖动的原因和解决方法.md",
        "hash": "e9889dce13f04bc7cce25088805ee4512efae345",
        "modified": 1707983225700
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-1、基础篇：TypeScript介绍.md",
        "hash": "6606f4cd93b56425e66fe3f8206dbf32dae54f5f",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-2、基础篇：TypeScript入门.md",
        "hash": "55315295bc51c604c0e27531e402075cd40b4d34",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-4、基础篇：类型缩小.md",
        "hash": "44f194e1c2c9a816dfba3da074d17d24d6042a5c",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-3、基础篇：常用类型.md",
        "hash": "5aa6603f0f3e325dc6d19c943edaaafab76d3cbe",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-5、基础篇：函数更多.md",
        "hash": "8580cad665a5ac10d04ef068c3f469b831b1fb98",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-6、基础篇：对象类型.md",
        "hash": "547ec7bc037556c458e0c91cad542ea44a339e0f",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-7、基础篇：类型操纵.md",
        "hash": "c90d91fa09a0c67a4a7c0d09b8c0b330df83dd86",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-8、基础篇：类.md",
        "hash": "f6145cd95baef65568dd76c598e5df8385845e92",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/1-9、基础篇：模块.md",
        "hash": "eb89820e4b63ce2365c4c3b72df8bccb754b08ab",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-1、高级篇：变量声明.md",
        "hash": "da5829a7fe711033f6a38fb9b49c29898e635e46",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-3、高级篇：枚举.md",
        "hash": "3827f5194648bffd82c015b0a8625ab65845df0e",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-2、高级篇：类型推断.md",
        "hash": "1a830a63e5acd99a663bd99f33ce9d35bafd43b1",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-4、高级篇：公共类型.md",
        "hash": "866d3575ca267fb27b02f4b6f5a0cd1b9f6b8537",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-6、高级篇：类型兼容性.md",
        "hash": "0777ea35b0334ddb1584cd39250a519a9fec514b",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-5、高级篇：Symbols.md",
        "hash": "2396d2a4a0b5edae2743ce9e66d19cb5c035dd7b",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-7、高级篇：迭代器和生成器.md",
        "hash": "afe265205f2f26ebb711912ae2570f4b91adaa09",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-9、高级篇：JSX.md",
        "hash": "0de66fecc2da5c898f51a5ea0d471611ce6bffe9",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/3-1、高级篇：混入.md",
        "hash": "0dbc63500bc34da9b8d5e9d9545ba6bf6f31bf20",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/3-3、高级篇：模块.md",
        "hash": "55db9781ea3c066ca7ab8518da771cfec001af60",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/3-4、高级篇：模块解析.md",
        "hash": "0e7cd22f5c1199655652aa476705c90a4ef819e2",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/3-5、高级篇：命名空间.md",
        "hash": "6c2971a6f6308c5c425bd8aeb48d8c84ef70fb22",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/2-8、高级篇：装饰器（Decorators）.md",
        "hash": "dba7f20fdcb9e5ac45767a19f934af2d11c5fec9",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/3-6、高级篇：命名空间与模块.md",
        "hash": "7457022cc5c977a9377ec02224d453735570584c",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/3-2、高级篇：三斜线指令.md",
        "hash": "70b7acb7dd9439c64762ec7f0aad46640c8870d6",
        "modified": 1706449602267
      },
      {
        "_id": "source/_posts/简体中文/TypeScript/3-7、高级篇：声明合并.md",
        "hash": "35f3d6bcfda130723586969ac38adff6e594e25e",
        "modified": 1706449602268
      },
      {
        "_id": "themes/butterfly/package.json",
        "hash": "5aeca0522902fc5a9e5f92850143fae9585f0677",
        "modified": 1706206770091
      },
      {
        "_id": "themes/butterfly/README.md",
        "hash": "c03e6d2ba37f5280e553f0452879cb2db5cffc4d",
        "modified": 1706206770156
      },
      {
        "_id": "themes/butterfly/_config.yml",
        "hash": "f0e20005918cd61b5f0344b919e8f6d86fbb5937",
        "modified": 1707985595202
      },
      {
        "_id": "themes/butterfly/languages/ja.yml",
        "hash": "53439513508b7c7698a44086a67efa404bb71fae",
        "modified": 1706433874114
      },
      {
        "_id": "themes/butterfly/README_CN.md",
        "hash": "0f2ea8b3750db964a49a6d67aafb46f845a5a946",
        "modified": 1706206770142
      },
      {
        "_id": "themes/butterfly/languages/default.yml",
        "hash": "ebb14ad0e97194150cf88320a0c9a45e148181f6",
        "modified": 1706206769842
      },
      {
        "_id": "themes/butterfly/languages/en.yml",
        "hash": "ebb14ad0e97194150cf88320a0c9a45e148181f6",
        "modified": 1706206769859
      },
      {
        "_id": "themes/butterfly/LICENSE",
        "hash": "c8bc7df08db9dd3b39c2c2259a163a36cf2f6808",
        "modified": 1706107425705
      },
      {
        "_id": "themes/butterfly/.github/FUNDING.yml",
        "hash": "4af1026b7f33e68bfc335c770b38e2443613c30a",
        "modified": 1706206769792
      },
      {
        "_id": "themes/butterfly/plugins.yml",
        "hash": "f1fa046ff46928dd3827ad19663bf99a1a915a09",
        "modified": 1706206770108
      },
      {
        "_id": "themes/butterfly/languages/zh-CN.yml",
        "hash": "2bb32322f3a18165600c94b63c552ce7c9aa8fb2",
        "modified": 1706206769872
      },
      {
        "_id": "themes/butterfly/layout/category.pug",
        "hash": "bf979aec88d78b644fc5d31518f8679ad7625792",
        "modified": 1706107425709
      },
      {
        "_id": "themes/butterfly/layout/page.pug",
        "hash": "bf2d6c6d2d156777b55292e51be02b0b3acf0af8",
        "modified": 1706107425741
      },
      {
        "_id": "themes/butterfly/layout/index.pug",
        "hash": "648dcbdb3d145a710de81c909e000e8664d2ac9c",
        "modified": 1706107425740
      },
      {
        "_id": "themes/butterfly/layout/archive.pug",
        "hash": "bc77220dfc269b8faad0930e1a4142ebf68165e5",
        "modified": 1706107425708
      },
      {
        "_id": "themes/butterfly/source/robots.txt",
        "hash": "6f855a7ab80bfc7cd5517c652126c2b86e225a95",
        "modified": 1706459648525
      },
      {
        "_id": "themes/butterfly/source/CNAME",
        "hash": "0b0154a92c4d0287ecfffd8dc5ddf165350840da",
        "modified": 1706461198626
      },
      {
        "_id": "themes/butterfly/source/ads.txt",
        "hash": "332155d31c64d03379883c36522803b9bfba8450",
        "modified": 1707919383686
      },
      {
        "_id": "themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml",
        "hash": "bf8a1950601c9dd5fe72574f4e5be3d598008ad8",
        "modified": 1706206769809
      },
      {
        "_id": "themes/butterfly/layout/tag.pug",
        "hash": "4bb5efc6dabdf1626685bf6771aaa1467155ae86",
        "modified": 1706107425741
      },
      {
        "_id": "themes/butterfly/.github/ISSUE_TEMPLATE/config.yml",
        "hash": "73e7e28b29df2587295ab02a7fab5d045c4c4f65",
        "modified": 1706206769809
      },
      {
        "_id": "themes/butterfly/layout/post.pug",
        "hash": "fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0",
        "modified": 1706107425741
      },
      {
        "_id": "themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml",
        "hash": "b2124867531955720e1c2046a2e22a9ad09b1f00",
        "modified": 1706206769809
      },
      {
        "_id": "themes/butterfly/.github/workflows/stale.yml",
        "hash": "5369cab4260b44c1c55e3e762ed717c08cdc2d08",
        "modified": 1706206769825
      },
      {
        "_id": "themes/butterfly/.github/workflows/publish.yml",
        "hash": "bc494e9ddea7a06c257c3829f269a9997f76de52",
        "modified": 1706206769825
      },
      {
        "_id": "themes/butterfly/layout/includes/404.pug",
        "hash": "aace9ddff469de4226e47a52ede1c81e66d66d5c",
        "modified": 1706107425709
      },
      {
        "_id": "themes/butterfly/layout/includes/additional-js.pug",
        "hash": "50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e",
        "modified": 1706107425709
      },
      {
        "_id": "themes/butterfly/layout/includes/footer.pug",
        "hash": "1ca7d2a91e15bf040d7b97bf98f909fcfb203e52",
        "modified": 1706175464247
      },
      {
        "_id": "themes/butterfly/layout/includes/head.pug",
        "hash": "ea8d4e8ac6af93cd268ba8f6ffcb80417bc2501e",
        "modified": 1706107425710
      },
      {
        "_id": "themes/butterfly/layout/includes/layout.pug",
        "hash": "b86525827680d80c3e2ce2fbe30c326444429786",
        "modified": 1706290341122
      },
      {
        "_id": "themes/butterfly/layout/includes/pagination.pug",
        "hash": "c5c58714fb3cb839653e5c32e6094784c8662935",
        "modified": 1706107425717
      },
      {
        "_id": "themes/butterfly/layout/includes/rightside.pug",
        "hash": "e31dbc2f792ec23eb0b54d1a7d406b979394c99a",
        "modified": 1706461521832
      },
      {
        "_id": "themes/butterfly/scripts/events/404.js",
        "hash": "d91a24ebb5ad7c6eb1d41cb63404da8b39c300bc",
        "modified": 1706206770175
      },
      {
        "_id": "themes/butterfly/layout/includes/sidebar.pug",
        "hash": "9277fead4c29dbe93976f078adaa26e8f9253da3",
        "modified": 1706107425718
      },
      {
        "_id": "themes/butterfly/scripts/events/cdn.js",
        "hash": "028e1a15cbe7e432862d4e1522321955c65e1d29",
        "modified": 1706206770195
      },
      {
        "_id": "themes/butterfly/scripts/events/comment.js",
        "hash": "42ab62cf9e9f701df13f4d349ea3f73b193a5517",
        "modified": 1706206770208
      },
      {
        "_id": "themes/butterfly/scripts/events/init.js",
        "hash": "060e1bc67e58a66da749a5b7abf74a4551817311",
        "modified": 1706206770208
      },
      {
        "_id": "themes/butterfly/scripts/events/merge_config.js",
        "hash": "0c2880d80e60e44600d2915e8dc56726299e955c",
        "modified": 1707982542665
      },
      {
        "_id": "themes/butterfly/scripts/events/welcome.js",
        "hash": "6c0ea3f3b34a29f6012efcc8e2e3182a707074c9",
        "modified": 1706206770258
      },
      {
        "_id": "themes/butterfly/scripts/events/stylus.js",
        "hash": "06f1cb85150c3f392a745463745f22d7beedc6ea",
        "modified": 1706206770242
      },
      {
        "_id": "themes/butterfly/scripts/helpers/aside_categories.js",
        "hash": "05ad337c6d0bc75acefe92c5eb5ddf876ccb3e95",
        "modified": 1706206770291
      },
      {
        "_id": "themes/butterfly/scripts/filters/random_cover.js",
        "hash": "d6dd5d40ef25ff294749c47e499692459131c876",
        "modified": 1706206770273
      },
      {
        "_id": "themes/butterfly/scripts/filters/post_lazyload.js",
        "hash": "eafae93c9c0b5f21caa1aa2cd0f259d9d33de665",
        "modified": 1706206770258
      },
      {
        "_id": "themes/butterfly/scripts/helpers/findArchiveLength.js",
        "hash": "9bfb3a8674166e0690b40afdb5637b4a41cbad77",
        "modified": 1706206770305
      },
      {
        "_id": "themes/butterfly/scripts/helpers/related_post.js",
        "hash": "a584cb16fb7a7af3ff523b02250e3ac82eed785f",
        "modified": 1706206770325
      },
      {
        "_id": "themes/butterfly/scripts/helpers/aside_archives.js",
        "hash": "0f29af6bf15b2bc95416054797d982550365f0ce",
        "modified": 1706206770288
      },
      {
        "_id": "themes/butterfly/scripts/helpers/page.js",
        "hash": "3ef63c38f45ec8580561fa6bdff78cd89856e55b",
        "modified": 1706206770322
      },
      {
        "_id": "themes/butterfly/scripts/helpers/series.js",
        "hash": "6458ee0c4ce434d3a65945e07a733ba34f24a165",
        "modified": 1706206770337
      },
      {
        "_id": "themes/butterfly/scripts/helpers/inject_head_js.js",
        "hash": "12b03d79f982e8c45c669c59ac4f8cab13ec2016",
        "modified": 1706206770309
      },
      {
        "_id": "themes/butterfly/scripts/tag/gallery.js",
        "hash": "d4460f03debb06f8e531ceb315c1c87140cc13bc",
        "modified": 1706206770354
      },
      {
        "_id": "themes/butterfly/scripts/tag/flink.js",
        "hash": "b473df1a25ac804e39b71e360c0620a151d2a773",
        "modified": 1706206770341
      },
      {
        "_id": "themes/butterfly/scripts/tag/button.js",
        "hash": "a8611ee0ff818a36ca227202371de079925aeb36",
        "modified": 1706206770341
      },
      {
        "_id": "themes/butterfly/scripts/tag/hide.js",
        "hash": "1cd6ddc57feadc63f8bdc43fe124dad3a5f2d74a",
        "modified": 1706206770358
      },
      {
        "_id": "themes/butterfly/scripts/tag/note.js",
        "hash": "719624260538c5d5b1b224c6721a0b36af6ef5b5",
        "modified": 1706206770374
      },
      {
        "_id": "themes/butterfly/scripts/tag/inlineImg.js",
        "hash": "e3c8777c86bd5aa1a509b8de4723ae87ba94518d",
        "modified": 1706206770358
      },
      {
        "_id": "themes/butterfly/scripts/tag/mermaid.js",
        "hash": "dc364b0add873c060dc6d48e5dfc867dd018c23f",
        "modified": 1706206770370
      },
      {
        "_id": "themes/butterfly/scripts/tag/label.js",
        "hash": "3a46b05fad365f36b6ea1bf01e0716d73b3e090d",
        "modified": 1706206770358
      },
      {
        "_id": "themes/butterfly/scripts/tag/series.js",
        "hash": "562c3fbc856ff7cc1a62b254a0354ff43486bf31",
        "modified": 1706206770374
      },
      {
        "_id": "themes/butterfly/scripts/tag/timeline.js",
        "hash": "6d5592d5d51076f40a936ab8e6804e68fcdfebfc",
        "modified": 1706206770391
      },
      {
        "_id": "themes/butterfly/scripts/tag/score.js",
        "hash": "85b4cc3ca26b433ddc83c074fa9a5656cf88f9f3",
        "modified": 1706206770374
      },
      {
        "_id": "themes/butterfly/scripts/tag/tabs.js",
        "hash": "076663cc41470cdca326cb7235c795fb5ae68829",
        "modified": 1706206770391
      },
      {
        "_id": "themes/butterfly/source/img/404.jpg",
        "hash": "fb4489bc1d30c93d28f7332158c1c6c1416148de",
        "modified": 1706107425765
      },
      {
        "_id": "themes/butterfly/source/css/index.styl",
        "hash": "02171b11b5faa469f8b3f70765400b0f66c52563",
        "modified": 1706172312898
      },
      {
        "_id": "themes/butterfly/source/img/favicon.png",
        "hash": "cef6331d1e17fcc8e403acefb744b3c6fdbc52ce",
        "modified": 1706168333464
      },
      {
        "_id": "themes/butterfly/source/css/var.styl",
        "hash": "950250f66faeb611a67540e0fa6cedbcf5a7a321",
        "modified": 1706107425765
      },
      {
        "_id": "themes/butterfly/source/img/avatar.jpg",
        "hash": "feaadc8bdf10abfb16b4d50bd644b51ce98c51d5",
        "modified": 1706175611076
      },
      {
        "_id": "themes/butterfly/source/img/friend_404.gif",
        "hash": "8d2d0ebef70a8eb07329f57e645889b0e420fa48",
        "modified": 1706107425766
      },
      {
        "_id": "themes/butterfly/layout/includes/head/Open_Graph.pug",
        "hash": "c8dbdfe6145a0bc6f7691c9551be8169a2698f0a",
        "modified": 1706107425710
      },
      {
        "_id": "themes/butterfly/layout/includes/head/analytics.pug",
        "hash": "c7666a10448edd93f5ace37296051b7670495f1b",
        "modified": 1706107425710
      },
      {
        "_id": "themes/butterfly/source/js/tw_cn.js",
        "hash": "1a5cc4cd4373980bfbe89699d2eff67aa9df85ed",
        "modified": 1706434136716
      },
      {
        "_id": "themes/butterfly/source/js/main.js",
        "hash": "29e13e6f1a9eca4aef0b06ab6917d5db5eeae8e3",
        "modified": 1706458386112
      },
      {
        "_id": "themes/butterfly/source/js/utils.js",
        "hash": "940c1476ae1674e43b69324e19ae64c51e9aa6cb",
        "modified": 1706206771025
      },
      {
        "_id": "themes/butterfly/layout/includes/head/google_adsense.pug",
        "hash": "f29123e603cbbcc6ce277d4e8f600ba67498077c",
        "modified": 1707982429329
      },
      {
        "_id": "themes/butterfly/layout/includes/head/config.pug",
        "hash": "39e1ca0a54eb5fd3688a78737417a1aaa50914c9",
        "modified": 1706107425711
      },
      {
        "_id": "themes/butterfly/layout/includes/head/config_site.pug",
        "hash": "bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149",
        "modified": 1706107425711
      },
      {
        "_id": "themes/butterfly/layout/includes/head/preconnect.pug",
        "hash": "a7c929b90ae52b78b39b1728e3ab0e3db1cb7b9a",
        "modified": 1706107425712
      },
      {
        "_id": "themes/butterfly/layout/includes/head/pwa.pug",
        "hash": "6dc2c9b85df9ab4f5b554305339fd80a90a6cf43",
        "modified": 1706107425712
      },
      {
        "_id": "themes/butterfly/layout/includes/header/menu_item.pug",
        "hash": "03793c1c881e115cd18fc25b0103bdc0e17d8b10",
        "modified": 1706458393610
      },
      {
        "_id": "themes/butterfly/layout/includes/header/index.pug",
        "hash": "1bef867c799ba158c5417272fb137539951aa120",
        "modified": 1706107425713
      },
      {
        "_id": "themes/butterfly/layout/includes/head/site_verification.pug",
        "hash": "5168caadc4cf541f5d6676a9c5e8ae47a948f9ad",
        "modified": 1706107425712
      },
      {
        "_id": "themes/butterfly/layout/includes/header/post-info.pug",
        "hash": "e7b25a322ae861dca06d458d3f914220e92758cf",
        "modified": 1706107425713
      },
      {
        "_id": "themes/butterfly/layout/includes/header/nav.pug",
        "hash": "0846a108fec1c3c0725299a75b84f866d16ff5d6",
        "modified": 1706452791393
      },
      {
        "_id": "themes/butterfly/layout/includes/header/social.pug",
        "hash": "7a641b5dd45b970e1dafd1433eb32ea149e55cf2",
        "modified": 1706107425714
      },
      {
        "_id": "themes/butterfly/layout/includes/loading/index.pug",
        "hash": "00ae419f527d8225a2dc03d4f977cec737248423",
        "modified": 1706107425715
      },
      {
        "_id": "themes/butterfly/layout/includes/loading/fullpage-loading.pug",
        "hash": "766baca6ddce49d1724a02312387b292ff2d0bdc",
        "modified": 1706107425714
      },
      {
        "_id": "themes/butterfly/layout/includes/loading/pace.pug",
        "hash": "a6fde4835d6460ce7baf792fd5e1977fad73db25",
        "modified": 1706107425715
      },
      {
        "_id": "themes/butterfly/layout/includes/mixins/article-sort.pug",
        "hash": "9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf",
        "modified": 1706107425715
      },
      {
        "_id": "themes/butterfly/layout/includes/mixins/post-ui.pug",
        "hash": "194a5f310dccecee3ae0b648e4e5318f6fbbddcd",
        "modified": 1706107425716
      },
      {
        "_id": "themes/butterfly/layout/includes/page/categories.pug",
        "hash": "5276a8d2835e05bd535fedc9f593a0ce8c3e8437",
        "modified": 1706107425716
      },
      {
        "_id": "themes/butterfly/layout/includes/page/flink.pug",
        "hash": "e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f",
        "modified": 1706107425716
      },
      {
        "_id": "themes/butterfly/layout/includes/page/default-page.pug",
        "hash": "e9459f122af7b733398578f9f0f8ab3c5e12a217",
        "modified": 1706107425716
      },
      {
        "_id": "themes/butterfly/layout/includes/post/reward.pug",
        "hash": "912df10a053db3135968e92b6fd1a707ee94c968",
        "modified": 1706107425718
      },
      {
        "_id": "themes/butterfly/layout/includes/page/tags.pug",
        "hash": "12be059c536490af216a397e8f2a7abbf6d4610e",
        "modified": 1706107425717
      },
      {
        "_id": "themes/butterfly/layout/includes/post/post-copyright.pug",
        "hash": "0abad416b1974a17e5be7817931d5fe799180170",
        "modified": 1706107425718
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/aplayer.pug",
        "hash": "e939344fd389aeb11864ee697d5fd9b036d8325f",
        "modified": 1706107425719
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/pjax.pug",
        "hash": "9b734d99963f3e7f562597dcf60485ccbf6e961c",
        "modified": 1706107425733
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/prismjs.pug",
        "hash": "08979afbfecb4476a5ae8e360947b92624d285b8",
        "modified": 1706107425733
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/effect.pug",
        "hash": "43014bfc63583d3ee8808d526dd165848c0ed52f",
        "modified": 1706107425729
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/pangu.pug",
        "hash": "f0898509da70388b5c532f19e762756d74080200",
        "modified": 1706107425733
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/subtitle.pug",
        "hash": "dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609",
        "modified": 1706107425735
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_archives.pug",
        "hash": "73d33b6930e7944187a4b3403daf25d27077a2dd",
        "modified": 1706107425737
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_ad.pug",
        "hash": "a8312b527493dabbadbb1280760168d3bc909a3b",
        "modified": 1707982084882
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_bottom_self.pug",
        "hash": "1dba77d250eeebfb6e293d504352c7e9ea31980b",
        "modified": 1706107425738
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_announcement.pug",
        "hash": "21e019bdc3b1e796bb00976bb29af2d51f873624",
        "modified": 1706107425737
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_author.pug",
        "hash": "a42b85b5b0d2d0edfc363c41f7205ac2ce8a70c1",
        "modified": 1706288880769
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_google_ad.pug",
        "hash": "4ba9b322a1d8b8cd36bb5cbc91c58fde39ea1a27",
        "modified": 1707982193626
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_categories.pug",
        "hash": "66e383b4ef374951eb87dd1bf4cdb7a667193fb5",
        "modified": 1706107425738
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_post_series.pug",
        "hash": "e0bb72fa0ce15964b11b8fe421cae3432394e35f",
        "modified": 1706107425739
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_newest_comment.pug",
        "hash": "8e22f53886a57a68286970d8af8b4c950fd4a1d7",
        "modified": 1706107425738
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_post_toc.pug",
        "hash": "d48d77af1670bd568d784794408bf524a448bfcc",
        "modified": 1706107425739
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_recent_post.pug",
        "hash": "bb842d2aa6469d65bf06af1372f0a19a9e4ef44c",
        "modified": 1706107425739
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_top_self.pug",
        "hash": "7b5ae404a1205546b7de4be42291315cf918f2b3",
        "modified": 1706107425740
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_webinfo.pug",
        "hash": "12185713f9ca08984fc74e3b69d8cd6828d23da8",
        "modified": 1706107425740
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/card_tags.pug",
        "hash": "842b772a387b576550fa127030e1c2e9bf65716d",
        "modified": 1707982086994
      },
      {
        "_id": "themes/butterfly/layout/includes/widget/index.pug",
        "hash": "2dec3aeccba9e6742ab97f87a6b43dbbea1d949d",
        "modified": 1707982651413
      },
      {
        "_id": "themes/butterfly/source/css/_custom/footer.styl",
        "hash": "40cc16eeb4b23b70d7940a850a95fdef7148fceb",
        "modified": 1706175526219
      },
      {
        "_id": "themes/butterfly/source/css/_custom/header.styl",
        "hash": "af4c0fe25ff4cdbace69395907c93e9eb1ca5fa5",
        "modified": 1706432314204
      },
      {
        "_id": "themes/butterfly/source/css/_custom/swiper.styl",
        "hash": "ac7d33b35a27ac9f7c0c5ee945563cc591a86b86",
        "modified": 1706286236032
      },
      {
        "_id": "themes/butterfly/source/css/_custom/page.styl",
        "hash": "8226208e45d0ed7a105567d5e35e3f3e11437c32",
        "modified": 1706186699157
      },
      {
        "_id": "themes/butterfly/source/css/_highlight/highlight.styl",
        "hash": "41054740cfbd1357138785464f6859681ca58493",
        "modified": 1706107425751
      },
      {
        "_id": "themes/butterfly/source/css/_global/function.styl",
        "hash": "313694a81bdb0f91fdf999647c53dfab8126e3c3",
        "modified": 1706268398277
      },
      {
        "_id": "themes/butterfly/source/css/_highlight/theme.styl",
        "hash": "3c178608406c31d768af355ef1d7326da37cc75f",
        "modified": 1706107425754
      },
      {
        "_id": "themes/butterfly/source/css/_global/index.styl",
        "hash": "0f2a173fe8f736a3486b358e2ba5f1291b4cb6a4",
        "modified": 1706268026676
      },
      {
        "_id": "themes/butterfly/source/css/_mode/darkmode.styl",
        "hash": "dbc855795a881f8c805bf5c9c5c4d5d542a648ec",
        "modified": 1706107425758
      },
      {
        "_id": "themes/butterfly/source/css/_mode/readmode.styl",
        "hash": "a22fd15048d21452f0015d0765d295d730203308",
        "modified": 1706107425759
      },
      {
        "_id": "themes/butterfly/source/css/_layout/chat.styl",
        "hash": "792a04d36de32f230ca3256ad87a90fe8392f333",
        "modified": 1706107425755
      },
      {
        "_id": "themes/butterfly/source/css/_layout/aside.styl",
        "hash": "156078ff9b040601a4c9e7cac133deaf11a3b861",
        "modified": 1706288902839
      },
      {
        "_id": "themes/butterfly/source/css/_layout/head.styl",
        "hash": "66a7a0e3c58ac23c81afe9fe18834b9db9c42698",
        "modified": 1706107425756
      },
      {
        "_id": "themes/butterfly/source/css/_layout/comments.styl",
        "hash": "fbfce4d67cacd1df22fb73d89d008693f59d9d91",
        "modified": 1706107425755
      },
      {
        "_id": "themes/butterfly/source/css/_layout/footer.styl",
        "hash": "5e27f7842af82ff7498d4b59787ce9ca90fa9e6f",
        "modified": 1706107425756
      },
      {
        "_id": "themes/butterfly/source/css/_layout/loading.styl",
        "hash": "f0b01bbf321c2c24fdccaee367dd9fd448031a72",
        "modified": 1706107425756
      },
      {
        "_id": "themes/butterfly/source/css/_layout/pagination.styl",
        "hash": "bd099f7d3adef4b7edd24c0a25a07415b156e587",
        "modified": 1706107425757
      },
      {
        "_id": "themes/butterfly/source/css/_layout/post.styl",
        "hash": "7ae27854a737a02eca89b0b92db94cb298fef59e",
        "modified": 1706107425757
      },
      {
        "_id": "themes/butterfly/source/css/_layout/relatedposts.styl",
        "hash": "6dcf19c0933c8828a439f801b0f4b256447dec07",
        "modified": 1706107425757
      },
      {
        "_id": "themes/butterfly/source/css/_layout/reward.styl",
        "hash": "c0b11a1a5f52e3a6af4e312a8134c93eda18a7dd",
        "modified": 1706107425757
      },
      {
        "_id": "themes/butterfly/source/css/_layout/rightside.styl",
        "hash": "c837ab51b4119f1d3c065b2f8fba447738611a6c",
        "modified": 1706423113052
      },
      {
        "_id": "themes/butterfly/source/css/_layout/third-party.styl",
        "hash": "15ea7564b2e3bf46bc91fb6e49c94d057b37caaf",
        "modified": 1706107425758
      },
      {
        "_id": "themes/butterfly/source/css/_page/404.styl",
        "hash": "a7223a8fcc4fa7b81e552c9a2554be7df9de312e",
        "modified": 1706107425759
      },
      {
        "_id": "themes/butterfly/source/css/_layout/sidebar.styl",
        "hash": "80ee9d0bfe5d38aac1f0cdcea5fc88b71d310041",
        "modified": 1706107425758
      },
      {
        "_id": "themes/butterfly/source/css/_page/archives.styl",
        "hash": "5dd1ba997741d02894ff846eda939ad8051c0bb2",
        "modified": 1706107425759
      },
      {
        "_id": "themes/butterfly/source/css/_page/categories.styl",
        "hash": "68bc8cbea25dbb3cdc170f09f9b43ce130547717",
        "modified": 1706107425759
      },
      {
        "_id": "themes/butterfly/source/css/_page/common.styl",
        "hash": "df7a51fcabbadab5aa31770e3202a47c9599bbb7",
        "modified": 1706107425759
      },
      {
        "_id": "themes/butterfly/source/css/_page/flink.styl",
        "hash": "ecc2b2e28c179eb9406fc2c6f00e141078249cdd",
        "modified": 1706107425760
      },
      {
        "_id": "themes/butterfly/source/css/_page/homepage.styl",
        "hash": "a977cd8161ef4d6ddd5293e81403519076657430",
        "modified": 1706107425760
      },
      {
        "_id": "themes/butterfly/source/css/_search/algolia.styl",
        "hash": "37db99299af380e9111dce2a78a5049b301b13e0",
        "modified": 1706107425760
      },
      {
        "_id": "themes/butterfly/source/css/_tags/button.styl",
        "hash": "62da1de0d5b8453fcecbfacddb16985265638ba5",
        "modified": 1706107425762
      },
      {
        "_id": "themes/butterfly/source/css/_page/tags.styl",
        "hash": "9e35f91847773b915c74a78b8aa66c7bdb950ad0",
        "modified": 1706107425760
      },
      {
        "_id": "themes/butterfly/source/css/_search/local-search.styl",
        "hash": "8a53d7ba5ca2f5eb4124b684e7845b648583f658",
        "modified": 1706107425762
      },
      {
        "_id": "themes/butterfly/source/css/_search/index.styl",
        "hash": "0b23010154e19f37f0c4af0110f9f834d6d41a13",
        "modified": 1706107425762
      },
      {
        "_id": "themes/butterfly/source/css/_tags/gallery.styl",
        "hash": "3e9355b76f87e2ee90f652855282b37ab5ae0b3e",
        "modified": 1706107425763
      },
      {
        "_id": "themes/butterfly/source/css/_tags/inlineImg.styl",
        "hash": "5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4",
        "modified": 1706107425763
      },
      {
        "_id": "themes/butterfly/source/css/_tags/label.styl",
        "hash": "2f83bd145b870d80d4b18b0ac603235229a5694e",
        "modified": 1706107425764
      },
      {
        "_id": "themes/butterfly/source/css/_tags/note.styl",
        "hash": "4929382bd60788d34752a66e2fe764ef797a72a0",
        "modified": 1706107425764
      },
      {
        "_id": "themes/butterfly/source/css/_tags/hexo.styl",
        "hash": "985b183db7b7bfd8f9bdb60494549fb7f850348b",
        "modified": 1706107425763
      },
      {
        "_id": "themes/butterfly/source/css/_tags/hide.styl",
        "hash": "b7cf7753479fcf2fe07287ffdb0e568adbba4c18",
        "modified": 1706107425763
      },
      {
        "_id": "themes/butterfly/source/css/_tags/tabs.styl",
        "hash": "353b95f9a6c2c1e777d978118cb61f909ccbf89c",
        "modified": 1706107425764
      },
      {
        "_id": "themes/butterfly/source/css/_tags/timeline.styl",
        "hash": "07ea7134db7a66c87658116f089fb1a2a6906563",
        "modified": 1706107425765
      },
      {
        "_id": "themes/butterfly/source/css/_third-party/normalize.min.css",
        "hash": "644694eeb458aee5b9e03e4646944317ae0191ec",
        "modified": 1706206770506
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-02.png",
        "hash": "50b66f86495d0192a6d201c3ed5ad1db9e05fed8",
        "modified": 1706259430454
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-03.png",
        "hash": "279dd1d3b0e2d28bd10b0484bbc6fc2866ea49ea",
        "modified": 1706259430462
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-05.png",
        "hash": "99989fc07e8f19c8569bdfb7711f20b971c15261",
        "modified": 1706259430478
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-02.png",
        "hash": "9feb8c892bb2b922f27d10fc6bfc747b8e10c740",
        "modified": 1706259430508
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-01.png",
        "hash": "5a352eb8f0b394e2dee616bc2eb3524be587aa30",
        "modified": 1706259430501
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-07.png",
        "hash": "2d7a5a66f2a15639c7e76a7a227f6efee9557a45",
        "modified": 1706259430549
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-06.png",
        "hash": "d9f5223d3315d7302a2ef9f2cbf5be9c0b0d2d29",
        "modified": 1706259430485
      },
      {
        "_id": "themes/butterfly/source/img/cover/cover_02.jpeg",
        "hash": "1ebdf47a93327358220db57990b36e1e8c24c303",
        "modified": 1706207088723
      },
      {
        "_id": "themes/butterfly/source/img/qrCode/alipay.jpg",
        "hash": "c6aa6cdc3ea2370e689772c1febaa57ed3148482",
        "modified": 1706181183414
      },
      {
        "_id": "themes/butterfly/source/img/cover/cover_01.jpg",
        "hash": "506ee8e4d0698317a7579a13bbedc7532574b7aa",
        "modified": 1706207061584
      },
      {
        "_id": "themes/butterfly/source/img/cover/cover_03.jpg",
        "hash": "623811fd46077673ae42f70e436b1b66b906d001",
        "modified": 1706207109491
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_01.jpg",
        "hash": "c4a33f204e5d1fbba5d262da4f1b8228cef5c711",
        "modified": 1706282519495
      },
      {
        "_id": "themes/butterfly/source/img/qrCode/wechat.jpg",
        "hash": "d5ce1859e974652eae7e32806d85c27d8bacff9b",
        "modified": 1706181161473
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_02.jpg",
        "hash": "6b8b6a96128b8dd36d72f5b7369934f98a29e6e8",
        "modified": 1706282544969
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_03.jpg",
        "hash": "f46e6d02e0e32eb7f108e5408f7ec3a060c9a5ad",
        "modified": 1706282579591
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_04.jpg",
        "hash": "18191a6acfa0a339bc886c41a93e24b66757b475",
        "modified": 1706282601536
      },
      {
        "_id": "themes/butterfly/source/js/search/local-search.js",
        "hash": "5db6f9f10296b0f2088f8f3d7b313a19136dee97",
        "modified": 1706206770622
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_05.jpg",
        "hash": "344ef44a56c535f3ff77e6e4d21300975144b013",
        "modified": 1706282619348
      },
      {
        "_id": "themes/butterfly/source/js/src/nav.js",
        "hash": "9c50614e252ca2d4ae0812d193f10d846eb8d953",
        "modified": 1706452779680
      },
      {
        "_id": "themes/butterfly/source/js/search/algolia.js",
        "hash": "d77bdee318c4bcf078adb1784b80c304b01da3d6",
        "modified": 1706206770591
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug",
        "hash": "8f95aca305b56ccd7c8c7367b03d26db816ebd5f",
        "modified": 1706107425719
      },
      {
        "_id": "themes/butterfly/source/img/recommend/recommend_06.jpg",
        "hash": "a613404128a12931794c7368541378b407c83036",
        "modified": 1706282635928
      },
      {
        "_id": "themes/butterfly/source/js/src/vue_js.js",
        "hash": "5eb6263824c1cd10c6f65eaac5c7bff60090af3a",
        "modified": 1706289592194
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/abcjs/index.pug",
        "hash": "58f37823f6cd9a194fb50f7ca7c2233e49939034",
        "modified": 1706107425719
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/chat/daovoice.pug",
        "hash": "0d960849d5b05d27ec87627b983ca35f2411b9e8",
        "modified": 1706107425723
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/chat/crisp.pug",
        "hash": "09d2ab2570b67e6f09244a898ccab5567cb82ace",
        "modified": 1706107425723
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/chat/index.pug",
        "hash": "1157118db9f5d7c0c5a0fc7c346f6e934ca00d52",
        "modified": 1706107425723
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/chat/chatra.pug",
        "hash": "08a85e52fc800d3562df869e5e2613313e76fce6",
        "modified": 1706107425722
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/chat/messenger.pug",
        "hash": "799da8f3015e6fe440681b21644bcb3810a5518c",
        "modified": 1706107425723
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/card-post-count/fb.pug",
        "hash": "4b98145d6584d586cabf033493282afc72ae816a",
        "modified": 1706107425721
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug",
        "hash": "d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea",
        "modified": 1706107425720
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug",
        "hash": "716dc463fe4ef5112e7018ed60804125fdfa5cad",
        "modified": 1706107425721
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/card-post-count/index.pug",
        "hash": "846cabae287ae31b3bbfac3da022475713dd5ecc",
        "modified": 1706107425721
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/card-post-count/valine.pug",
        "hash": "cd4fc9c5a61608a5dedf645c1295430a1623040f",
        "modified": 1706107425722
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug",
        "hash": "19b5cfa1f77781246e02967cefe149f19170e45f",
        "modified": 1706107425720
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug",
        "hash": "7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d",
        "modified": 1706107425722
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/card-post-count/waline.pug",
        "hash": "fd2320ee25507bb8ef49f932c2d170586b44ea4d",
        "modified": 1706107425722
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/chat/tidio.pug",
        "hash": "6d40b521eec4136f6742c548a4445ed593470b1b",
        "modified": 1706107425724
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/artalk.pug",
        "hash": "2dc9f36085ed33d040549fa3954e8fdecf1e5c6d",
        "modified": 1706107425724
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/disqusjs.pug",
        "hash": "f78c9c20c86d58c7cf099f6f8d6097103d7d43e5",
        "modified": 1706107425726
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/gitalk.pug",
        "hash": "1c86c8fc1a28514a02a1f6a25ca9ec05eb3955b7",
        "modified": 1706107425727
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/giscus.pug",
        "hash": "1eab7ca1cb16c6786f9c3ca0efef8cc15e444ab4",
        "modified": 1706107425726
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/disqus.pug",
        "hash": "364d1fd655baca9132038ef1e312abde2c0bc7de",
        "modified": 1706107425725
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/index.pug",
        "hash": "db6713d2b90eb8183f86ac92c26761a8501c0ddb",
        "modified": 1706107425727
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/js.pug",
        "hash": "3abbaaa4ea575c45b3cebffd40bad1acc6ffce84",
        "modified": 1706107425727
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug",
        "hash": "11f5dca1432e59f22955aaf4ac3e9de6b286d887",
        "modified": 1706107425726
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/twikoo.pug",
        "hash": "0b44f6de0f5632b55298d506833f45dae46a6346",
        "modified": 1706107425728
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/valine.pug",
        "hash": "4ed7c74087e81c6fcaf4fca7dced58b4e19f4cb1",
        "modified": 1706107425728
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/remark42.pug",
        "hash": "7f450664e6323a076ae59c393b0f22167cfa82e5",
        "modified": 1706107425728
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/waline.pug",
        "hash": "a7d794987bde815607206254df6549a5a53e2cb0",
        "modified": 1706107425728
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/math/katex.pug",
        "hash": "f0d3eddd2bed68e5517274b3530bfe0fa5057d8e",
        "modified": 1706107425729
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/livere.pug",
        "hash": "09c2ef4bc6d005f96dfa48b1d9af1ec095c5266d",
        "modified": 1706107425728
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/math/index.pug",
        "hash": "2afa4c21dd19890f47fb568cfb0d90efb676a253",
        "modified": 1706107425729
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/math/mermaid.pug",
        "hash": "c682e4d61017fb0dd2e837bfcc242371f1a13364",
        "modified": 1706107425729
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/comments/utterances.pug",
        "hash": "b65a42167df5fb07e2a63f312a58c321d3112a90",
        "modified": 1706107425728
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/math/mathjax.pug",
        "hash": "bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf",
        "modified": 1706107425729
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug",
        "hash": "d8898e427acd91ceb97d6a7ee3acb011ca86b9fc",
        "modified": 1706107425731
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug",
        "hash": "6de0c412a4d9b65c576ec79e1949925823c90fa6",
        "modified": 1706107425731
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug",
        "hash": "fc8814bd016d039874ec2fc24dcb78587892e2a6",
        "modified": 1706107425731
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/newest-comments/index.pug",
        "hash": "f8b65460c399973090c1fb7ab81e3708c252e7cc",
        "modified": 1706107425731
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug",
        "hash": "a4e52188b6effeee1df2a01dcbf4105de76a61a8",
        "modified": 1706107425732
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug",
        "hash": "17520a86de12ae585289463c066d3ac91b78a2ff",
        "modified": 1706107425732
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/search/algolia.pug",
        "hash": "90338ac4cd114d324fe1caaaeea8be9ca05d6a46",
        "modified": 1706107425734
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/newest-comments/waline.pug",
        "hash": "0544d91c0bc9e26e0fe1b5ff490f4a8540ed1ee1",
        "modified": 1706107425732
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/newest-comments/valine.pug",
        "hash": "ecfff55b2c7f6d87ce4d5028fdf9f8c0bf155c73",
        "modified": 1706107425732
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/search/docsearch.pug",
        "hash": "52a06a2e039f44383085333cac69f3f4e7d0ad3a",
        "modified": 1706107425734
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/search/index.pug",
        "hash": "3adcf28a8d205ea3ee19828eda0e668702fac07a",
        "modified": 1706107425734
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/share/addtoany.pug",
        "hash": "1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba",
        "modified": 1706107425735
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/share/index.pug",
        "hash": "c16ee69b5ca8db016db0508d014ae0867c4ce929",
        "modified": 1706107425735
      },
      {
        "_id": "themes/butterfly/source/css/_highlight/highlight/diff.styl",
        "hash": "6e77f1ca0cfb0db6b028f5c0238780e66d344f3d",
        "modified": 1706107425752
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/search/local-search.pug",
        "hash": "420a86e73d0d748ac234fd00d06d9e433ca5e3f2",
        "modified": 1706107425734
      },
      {
        "_id": "themes/butterfly/source/css/_highlight/highlight/index.styl",
        "hash": "fc702a4614d0562a381907b083f71ba63d301d86",
        "modified": 1706107425753
      },
      {
        "_id": "themes/butterfly/source/css/_highlight/prismjs/diff.styl",
        "hash": "1309292f1c8c53d96cd7333507b106bcc24ca8fc",
        "modified": 1706107425753
      },
      {
        "_id": "themes/butterfly/layout/includes/third-party/share/share-js.pug",
        "hash": "8106bd031586f075a994956ee4438eb13be25d7b",
        "modified": 1706107425735
      },
      {
        "_id": "themes/butterfly/source/css/_highlight/prismjs/index.styl",
        "hash": "01ff9e77eb1bd454bec65a6ff5972c8e219bc708",
        "modified": 1706107425753
      },
      {
        "_id": "themes/butterfly/source/css/_highlight/prismjs/line-number.styl",
        "hash": "7c9cc43e1d2577f7151039d58e603c30860fd281",
        "modified": 1706107425754
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-01.png",
        "hash": "b8f4163fdd7c31fe1752ae3ee953d7bad492456d",
        "modified": 1706259430445
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-04.png",
        "hash": "d4fbfa22d4712c7f8fbf81279b26c3fb1a27e1ec",
        "modified": 1706259430471
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/01-07.png",
        "hash": "947b098c90d9337f06445200a855e7757de11e16",
        "modified": 1706259430493
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-03.png",
        "hash": "ec3a45efd8b8e3c7bcd7a57330e332191a4f13f2",
        "modified": 1706259430516
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-01.png",
        "hash": "6f22daa06cba950eeae74bba5fb4bf2856425f46",
        "modified": 1706259430601
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-05.png",
        "hash": "0de5bf1e83ce8b6aa51a22518d3c77be2fea4192",
        "modified": 1706259430853
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-12.png",
        "hash": "d39e1f402ea77cacc0145abe5dbf7ad8be775573",
        "modified": 1706259430948
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-05.png",
        "hash": "b57fb37d8eb491a6f09f66bd769350fa2fb25841",
        "modified": 1706259431022
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-04.png",
        "hash": "1f5368b542f335f6603e13be7d795812230b4239",
        "modified": 1706259431068
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-05.png",
        "hash": "1f5368b542f335f6603e13be7d795812230b4239",
        "modified": 1706259431078
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-04.png",
        "hash": "ee469c909cd592d9037d05d4b746ccf8b1e6d061",
        "modified": 1706259431098
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-02.png",
        "hash": "3e23782ea6f1c8c5dc8827741bda8fb1cb8fba78",
        "modified": 1706259431281
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-02.png",
        "hash": "045fd3425f8435d98006a600916bf9203ad91a94",
        "modified": 1706259431328
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-06.png",
        "hash": "2b4bc123f06a62c791effe1c655137a800678da9",
        "modified": 1706259431314
      },
      {
        "_id": "themes/butterfly/source/img/banner/banner_01.jpg",
        "hash": "a161e62f2436ff4e0ae2b6bb8dba0198539ec0aa",
        "modified": 1706179639174
      },
      {
        "_id": "themes/butterfly/source/js/src/sakura.js",
        "hash": "710dc81918592f5c142466bce12da48c07352dd4",
        "modified": 1706287954573
      },
      {
        "_id": "themes/butterfly/source/js/src/vue.js",
        "hash": "0bb16d698d6fccbe56eb9280d09b60233f953369",
        "modified": 1707920047579
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-11.png",
        "hash": "49fdc9a611b9ce3444c003b251871f4fc1418ba4",
        "modified": 1706259430580
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-13.png",
        "hash": "669ef7e24aaf383f8379a0ab86987621882bbda1",
        "modified": 1706259430594
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-08.png",
        "hash": "284b6e0b20af2f7ad11ec14996e80b0893f55746",
        "modified": 1706259430651
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-09.png",
        "hash": "da069b35106ba30fc906a084af20cc54ecc1e690",
        "modified": 1706259430659
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-12.png",
        "hash": "46a022e9c63d897f2bb63709987f020bf3adc197",
        "modified": 1706259430676
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-07.png",
        "hash": "575669a1f2072c6c0e035385bff60d03b8e7defb",
        "modified": 1706259430750
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-13.png",
        "hash": "2b06c9b41ec6f21755d9b264e0b5725ded0bf430",
        "modified": 1706259430793
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-16.png",
        "hash": "0a6419d639fd24e2e192937f00778853faf4b90a",
        "modified": 1706259430817
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-01.png",
        "hash": "a0abf35ed4a32bdfe637649979189a754c7139f6",
        "modified": 1706259430824
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-02.png",
        "hash": "bb1fa11b64312704d4e2a5b332bb742e33d9bab8",
        "modified": 1706259430831
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-06.png",
        "hash": "97f8fe5e53376562d8b9a128519c89ba64438d3b",
        "modified": 1706259430859
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-07.png",
        "hash": "1ba99b4f98c8bfa6d19c0e44f0c46a2d3af5e076",
        "modified": 1706259430865
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-01.png",
        "hash": "ed7ff05db97f20e01ec60b45b594cce679aab38e",
        "modified": 1706259430872
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-05.png",
        "hash": "ddd0f019c58a7016f0f8ae1d18af9b7d6470b03a",
        "modified": 1706259430900
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-06.png",
        "hash": "b78c9b14bc952bf5732c14c0b807ea0f8414e066",
        "modified": 1706259430907
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-10.png",
        "hash": "d0eda90ae79d12cdcd6f369a526891d7cfb5ca72",
        "modified": 1706259430935
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-08.png",
        "hash": "164dc5f50c9c6a8fb997a136be46dfa42d76f75d",
        "modified": 1706259430921
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-14.png",
        "hash": "eacbee2d67d2204ece4f93659ddc73289401ece6",
        "modified": 1706259430961
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-15.png",
        "hash": "493ff8d1dd9ff20f6d6830d529c144d9dc5067af",
        "modified": 1706259430968
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-17.png",
        "hash": "53e49db89cbda090a3ed5371899b835b7cb4d31b",
        "modified": 1706259430982
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-01.png",
        "hash": "b63f71ee240b02d8816ece5c57034b65e37f521f",
        "modified": 1706259430995
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-02.png",
        "hash": "2b222b30842f081d73a1beec6ea5f920a54624d0",
        "modified": 1706259431002
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-06.png",
        "hash": "9da7724e188df733d02b4226ff2d4a518e8229e5",
        "modified": 1706259431029
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-07.png",
        "hash": "9da7724e188df733d02b4226ff2d4a518e8229e5",
        "modified": 1706259431036
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-08.png",
        "hash": "4e08f8b8de348d8a10054ffa23ae24a56fcf38ec",
        "modified": 1706259431042
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-01.png",
        "hash": "2578881e26615508713e1f3f66c6c815cddb7ed6",
        "modified": 1706259431048
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-02.png",
        "hash": "4b80aca3d5322f8c321aba53905f7d39db38c896",
        "modified": 1706259431054
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/08-03.png",
        "hash": "0caa9441f901b8dc1fcfeb9922a190fc3881eade",
        "modified": 1706259431060
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-01.png",
        "hash": "17fadc6b385a056ac1fa8d47481fe38ee6fca393",
        "modified": 1706259431084
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-06.png",
        "hash": "cd136ca114f1506ef3623d9f677a6ebdf2ebff1d",
        "modified": 1706259431112
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-09.png",
        "hash": "3b5b35b8e45a326f2262cb91d7bd0be00c73ff36",
        "modified": 1706259431136
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-13.png",
        "hash": "f4253995a15fdc5a455a6dd1589ce4ab8e833bbf",
        "modified": 1706259431170
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-18.png",
        "hash": "1bf56ec3ce7452338c97b696fe147eb43df82d9b",
        "modified": 1706259431214
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-19.png",
        "hash": "b1e9945e4bd7d59edc52d3721fddc4257fadf801",
        "modified": 1706259431222
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-17.png",
        "hash": "57f1cd14a622b15d054cf1273ea75aba9457a55c",
        "modified": 1706259431207
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-20.png",
        "hash": "1bdcc9aea3bce25b2d9494a48fe673062b00365d",
        "modified": 1706259431229
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-21.png",
        "hash": "ba6b8873273ae35da0a677b5d1c3dc1d96119c9e",
        "modified": 1706259431236
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-23.png",
        "hash": "ee44d21fbe1ed6f259d187a1ad5b148c6e269980",
        "modified": 1706259431245
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-22.png",
        "hash": "018a3a5caec70a25e78527deaef35555d593b852",
        "modified": 1706259431243
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-01.png",
        "hash": "727a6af4b8021fb7c76ccf76da1fb8a76b1d2a6e",
        "modified": 1706259431273
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-03.png",
        "hash": "4d5bdce32f0f6118cdfc09e5a6b17eca69735220",
        "modified": 1706259431289
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-04.png",
        "hash": "39ee715a9ff726863d8138a464cae7d21d37f47c",
        "modified": 1706259431293
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-01.png",
        "hash": "537133b686f876d16c2a937835cebf1bfaca3440",
        "modified": 1706259431320
      },
      {
        "_id": "themes/butterfly/source/js/src/jquery.js",
        "hash": "5aaffdf91d6286b54e90a2ef6d6b446a38beeafc",
        "modified": 1706206770948
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-06.png",
        "hash": "f4fbe6abf0d89ff3eb7f2901c6e354e73b3d19f1",
        "modified": 1706259430543
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-09.png",
        "hash": "efee333d32a06d6adad557f65dd5f965858d8133",
        "modified": 1706259430566
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-08.png",
        "hash": "42329a475f2eed06f74256bea95a7da99e7ab3a2",
        "modified": 1706259430558
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-10.png",
        "hash": "609a209e115c77c58be0872e63ba37dbac2654e3",
        "modified": 1706259430573
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-12.png",
        "hash": "3b54b9b8bb42ba423534a3e4279c07eb6b27ca6f",
        "modified": 1706259430587
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-03.png",
        "hash": "5d2c5033a2ed515e5f40735588b11f3325732ade",
        "modified": 1706259430616
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-05.png",
        "hash": "49deff5c3a722330486bcece4662d1ceb1558fdb",
        "modified": 1706259430630
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-06.png",
        "hash": "6b39eaaa434d39eb0f0e779d0b4f458b6c22ae59",
        "modified": 1706259430630
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-07.png",
        "hash": "5c5843e9db2c62ce0ef003a7887e6e00ef0f42a5",
        "modified": 1706259430645
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-10.png",
        "hash": "2e768c7b3765582a0d1ecaa7ea4b2c30d1f04235",
        "modified": 1706259430666
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-11.png",
        "hash": "11ded056da2699fa253d2418d356309b8c87d52b",
        "modified": 1706259430673
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-14.png",
        "hash": "d77ec3760ba6670609582723b81012d972d7eede",
        "modified": 1706259430695
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-01.png",
        "hash": "9801134fb4ab017b80403fb1b6ee007c599ce145",
        "modified": 1706259430710
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-002.png",
        "hash": "7a77d2dd32efc01195e061c410b842c8b84fc84d",
        "modified": 1706259430703
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-04.png",
        "hash": "47133a4cfdcfc7127252896db10e3eee5f46e681",
        "modified": 1706259430726
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-06.png",
        "hash": "2f89fe85c8203ddc9007d4c9fddde27b6fe88995",
        "modified": 1706259430741
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-08.png",
        "hash": "9305b9c739c320d482802ac2aa0ca16c8e0f98d5",
        "modified": 1706259430757
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-09.png",
        "hash": "6776d0201ff83d82bfa82df0690b5d36675109fd",
        "modified": 1706259430765
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-12.png",
        "hash": "9a5d0c1dae44e8bab5cd5fd171fd300e91581c93",
        "modified": 1706259430786
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-14.png",
        "hash": "b503d4d37acf18bc46f3a212e7734da3950a4375",
        "modified": 1706259430800
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-02.png",
        "hash": "868142aab142e39a2a4957c37ec4304ebaae0f31",
        "modified": 1706259430879
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-04.png",
        "hash": "fbc92981e6b631ddccf1365437702a0bcbf56cf9",
        "modified": 1706259430893
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-09.png",
        "hash": "044155995665c0ab4c13d9bfa86bc02e16114002",
        "modified": 1706259430929
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-11.png",
        "hash": "45fd856a7c7bdf68f761e282f651756c618e0234",
        "modified": 1706259430943
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-13.png",
        "hash": "27fa07800bd8cdb1b26a127273cca8a8f745f8bf",
        "modified": 1706259430955
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-16.png",
        "hash": "d87b428c77007779682896a082a5f49e6cccadbc",
        "modified": 1706259430975
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-18.png",
        "hash": "37c206c4925366109131cb42ecd31f88b9fb2d21",
        "modified": 1706259430989
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-03.png",
        "hash": "f72e5b909267c8575117de08114ba5946f310cdd",
        "modified": 1706259431008
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/07-04.png",
        "hash": "a112e439eae1467ca19936eea5cf41c1d707b978",
        "modified": 1706259431015
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-05.png",
        "hash": "4365efc65dd76b2ecfef20f4f177c0312da90789",
        "modified": 1706259431105
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-07.png",
        "hash": "1a88a04705b2f8c4d56f98c3c874fceac2176455",
        "modified": 1706259431119
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-08.png",
        "hash": "3bd1b023cefe1802740ec41e7882077ef7a64a71",
        "modified": 1706259431128
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-10.png",
        "hash": "fc050d72312ab9ffcc138c130d9339aada643b0f",
        "modified": 1706259431143
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-14.png",
        "hash": "2128df6a028d4018bf0506c0b9ad46ab2cd0d98c",
        "modified": 1706259431179
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-16.png",
        "hash": "e2e69052e5133506cc790804db1c34284a690051",
        "modified": 1706259431199
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-24.png",
        "hash": "4bfdd8016084e09ea5b6bcd436e2dd1af1c42c23",
        "modified": 1706259431258
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-25.png",
        "hash": "3588c6ccfcb8e139fffa2e6f81584247fdcaba81",
        "modified": 1706259431266
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/10-05.png",
        "hash": "52a790ab4e106003f56d18bd6c3a039961f45b1b",
        "modified": 1706259431305
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-05.png",
        "hash": "a6d5a13b2a7194c67eb7d3aea686b9f9937f7ac4",
        "modified": 1706259430535
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-13.png",
        "hash": "a50dd2928c7a87afd9a812d55f993d4f674e98c4",
        "modified": 1706259430676
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-05.png",
        "hash": "491da987ac0e6215828ab5c0407c424004481e6e",
        "modified": 1706259430734
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-11.png",
        "hash": "774a7f5de6a4e5ccdaae9a3bad942b80e49ed63e",
        "modified": 1706259430780
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-15.png",
        "hash": "43a7a05fe7c8ec13c5677127da57eb50ed8d0b4d",
        "modified": 1706259430808
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-04.png",
        "hash": "9aa30ba8f9d571ddcc1ae117d764b673da638bd7",
        "modified": 1706259430847
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-07.png",
        "hash": "98017d6cbb7ed62bf50f9d0a19f111dac195ceeb",
        "modified": 1706259430914
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/06-03.png",
        "hash": "4a7d04b36ccf1b5311fbd0651356d8f1e101e57f",
        "modified": 1706259430886
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-02.png",
        "hash": "63852b193b646c4c9295a5656510985e536b4a3f",
        "modified": 1706259431091
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-15.png",
        "hash": "496162687cfe188ab3823a0ec7de5887133b6ff2",
        "modified": 1706259431190
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-05.png",
        "hash": "d35c530f81402dfa91367367e45c539b23f0cbd1",
        "modified": 1706259431345
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-06.png",
        "hash": "1323b13ca4eb947c22373b78d3e96f0c732711ae",
        "modified": 1706259431354
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-07.png",
        "hash": "1323b13ca4eb947c22373b78d3e96f0c732711ae",
        "modified": 1706259431363
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-4.png",
        "hash": "055c52efca75205877905c1d80c7c51535e8dd30",
        "modified": 1706259431380
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/02-04.png",
        "hash": "d9e89094babca8ef90efcd0be4b62af959ae570b",
        "modified": 1706259430526
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-03.png",
        "hash": "755d0953cc157c4892e72a5f7f97c76d103ff19f",
        "modified": 1706259430719
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/04-10.png",
        "hash": "44c584c2673536c08a606a1ff56423376617840b",
        "modified": 1706259430773
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/05-03.png",
        "hash": "eb4573b44998d363a8deb18fbe17ef04b3169631",
        "modified": 1706259430838
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-08.png",
        "hash": "add12ab0e80ffb68db194a8f0352db91004cd300",
        "modified": 1706259431371
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/目录（基础篇）.png",
        "hash": "87b5c37a7235a2fa3b29a6f967176eedae87fa7e",
        "modified": 1706259431398
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-02.png",
        "hash": "7d770f6c2bc50d4a9fc32690fac887446b9374c9",
        "modified": 1706259430610
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/03-04.png",
        "hash": "74a7db3c6d9f4e98a9bd4e8cf026549fc69a1860",
        "modified": 1706259430624
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-12.png",
        "hash": "d2a5c2bd3a482f6019cc7b82bb0eb74d3115a66e",
        "modified": 1706259431162
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/11-03.png",
        "hash": "7db6cbdc418fa04ec34cac323b8bfa8efe58c2ad",
        "modified": 1706259431337
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/目录（高级篇）.png",
        "hash": "9f15d8c1ed9285ad150b59a826b6ae92b82ebadd",
        "modified": 1706259431409
      },
      {
        "_id": "themes/butterfly/source/img/TypeScript/09-11.png",
        "hash": "55473b668ec41b5015fbacf8fd5297243dbe6a51",
        "modified": 1706259431153
      }
    ],
    "Category": [
      { "name": "日本語", "_id": "cmesvjanv000494v36d0yamuu" },
      {
        "name": "TypeScript",
        "parent": "cmesvjanv000494v36d0yamuu",
        "_id": "cmesvjao2000j94v3ghyv99qm"
      },
      { "name": "简体中文", "_id": "cmesvjao5001094v32emrf46y" },
      { "name": "Css", "parent": "cmesvjanv000494v36d0yamuu", "_id": "cmesvjao9001u94v3bt383u33" },
      {
        "name": "TypeScript",
        "parent": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaof003094v3ab8t1oso"
      },
      { "name": "Css", "parent": "cmesvjao5001094v32emrf46y", "_id": "cmesvjaof003594v33nhf7eh8" }
    ],
    "Data": [],
    "Page": [
      {
        "_content": "ff6d8ad11f482b8ad40e283cb99ff8b4",
        "source": "baidu_verify_codeva-JddVaE5CKl.html",
        "raw": "ff6d8ad11f482b8ad40e283cb99ff8b4",
        "date": "2024-01-27T06:05:30.065Z",
        "updated": "2024-01-27T06:05:22.497Z",
        "path": "baidu_verify_codeva-JddVaE5CKl.html",
        "title": "",
        "comments": 1,
        "layout": "page",
        "_id": "cmesvjanq000094v31la7dys9",
        "content": "ff6d8ad11f482b8ad40e283cb99ff8b4",
        "cover": "/img/cover/cover_03.jpg",
        "cover_type": "img",
        "excerpt": "",
        "more": "ff6d8ad11f482b8ad40e283cb99ff8b4"
      },
      {
        "title": "categories",
        "date": "2024-01-25T17:46:39.000Z",
        "type": "categories",
        "categories": [
          "CSS",
          "HTML",
          "Vue",
          "React",
          "JavaScript",
          "Jquery",
          "TypeScript",
          "Webpack",
          "Node",
          "Nginx",
          "Docker",
          "Broswer",
          "日本語",
          "English"
        ],
        "_content": "",
        "source": "categories/index.md",
        "raw": "---\ntitle: categories\ndate: 2024-01-26 01:46:39\ntype: \"categories\"\ncategories:\n  - CSS\n  - HTML\n  - Vue\n  - React\n  - JavaScript\n  - Jquery\n  - TypeScript\n  - Webpack\n  - Node\n  - Nginx\n  - Docker\n  - Broswer\n  - 日本語\n  - English\n---\n",
        "updated": "2024-01-28T10:59:49.540Z",
        "path": "categories/index.html",
        "comments": 1,
        "layout": "page",
        "_id": "cmesvjanu000294v3g5u6c6pv",
        "content": "",
        "cover": "/img/cover/cover_03.jpg",
        "cover_type": "img",
        "excerpt": "",
        "more": ""
      },
      {
        "title": "tags",
        "date": "2024-01-25T17:47:31.000Z",
        "type": "tags",
        "tags": [
          "CSS",
          "前端",
          "服务器",
          "云端",
          "HTML",
          "Vue",
          "Nuxt",
          "React",
          "Next",
          "JavaScript",
          "Jquery",
          "TypeScript",
          "Webpack",
          "Npm",
          "Node",
          "Express",
          "Koa",
          "Nginx",
          "Docker",
          "Broswer",
          "フロントエンド"
        ],
        "_content": "",
        "source": "tags/index.md",
        "raw": "---\ntitle: tags\ndate: 2024-01-26 01:47:31\ntype: \"tags\"\ntags:\n  - CSS\n  - 前端\n  - 服务器\n  - 云端\n  - HTML\n  - Vue\n  - Nuxt\n  - React\n  - Next\n  - JavaScript\n  - Jquery\n  - TypeScript\n  - Webpack\n  - Npm\n  - Node\n  - Express\n  - Koa\n  - Nginx\n  - Docker\n  - Broswer\n  - フロントエンド\n---\n",
        "updated": "2024-01-28T09:55:28.508Z",
        "path": "tags/index.html",
        "comments": 1,
        "layout": "page",
        "_id": "cmesvjanx000694v35wd4ggci",
        "content": "",
        "cover": "/img/cover/cover_02.jpeg",
        "cover_type": "img",
        "excerpt": "",
        "more": ""
      }
    ],
    "Post": [
      {
        "title": "1-2、基本：TypeScriptの概要(2)",
        "toc": true,
        "abbrlink": 52879,
        "date": "2024-01-28T13:16:17.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_01.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 二、TypeScriptについて\n\n## 2.1問題の発見\n\nJavaScriptの各値には動作のセットがあり、さまざまなアクションを実行することで確認できます。これは抽象的に聞こえるので、簡単な例として、 `message` という変数に対して実行する可能性のあるアクションを考えてみましょう：\n\n```js\n// 在 'message' 上访问属性 'toLowerCase'，并调用它\nmessage.toLowerCase();\n// 调用 'message'\nmessage();\n```\n\nこれを分解すると、実行可能なコードの最初の行は属性 `toLowerCase` にアクセスし、それを呼び出します。2番目の試みは、 `message` を直接呼び出すことです。\n\nしかし、 `message` が分からないとします。これはよくあることですが、これらのコードを実行しようとすると、どのような結果が得られるのかを確実に説明することはできません。各操作の動作は、最初に与えた `message` に依存します。\n\n- `message` を呼び出すことはできますか？\n- `toLowerCase` という属性を持っていますか？\n- できる場合、 `toLowerCase` を呼び出すことができますか？\n- 両方の値が呼び出し可能な場合、何を返しますか。\n\nこれらの質問に対する答えは、通常、JavaScriptを書くときに心に留めていることであり、すべての詳細が正確であることを期待しなければなりません。\n\n`message` が次のように定義されているとします：\n\n```js\nconst message = \"Hello World!\";\n```\n\n予想されるように、 `message.toLowerCase()` を実行しようとすると、同じ小文字の文字列しか得られません。\n\n2行目のコードは？JavaScriptに精通していれば、これが失敗して例外が発生することがわかります：\n\n```shell\nTypeError: message is not a function\n```\n\n私たちがそのような間違いを避けられれば幸いです。\n\nコードを実行するとき、JavaScriptの実行時に何をするかを選択する方法は、値の*タイプ*を決定することです。それがどのような動作と機能を持つかを決定します。この `TypeError` は暗示の一部です。文字列 `\"Hello World!\"` は関数として呼び出すことはできません。\n\n基本型 `string` や `number` などの一部の値については、 `typeof` 演算子を使用して実行時にその型を識別できます。しかし、関数のような他のものについては、それらの型を識別するための適切な実行時機構がありません。たとえば、次の関数を考えてみます：\n\n```js\nfunction fn(x) {\n  return x.flip();\n}\n```\n\nコード*観察*を読むことで、この関数は `flip` を呼び出せるプロパティを持つオブジェクトが与えられている場合にのみ機能しますが、JavaScriptはコードの実行時に確認できるような方法でこれらの情報を表示しません。純粋なJavaScriptでは、 `fn` に特定の値が何をするかを指定する**唯一の方法**は、その値を呼び出して何が起こるかを確認します。この動作は、実行前にコードが何をするかを予測することを困難にします。つまり、コードを書くときにコードが何をするかを知ることがより困難になることを意味します。\n\nこのように、*タイプ*は、 `fn` に渡すことができる値がクラッシュすることを示す概念である。JavaScriptが実際に提供するのは*動態*型だけです。コードを実行して、何が起こるかを確認してください。\n\nもう1つの方法は、*せいてき*タイプのシステム*在る*を使用して、*前*予測コードを実行することです。\n\n## 2.2**せいてきtypeけんさ**\n\n`TypeError` 以前に `string` を関数として呼び出してみたことを思い出してください。*大多数の人*コードを実行するときに発生するあらゆる種類のエラーは好ましくありません。これらはエラーとみなされます！私たちは新しいコードを書くときに、新しいエラーを導入しないようにしています。\n\n理想的には、*在る*コード実行*前*がこれらのエラーを発見するのに役立つツールがあります。これは、TypeScriptのような静的タイプインスペクタによって行われます。*せいてきがたシステム*は、プログラムを実行したときの値の形状と動作を記述しています。TypeScriptのようなタイプチェッカーは、どんなときに物事が浮気する可能性があるかを教えてくれます。\n\n<img src=\"https://s2.loli.net/2022/02/22/5yhsbTCF7cqVGNQ.png\" alt=\"image-20211109134610557\" style=\"zoom:50%;\" align=\"left\" />\n\nコードを実行する前にTypeScriptを使用して最後のサンプルを実行すると、エラーメッセージが表示されます。\n\n## 2.3**異常なし故障**\n\nここまでランタイムエラーについてお話ししてきました--JavaScriptの実行時に、何かが無意味だと思っていることを教えてくれる場合です。このような状況が発生するのは、[ECMAScript仕様](https://tc39.github.io/ecma262/)が予期しない状況が発生した場合に言語がどのように動作するかを明示的に示しているからです。\n\nたとえば、呼び出せないものを呼び出そうとすると、エラーがスローされると仕様書は言う。これは「明らかな行為」のように聞こえるかもしれませんが、オブジェクトに存在しない属性にアクセスしてもエラーがスローされるべきであることは想像できます。逆に、JavaScriptは別の動作を行い、値 `undefined` を返します：\n\n```js\nconst user = {\n  name: \"小千\",\n  age: 26,\n};\nuser.location; // 返回 undefined\n```\n\n最終的に、静的タイプのシステムでは、呼び出しが必要なコードがシステム内でマークされる必要があります。たとえ、それがすぐにエラーがスローされない「有効な」JavaScriptであっても、そのコードはそのシステム内でマークされる必要があります。たとえば、TypeScriptでは、次のコードが未定義の `location` に関するエラーを生成します：\n\n<img src=\"https://s2.loli.net/2022/02/22/Qqo8BZmtJnGC1D4.png\" alt=\"image-20211109141050215\" style=\"zoom:50%;\" />\n\nTypeScriptは、私たちのプログラム内の*おびただしい*正当なエラーをキャプチャすることができます。例：\n\n- 誤字![](/img/TypeScript/01-04.png)\n- 呼び出されていない関数\n\n<img src=\"https://s2.loli.net/2022/02/22/U1MmrPyjdbkueRC.png\" alt=\"image-20211109142053954\" style=\"zoom:50%;\" align=\"left\" />\n\n- または基本的な論理エラー\n\n![](/img/TypeScript/01-06.png)\n\n## 2.4**ツールの使用**\n\nコード内でエラーが発生した場合、TypeScriptはエラーをキャッチします。これは素晴らしいことですが、TypeScriptも*まずは*私たちがこれらのミスを犯すのを防いでくれます。\n\nタイプインスペクタは、変数やその他のプロパティの正しいプロパティにアクセスしているかどうかなどを確認するのに役立ちます。これらの情報を取得すると、使用したい属性を開始することもできます*提案*。\n\nこれは、ツールを使用してTypeScriptコードを編集するときにエラーメッセージとコード補完が表示され、コアタイプインスペクタがエディタにコードを入力できることを意味します。これは、TypeScriptのツールについて話す際によく言及する部分です。\n\n<img src=\"https://s2.loli.net/2022/02/22/qolAfbMnVIcXvys.png\" alt=\"image-20211113085757666\" style=\"zoom: 25%;\" align=\"left\" />\n\nTypeScriptはツールを非常に重視しています。TypeScriptをサポートするエディタには、エラーを自動的に修正する「簡易修正」機能、コードを簡単に再編成するためのリファクタリング機能、変数定義にジャンプしたり、特定の変数へのすべての参照を検索するための便利なナビゲーション機能が用意されています。これらはすべてタイプチェッカーに基づいており、完全にクロスプラットフォームであるため、[您最喜欢的编辑器](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)は[TypeScriptのサポートが利用可能](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)の可能性があります。\n\n## 2.5 `tsc` コンパイラ\n\nタイプチェックについて話してきましたが、私たちのタイプ*チェッカー*はまだ使用されていません。新しい友人 `tsc` TypeScriptコンパイラを紹介しましょう。まずnpmで入手する必要があります。\n\n```she\nnpm install -g typescript\n```\n\nこれにより、TypeScriptコンパイラがグローバルにインストールされます。\n\nでは、空のフォルダに移動して、最初のTypeScriptプログラム `hello.ts` を作成してみましょう。\n\n**01-ts-basics/hello.ts**\n\n```ts\n// 你好，世界\nconsole.log(\"Hello World\");\n```\n\nここには余分な装飾がないことに注意してください。この「ハローワールド」プログラムは、JavaScriptで「ハローワールド」プログラム用に書いたプログラムと同じように見えます。次に、 `tsc` パッケージを実行して、 `typescript` パッケージをコンパイルします：\n\n```shell\n[felix] 01-ts-basics $ tsc hello.ts\n```\n\n私たちは `tsc` を走りましたが、何も起きませんでした！はい、タイプエラーはありませんので、何も報告されていないので、コンソールには何も出力されていません。\n\n<img src=\"https://s2.loli.net/2022/02/22/APiNb5FzvuwGlZk.png\" alt=\"image-20211113093244339\" style=\"zoom: 50%;\" align=\"left\"/>\n\nしかし、もう一度調べてみると、*ファイル*という出力がいくつか出てきます。現在のディレクトリを見ると、2つのファイル `hello.js` が `hello.ts` にあります。これは、 `hello.ts` ファイルが `tsc` *コンパイル*または*変換*に純粋なJavaScriptファイルである場合の出力です。\n\n<img src=\"https://s2.loli.net/2022/02/22/ctI9MPpSY1y8uLr.png\" alt=\"image-20211113093559374\" style=\"zoom: 50%;\" align=\"left\" />\n\n`hello.js` を確認すると、 `.ts` ファイルを処理した後にTypeScriptが吐き出す内容が表示されます：\n\n```js\n// 你好，世界\nconsole.log(\"Hello World\");\n```\n\nこの場合、TypeScriptは変換するものがほとんどないので、私たちが書いたものと同じように見えます。コンパイラは、人間が書いたもののように見える、明瞭に読めるコードをコンパイルしようとします。注釈も残しておいてください。\n\nタイプチェックエラーを導入した場合*確かに*はどうでしょうか。 `hello.ts` を上書きしてみましょう。\n\n```ts\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`);\n}\n\ngreet(\"小千\");\n```\n\nもう一度実行すると、コマンドラインにエラーが表示されます！\n\n<img src=\"https://s2.loli.net/2022/02/22/QNL3DlBHYUbxu9Z.png\" alt=\"image-20211113095515775\" style=\"zoom:50%;\" align=\"left\"/>\n\nTypeScriptは、 `greet` 関数に引数を渡すことを忘れていることを示していますが、これは当然のことです。これまでは標準的なJavaScriptしか書いていませんでしたが、タイプチェックではコードの他の問題を見つけることができます。TypeScriptに感謝！\n\n## 2.6エラーが発生しました\n\n前の例では、私たちの `hello.js` ファイルが再び変更されたことに気がつかないかもしれません。このファイルを開くと、内容が入力ファイルとほぼ同じであることがわかります。\n\n```js\n// 你好，世界\nconsole.log(\"Hello World\");\nfunction greet(person, date) {\n  console.log(\"Hello \" + person + \", today is \" + date + \"!\");\n}\ngreet(\"小千\");\n```\n\n`tsc` が私たちのコードに関するエラーを報告しているという事実を考えると、これは少し驚くべきことかもしれませんが、これはTypeScriptの重要な価値観の1つに基づいています。ほとんどの場合、*君*はTypeScriptよりも何が起きているかを理解しています。\n\nこれまでにも触れておくと、タイプチェックコードによって実行できるプログラムの種類が制限されているため、タイプチェッカーが許容できると判断したタイプを比較検討する必要があります。ほとんどの場合、これは問題ありませんが、場合によっては、これらのチェックが邪魔になることがあります。たとえば、JavaScriptコードをTypeScriptに移行し、タイプチェックエラーを導入したとします。最終的には、タイプチェッカーのコードクリーンアップを開始しますが、元のJavaScriptコードを実行できるようになりました！なぜ、JSコードをTypeScriptコードに変換して実行しないようにしなければならないのでしょうか。\n\nしたがって、デフォルトではTypeScriptは我々のコードの実行を妨げることはありません。これらのJSはホスト環境で実行されても問題ありません。もちろん、時間の経過とともに、エラーに対してより防御し、TypeScriptの挙動をより厳しくしたいと思うかもしれません。この場合は、[ `noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)コンパイラオプションを使用します。このオプションを使用して、 `hello.ts` ファイルを変更し、 `tsc` を再コンパイルしてみます：\n\n```\ntsc --noEmitOnError hello.ts\n```\n\n![](/img/TypeScript/02-04.png)\n\n`hello.js` は決して更新されないことに気づくでしょう。\n\n## 2.7明示型\n\nこれまでのところ、typescript `person` や `date` がどのような型であるかは教えていません。コードを編集するときに、 `person` は `string` であり、 `date` は `Date` オブジェクトであるべきであることをTypeScriptに伝えます。\n\nこれにより、TypeScriptは他の `greet` が誤って呼び出された可能性があることを知らせることができます。たとえば、 `hello.ts` コードを変更します：\n\n```js\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n```\n\n![](/img/TypeScript/02-05.png)\n\nん？TypeScriptは2番目のパラメータでエラーを報告していますが、これはなぜでしょうか。\n\n驚くべきことに、 `Date()` をJavaScriptで呼び出すと、 `string` が返されます。 `new Date()` を使用すると、期待どおりに簡単にエラーを修正できます：\n\n```js\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n\ngreet(\"小锋\", new Date());\n```\n\n![](/img/TypeScript/02-06.png)\n\nコンパイルに成功した結果、 `hello.js` が出力されました。\n\n変数に明示的な型コメントを書く必要があるわけではないことを覚えておいてください。多くの場合、タイプの定義を無視しても、TypeScriptはタイプを自動的に*推論*(または「見つける」)ことができます。例えば：\n\n<img src=\"https://s2.loli.net/2022/02/22/N2pXBbY6LRwoaC1.png\" alt=\"image-20211113111924590\" style=\"zoom:50%;\" align=\"left\" />\n\nここではmsgに具体的な型を指定しておらず、typescriptは関数の実数から型を自動的に推定する。これは、タイプシステムが最終的に同じタイプを推定する場合には、タイプコメントを追加しない方がよい特性です。\n\n## 2.8消去タイプ\n\n上のコードを `tsc` でコンパイルしたときにどのようなJavaScriptが出力されるかを詳しく見てみましょう。 `hello.js`\n\n![](/img/TypeScript/02-08.png)\n\nここでは、2つの点に注意してください：\n\n1. 引数 `person` および `date` には型に関するコメントがありません。\n2. 「テンプレート文字列」--逆引用符(`文字)を使用した文字列は、連結(+)を持つ純粋な文字列に変換されます。\n\n2点目については後ほど詳しく紹介しますが、ここでは1点目に焦点を当ててみましょう。型注釈はJavaScriptの一部ではありません(つまり、ECMAScriptは遅れています)。そのため、実際にはブラウザが存在しないか、他のランタイムが変更なしでTypeScriptを実行することができます。これは、TypeScriptが最初にコンパイラを必要とする理由です。TypeScript固有のコードを切り離したり変換したりして、実行できるようにする方法が必要です。TypeScript固有のコードのほとんどが削除されました。\n\n> **覚えておいてください**：型コメントは、プログラムの実行時の動作を変更しません。\n\n## 2.9ダウングレードコンパイル\n\n上記とのもう1つの違いは、テンプレート文字列が次のものから構成されていることです：\n\n```js\n`Hello ${person}, today is ${date.toDateString()}!`;\n```\n\n対象：\n\n```js\n\"Hello \" + person + \", today is \" + date.toDateString() + \"!\";\n```\n\nなぜそうなったのか。\n\nテンプレート文字列は、ECMAScriptバージョンの機能であり、ECMAScript 2015（別名ECMAScript 6、ES2015、ES6など）と呼ばれます。TypeScriptは、新しいバージョンのECMAScriptから古いバージョン(ECMAScript 3やECMAScript 5(別名ES3とES5)など)にコードを書き換えることができます。ECMAScriptの最新バージョンまたはそれ以降のバージョンから、古いバージョンまたはそれ以前のバージョンへの移行プロセスは、*降格*と呼ばれることがあります。\n\nデフォルトでは、TypeScriptはECMAScriptの非常に古いバージョンであるES3をターゲットにしています。[ `target`](https://www.typescriptlang.org/tsconfig#target)オプションを使用すると、のコンテンツを更新することができます。 `--target es2015` TypeScriptを実行してECMAScript 2015に変更を加えます。つまり、コードはECMAScript 2015をサポートするどこでも実行できるはずです。したがって、 `tsc --target es2015 hello.ts` を実行すると、次のような出力が得られます：\n\n<img src=\"https://s2.loli.net/2022/02/22/3BbKfisq9htp4nr.png\" alt=\"image-20211113113644658\" style=\"zoom:33%;\" />\n\n> デフォルトのターゲットはES3ですが、現在はほとんどのブラウザがES2015をサポートしています。そのため、一部の古いブラウザとの互換性を考慮しない限り、ほとんどの開発者はES2015以降をターゲットとして安全に指定することができます。\n\n## 2.10厳格モード\n\nタイプインスペクタでTypeScriptを使用するユーザーによって、どの程度厳密にチェックしたいかが異なります。一部の人は、プログラムの一部のみを検証するのに役立つ、より緩やかな検証体験を探していますが、それでもよいツールを持っています。これはTypeScriptのデフォルトの操作です。タイプはオプションで、推論は最も緩いタイプを使用します。 `null`/ `undefined` は、 `tsc` がエラーに直面したときにJSファイルをコンパイルして生成する方法と同様に、潜在的な `null`/ `undefined` の値をチェックしません。既存のJavaScriptを移行するのであれば、これは理想的な第一歩かもしれません。\n\nそれよりも、多くのユーザーがTypeScriptをできるだけすぐに検証できるようにすることを好むのは、この言語が厳格な設定を提供する理由です。これらの厳密な設定は、(コードがチェックされているかどうかにかかわらず)スイッチから、よりダイヤルアップに近いものへと静的なタイプチェックを変えます。このダイアルを遠くに合わせるほど、TypeScriptがチェックしてくれます。これには多少の追加作業が必要になるかもしれないが、概して長期的に見れば価値があり、より徹底した検査とより正確なツールを実現することができる。可能であれば、新しいコードベースではこれらの厳密性チェックを常にオンにしておくべきである。\n\nTypeScriptにはいくつかのタイプチェック厳密フラグがありますが、特に明記されていない限り、これらのフラグをすべて有効にして記述します。コマンドラインで[ `strict`](https://www.typescriptlang.org/tsconfig#strict)を設定するか、[ `tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)で `\"strict\": true` を設定して開きます。\n\n![](/img/TypeScript/02-10.png)\n\n![](/img/TypeScript/02-11.png)\n\n上の2つのケースは、 `--strict true` を構成したためにエラーが発生しました。\n\nまた、個別に構成を選択することもできます。知っておくべき最も典型的な2つは、[ `noImplicitAny`]（https://www.typescriptlang.org/tsconfig#noImplicitAny）と[ `strictNullChecks`]（https://www.typescriptlang.org/tsconfig#strictNullChecks）です。\n\n- ** `noImplicitAny` **\n\nいくつかの場所では、TypeScriptはタイプを推定しようとせず、最も緩いタイプに戻ります。 `any`。これは起こりうる最悪の事態ではありません--結局のところ、 `any` はいずれにしても、通常のJavaScript体験に戻ることができます。\n\nただし、通常、 `any` を使用すると、最初にTypeScriptを使用する目的が損なわれます。プログラムの種類が多ければ多いほど、より多くの検証やツールを手に入れることができます。つまり、コードを書くときのエラーが少なくなります。この[ `noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)フラグをオンにすると、タイプが暗黙的に推定され、変数がエラーを起こしたときに `any` が適用されます。\n\n<img src=\"https://s2.loli.net/2022/02/22/Ir7T4vckJMsSnuK.png\" alt=\"image-20211113122642576\" style=\"zoom:40%;\" />\n\n- ** `strictNullChecks` **\n\nデフォルトでは、 `null` および `undefined` の値は、他の任意の型に割り当てることができます。これはいくつかのコードを書くのを簡単にすることができますが、 `null` の処理を忘れて、 `undefined` があなたのコードの無数の誤りの原因です-一部の人はこれを[十亿美元的错误](https://www.youtube.com/watch?v=ybrQvs4x0Ps)と考えています！この[ `strictNullChecks`]（https://www.typescriptlang.org/tsconfig#strictNullChecks）フラグにより、オペレーション `null` および `undefined` がより明確になり、*忘れる*が `null` および `undefined` を処理するかどうかを心配する必要がなくなります。\n\n<img src=\"https://s2.loli.net/2022/02/22/wRlPY8gO9v1zkZa.png\" alt=\"image-20211113122914750\" style=\"zoom:50%;\" />\n\n### 特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。\n",
        "source": "_posts/日本語/TypeScript/1-2、基本：TypeScriptの概要.md",
        "raw": "---\ntitle: 1-2、基本：TypeScriptの概要(2)\ntoc: true\ncategories:\n  - 日本語\n  - TypeScript\ntags:\n  - フロントエンド\n  - TypeScript\nabbrlink: 52879\ndate: 2024-01-28 21:16:17\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 二、TypeScriptについて\n\n## 2.1問題の発見\n\nJavaScriptの各値には動作のセットがあり、さまざまなアクションを実行することで確認できます。これは抽象的に聞こえるので、簡単な例として、 `message` という変数に対して実行する可能性のあるアクションを考えてみましょう：\n\n```js\n// 在 'message' 上访问属性 'toLowerCase'，并调用它\nmessage.toLowerCase();\n// 调用 'message'\nmessage();\n```\n\nこれを分解すると、実行可能なコードの最初の行は属性 `toLowerCase` にアクセスし、それを呼び出します。2番目の試みは、 `message` を直接呼び出すことです。\n\nしかし、 `message` が分からないとします。これはよくあることですが、これらのコードを実行しようとすると、どのような結果が得られるのかを確実に説明することはできません。各操作の動作は、最初に与えた `message` に依存します。\n\n- `message` を呼び出すことはできますか？\n- `toLowerCase` という属性を持っていますか？\n- できる場合、 `toLowerCase` を呼び出すことができますか？\n- 両方の値が呼び出し可能な場合、何を返しますか。\n\nこれらの質問に対する答えは、通常、JavaScriptを書くときに心に留めていることであり、すべての詳細が正確であることを期待しなければなりません。\n\n`message` が次のように定義されているとします：\n\n```js\nconst message = \"Hello World!\";\n```\n\n予想されるように、 `message.toLowerCase()` を実行しようとすると、同じ小文字の文字列しか得られません。\n\n2行目のコードは？JavaScriptに精通していれば、これが失敗して例外が発生することがわかります：\n\n```shell\nTypeError: message is not a function\n```\n\n私たちがそのような間違いを避けられれば幸いです。\n\nコードを実行するとき、JavaScriptの実行時に何をするかを選択する方法は、値の*タイプ*を決定することです。それがどのような動作と機能を持つかを決定します。この `TypeError` は暗示の一部です。文字列 `\"Hello World!\"` は関数として呼び出すことはできません。\n\n基本型 `string` や `number` などの一部の値については、 `typeof` 演算子を使用して実行時にその型を識別できます。しかし、関数のような他のものについては、それらの型を識別するための適切な実行時機構がありません。たとえば、次の関数を考えてみます：\n\n```js\nfunction fn(x) {\n  return x.flip();\n}\n```\n\nコード*観察*を読むことで、この関数は `flip` を呼び出せるプロパティを持つオブジェクトが与えられている場合にのみ機能しますが、JavaScriptはコードの実行時に確認できるような方法でこれらの情報を表示しません。純粋なJavaScriptでは、 `fn` に特定の値が何をするかを指定する**唯一の方法**は、その値を呼び出して何が起こるかを確認します。この動作は、実行前にコードが何をするかを予測することを困難にします。つまり、コードを書くときにコードが何をするかを知ることがより困難になることを意味します。\n\nこのように、*タイプ*は、 `fn` に渡すことができる値がクラッシュすることを示す概念である。JavaScriptが実際に提供するのは*動態*型だけです。コードを実行して、何が起こるかを確認してください。\n\nもう1つの方法は、*せいてき*タイプのシステム*在る*を使用して、*前*予測コードを実行することです。\n\n## 2.2**せいてきtypeけんさ**\n\n`TypeError` 以前に `string` を関数として呼び出してみたことを思い出してください。*大多数の人*コードを実行するときに発生するあらゆる種類のエラーは好ましくありません。これらはエラーとみなされます！私たちは新しいコードを書くときに、新しいエラーを導入しないようにしています。\n\n理想的には、*在る*コード実行*前*がこれらのエラーを発見するのに役立つツールがあります。これは、TypeScriptのような静的タイプインスペクタによって行われます。*せいてきがたシステム*は、プログラムを実行したときの値の形状と動作を記述しています。TypeScriptのようなタイプチェッカーは、どんなときに物事が浮気する可能性があるかを教えてくれます。\n\n<img src=\"https://s2.loli.net/2022/02/22/5yhsbTCF7cqVGNQ.png\" alt=\"image-20211109134610557\" style=\"zoom:50%;\" align=\"left\" />\n\nコードを実行する前にTypeScriptを使用して最後のサンプルを実行すると、エラーメッセージが表示されます。\n\n## 2.3**異常なし故障**\n\nここまでランタイムエラーについてお話ししてきました--JavaScriptの実行時に、何かが無意味だと思っていることを教えてくれる場合です。このような状況が発生するのは、[ECMAScript仕様](https://tc39.github.io/ecma262/)が予期しない状況が発生した場合に言語がどのように動作するかを明示的に示しているからです。\n\nたとえば、呼び出せないものを呼び出そうとすると、エラーがスローされると仕様書は言う。これは「明らかな行為」のように聞こえるかもしれませんが、オブジェクトに存在しない属性にアクセスしてもエラーがスローされるべきであることは想像できます。逆に、JavaScriptは別の動作を行い、値 `undefined` を返します：\n\n```js\nconst user = {\n  name: \"小千\",\n  age: 26,\n};\nuser.location; // 返回 undefined\n```\n\n最終的に、静的タイプのシステムでは、呼び出しが必要なコードがシステム内でマークされる必要があります。たとえ、それがすぐにエラーがスローされない「有効な」JavaScriptであっても、そのコードはそのシステム内でマークされる必要があります。たとえば、TypeScriptでは、次のコードが未定義の `location` に関するエラーを生成します：\n\n<img src=\"https://s2.loli.net/2022/02/22/Qqo8BZmtJnGC1D4.png\" alt=\"image-20211109141050215\" style=\"zoom:50%;\" />\n\nTypeScriptは、私たちのプログラム内の*おびただしい*正当なエラーをキャプチャすることができます。例：\n\n- 誤字![](/img/TypeScript/01-04.png)\n- 呼び出されていない関数\n\n<img src=\"https://s2.loli.net/2022/02/22/U1MmrPyjdbkueRC.png\" alt=\"image-20211109142053954\" style=\"zoom:50%;\" align=\"left\" />\n\n- または基本的な論理エラー\n\n![](/img/TypeScript/01-06.png)\n\n## 2.4**ツールの使用**\n\nコード内でエラーが発生した場合、TypeScriptはエラーをキャッチします。これは素晴らしいことですが、TypeScriptも*まずは*私たちがこれらのミスを犯すのを防いでくれます。\n\nタイプインスペクタは、変数やその他のプロパティの正しいプロパティにアクセスしているかどうかなどを確認するのに役立ちます。これらの情報を取得すると、使用したい属性を開始することもできます*提案*。\n\nこれは、ツールを使用してTypeScriptコードを編集するときにエラーメッセージとコード補完が表示され、コアタイプインスペクタがエディタにコードを入力できることを意味します。これは、TypeScriptのツールについて話す際によく言及する部分です。\n\n<img src=\"https://s2.loli.net/2022/02/22/qolAfbMnVIcXvys.png\" alt=\"image-20211113085757666\" style=\"zoom: 25%;\" align=\"left\" />\n\nTypeScriptはツールを非常に重視しています。TypeScriptをサポートするエディタには、エラーを自動的に修正する「簡易修正」機能、コードを簡単に再編成するためのリファクタリング機能、変数定義にジャンプしたり、特定の変数へのすべての参照を検索するための便利なナビゲーション機能が用意されています。これらはすべてタイプチェッカーに基づいており、完全にクロスプラットフォームであるため、[您最喜欢的编辑器](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)は[TypeScriptのサポートが利用可能](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)の可能性があります。\n\n## 2.5 `tsc` コンパイラ\n\nタイプチェックについて話してきましたが、私たちのタイプ*チェッカー*はまだ使用されていません。新しい友人 `tsc` TypeScriptコンパイラを紹介しましょう。まずnpmで入手する必要があります。\n\n```she\nnpm install -g typescript\n```\n\nこれにより、TypeScriptコンパイラがグローバルにインストールされます。\n\nでは、空のフォルダに移動して、最初のTypeScriptプログラム `hello.ts` を作成してみましょう。\n\n**01-ts-basics/hello.ts**\n\n```ts\n// 你好，世界\nconsole.log(\"Hello World\");\n```\n\nここには余分な装飾がないことに注意してください。この「ハローワールド」プログラムは、JavaScriptで「ハローワールド」プログラム用に書いたプログラムと同じように見えます。次に、 `tsc` パッケージを実行して、 `typescript` パッケージをコンパイルします：\n\n```shell\n[felix] 01-ts-basics $ tsc hello.ts\n```\n\n私たちは `tsc` を走りましたが、何も起きませんでした！はい、タイプエラーはありませんので、何も報告されていないので、コンソールには何も出力されていません。\n\n<img src=\"https://s2.loli.net/2022/02/22/APiNb5FzvuwGlZk.png\" alt=\"image-20211113093244339\" style=\"zoom: 50%;\" align=\"left\"/>\n\nしかし、もう一度調べてみると、*ファイル*という出力がいくつか出てきます。現在のディレクトリを見ると、2つのファイル `hello.js` が `hello.ts` にあります。これは、 `hello.ts` ファイルが `tsc` *コンパイル*または*変換*に純粋なJavaScriptファイルである場合の出力です。\n\n<img src=\"https://s2.loli.net/2022/02/22/ctI9MPpSY1y8uLr.png\" alt=\"image-20211113093559374\" style=\"zoom: 50%;\" align=\"left\" />\n\n`hello.js` を確認すると、 `.ts` ファイルを処理した後にTypeScriptが吐き出す内容が表示されます：\n\n```js\n// 你好，世界\nconsole.log(\"Hello World\");\n```\n\nこの場合、TypeScriptは変換するものがほとんどないので、私たちが書いたものと同じように見えます。コンパイラは、人間が書いたもののように見える、明瞭に読めるコードをコンパイルしようとします。注釈も残しておいてください。\n\nタイプチェックエラーを導入した場合*確かに*はどうでしょうか。 `hello.ts` を上書きしてみましょう。\n\n```ts\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`);\n}\n\ngreet(\"小千\");\n```\n\nもう一度実行すると、コマンドラインにエラーが表示されます！\n\n<img src=\"https://s2.loli.net/2022/02/22/QNL3DlBHYUbxu9Z.png\" alt=\"image-20211113095515775\" style=\"zoom:50%;\" align=\"left\"/>\n\nTypeScriptは、 `greet` 関数に引数を渡すことを忘れていることを示していますが、これは当然のことです。これまでは標準的なJavaScriptしか書いていませんでしたが、タイプチェックではコードの他の問題を見つけることができます。TypeScriptに感謝！\n\n## 2.6エラーが発生しました\n\n前の例では、私たちの `hello.js` ファイルが再び変更されたことに気がつかないかもしれません。このファイルを開くと、内容が入力ファイルとほぼ同じであることがわかります。\n\n```js\n// 你好，世界\nconsole.log(\"Hello World\");\nfunction greet(person, date) {\n  console.log(\"Hello \" + person + \", today is \" + date + \"!\");\n}\ngreet(\"小千\");\n```\n\n`tsc` が私たちのコードに関するエラーを報告しているという事実を考えると、これは少し驚くべきことかもしれませんが、これはTypeScriptの重要な価値観の1つに基づいています。ほとんどの場合、*君*はTypeScriptよりも何が起きているかを理解しています。\n\nこれまでにも触れておくと、タイプチェックコードによって実行できるプログラムの種類が制限されているため、タイプチェッカーが許容できると判断したタイプを比較検討する必要があります。ほとんどの場合、これは問題ありませんが、場合によっては、これらのチェックが邪魔になることがあります。たとえば、JavaScriptコードをTypeScriptに移行し、タイプチェックエラーを導入したとします。最終的には、タイプチェッカーのコードクリーンアップを開始しますが、元のJavaScriptコードを実行できるようになりました！なぜ、JSコードをTypeScriptコードに変換して実行しないようにしなければならないのでしょうか。\n\nしたがって、デフォルトではTypeScriptは我々のコードの実行を妨げることはありません。これらのJSはホスト環境で実行されても問題ありません。もちろん、時間の経過とともに、エラーに対してより防御し、TypeScriptの挙動をより厳しくしたいと思うかもしれません。この場合は、[ `noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)コンパイラオプションを使用します。このオプションを使用して、 `hello.ts` ファイルを変更し、 `tsc` を再コンパイルしてみます：\n\n```\ntsc --noEmitOnError hello.ts\n```\n\n![](/img/TypeScript/02-04.png)\n\n`hello.js` は決して更新されないことに気づくでしょう。\n\n## 2.7明示型\n\nこれまでのところ、typescript `person` や `date` がどのような型であるかは教えていません。コードを編集するときに、 `person` は `string` であり、 `date` は `Date` オブジェクトであるべきであることをTypeScriptに伝えます。\n\nこれにより、TypeScriptは他の `greet` が誤って呼び出された可能性があることを知らせることができます。たとえば、 `hello.ts` コードを変更します：\n\n```js\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n```\n\n![](/img/TypeScript/02-05.png)\n\nん？TypeScriptは2番目のパラメータでエラーを報告していますが、これはなぜでしょうか。\n\n驚くべきことに、 `Date()` をJavaScriptで呼び出すと、 `string` が返されます。 `new Date()` を使用すると、期待どおりに簡単にエラーを修正できます：\n\n```js\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n\ngreet(\"小锋\", new Date());\n```\n\n![](/img/TypeScript/02-06.png)\n\nコンパイルに成功した結果、 `hello.js` が出力されました。\n\n変数に明示的な型コメントを書く必要があるわけではないことを覚えておいてください。多くの場合、タイプの定義を無視しても、TypeScriptはタイプを自動的に*推論*(または「見つける」)ことができます。例えば：\n\n<img src=\"https://s2.loli.net/2022/02/22/N2pXBbY6LRwoaC1.png\" alt=\"image-20211113111924590\" style=\"zoom:50%;\" align=\"left\" />\n\nここではmsgに具体的な型を指定しておらず、typescriptは関数の実数から型を自動的に推定する。これは、タイプシステムが最終的に同じタイプを推定する場合には、タイプコメントを追加しない方がよい特性です。\n\n## 2.8消去タイプ\n\n上のコードを `tsc` でコンパイルしたときにどのようなJavaScriptが出力されるかを詳しく見てみましょう。 `hello.js`\n\n![](/img/TypeScript/02-08.png)\n\nここでは、2つの点に注意してください：\n\n1. 引数 `person` および `date` には型に関するコメントがありません。\n2. 「テンプレート文字列」--逆引用符(`文字)を使用した文字列は、連結(+)を持つ純粋な文字列に変換されます。\n\n2点目については後ほど詳しく紹介しますが、ここでは1点目に焦点を当ててみましょう。型注釈はJavaScriptの一部ではありません(つまり、ECMAScriptは遅れています)。そのため、実際にはブラウザが存在しないか、他のランタイムが変更なしでTypeScriptを実行することができます。これは、TypeScriptが最初にコンパイラを必要とする理由です。TypeScript固有のコードを切り離したり変換したりして、実行できるようにする方法が必要です。TypeScript固有のコードのほとんどが削除されました。\n\n> **覚えておいてください**：型コメントは、プログラムの実行時の動作を変更しません。\n\n## 2.9ダウングレードコンパイル\n\n上記とのもう1つの違いは、テンプレート文字列が次のものから構成されていることです：\n\n```js\n`Hello ${person}, today is ${date.toDateString()}!`;\n```\n\n対象：\n\n```js\n\"Hello \" + person + \", today is \" + date.toDateString() + \"!\";\n```\n\nなぜそうなったのか。\n\nテンプレート文字列は、ECMAScriptバージョンの機能であり、ECMAScript 2015（別名ECMAScript 6、ES2015、ES6など）と呼ばれます。TypeScriptは、新しいバージョンのECMAScriptから古いバージョン(ECMAScript 3やECMAScript 5(別名ES3とES5)など)にコードを書き換えることができます。ECMAScriptの最新バージョンまたはそれ以降のバージョンから、古いバージョンまたはそれ以前のバージョンへの移行プロセスは、*降格*と呼ばれることがあります。\n\nデフォルトでは、TypeScriptはECMAScriptの非常に古いバージョンであるES3をターゲットにしています。[ `target`](https://www.typescriptlang.org/tsconfig#target)オプションを使用すると、のコンテンツを更新することができます。 `--target es2015` TypeScriptを実行してECMAScript 2015に変更を加えます。つまり、コードはECMAScript 2015をサポートするどこでも実行できるはずです。したがって、 `tsc --target es2015 hello.ts` を実行すると、次のような出力が得られます：\n\n<img src=\"https://s2.loli.net/2022/02/22/3BbKfisq9htp4nr.png\" alt=\"image-20211113113644658\" style=\"zoom:33%;\" />\n\n> デフォルトのターゲットはES3ですが、現在はほとんどのブラウザがES2015をサポートしています。そのため、一部の古いブラウザとの互換性を考慮しない限り、ほとんどの開発者はES2015以降をターゲットとして安全に指定することができます。\n\n## 2.10厳格モード\n\nタイプインスペクタでTypeScriptを使用するユーザーによって、どの程度厳密にチェックしたいかが異なります。一部の人は、プログラムの一部のみを検証するのに役立つ、より緩やかな検証体験を探していますが、それでもよいツールを持っています。これはTypeScriptのデフォルトの操作です。タイプはオプションで、推論は最も緩いタイプを使用します。 `null`/ `undefined` は、 `tsc` がエラーに直面したときにJSファイルをコンパイルして生成する方法と同様に、潜在的な `null`/ `undefined` の値をチェックしません。既存のJavaScriptを移行するのであれば、これは理想的な第一歩かもしれません。\n\nそれよりも、多くのユーザーがTypeScriptをできるだけすぐに検証できるようにすることを好むのは、この言語が厳格な設定を提供する理由です。これらの厳密な設定は、(コードがチェックされているかどうかにかかわらず)スイッチから、よりダイヤルアップに近いものへと静的なタイプチェックを変えます。このダイアルを遠くに合わせるほど、TypeScriptがチェックしてくれます。これには多少の追加作業が必要になるかもしれないが、概して長期的に見れば価値があり、より徹底した検査とより正確なツールを実現することができる。可能であれば、新しいコードベースではこれらの厳密性チェックを常にオンにしておくべきである。\n\nTypeScriptにはいくつかのタイプチェック厳密フラグがありますが、特に明記されていない限り、これらのフラグをすべて有効にして記述します。コマンドラインで[ `strict`](https://www.typescriptlang.org/tsconfig#strict)を設定するか、[ `tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)で `\"strict\": true` を設定して開きます。\n\n![](/img/TypeScript/02-10.png)\n\n![](/img/TypeScript/02-11.png)\n\n上の2つのケースは、 `--strict true` を構成したためにエラーが発生しました。\n\nまた、個別に構成を選択することもできます。知っておくべき最も典型的な2つは、[ `noImplicitAny`]（https://www.typescriptlang.org/tsconfig#noImplicitAny）と[ `strictNullChecks`]（https://www.typescriptlang.org/tsconfig#strictNullChecks）です。\n\n- ** `noImplicitAny` **\n\nいくつかの場所では、TypeScriptはタイプを推定しようとせず、最も緩いタイプに戻ります。 `any`。これは起こりうる最悪の事態ではありません--結局のところ、 `any` はいずれにしても、通常のJavaScript体験に戻ることができます。\n\nただし、通常、 `any` を使用すると、最初にTypeScriptを使用する目的が損なわれます。プログラムの種類が多ければ多いほど、より多くの検証やツールを手に入れることができます。つまり、コードを書くときのエラーが少なくなります。この[ `noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)フラグをオンにすると、タイプが暗黙的に推定され、変数がエラーを起こしたときに `any` が適用されます。\n\n<img src=\"https://s2.loli.net/2022/02/22/Ir7T4vckJMsSnuK.png\" alt=\"image-20211113122642576\" style=\"zoom:40%;\" />\n\n- ** `strictNullChecks` **\n\nデフォルトでは、 `null` および `undefined` の値は、他の任意の型に割り当てることができます。これはいくつかのコードを書くのを簡単にすることができますが、 `null` の処理を忘れて、 `undefined` があなたのコードの無数の誤りの原因です-一部の人はこれを[十亿美元的错误](https://www.youtube.com/watch?v=ybrQvs4x0Ps)と考えています！この[ `strictNullChecks`]（https://www.typescriptlang.org/tsconfig#strictNullChecks）フラグにより、オペレーション `null` および `undefined` がより明確になり、*忘れる*が `null` および `undefined` を処理するかどうかを心配する必要がなくなります。\n\n<img src=\"https://s2.loli.net/2022/02/22/wRlPY8gO9v1zkZa.png\" alt=\"image-20211113122914750\" style=\"zoom:50%;\" />\n\n### 特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。\n",
        "slug": "日本語/TypeScript/1-2、基本：TypeScriptの概要",
        "published": 1,
        "updated": "2024-02-14T14:03:41.936Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjans000194v3cdfvfhsx",
        "content": "<h1 id=\"二、TypeScriptについて\"><a href=\"#二、TypeScriptについて\" class=\"headerlink\" title=\"二、TypeScriptについて\"></a>二、TypeScriptについて</h1><h2 id=\"2-1問題の発見\"><a href=\"#2-1問題の発見\" class=\"headerlink\" title=\"2.1問題の発見\"></a>2.1問題の発見</h2><p>JavaScriptの各値には動作のセットがあり、さまざまなアクションを実行することで確認できます。これは抽象的に聞こえるので、簡単な例として、 <code>message</code> という変数に対して実行する可能性のあるアクションを考えてみましょう：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 &#x27;message&#x27; 上访问属性 &#x27;toLowerCase&#x27;，并调用它</span></span><br><span class=\"line\">message.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\"><span class=\"comment\">// 调用 &#x27;message&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">message</span>();</span><br></pre></td></tr></table></figure>\n\n<p>これを分解すると、実行可能なコードの最初の行は属性 <code>toLowerCase</code> にアクセスし、それを呼び出します。2番目の試みは、 <code>message</code> を直接呼び出すことです。</p>\n<p>しかし、 <code>message</code> が分からないとします。これはよくあることですが、これらのコードを実行しようとすると、どのような結果が得られるのかを確実に説明することはできません。各操作の動作は、最初に与えた <code>message</code> に依存します。</p>\n<ul>\n<li><code>message</code> を呼び出すことはできますか？</li>\n<li><code>toLowerCase</code> という属性を持っていますか？</li>\n<li>できる場合、 <code>toLowerCase</code> を呼び出すことができますか？</li>\n<li>両方の値が呼び出し可能な場合、何を返しますか。</li>\n</ul>\n<p>これらの質問に対する答えは、通常、JavaScriptを書くときに心に留めていることであり、すべての詳細が正確であることを期待しなければなりません。</p>\n<p><code>message</code> が次のように定義されているとします：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>予想されるように、 <code>message.toLowerCase()</code> を実行しようとすると、同じ小文字の文字列しか得られません。</p>\n<p>2行目のコードは？JavaScriptに精通していれば、これが失敗して例外が発生することがわかります：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: message is not a function</span><br></pre></td></tr></table></figure>\n\n<p>私たちがそのような間違いを避けられれば幸いです。</p>\n<p>コードを実行するとき、JavaScriptの実行時に何をするかを選択する方法は、値の<em>タイプ</em>を決定することです。それがどのような動作と機能を持つかを決定します。この <code>TypeError</code> は暗示の一部です。文字列 <code>&quot;Hello World!&quot;</code> は関数として呼び出すことはできません。</p>\n<p>基本型 <code>string</code> や <code>number</code> などの一部の値については、 <code>typeof</code> 演算子を使用して実行時にその型を識別できます。しかし、関数のような他のものについては、それらの型を識別するための適切な実行時機構がありません。たとえば、次の関数を考えてみます：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"title function_\">flip</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>コード<em>観察</em>を読むことで、この関数は <code>flip</code> を呼び出せるプロパティを持つオブジェクトが与えられている場合にのみ機能しますが、JavaScriptはコードの実行時に確認できるような方法でこれらの情報を表示しません。純粋なJavaScriptでは、 <code>fn</code> に特定の値が何をするかを指定する<strong>唯一の方法</strong>は、その値を呼び出して何が起こるかを確認します。この動作は、実行前にコードが何をするかを予測することを困難にします。つまり、コードを書くときにコードが何をするかを知ることがより困難になることを意味します。</p>\n<p>このように、<em>タイプ</em>は、 <code>fn</code> に渡すことができる値がクラッシュすることを示す概念である。JavaScriptが実際に提供するのは<em>動態</em>型だけです。コードを実行して、何が起こるかを確認してください。</p>\n<p>もう1つの方法は、<em>せいてき</em>タイプのシステム<em>在る</em>を使用して、<em>前</em>予測コードを実行することです。</p>\n<h2 id=\"2-2せいてきtypeけんさ\"><a href=\"#2-2せいてきtypeけんさ\" class=\"headerlink\" title=\"2.2せいてきtypeけんさ\"></a>2.2<strong>せいてきtypeけんさ</strong></h2><p><code>TypeError</code> 以前に <code>string</code> を関数として呼び出してみたことを思い出してください。<em>大多数の人</em>コードを実行するときに発生するあらゆる種類のエラーは好ましくありません。これらはエラーとみなされます！私たちは新しいコードを書くときに、新しいエラーを導入しないようにしています。</p>\n<p>理想的には、<em>在る</em>コード実行<em>前</em>がこれらのエラーを発見するのに役立つツールがあります。これは、TypeScriptのような静的タイプインスペクタによって行われます。<em>せいてきがたシステム</em>は、プログラムを実行したときの値の形状と動作を記述しています。TypeScriptのようなタイプチェッカーは、どんなときに物事が浮気する可能性があるかを教えてくれます。</p>\n<img src=\"https://s2.loli.net/2022/02/22/5yhsbTCF7cqVGNQ.png\" alt=\"image-20211109134610557\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>コードを実行する前にTypeScriptを使用して最後のサンプルを実行すると、エラーメッセージが表示されます。</p>\n<h2 id=\"2-3異常なし故障\"><a href=\"#2-3異常なし故障\" class=\"headerlink\" title=\"2.3異常なし故障\"></a>2.3<strong>異常なし故障</strong></h2><p>ここまでランタイムエラーについてお話ししてきました–JavaScriptの実行時に、何かが無意味だと思っていることを教えてくれる場合です。このような状況が発生するのは、<a href=\"https://tc39.github.io/ecma262/\">ECMAScript仕様</a>が予期しない状況が発生した場合に言語がどのように動作するかを明示的に示しているからです。</p>\n<p>たとえば、呼び出せないものを呼び出そうとすると、エラーがスローされると仕様書は言う。これは「明らかな行為」のように聞こえるかもしれませんが、オブジェクトに存在しない属性にアクセスしてもエラーがスローされるべきであることは想像できます。逆に、JavaScriptは別の動作を行い、値 <code>undefined</code> を返します：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;小千&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">26</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">user.<span class=\"property\">location</span>; <span class=\"comment\">// 返回 undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>最終的に、静的タイプのシステムでは、呼び出しが必要なコードがシステム内でマークされる必要があります。たとえ、それがすぐにエラーがスローされない「有効な」JavaScriptであっても、そのコードはそのシステム内でマークされる必要があります。たとえば、TypeScriptでは、次のコードが未定義の <code>location</code> に関するエラーを生成します：</p>\n<img src=\"https://s2.loli.net/2022/02/22/Qqo8BZmtJnGC1D4.png\" alt=\"image-20211109141050215\" style=\"zoom:50%;\" />\n\n<p>TypeScriptは、私たちのプログラム内の<em>おびただしい</em>正当なエラーをキャプチャすることができます。例：</p>\n<ul>\n<li>誤字<img src=\"/img/TypeScript/01-04.png\"></li>\n<li>呼び出されていない関数</li>\n</ul>\n<img src=\"https://s2.loli.net/2022/02/22/U1MmrPyjdbkueRC.png\" alt=\"image-20211109142053954\" style=\"zoom:50%;\" align=\"left\" />\n\n<ul>\n<li>または基本的な論理エラー</li>\n</ul>\n<p><img src=\"/img/TypeScript/01-06.png\"></p>\n<h2 id=\"2-4ツールの使用\"><a href=\"#2-4ツールの使用\" class=\"headerlink\" title=\"2.4ツールの使用\"></a>2.4<strong>ツールの使用</strong></h2><p>コード内でエラーが発生した場合、TypeScriptはエラーをキャッチします。これは素晴らしいことですが、TypeScriptも<em>まずは</em>私たちがこれらのミスを犯すのを防いでくれます。</p>\n<p>タイプインスペクタは、変数やその他のプロパティの正しいプロパティにアクセスしているかどうかなどを確認するのに役立ちます。これらの情報を取得すると、使用したい属性を開始することもできます<em>提案</em>。</p>\n<p>これは、ツールを使用してTypeScriptコードを編集するときにエラーメッセージとコード補完が表示され、コアタイプインスペクタがエディタにコードを入力できることを意味します。これは、TypeScriptのツールについて話す際によく言及する部分です。</p>\n<img src=\"https://s2.loli.net/2022/02/22/qolAfbMnVIcXvys.png\" alt=\"image-20211113085757666\" style=\"zoom: 25%;\" align=\"left\" />\n\n<p>TypeScriptはツールを非常に重視しています。TypeScriptをサポートするエディタには、エラーを自動的に修正する「簡易修正」機能、コードを簡単に再編成するためのリファクタリング機能、変数定義にジャンプしたり、特定の変数へのすべての参照を検索するための便利なナビゲーション機能が用意されています。これらはすべてタイプチェッカーに基づいており、完全にクロスプラットフォームであるため、<a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">您最喜欢的编辑器</a>は<a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">TypeScriptのサポートが利用可能</a>の可能性があります。</p>\n<h2 id=\"2-5-tsc-コンパイラ\"><a href=\"#2-5-tsc-コンパイラ\" class=\"headerlink\" title=\"2.5 tsc コンパイラ\"></a>2.5 <code>tsc</code> コンパイラ</h2><p>タイプチェックについて話してきましたが、私たちのタイプ<em>チェッカー</em>はまだ使用されていません。新しい友人 <code>tsc</code> TypeScriptコンパイラを紹介しましょう。まずnpmで入手する必要があります。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n\n<p>これにより、TypeScriptコンパイラがグローバルにインストールされます。</p>\n<p>では、空のフォルダに移動して、最初のTypeScriptプログラム <code>hello.ts</code> を作成してみましょう。</p>\n<p><strong>01-ts-basics&#x2F;hello.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>ここには余分な装飾がないことに注意してください。この「ハローワールド」プログラムは、JavaScriptで「ハローワールド」プログラム用に書いたプログラムと同じように見えます。次に、 <code>tsc</code> パッケージを実行して、 <code>typescript</code> パッケージをコンパイルします：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[felix] 01-ts-basics $ tsc hello.ts</span><br></pre></td></tr></table></figure>\n\n<p>私たちは <code>tsc</code> を走りましたが、何も起きませんでした！はい、タイプエラーはありませんので、何も報告されていないので、コンソールには何も出力されていません。</p>\n<img src=\"https://s2.loli.net/2022/02/22/APiNb5FzvuwGlZk.png\" alt=\"image-20211113093244339\" style=\"zoom: 50%;\" align=\"left\"/>\n\n<p>しかし、もう一度調べてみると、<em>ファイル</em>という出力がいくつか出てきます。現在のディレクトリを見ると、2つのファイル <code>hello.js</code> が <code>hello.ts</code> にあります。これは、 <code>hello.ts</code> ファイルが <code>tsc</code> <em>コンパイル</em>または<em>変換</em>に純粋なJavaScriptファイルである場合の出力です。</p>\n<img src=\"https://s2.loli.net/2022/02/22/ctI9MPpSY1y8uLr.png\" alt=\"image-20211113093559374\" style=\"zoom: 50%;\" align=\"left\" />\n\n<p><code>hello.js</code> を確認すると、 <code>.ts</code> ファイルを処理した後にTypeScriptが吐き出す内容が表示されます：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>この場合、TypeScriptは変換するものがほとんどないので、私たちが書いたものと同じように見えます。コンパイラは、人間が書いたもののように見える、明瞭に読めるコードをコンパイルしようとします。注釈も残しておいてください。</p>\n<p>タイプチェックエラーを導入した場合<em>確かに</em>はどうでしょうか。 <code>hello.ts</code> を上書きしてみましょう。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person, date</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小千&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>もう一度実行すると、コマンドラインにエラーが表示されます！</p>\n<img src=\"https://s2.loli.net/2022/02/22/QNL3DlBHYUbxu9Z.png\" alt=\"image-20211113095515775\" style=\"zoom:50%;\" align=\"left\"/>\n\n<p>TypeScriptは、 <code>greet</code> 関数に引数を渡すことを忘れていることを示していますが、これは当然のことです。これまでは標準的なJavaScriptしか書いていませんでしたが、タイプチェックではコードの他の問題を見つけることができます。TypeScriptに感謝！</p>\n<h2 id=\"2-6エラーが発生しました\"><a href=\"#2-6エラーが発生しました\" class=\"headerlink\" title=\"2.6エラーが発生しました\"></a>2.6エラーが発生しました</h2><p>前の例では、私たちの <code>hello.js</code> ファイルが再び変更されたことに気がつかないかもしれません。このファイルを開くと、内容が入力ファイルとほぼ同じであることがわかります。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person, date</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello &quot;</span> + person + <span class=\"string\">&quot;, today is &quot;</span> + date + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小千&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>tsc</code> が私たちのコードに関するエラーを報告しているという事実を考えると、これは少し驚くべきことかもしれませんが、これはTypeScriptの重要な価値観の1つに基づいています。ほとんどの場合、<em>君</em>はTypeScriptよりも何が起きているかを理解しています。</p>\n<p>これまでにも触れておくと、タイプチェックコードによって実行できるプログラムの種類が制限されているため、タイプチェッカーが許容できると判断したタイプを比較検討する必要があります。ほとんどの場合、これは問題ありませんが、場合によっては、これらのチェックが邪魔になることがあります。たとえば、JavaScriptコードをTypeScriptに移行し、タイプチェックエラーを導入したとします。最終的には、タイプチェッカーのコードクリーンアップを開始しますが、元のJavaScriptコードを実行できるようになりました！なぜ、JSコードをTypeScriptコードに変換して実行しないようにしなければならないのでしょうか。</p>\n<p>したがって、デフォルトではTypeScriptは我々のコードの実行を妨げることはありません。これらのJSはホスト環境で実行されても問題ありません。もちろん、時間の経過とともに、エラーに対してより防御し、TypeScriptの挙動をより厳しくしたいと思うかもしれません。この場合は、<a href=\"https://www.typescriptlang.org/tsconfig#noEmitOnError\"> <code>noEmitOnError</code></a>コンパイラオプションを使用します。このオプションを使用して、 <code>hello.ts</code> ファイルを変更し、 <code>tsc</code> を再コンパイルしてみます：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --noEmitOnError hello.ts</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-04.png\"></p>\n<p><code>hello.js</code> は決して更新されないことに気づくでしょう。</p>\n<h2 id=\"2-7明示型\"><a href=\"#2-7明示型\" class=\"headerlink\" title=\"2.7明示型\"></a>2.7明示型</h2><p>これまでのところ、typescript <code>person</code> や <code>date</code> がどのような型であるかは教えていません。コードを編集するときに、 <code>person</code> は <code>string</code> であり、 <code>date</code> は <code>Date</code> オブジェクトであるべきであることをTypeScriptに伝えます。</p>\n<p>これにより、TypeScriptは他の <code>greet</code> が誤って呼び出された可能性があることを知らせることができます。たとえば、 <code>hello.ts</code> コードを変更します：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person: string, date: <span class=\"built_in\">Date</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-05.png\"></p>\n<p>ん？TypeScriptは2番目のパラメータでエラーを報告していますが、これはなぜでしょうか。</p>\n<p>驚くべきことに、 <code>Date()</code> をJavaScriptで呼び出すと、 <code>string</code> が返されます。 <code>new Date()</code> を使用すると、期待どおりに簡単にエラーを修正できます：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person: string, date: <span class=\"built_in\">Date</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小锋&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-06.png\"></p>\n<p>コンパイルに成功した結果、 <code>hello.js</code> が出力されました。</p>\n<p>変数に明示的な型コメントを書く必要があるわけではないことを覚えておいてください。多くの場合、タイプの定義を無視しても、TypeScriptはタイプを自動的に<em>推論</em>(または「見つける」)ことができます。例えば：</p>\n<img src=\"https://s2.loli.net/2022/02/22/N2pXBbY6LRwoaC1.png\" alt=\"image-20211113111924590\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>ここではmsgに具体的な型を指定しておらず、typescriptは関数の実数から型を自動的に推定する。これは、タイプシステムが最終的に同じタイプを推定する場合には、タイプコメントを追加しない方がよい特性です。</p>\n<h2 id=\"2-8消去タイプ\"><a href=\"#2-8消去タイプ\" class=\"headerlink\" title=\"2.8消去タイプ\"></a>2.8消去タイプ</h2><p>上のコードを <code>tsc</code> でコンパイルしたときにどのようなJavaScriptが出力されるかを詳しく見てみましょう。 <code>hello.js</code></p>\n<p><img src=\"/img/TypeScript/02-08.png\"></p>\n<p>ここでは、2つの点に注意してください：</p>\n<ol>\n<li>引数 <code>person</code> および <code>date</code> には型に関するコメントがありません。</li>\n<li>「テンプレート文字列」–逆引用符(&#96;文字)を使用した文字列は、連結(+)を持つ純粋な文字列に変換されます。</li>\n</ol>\n<p>2点目については後ほど詳しく紹介しますが、ここでは1点目に焦点を当ててみましょう。型注釈はJavaScriptの一部ではありません(つまり、ECMAScriptは遅れています)。そのため、実際にはブラウザが存在しないか、他のランタイムが変更なしでTypeScriptを実行することができます。これは、TypeScriptが最初にコンパイラを必要とする理由です。TypeScript固有のコードを切り離したり変換したりして、実行できるようにする方法が必要です。TypeScript固有のコードのほとんどが削除されました。</p>\n<blockquote>\n<p><strong>覚えておいてください</strong>：型コメントは、プログラムの実行時の動作を変更しません。</p>\n</blockquote>\n<h2 id=\"2-9ダウングレードコンパイル\"><a href=\"#2-9ダウングレードコンパイル\" class=\"headerlink\" title=\"2.9ダウングレードコンパイル\"></a>2.9ダウングレードコンパイル</h2><p>上記とのもう1つの違いは、テンプレート文字列が次のものから構成されていることです：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>対象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello &quot;</span> + person + <span class=\"string\">&quot;, today is &quot;</span> + date.<span class=\"title function_\">toDateString</span>() + <span class=\"string\">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>なぜそうなったのか。</p>\n<p>テンプレート文字列は、ECMAScriptバージョンの機能であり、ECMAScript 2015（別名ECMAScript 6、ES2015、ES6など）と呼ばれます。TypeScriptは、新しいバージョンのECMAScriptから古いバージョン(ECMAScript 3やECMAScript 5(別名ES3とES5)など)にコードを書き換えることができます。ECMAScriptの最新バージョンまたはそれ以降のバージョンから、古いバージョンまたはそれ以前のバージョンへの移行プロセスは、<em>降格</em>と呼ばれることがあります。</p>\n<p>デフォルトでは、TypeScriptはECMAScriptの非常に古いバージョンであるES3をターゲットにしています。<a href=\"https://www.typescriptlang.org/tsconfig#target\"> <code>target</code></a>オプションを使用すると、のコンテンツを更新することができます。 <code>--target es2015</code> TypeScriptを実行してECMAScript 2015に変更を加えます。つまり、コードはECMAScript 2015をサポートするどこでも実行できるはずです。したがって、 <code>tsc --target es2015 hello.ts</code> を実行すると、次のような出力が得られます：</p>\n<img src=\"https://s2.loli.net/2022/02/22/3BbKfisq9htp4nr.png\" alt=\"image-20211113113644658\" style=\"zoom:33%;\" />\n\n<blockquote>\n<p>デフォルトのターゲットはES3ですが、現在はほとんどのブラウザがES2015をサポートしています。そのため、一部の古いブラウザとの互換性を考慮しない限り、ほとんどの開発者はES2015以降をターゲットとして安全に指定することができます。</p>\n</blockquote>\n<h2 id=\"2-10厳格モード\"><a href=\"#2-10厳格モード\" class=\"headerlink\" title=\"2.10厳格モード\"></a>2.10厳格モード</h2><p>タイプインスペクタでTypeScriptを使用するユーザーによって、どの程度厳密にチェックしたいかが異なります。一部の人は、プログラムの一部のみを検証するのに役立つ、より緩やかな検証体験を探していますが、それでもよいツールを持っています。これはTypeScriptのデフォルトの操作です。タイプはオプションで、推論は最も緩いタイプを使用します。 <code>null</code>&#x2F; <code>undefined</code> は、 <code>tsc</code> がエラーに直面したときにJSファイルをコンパイルして生成する方法と同様に、潜在的な <code>null</code>&#x2F; <code>undefined</code> の値をチェックしません。既存のJavaScriptを移行するのであれば、これは理想的な第一歩かもしれません。</p>\n<p>それよりも、多くのユーザーがTypeScriptをできるだけすぐに検証できるようにすることを好むのは、この言語が厳格な設定を提供する理由です。これらの厳密な設定は、(コードがチェックされているかどうかにかかわらず)スイッチから、よりダイヤルアップに近いものへと静的なタイプチェックを変えます。このダイアルを遠くに合わせるほど、TypeScriptがチェックしてくれます。これには多少の追加作業が必要になるかもしれないが、概して長期的に見れば価値があり、より徹底した検査とより正確なツールを実現することができる。可能であれば、新しいコードベースではこれらの厳密性チェックを常にオンにしておくべきである。</p>\n<p>TypeScriptにはいくつかのタイプチェック厳密フラグがありますが、特に明記されていない限り、これらのフラグをすべて有効にして記述します。コマンドラインで<a href=\"https://www.typescriptlang.org/tsconfig#strict\"> <code>strict</code></a>を設定するか、<a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\"> <code>tsconfig.json</code></a>で <code>&quot;strict&quot;: true</code> を設定して開きます。</p>\n<p><img src=\"/img/TypeScript/02-10.png\"></p>\n<p><img src=\"/img/TypeScript/02-11.png\"></p>\n<p>上の2つのケースは、 <code>--strict true</code> を構成したためにエラーが発生しました。</p>\n<p>また、個別に構成を選択することもできます。知っておくべき最も典型的な2つは、[ <code>noImplicitAny</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny%EF%BC%89%E3%81%A8[\">https://www.typescriptlang.org/tsconfig#noImplicitAny）と[</a> <code>strictNullChecks</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks%EF%BC%89%E3%81%A7%E3%81%99%E3%80%82\">https://www.typescriptlang.org/tsconfig#strictNullChecks）です。</a></p>\n<ul>\n<li>** <code>noImplicitAny</code> **</li>\n</ul>\n<p>いくつかの場所では、TypeScriptはタイプを推定しようとせず、最も緩いタイプに戻ります。 <code>any</code>。これは起こりうる最悪の事態ではありません–結局のところ、 <code>any</code> はいずれにしても、通常のJavaScript体験に戻ることができます。</p>\n<p>ただし、通常、 <code>any</code> を使用すると、最初にTypeScriptを使用する目的が損なわれます。プログラムの種類が多ければ多いほど、より多くの検証やツールを手に入れることができます。つまり、コードを書くときのエラーが少なくなります。この<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"> <code>noImplicitAny</code></a>フラグをオンにすると、タイプが暗黙的に推定され、変数がエラーを起こしたときに <code>any</code> が適用されます。</p>\n<img src=\"https://s2.loli.net/2022/02/22/Ir7T4vckJMsSnuK.png\" alt=\"image-20211113122642576\" style=\"zoom:40%;\" />\n\n<ul>\n<li>** <code>strictNullChecks</code> **</li>\n</ul>\n<p>デフォルトでは、 <code>null</code> および <code>undefined</code> の値は、他の任意の型に割り当てることができます。これはいくつかのコードを書くのを簡単にすることができますが、 <code>null</code> の処理を忘れて、 <code>undefined</code> があなたのコードの無数の誤りの原因です-一部の人はこれを<a href=\"https://www.youtube.com/watch?v=ybrQvs4x0Ps\">十亿美元的错误</a>と考えています！この[ <code>strictNullChecks</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks%EF%BC%89%E3%83%95%E3%83%A9%E3%82%B0%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3\">https://www.typescriptlang.org/tsconfig#strictNullChecks）フラグにより、オペレーション</a> <code>null</code> および <code>undefined</code> がより明確になり、<em>忘れる</em>が <code>null</code> および <code>undefined</code> を処理するかどうかを心配する必要がなくなります。</p>\n<img src=\"https://s2.loli.net/2022/02/22/wRlPY8gO9v1zkZa.png\" alt=\"image-20211113122914750\" style=\"zoom:50%;\" />\n\n<h3 id=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"><a href=\"#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\" class=\"headerlink\" title=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"></a>特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"二、TypeScriptについて\"><a href=\"#二、TypeScriptについて\" class=\"headerlink\" title=\"二、TypeScriptについて\"></a>二、TypeScriptについて</h1><h2 id=\"2-1問題の発見\"><a href=\"#2-1問題の発見\" class=\"headerlink\" title=\"2.1問題の発見\"></a>2.1問題の発見</h2><p>JavaScriptの各値には動作のセットがあり、さまざまなアクションを実行することで確認できます。これは抽象的に聞こえるので、簡単な例として、 <code>message</code> という変数に対して実行する可能性のあるアクションを考えてみましょう：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 &#x27;message&#x27; 上访问属性 &#x27;toLowerCase&#x27;，并调用它</span></span><br><span class=\"line\">message.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\"><span class=\"comment\">// 调用 &#x27;message&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">message</span>();</span><br></pre></td></tr></table></figure>\n\n<p>これを分解すると、実行可能なコードの最初の行は属性 <code>toLowerCase</code> にアクセスし、それを呼び出します。2番目の試みは、 <code>message</code> を直接呼び出すことです。</p>\n<p>しかし、 <code>message</code> が分からないとします。これはよくあることですが、これらのコードを実行しようとすると、どのような結果が得られるのかを確実に説明することはできません。各操作の動作は、最初に与えた <code>message</code> に依存します。</p>\n<ul>\n<li><code>message</code> を呼び出すことはできますか？</li>\n<li><code>toLowerCase</code> という属性を持っていますか？</li>\n<li>できる場合、 <code>toLowerCase</code> を呼び出すことができますか？</li>\n<li>両方の値が呼び出し可能な場合、何を返しますか。</li>\n</ul>\n<p>これらの質問に対する答えは、通常、JavaScriptを書くときに心に留めていることであり、すべての詳細が正確であることを期待しなければなりません。</p>\n<p><code>message</code> が次のように定義されているとします：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>予想されるように、 <code>message.toLowerCase()</code> を実行しようとすると、同じ小文字の文字列しか得られません。</p>\n<p>2行目のコードは？JavaScriptに精通していれば、これが失敗して例外が発生することがわかります：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: message is not a function</span><br></pre></td></tr></table></figure>\n\n<p>私たちがそのような間違いを避けられれば幸いです。</p>\n<p>コードを実行するとき、JavaScriptの実行時に何をするかを選択する方法は、値の<em>タイプ</em>を決定することです。それがどのような動作と機能を持つかを決定します。この <code>TypeError</code> は暗示の一部です。文字列 <code>&quot;Hello World!&quot;</code> は関数として呼び出すことはできません。</p>\n<p>基本型 <code>string</code> や <code>number</code> などの一部の値については、 <code>typeof</code> 演算子を使用して実行時にその型を識別できます。しかし、関数のような他のものについては、それらの型を識別するための適切な実行時機構がありません。たとえば、次の関数を考えてみます：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"title function_\">flip</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>コード<em>観察</em>を読むことで、この関数は <code>flip</code> を呼び出せるプロパティを持つオブジェクトが与えられている場合にのみ機能しますが、JavaScriptはコードの実行時に確認できるような方法でこれらの情報を表示しません。純粋なJavaScriptでは、 <code>fn</code> に特定の値が何をするかを指定する<strong>唯一の方法</strong>は、その値を呼び出して何が起こるかを確認します。この動作は、実行前にコードが何をするかを予測することを困難にします。つまり、コードを書くときにコードが何をするかを知ることがより困難になることを意味します。</p>\n<p>このように、<em>タイプ</em>は、 <code>fn</code> に渡すことができる値がクラッシュすることを示す概念である。JavaScriptが実際に提供するのは<em>動態</em>型だけです。コードを実行して、何が起こるかを確認してください。</p>\n<p>もう1つの方法は、<em>せいてき</em>タイプのシステム<em>在る</em>を使用して、<em>前</em>予測コードを実行することです。</p>\n<h2 id=\"2-2せいてきtypeけんさ\"><a href=\"#2-2せいてきtypeけんさ\" class=\"headerlink\" title=\"2.2せいてきtypeけんさ\"></a>2.2<strong>せいてきtypeけんさ</strong></h2><p><code>TypeError</code> 以前に <code>string</code> を関数として呼び出してみたことを思い出してください。<em>大多数の人</em>コードを実行するときに発生するあらゆる種類のエラーは好ましくありません。これらはエラーとみなされます！私たちは新しいコードを書くときに、新しいエラーを導入しないようにしています。</p>\n<p>理想的には、<em>在る</em>コード実行<em>前</em>がこれらのエラーを発見するのに役立つツールがあります。これは、TypeScriptのような静的タイプインスペクタによって行われます。<em>せいてきがたシステム</em>は、プログラムを実行したときの値の形状と動作を記述しています。TypeScriptのようなタイプチェッカーは、どんなときに物事が浮気する可能性があるかを教えてくれます。</p>\n<img src=\"https://s2.loli.net/2022/02/22/5yhsbTCF7cqVGNQ.png\" alt=\"image-20211109134610557\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>コードを実行する前にTypeScriptを使用して最後のサンプルを実行すると、エラーメッセージが表示されます。</p>\n<h2 id=\"2-3異常なし故障\"><a href=\"#2-3異常なし故障\" class=\"headerlink\" title=\"2.3異常なし故障\"></a>2.3<strong>異常なし故障</strong></h2><p>ここまでランタイムエラーについてお話ししてきました–JavaScriptの実行時に、何かが無意味だと思っていることを教えてくれる場合です。このような状況が発生するのは、<a href=\"https://tc39.github.io/ecma262/\">ECMAScript仕様</a>が予期しない状況が発生した場合に言語がどのように動作するかを明示的に示しているからです。</p>\n<p>たとえば、呼び出せないものを呼び出そうとすると、エラーがスローされると仕様書は言う。これは「明らかな行為」のように聞こえるかもしれませんが、オブジェクトに存在しない属性にアクセスしてもエラーがスローされるべきであることは想像できます。逆に、JavaScriptは別の動作を行い、値 <code>undefined</code> を返します：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;小千&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">26</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">user.<span class=\"property\">location</span>; <span class=\"comment\">// 返回 undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>最終的に、静的タイプのシステムでは、呼び出しが必要なコードがシステム内でマークされる必要があります。たとえ、それがすぐにエラーがスローされない「有効な」JavaScriptであっても、そのコードはそのシステム内でマークされる必要があります。たとえば、TypeScriptでは、次のコードが未定義の <code>location</code> に関するエラーを生成します：</p>\n<img src=\"https://s2.loli.net/2022/02/22/Qqo8BZmtJnGC1D4.png\" alt=\"image-20211109141050215\" style=\"zoom:50%;\" />\n\n<p>TypeScriptは、私たちのプログラム内の<em>おびただしい</em>正当なエラーをキャプチャすることができます。例：</p>\n<ul>\n<li>誤字<img src=\"/img/TypeScript/01-04.png\"></li>\n<li>呼び出されていない関数</li>\n</ul>\n<img src=\"https://s2.loli.net/2022/02/22/U1MmrPyjdbkueRC.png\" alt=\"image-20211109142053954\" style=\"zoom:50%;\" align=\"left\" />\n\n<ul>\n<li>または基本的な論理エラー</li>\n</ul>\n<p><img src=\"/img/TypeScript/01-06.png\"></p>\n<h2 id=\"2-4ツールの使用\"><a href=\"#2-4ツールの使用\" class=\"headerlink\" title=\"2.4ツールの使用\"></a>2.4<strong>ツールの使用</strong></h2><p>コード内でエラーが発生した場合、TypeScriptはエラーをキャッチします。これは素晴らしいことですが、TypeScriptも<em>まずは</em>私たちがこれらのミスを犯すのを防いでくれます。</p>\n<p>タイプインスペクタは、変数やその他のプロパティの正しいプロパティにアクセスしているかどうかなどを確認するのに役立ちます。これらの情報を取得すると、使用したい属性を開始することもできます<em>提案</em>。</p>\n<p>これは、ツールを使用してTypeScriptコードを編集するときにエラーメッセージとコード補完が表示され、コアタイプインスペクタがエディタにコードを入力できることを意味します。これは、TypeScriptのツールについて話す際によく言及する部分です。</p>\n<img src=\"https://s2.loli.net/2022/02/22/qolAfbMnVIcXvys.png\" alt=\"image-20211113085757666\" style=\"zoom: 25%;\" align=\"left\" />\n\n<p>TypeScriptはツールを非常に重視しています。TypeScriptをサポートするエディタには、エラーを自動的に修正する「簡易修正」機能、コードを簡単に再編成するためのリファクタリング機能、変数定義にジャンプしたり、特定の変数へのすべての参照を検索するための便利なナビゲーション機能が用意されています。これらはすべてタイプチェッカーに基づいており、完全にクロスプラットフォームであるため、<a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">您最喜欢的编辑器</a>は<a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">TypeScriptのサポートが利用可能</a>の可能性があります。</p>\n<h2 id=\"2-5-tsc-コンパイラ\"><a href=\"#2-5-tsc-コンパイラ\" class=\"headerlink\" title=\"2.5 tsc コンパイラ\"></a>2.5 <code>tsc</code> コンパイラ</h2><p>タイプチェックについて話してきましたが、私たちのタイプ<em>チェッカー</em>はまだ使用されていません。新しい友人 <code>tsc</code> TypeScriptコンパイラを紹介しましょう。まずnpmで入手する必要があります。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n\n<p>これにより、TypeScriptコンパイラがグローバルにインストールされます。</p>\n<p>では、空のフォルダに移動して、最初のTypeScriptプログラム <code>hello.ts</code> を作成してみましょう。</p>\n<p><strong>01-ts-basics&#x2F;hello.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>ここには余分な装飾がないことに注意してください。この「ハローワールド」プログラムは、JavaScriptで「ハローワールド」プログラム用に書いたプログラムと同じように見えます。次に、 <code>tsc</code> パッケージを実行して、 <code>typescript</code> パッケージをコンパイルします：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[felix] 01-ts-basics $ tsc hello.ts</span><br></pre></td></tr></table></figure>\n\n<p>私たちは <code>tsc</code> を走りましたが、何も起きませんでした！はい、タイプエラーはありませんので、何も報告されていないので、コンソールには何も出力されていません。</p>\n<img src=\"https://s2.loli.net/2022/02/22/APiNb5FzvuwGlZk.png\" alt=\"image-20211113093244339\" style=\"zoom: 50%;\" align=\"left\"/>\n\n<p>しかし、もう一度調べてみると、<em>ファイル</em>という出力がいくつか出てきます。現在のディレクトリを見ると、2つのファイル <code>hello.js</code> が <code>hello.ts</code> にあります。これは、 <code>hello.ts</code> ファイルが <code>tsc</code> <em>コンパイル</em>または<em>変換</em>に純粋なJavaScriptファイルである場合の出力です。</p>\n<img src=\"https://s2.loli.net/2022/02/22/ctI9MPpSY1y8uLr.png\" alt=\"image-20211113093559374\" style=\"zoom: 50%;\" align=\"left\" />\n\n<p><code>hello.js</code> を確認すると、 <code>.ts</code> ファイルを処理した後にTypeScriptが吐き出す内容が表示されます：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>この場合、TypeScriptは変換するものがほとんどないので、私たちが書いたものと同じように見えます。コンパイラは、人間が書いたもののように見える、明瞭に読めるコードをコンパイルしようとします。注釈も残しておいてください。</p>\n<p>タイプチェックエラーを導入した場合<em>確かに</em>はどうでしょうか。 <code>hello.ts</code> を上書きしてみましょう。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person, date</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小千&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>もう一度実行すると、コマンドラインにエラーが表示されます！</p>\n<img src=\"https://s2.loli.net/2022/02/22/QNL3DlBHYUbxu9Z.png\" alt=\"image-20211113095515775\" style=\"zoom:50%;\" align=\"left\"/>\n\n<p>TypeScriptは、 <code>greet</code> 関数に引数を渡すことを忘れていることを示していますが、これは当然のことです。これまでは標準的なJavaScriptしか書いていませんでしたが、タイプチェックではコードの他の問題を見つけることができます。TypeScriptに感謝！</p>\n<h2 id=\"2-6エラーが発生しました\"><a href=\"#2-6エラーが発生しました\" class=\"headerlink\" title=\"2.6エラーが発生しました\"></a>2.6エラーが発生しました</h2><p>前の例では、私たちの <code>hello.js</code> ファイルが再び変更されたことに気がつかないかもしれません。このファイルを開くと、内容が入力ファイルとほぼ同じであることがわかります。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person, date</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello &quot;</span> + person + <span class=\"string\">&quot;, today is &quot;</span> + date + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小千&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>tsc</code> が私たちのコードに関するエラーを報告しているという事実を考えると、これは少し驚くべきことかもしれませんが、これはTypeScriptの重要な価値観の1つに基づいています。ほとんどの場合、<em>君</em>はTypeScriptよりも何が起きているかを理解しています。</p>\n<p>これまでにも触れておくと、タイプチェックコードによって実行できるプログラムの種類が制限されているため、タイプチェッカーが許容できると判断したタイプを比較検討する必要があります。ほとんどの場合、これは問題ありませんが、場合によっては、これらのチェックが邪魔になることがあります。たとえば、JavaScriptコードをTypeScriptに移行し、タイプチェックエラーを導入したとします。最終的には、タイプチェッカーのコードクリーンアップを開始しますが、元のJavaScriptコードを実行できるようになりました！なぜ、JSコードをTypeScriptコードに変換して実行しないようにしなければならないのでしょうか。</p>\n<p>したがって、デフォルトではTypeScriptは我々のコードの実行を妨げることはありません。これらのJSはホスト環境で実行されても問題ありません。もちろん、時間の経過とともに、エラーに対してより防御し、TypeScriptの挙動をより厳しくしたいと思うかもしれません。この場合は、<a href=\"https://www.typescriptlang.org/tsconfig#noEmitOnError\"> <code>noEmitOnError</code></a>コンパイラオプションを使用します。このオプションを使用して、 <code>hello.ts</code> ファイルを変更し、 <code>tsc</code> を再コンパイルしてみます：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --noEmitOnError hello.ts</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-04.png\"></p>\n<p><code>hello.js</code> は決して更新されないことに気づくでしょう。</p>\n<h2 id=\"2-7明示型\"><a href=\"#2-7明示型\" class=\"headerlink\" title=\"2.7明示型\"></a>2.7明示型</h2><p>これまでのところ、typescript <code>person</code> や <code>date</code> がどのような型であるかは教えていません。コードを編集するときに、 <code>person</code> は <code>string</code> であり、 <code>date</code> は <code>Date</code> オブジェクトであるべきであることをTypeScriptに伝えます。</p>\n<p>これにより、TypeScriptは他の <code>greet</code> が誤って呼び出された可能性があることを知らせることができます。たとえば、 <code>hello.ts</code> コードを変更します：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person: string, date: <span class=\"built_in\">Date</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-05.png\"></p>\n<p>ん？TypeScriptは2番目のパラメータでエラーを報告していますが、これはなぜでしょうか。</p>\n<p>驚くべきことに、 <code>Date()</code> をJavaScriptで呼び出すと、 <code>string</code> が返されます。 <code>new Date()</code> を使用すると、期待どおりに簡単にエラーを修正できます：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person: string, date: <span class=\"built_in\">Date</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小锋&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-06.png\"></p>\n<p>コンパイルに成功した結果、 <code>hello.js</code> が出力されました。</p>\n<p>変数に明示的な型コメントを書く必要があるわけではないことを覚えておいてください。多くの場合、タイプの定義を無視しても、TypeScriptはタイプを自動的に<em>推論</em>(または「見つける」)ことができます。例えば：</p>\n<img src=\"https://s2.loli.net/2022/02/22/N2pXBbY6LRwoaC1.png\" alt=\"image-20211113111924590\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>ここではmsgに具体的な型を指定しておらず、typescriptは関数の実数から型を自動的に推定する。これは、タイプシステムが最終的に同じタイプを推定する場合には、タイプコメントを追加しない方がよい特性です。</p>\n<h2 id=\"2-8消去タイプ\"><a href=\"#2-8消去タイプ\" class=\"headerlink\" title=\"2.8消去タイプ\"></a>2.8消去タイプ</h2><p>上のコードを <code>tsc</code> でコンパイルしたときにどのようなJavaScriptが出力されるかを詳しく見てみましょう。 <code>hello.js</code></p>\n<p><img src=\"/img/TypeScript/02-08.png\"></p>\n<p>ここでは、2つの点に注意してください：</p>\n<ol>\n<li>引数 <code>person</code> および <code>date</code> には型に関するコメントがありません。</li>\n<li>「テンプレート文字列」–逆引用符(&#96;文字)を使用した文字列は、連結(+)を持つ純粋な文字列に変換されます。</li>\n</ol>\n<p>2点目については後ほど詳しく紹介しますが、ここでは1点目に焦点を当ててみましょう。型注釈はJavaScriptの一部ではありません(つまり、ECMAScriptは遅れています)。そのため、実際にはブラウザが存在しないか、他のランタイムが変更なしでTypeScriptを実行することができます。これは、TypeScriptが最初にコンパイラを必要とする理由です。TypeScript固有のコードを切り離したり変換したりして、実行できるようにする方法が必要です。TypeScript固有のコードのほとんどが削除されました。</p>\n<blockquote>\n<p><strong>覚えておいてください</strong>：型コメントは、プログラムの実行時の動作を変更しません。</p>\n</blockquote>\n<h2 id=\"2-9ダウングレードコンパイル\"><a href=\"#2-9ダウングレードコンパイル\" class=\"headerlink\" title=\"2.9ダウングレードコンパイル\"></a>2.9ダウングレードコンパイル</h2><p>上記とのもう1つの違いは、テンプレート文字列が次のものから構成されていることです：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>対象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello &quot;</span> + person + <span class=\"string\">&quot;, today is &quot;</span> + date.<span class=\"title function_\">toDateString</span>() + <span class=\"string\">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>なぜそうなったのか。</p>\n<p>テンプレート文字列は、ECMAScriptバージョンの機能であり、ECMAScript 2015（別名ECMAScript 6、ES2015、ES6など）と呼ばれます。TypeScriptは、新しいバージョンのECMAScriptから古いバージョン(ECMAScript 3やECMAScript 5(別名ES3とES5)など)にコードを書き換えることができます。ECMAScriptの最新バージョンまたはそれ以降のバージョンから、古いバージョンまたはそれ以前のバージョンへの移行プロセスは、<em>降格</em>と呼ばれることがあります。</p>\n<p>デフォルトでは、TypeScriptはECMAScriptの非常に古いバージョンであるES3をターゲットにしています。<a href=\"https://www.typescriptlang.org/tsconfig#target\"> <code>target</code></a>オプションを使用すると、のコンテンツを更新することができます。 <code>--target es2015</code> TypeScriptを実行してECMAScript 2015に変更を加えます。つまり、コードはECMAScript 2015をサポートするどこでも実行できるはずです。したがって、 <code>tsc --target es2015 hello.ts</code> を実行すると、次のような出力が得られます：</p>\n<img src=\"https://s2.loli.net/2022/02/22/3BbKfisq9htp4nr.png\" alt=\"image-20211113113644658\" style=\"zoom:33%;\" />\n\n<blockquote>\n<p>デフォルトのターゲットはES3ですが、現在はほとんどのブラウザがES2015をサポートしています。そのため、一部の古いブラウザとの互換性を考慮しない限り、ほとんどの開発者はES2015以降をターゲットとして安全に指定することができます。</p>\n</blockquote>\n<h2 id=\"2-10厳格モード\"><a href=\"#2-10厳格モード\" class=\"headerlink\" title=\"2.10厳格モード\"></a>2.10厳格モード</h2><p>タイプインスペクタでTypeScriptを使用するユーザーによって、どの程度厳密にチェックしたいかが異なります。一部の人は、プログラムの一部のみを検証するのに役立つ、より緩やかな検証体験を探していますが、それでもよいツールを持っています。これはTypeScriptのデフォルトの操作です。タイプはオプションで、推論は最も緩いタイプを使用します。 <code>null</code>&#x2F; <code>undefined</code> は、 <code>tsc</code> がエラーに直面したときにJSファイルをコンパイルして生成する方法と同様に、潜在的な <code>null</code>&#x2F; <code>undefined</code> の値をチェックしません。既存のJavaScriptを移行するのであれば、これは理想的な第一歩かもしれません。</p>\n<p>それよりも、多くのユーザーがTypeScriptをできるだけすぐに検証できるようにすることを好むのは、この言語が厳格な設定を提供する理由です。これらの厳密な設定は、(コードがチェックされているかどうかにかかわらず)スイッチから、よりダイヤルアップに近いものへと静的なタイプチェックを変えます。このダイアルを遠くに合わせるほど、TypeScriptがチェックしてくれます。これには多少の追加作業が必要になるかもしれないが、概して長期的に見れば価値があり、より徹底した検査とより正確なツールを実現することができる。可能であれば、新しいコードベースではこれらの厳密性チェックを常にオンにしておくべきである。</p>\n<p>TypeScriptにはいくつかのタイプチェック厳密フラグがありますが、特に明記されていない限り、これらのフラグをすべて有効にして記述します。コマンドラインで<a href=\"https://www.typescriptlang.org/tsconfig#strict\"> <code>strict</code></a>を設定するか、<a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\"> <code>tsconfig.json</code></a>で <code>&quot;strict&quot;: true</code> を設定して開きます。</p>\n<p><img src=\"/img/TypeScript/02-10.png\"></p>\n<p><img src=\"/img/TypeScript/02-11.png\"></p>\n<p>上の2つのケースは、 <code>--strict true</code> を構成したためにエラーが発生しました。</p>\n<p>また、個別に構成を選択することもできます。知っておくべき最も典型的な2つは、[ <code>noImplicitAny</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny%EF%BC%89%E3%81%A8[\">https://www.typescriptlang.org/tsconfig#noImplicitAny）と[</a> <code>strictNullChecks</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks%EF%BC%89%E3%81%A7%E3%81%99%E3%80%82\">https://www.typescriptlang.org/tsconfig#strictNullChecks）です。</a></p>\n<ul>\n<li>** <code>noImplicitAny</code> **</li>\n</ul>\n<p>いくつかの場所では、TypeScriptはタイプを推定しようとせず、最も緩いタイプに戻ります。 <code>any</code>。これは起こりうる最悪の事態ではありません–結局のところ、 <code>any</code> はいずれにしても、通常のJavaScript体験に戻ることができます。</p>\n<p>ただし、通常、 <code>any</code> を使用すると、最初にTypeScriptを使用する目的が損なわれます。プログラムの種類が多ければ多いほど、より多くの検証やツールを手に入れることができます。つまり、コードを書くときのエラーが少なくなります。この<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"> <code>noImplicitAny</code></a>フラグをオンにすると、タイプが暗黙的に推定され、変数がエラーを起こしたときに <code>any</code> が適用されます。</p>\n<img src=\"https://s2.loli.net/2022/02/22/Ir7T4vckJMsSnuK.png\" alt=\"image-20211113122642576\" style=\"zoom:40%;\" />\n\n<ul>\n<li>** <code>strictNullChecks</code> **</li>\n</ul>\n<p>デフォルトでは、 <code>null</code> および <code>undefined</code> の値は、他の任意の型に割り当てることができます。これはいくつかのコードを書くのを簡単にすることができますが、 <code>null</code> の処理を忘れて、 <code>undefined</code> があなたのコードの無数の誤りの原因です-一部の人はこれを<a href=\"https://www.youtube.com/watch?v=ybrQvs4x0Ps\">十亿美元的错误</a>と考えています！この[ <code>strictNullChecks</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks%EF%BC%89%E3%83%95%E3%83%A9%E3%82%B0%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%82%AA%E3%83%9A%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3\">https://www.typescriptlang.org/tsconfig#strictNullChecks）フラグにより、オペレーション</a> <code>null</code> および <code>undefined</code> がより明確になり、<em>忘れる</em>が <code>null</code> および <code>undefined</code> を処理するかどうかを心配する必要がなくなります。</p>\n<img src=\"https://s2.loli.net/2022/02/22/wRlPY8gO9v1zkZa.png\" alt=\"image-20211113122914750\" style=\"zoom:50%;\" />\n\n<h3 id=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"><a href=\"#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\" class=\"headerlink\" title=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"></a>特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3>"
      },
      {
        "title": "1-1、基本：TypeScriptの概要(1)",
        "toc": true,
        "abbrlink": 31375,
        "date": "2024-01-28T13:15:12.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n## 1.1 TypeScriptとは\n\nプログラミングコミュニティへの導入から20年以上が経ち、JavaScriptは今や史上最も広く利用されているクロスプラットフォーム言語の1つとなっています。JavaScriptは当初、Webページにわずかなインタラクティブ性を加えるための小さなスクリプト言語でしたが、現在ではあらゆる規模のフロントエンドおよびバックエンドのアプリケーションに最適な言語に成長しています。JavaScriptで書かれたプログラムのサイズ、範囲、複雑さは指数関数的に増加していますが、JavaScript言語は異なるコード単位間の関係を表現する能力がありません。JavaScriptの非常に特異なランタイムセマンティクスと組み合わせると、言語とプログラムの複雑さの間のこのミスマッチは、JavaScript開発を大規模な管理が困難なタスクにしてしまいます。\n\nプログラマが書く最も一般的なエラータイプは、タイプエラーとして記述できます。タイプが異なる値が予想される場所で、あるタイプの値が使用されています。これは、単純なスペルミス、ライブラリのAPI表面を理解できない、ランタイム動作の誤った仮定、その他のエラーが原因である可能性があります。TypeScriptの目標は、JavaScriptプログラムの静的型チェッカー、つまり、コードが実行される前に実行されるツール(静的)であり、プログラムの型が正しいことを確認する(型チェック)ことです。\n\nTypeScriptはマイクロソフトによって開発された自由でオープンソースのプログラミング言語です。これはJavaScriptのスーパーセットであり、基本的にはオプションの静的型とクラスベースのオブジェクト指向プログラミングがこの言語に追加されています。\n\nTypeScriptはJavaScriptの言語拡張として非常に人気があります。既存のJavaScript構文の上に型レイヤーを追加します。このレイヤーは削除されても、実行時のパフォーマンスにはまったく影響しません。多くの人はTypeScriptを「単なるコンパイラ」と考えていますが、TypeScriptを2つの独立したシステムと考える方が良いでしょう。コンパイラ(構文を処理する部分)と言語ツール(エディタとの統合を処理する部分)です。この2つのシステムを独立して見ることで、私たちがこれまで行ってきた意思決定を説明できる2つの重要な視点を得ることができます。\n\n**npm**[3]では、TypeScriptのダウンロード数は毎年倍増しています。2021年12月1日現在、週間ダウンロード数は2200万件を超えている。昨年12月には約1200万件だった。なお高成長傾向を維持しており、減速の兆しは見られない。\n\nバージョン2.0以降、TypeScriptでは2か月ごとに定期的にreleaseがリリースされるようになりました。しかし現在はリリースのペースを落とし、3カ月ごとのリリースに変更している。そのうち1か月かけて新しいfeaturesを書いてベータ版をリリースし、残り2か月でベータ版のテストとバグ修正を行い、その後のリリースをより安定させることができます。\n\n## 1.2 `JS`, `ES`, `TS` の関係\n\n- **1995年：JavaScript**\n\n当時のネットスケープは、そのNavigatorブラウザによって、Web時代が始まった当時、最も有名な第1世代のインターネット企業になりつつありました。\n\nネットスケープは、静的なHTMLページに動的な効果を追加したいと考えていたため、 `Brendan Eich` は2週間以内にJavaScript言語を設計しました。\n\nなぜJavaScriptと名付けられたのか。理由は当時Java言語が非常に人気だったので、ネットスケープ社はJavaの名を借りて普及させたいと考えていたのですが、実はJavaScriptは文法的にJavaに似ている部分以外はほとんど関係がありませんでした。\n\n- **1997年：ECMAScript**\n\nネットスケープがJavaScriptを開発し、その1年後にマイクロソフトがJavaScriptをまねてJScriptを開発したことで、JavaScriptをグローバル標準にするために、いくつかの企業がECMA（European Computer Manufacturers Association）（欧州コンピュータ製造業者協会）組織と連携してECMAScript標準と呼ばれるJavaScript言語の標準を制定したからだ。\n\n| 版本   | 发布时间       | 一般的な呼び方  | 简称 |\n| ------ | -------------- | --------------- | ---- |\n| 第1版  | 1997年6月      | ECMAScript 1    | ES1  |\n| 第2版  | 1998年4月      | ECMAScript 2    | ES2  |\n| 第3版  | 1999年12月     | ECMAScript 3    | ES3  |\n| 第4版  | 2007年10月草案 | ECMAScript 4    | ES4  |\n| 第5版  | 2009年12月     | ECMAScript 5    | ES5  |\n| 第6版  | 2015年6月      | ECMAScript 2015 | ES6  |\n| 第7版  | 2016年6月      | ECMAScript 2016 | ES7  |\n| 第8版  | 2017年6月      | ECMAScript 2017 | ES8  |\n| 第9版  | 2018年6月      | ECMAScript 2018 | ES9  |\n| 第10版 | 2019年6月      | ECMAScript 2019 | ES10 |\n| 第11版 | 2020年6月      | ECMAScript 2020 | ES11 |\n| 第12版 | 2021年6月      | ECMAScript 2021 | ES12 |\n\n- **2015年：TypeScript**\n\nTypeScriptは、JavaScriptのスーパーセットです。JavaScriptのすべての要素を含み、JavaScriptを実行するコードで、JavaScriptの構文を拡張します。JavaScriptよりも静的型、クラス、モジュール、インタフェース、型注釈の機能が追加され、大規模プロジェクトの開発が容易になりました。\n\nTypeScriptは、2015年のECMAScriptや、非同期機能やDecoratorsなどの将来的な提案など、最新のJavaScript機能を提供し、堅牢なコンポーネントの構築を支援しています。次の図に、TypeScriptとES5、ES2015+の関係を示します：\n\n<img src=\"https://s2.loli.net/2022/02/22/KVoCdwp5rB31zxm.png\" alt=\"image-20211109122048861\" style=\"zoom:50%;\" />\n\n## 1.3 TypeScriptとJavaScriptの違い\n\n| TypeScript                                                                                   | JavaScript                                 |\n| -------------------------------------------------------------------------------------------- | ------------------------------------------ |\n| JavaScriptのスーパーセットは、大規模プロジェクトのコードの複雑さを解決するために使用されます | 一种脚本语言，用于创建动态网页             |\n| コンパイル中にエラーを発見して修正できる                                                     | 作为一种解释型语言，只能在运行时发现错误   |\n| 静的タイプと動的タイプの両方をサポートする強力タイプ                                         | 弱类型，没有静态类型选项                   |\n| 最终被编译成 JavaScript 代码，使浏览器可以理解                                               | ブラウザで直接使用可能                     |\n| モジュール、汎用、インターフェイスのサポート                                                 | 不支持模块、泛型或接口                     |\n| ES3、ES4、ES5、およびES6+の機能をサポート                                                    | 不支持编译其他 ES3，ES4，ES5 或 ES6+ 功能  |\n| 地域社会の支援は増え続けており、まだそれほど大きくはない                                     | 大量的社区支持以及大量文档和解决问题的支持 |\n\n## 1.4 TypeScriptの競合他社について教えてください。\n\nTypeScriptの目標は、大規模なJavaScriptプロジェクトを作成し、ポストメンテナンスに自信のあるツールを人々に提供することです。JavaScript自体にはないシンタックスサポートは、JavaScriptを実行して実行時に検出しない限り、各識別子のタイプを表します。この問題を解決するために、TypeScriptにシンタックスが追加されました。\n\nつまり、ツールとしてサポートすることを目標としているのであれば、TypeScriptではこの分野では競争できない競合他社が少数存在します：\n\n- ESLintとTSLint：TypeScriptと同じように、コード内で発生する可能性のあるエラーを強調するために使用されますが、チェックプロセスに新しい構文は追加されません。どちらもIDE統合のためのツールとして動作するつもりはなく、またTSやTS/ESLintは、プロジェクトにとって意味のない特性を「相手の領域だ」と言うことが多い。最新のコードでは、TS/ESLintの存在により、TypeScriptはすべてのコードベースに適用されるわけではないチェックを少なくすることができます。いくつかの機能が重なってしまいましたが、それらを良い補完ツールとして活用することができます。\n- CoffeeScript：おい、TypeScriptは2012年にリリースされたんだ！CoffeeScriptとTypeScriptの違いは、CoffeeScriptがJavaScriptにいくつかの機能を追加するなど、JavaScript言語を改善したいという点です。これは、CoffeeScriptと書き出されるJavaScriptの違いを理解することを意味します。時間の経過とともに、CoffeeScriptのベストコンセプトが逆に別のJavaScriptにしてしまい、ほとんどJavaScriptになってしまったCoffeeScriptに困ってしまう。\n- Flow：これは、FacebookのJavaScript型検査ツールおよびIDEツール言語です。TypeScriptと同じように、FlowはJavaScriptにいくつかのシンタックスサポートを追加して、より豊富なタイプのシステムを手に入れ、コンパイル時に削除します。JavaScriptを書き始めた頃、Flowは標準的なJavaScriptに近いツールだったので、最初に使ったツールです。Flowは素晴らしいタイプのシステムで、TypeScriptとは異なる目標を持っています。目に見えないタイプ層システムは「正しい」あるいは「十分に正しいと感じる」決定をし続けなければならず、Flowの目標は「正しい」（訳者注：Flowは**soundness**[6]に偏っており、タイプ判断においてより悲観的である）であり、TypeScriptの目標は「感覚的にはほとんどの場合が正しい」（訳者注：TS公式は**TSは完全なタイプではありません**[7]と主張しており、unsound行動を許容し、completenessに偏っており、タイプ判断においてより楽観的である）である。魚と熊の掌は両方を得ることができなくて、完備な類型導出、良好な開発体験と完璧なJS協同（Perfect JavaScript Interop）はその2つしか取れない。\n\nでは、オープンソースのFlowコードベースのほとんどが最終的にTypeScriptに移行したのはなぜでしょうか。私の中では、2つのチームの異なるサイドポイントで決められている部分が大きいと思います。FlowはFacebookのコードベースを維持するために作られていますが、TypeScriptは独立した言語として作られています。ここには2つの証拠があります：\n\n1. Facebookのコードベースは分割できない巨大なモノレポであるが、Flowチームはこのような**大規模コードベース**[8]の下で型を実行するために**信じられないほど多くの仕事が**[9]を作成した。一方、TypeScriptは「小さなコードベースサービスを構築するため（use projects to make sets of smaller codebases）」と言えるが、これは人々がオープンソースコミュニティでJavaScriptモジュールを書く方法に合致しているからだ。そう言うのは理にかなっていると思いますが、TypeScriptはFlowのようにFacebookのコードベースでは動作せず、Facebookのコードを大量に書き直してプロジェクトを構築するか、TypeScriptに大量の修正を加える必要があり、TypeScript全体の開発者の体験に影響を与える可能性があります。\n2. タイプに対するDefinitelyTypedとFlowのアプローチを比較すると、TypeScriptチームはコンパイラエンジニアをローテーションで配置し、DefinitelyTypedのビルドツールをサポートし、コミュニティの管理を支援します。そしてFlowは、ほぼ完全にコミュニティによって維持されています。DTは現在、非Facebookコードの開発に注力してきたため、より規模が大きくなっており、Flowチームからの資金支援を得るのは困難になるだろう。\n\nマイクロソフトがTypeScriptに社内で作成した独立した環境により、TypeScriptは、特別に難しい問題の解決だけに集中するのではなく、ツール開発やエコシステム全体のメンテナンスに自由に集中できるようになりました。これにより、TypeScriptチームは多くの人と協力し、コミュニティが望む機能を次々とリリースできるようになりました。時間の経過とともに、外部からの需要の伸びが鈍化しているため、Flowチームはコミュニティの仕事に時間を割くことがますます難しくなっているのではないかと推測しています。これが悪循環となっている。これにより、FlowはTypeScriptの直接的な「競合者」ではなく、さまざまな角度から、さまざまな制約を使って、類似の問題を解決する方法について興味深い視点を持つようになりました。\n\n## 1.5 TypeScriptの今後\n\n### 1.5.1**TypeScriptの今後についてどう考えていますか。**\n\n現在、TypeScriptの使用を妨げている最大の障害は、ビルドツールが必要であることです。型文法がJavaScriptに組み込まれる可能性は低いと思いますが、JavaScriptでは「型をアノテーションで定義する」可能性は十分にあります。\n\nこのアイデアは、TypeScriptのようなタイプのシステムのシンタックスのセットを作成することですが、JSの実行時に何が起こるかは定義されていません。\n\n```tsx\nconst a: string = \"1234\";\n\n// 将会变成这样\nconst a /*: string */ = \"1234\";\n\n// 传入 JS 引擎\n```\n\nこの例では、JSエンジンは、stringが=で終わる型注釈であることを認識します。この実際の働き方は複雑で、解明に時間がかかる。しかし、JavaScriptでTypeScriptを「ネイティブに」実行できるようにすることで、TypeScriptが使用される際の障壁が低くなります。BabelがTypeScriptサポートを追加したときと同じように、TypeScriptにいくつかの制約を適用します。でもそれだけの価値はあると思う。\n\nDenoは、現在のJavaScriptエンジンによるネイティブTypeScriptのサポートをシミュレートしたRustで書かれたツールを実行することで、TSのJSへのコンパイルを非常に迅速に行うことができる、すべてのTSの障害を取り除く重要な例です。\n\n### 1.5.2今日の競合他社\n\n- JetBrains WebStorm-高度なJavaScriptツールをサポートするIDEです。リファクタリング、コードフロー解析、JavaScript構文のチェックを行う独自のエンジンがあります。これはすばらしいことです。JetBrainsはすべてのIDEでしっかりとした仕事をしています。私は過去にAppCodeを使ってiOSの仕事をすることが多かった。TypeScriptのプロジェクトがある場合、WebStormはTypeScriptの言語ツールと独自のツールをミックスしてくれるので、Win-Winです。\n- JSにコンパイルされた言語-現在の例としてElm、ReScript、KotlinScriptがありますが、これらの言語はJavaScriptとの対話を中心にしています。これらはTypeScriptにとって興味深い言語であり、タイプシステムを実装するためのクリーンな環境を持っています。つまり、JSの負担がありません。競合他社としては、JavaScriptが中心ではないことや、CoffeeScriptからの移行にコミュニティが悩まされてきたことから、より細分化された市場を好む傾向があります。\n- WASM-TypeScriptの競合他社としてのWASMの見解は、WASMがJSコントロールブラウザDOMに代わる言語として機能するというものだと聞きました。これに反対する人々は、WASMにはDOMバインディングがなく、おそらく永遠に存在しないと考えている。TypeScriptにはJavaScriptの欠点が含まれていますが、JavaScriptランタイムにWASMを組み込んだことがあれば、ほぼ常にもっと好きになるでしょう。ということは、AssemblyScriptはこの点でかなり良い仕事をしているということになります。WASMはJSONと考えた方が良いかもしれません。WASMはプロジェクトを構成する別のツールであり、WASMとDOMの相互作用の仕方が変わっていない限り、JavaScriptの競合にはなりそうにありません。\n- WASMにコンパイルされた言語-たとえば、Rust、Go、Swiftなど、WASMにコンパイルできる他の言語。これらの言語はいずれもTypeScriptの現在のツールやwebのコア・ビルディング・モジュールとしての位置を占めている可能性がありますが、どうなるかわかりません。これらの言語は、さまざまな基本型を提供し、異なる目標に基づいてゼロから構築することができます。WASMやWASIが最終的に成功するのであれば、プラットフォームに関わることになると思いますが（appsなどの機能実装を考えてみてください）、その方向性を見てみると面白いと思います。本音を言えば、それらはTypeScriptの競合ではなく、JavaScriptのものです。\n\n### 1.5.3 TypeScriptは生態系の中での位置をどう見ていますか？\n\nTypeScriptは、タイプシステムやエディタツールの分野でイノベーションを起こしたいと考えています。私たちは、主流のプログラミング言語の中で最も表現力の高いタイプのシステムの1つを持っています。\n\nTypeScriptが最初に作成されたときのJavaScriptの修正プロセスは現在とはかなり異なるため、TypeScriptには実際にはTC39の領域である機能がいくつかありますが、下位互換性が必要です。これらの機能はJavaScriptに何年も存在し、何度も繰り返されることがあります。つまり、TypeScriptは、特定の言語機能の2つのバージョンを維持する必要があります。\n\nそこでTC39 JavaScript言語委員会の優秀なメンバーになり、エディタがサポートする言語特性についてフィードバックし、TypeScriptユーザーが見たい特性をサポートすることを目指しています。このコラボレーションによって、TC39はJavaScriptを制御し、TypeScriptもそれらをサポートします。\n\n### 1.5.4 TypeScriptはそのオーディエンスをどのように見ていますか。\n\nTypeScriptのオーディエンスは主に次のとおりです。\n\n- JavaScriptユーザー(言語ツールとして)\n- JS+JSDocユーザー(言語ツールとして)\n- TypeScriptユーザー(コンパイラ、言語ツールとして)\n- TypeScript strictモード(コンパイラ、言語ツールとして)\n\nbabel/swc/sucrase/esbuildなどのツールを使用してプロジェクトを構築する場合、tscはオプションですが、前述の参加者はTSリリースのたびに、または少なくとも2回ごとに新しい機能を利用できます（訳者注：babel、esbuildなどはTSの新機能をサポートするために更新されます。TSチームが直接プロジェクトに参加するか、vscodeなどの機能をtscなしで提供する場合があります。その他のリリース計画については、**TS roadmap**[10]を参照してください）。\n\n### 1.5.5 TypeScriptはJSの生態をどのように追跡しているのか。\n\nチームは、次のような方法でフィードバックを受けます：\n\n- GitHub Isuesには絶え間ないコメントの残響がある\n- Microsoftの社内チームが機能を提供するか、低速なコードベースのデバッグを私たちに依頼してきた\n- GitterまたはTypeScriptコミュニティのDiscordを介してコミュニティとつながる\n- マイクロクラスターの内部ツールを使用したアイデア/デザインのユーザーテスト\n- VS Codeと非常に密接な関係があり、多くの言語ツールからフィードバックが寄せられている\n- @TypeScriptチームのツイートを読むと\n- TypeScriptに移行されたブログ投稿とTypeScriptから移行されたブログ投稿を追跡します\n- 業界調査とプログラミング言語の概要を追跡\n\n### 特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。\n",
        "source": "_posts/日本語/TypeScript/1-1、基本：TypeScriptの概要.md",
        "raw": "---\ntitle: 1-1、基本：TypeScriptの概要(1)\ntoc: true\ncategories:\n  - 日本語\n  - TypeScript\ntags:\n  - フロントエンド\n  - TypeScript\nabbrlink: 31375\ndate: 2024-01-28 21:15:12\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n## 1.1 TypeScriptとは\n\nプログラミングコミュニティへの導入から20年以上が経ち、JavaScriptは今や史上最も広く利用されているクロスプラットフォーム言語の1つとなっています。JavaScriptは当初、Webページにわずかなインタラクティブ性を加えるための小さなスクリプト言語でしたが、現在ではあらゆる規模のフロントエンドおよびバックエンドのアプリケーションに最適な言語に成長しています。JavaScriptで書かれたプログラムのサイズ、範囲、複雑さは指数関数的に増加していますが、JavaScript言語は異なるコード単位間の関係を表現する能力がありません。JavaScriptの非常に特異なランタイムセマンティクスと組み合わせると、言語とプログラムの複雑さの間のこのミスマッチは、JavaScript開発を大規模な管理が困難なタスクにしてしまいます。\n\nプログラマが書く最も一般的なエラータイプは、タイプエラーとして記述できます。タイプが異なる値が予想される場所で、あるタイプの値が使用されています。これは、単純なスペルミス、ライブラリのAPI表面を理解できない、ランタイム動作の誤った仮定、その他のエラーが原因である可能性があります。TypeScriptの目標は、JavaScriptプログラムの静的型チェッカー、つまり、コードが実行される前に実行されるツール(静的)であり、プログラムの型が正しいことを確認する(型チェック)ことです。\n\nTypeScriptはマイクロソフトによって開発された自由でオープンソースのプログラミング言語です。これはJavaScriptのスーパーセットであり、基本的にはオプションの静的型とクラスベースのオブジェクト指向プログラミングがこの言語に追加されています。\n\nTypeScriptはJavaScriptの言語拡張として非常に人気があります。既存のJavaScript構文の上に型レイヤーを追加します。このレイヤーは削除されても、実行時のパフォーマンスにはまったく影響しません。多くの人はTypeScriptを「単なるコンパイラ」と考えていますが、TypeScriptを2つの独立したシステムと考える方が良いでしょう。コンパイラ(構文を処理する部分)と言語ツール(エディタとの統合を処理する部分)です。この2つのシステムを独立して見ることで、私たちがこれまで行ってきた意思決定を説明できる2つの重要な視点を得ることができます。\n\n**npm**[3]では、TypeScriptのダウンロード数は毎年倍増しています。2021年12月1日現在、週間ダウンロード数は2200万件を超えている。昨年12月には約1200万件だった。なお高成長傾向を維持しており、減速の兆しは見られない。\n\nバージョン2.0以降、TypeScriptでは2か月ごとに定期的にreleaseがリリースされるようになりました。しかし現在はリリースのペースを落とし、3カ月ごとのリリースに変更している。そのうち1か月かけて新しいfeaturesを書いてベータ版をリリースし、残り2か月でベータ版のテストとバグ修正を行い、その後のリリースをより安定させることができます。\n\n## 1.2 `JS`, `ES`, `TS` の関係\n\n- **1995年：JavaScript**\n\n当時のネットスケープは、そのNavigatorブラウザによって、Web時代が始まった当時、最も有名な第1世代のインターネット企業になりつつありました。\n\nネットスケープは、静的なHTMLページに動的な効果を追加したいと考えていたため、 `Brendan Eich` は2週間以内にJavaScript言語を設計しました。\n\nなぜJavaScriptと名付けられたのか。理由は当時Java言語が非常に人気だったので、ネットスケープ社はJavaの名を借りて普及させたいと考えていたのですが、実はJavaScriptは文法的にJavaに似ている部分以外はほとんど関係がありませんでした。\n\n- **1997年：ECMAScript**\n\nネットスケープがJavaScriptを開発し、その1年後にマイクロソフトがJavaScriptをまねてJScriptを開発したことで、JavaScriptをグローバル標準にするために、いくつかの企業がECMA（European Computer Manufacturers Association）（欧州コンピュータ製造業者協会）組織と連携してECMAScript標準と呼ばれるJavaScript言語の標準を制定したからだ。\n\n| 版本   | 发布时间       | 一般的な呼び方  | 简称 |\n| ------ | -------------- | --------------- | ---- |\n| 第1版  | 1997年6月      | ECMAScript 1    | ES1  |\n| 第2版  | 1998年4月      | ECMAScript 2    | ES2  |\n| 第3版  | 1999年12月     | ECMAScript 3    | ES3  |\n| 第4版  | 2007年10月草案 | ECMAScript 4    | ES4  |\n| 第5版  | 2009年12月     | ECMAScript 5    | ES5  |\n| 第6版  | 2015年6月      | ECMAScript 2015 | ES6  |\n| 第7版  | 2016年6月      | ECMAScript 2016 | ES7  |\n| 第8版  | 2017年6月      | ECMAScript 2017 | ES8  |\n| 第9版  | 2018年6月      | ECMAScript 2018 | ES9  |\n| 第10版 | 2019年6月      | ECMAScript 2019 | ES10 |\n| 第11版 | 2020年6月      | ECMAScript 2020 | ES11 |\n| 第12版 | 2021年6月      | ECMAScript 2021 | ES12 |\n\n- **2015年：TypeScript**\n\nTypeScriptは、JavaScriptのスーパーセットです。JavaScriptのすべての要素を含み、JavaScriptを実行するコードで、JavaScriptの構文を拡張します。JavaScriptよりも静的型、クラス、モジュール、インタフェース、型注釈の機能が追加され、大規模プロジェクトの開発が容易になりました。\n\nTypeScriptは、2015年のECMAScriptや、非同期機能やDecoratorsなどの将来的な提案など、最新のJavaScript機能を提供し、堅牢なコンポーネントの構築を支援しています。次の図に、TypeScriptとES5、ES2015+の関係を示します：\n\n<img src=\"https://s2.loli.net/2022/02/22/KVoCdwp5rB31zxm.png\" alt=\"image-20211109122048861\" style=\"zoom:50%;\" />\n\n## 1.3 TypeScriptとJavaScriptの違い\n\n| TypeScript                                                                                   | JavaScript                                 |\n| -------------------------------------------------------------------------------------------- | ------------------------------------------ |\n| JavaScriptのスーパーセットは、大規模プロジェクトのコードの複雑さを解決するために使用されます | 一种脚本语言，用于创建动态网页             |\n| コンパイル中にエラーを発見して修正できる                                                     | 作为一种解释型语言，只能在运行时发现错误   |\n| 静的タイプと動的タイプの両方をサポートする強力タイプ                                         | 弱类型，没有静态类型选项                   |\n| 最终被编译成 JavaScript 代码，使浏览器可以理解                                               | ブラウザで直接使用可能                     |\n| モジュール、汎用、インターフェイスのサポート                                                 | 不支持模块、泛型或接口                     |\n| ES3、ES4、ES5、およびES6+の機能をサポート                                                    | 不支持编译其他 ES3，ES4，ES5 或 ES6+ 功能  |\n| 地域社会の支援は増え続けており、まだそれほど大きくはない                                     | 大量的社区支持以及大量文档和解决问题的支持 |\n\n## 1.4 TypeScriptの競合他社について教えてください。\n\nTypeScriptの目標は、大規模なJavaScriptプロジェクトを作成し、ポストメンテナンスに自信のあるツールを人々に提供することです。JavaScript自体にはないシンタックスサポートは、JavaScriptを実行して実行時に検出しない限り、各識別子のタイプを表します。この問題を解決するために、TypeScriptにシンタックスが追加されました。\n\nつまり、ツールとしてサポートすることを目標としているのであれば、TypeScriptではこの分野では競争できない競合他社が少数存在します：\n\n- ESLintとTSLint：TypeScriptと同じように、コード内で発生する可能性のあるエラーを強調するために使用されますが、チェックプロセスに新しい構文は追加されません。どちらもIDE統合のためのツールとして動作するつもりはなく、またTSやTS/ESLintは、プロジェクトにとって意味のない特性を「相手の領域だ」と言うことが多い。最新のコードでは、TS/ESLintの存在により、TypeScriptはすべてのコードベースに適用されるわけではないチェックを少なくすることができます。いくつかの機能が重なってしまいましたが、それらを良い補完ツールとして活用することができます。\n- CoffeeScript：おい、TypeScriptは2012年にリリースされたんだ！CoffeeScriptとTypeScriptの違いは、CoffeeScriptがJavaScriptにいくつかの機能を追加するなど、JavaScript言語を改善したいという点です。これは、CoffeeScriptと書き出されるJavaScriptの違いを理解することを意味します。時間の経過とともに、CoffeeScriptのベストコンセプトが逆に別のJavaScriptにしてしまい、ほとんどJavaScriptになってしまったCoffeeScriptに困ってしまう。\n- Flow：これは、FacebookのJavaScript型検査ツールおよびIDEツール言語です。TypeScriptと同じように、FlowはJavaScriptにいくつかのシンタックスサポートを追加して、より豊富なタイプのシステムを手に入れ、コンパイル時に削除します。JavaScriptを書き始めた頃、Flowは標準的なJavaScriptに近いツールだったので、最初に使ったツールです。Flowは素晴らしいタイプのシステムで、TypeScriptとは異なる目標を持っています。目に見えないタイプ層システムは「正しい」あるいは「十分に正しいと感じる」決定をし続けなければならず、Flowの目標は「正しい」（訳者注：Flowは**soundness**[6]に偏っており、タイプ判断においてより悲観的である）であり、TypeScriptの目標は「感覚的にはほとんどの場合が正しい」（訳者注：TS公式は**TSは完全なタイプではありません**[7]と主張しており、unsound行動を許容し、completenessに偏っており、タイプ判断においてより楽観的である）である。魚と熊の掌は両方を得ることができなくて、完備な類型導出、良好な開発体験と完璧なJS協同（Perfect JavaScript Interop）はその2つしか取れない。\n\nでは、オープンソースのFlowコードベースのほとんどが最終的にTypeScriptに移行したのはなぜでしょうか。私の中では、2つのチームの異なるサイドポイントで決められている部分が大きいと思います。FlowはFacebookのコードベースを維持するために作られていますが、TypeScriptは独立した言語として作られています。ここには2つの証拠があります：\n\n1. Facebookのコードベースは分割できない巨大なモノレポであるが、Flowチームはこのような**大規模コードベース**[8]の下で型を実行するために**信じられないほど多くの仕事が**[9]を作成した。一方、TypeScriptは「小さなコードベースサービスを構築するため（use projects to make sets of smaller codebases）」と言えるが、これは人々がオープンソースコミュニティでJavaScriptモジュールを書く方法に合致しているからだ。そう言うのは理にかなっていると思いますが、TypeScriptはFlowのようにFacebookのコードベースでは動作せず、Facebookのコードを大量に書き直してプロジェクトを構築するか、TypeScriptに大量の修正を加える必要があり、TypeScript全体の開発者の体験に影響を与える可能性があります。\n2. タイプに対するDefinitelyTypedとFlowのアプローチを比較すると、TypeScriptチームはコンパイラエンジニアをローテーションで配置し、DefinitelyTypedのビルドツールをサポートし、コミュニティの管理を支援します。そしてFlowは、ほぼ完全にコミュニティによって維持されています。DTは現在、非Facebookコードの開発に注力してきたため、より規模が大きくなっており、Flowチームからの資金支援を得るのは困難になるだろう。\n\nマイクロソフトがTypeScriptに社内で作成した独立した環境により、TypeScriptは、特別に難しい問題の解決だけに集中するのではなく、ツール開発やエコシステム全体のメンテナンスに自由に集中できるようになりました。これにより、TypeScriptチームは多くの人と協力し、コミュニティが望む機能を次々とリリースできるようになりました。時間の経過とともに、外部からの需要の伸びが鈍化しているため、Flowチームはコミュニティの仕事に時間を割くことがますます難しくなっているのではないかと推測しています。これが悪循環となっている。これにより、FlowはTypeScriptの直接的な「競合者」ではなく、さまざまな角度から、さまざまな制約を使って、類似の問題を解決する方法について興味深い視点を持つようになりました。\n\n## 1.5 TypeScriptの今後\n\n### 1.5.1**TypeScriptの今後についてどう考えていますか。**\n\n現在、TypeScriptの使用を妨げている最大の障害は、ビルドツールが必要であることです。型文法がJavaScriptに組み込まれる可能性は低いと思いますが、JavaScriptでは「型をアノテーションで定義する」可能性は十分にあります。\n\nこのアイデアは、TypeScriptのようなタイプのシステムのシンタックスのセットを作成することですが、JSの実行時に何が起こるかは定義されていません。\n\n```tsx\nconst a: string = \"1234\";\n\n// 将会变成这样\nconst a /*: string */ = \"1234\";\n\n// 传入 JS 引擎\n```\n\nこの例では、JSエンジンは、stringが=で終わる型注釈であることを認識します。この実際の働き方は複雑で、解明に時間がかかる。しかし、JavaScriptでTypeScriptを「ネイティブに」実行できるようにすることで、TypeScriptが使用される際の障壁が低くなります。BabelがTypeScriptサポートを追加したときと同じように、TypeScriptにいくつかの制約を適用します。でもそれだけの価値はあると思う。\n\nDenoは、現在のJavaScriptエンジンによるネイティブTypeScriptのサポートをシミュレートしたRustで書かれたツールを実行することで、TSのJSへのコンパイルを非常に迅速に行うことができる、すべてのTSの障害を取り除く重要な例です。\n\n### 1.5.2今日の競合他社\n\n- JetBrains WebStorm-高度なJavaScriptツールをサポートするIDEです。リファクタリング、コードフロー解析、JavaScript構文のチェックを行う独自のエンジンがあります。これはすばらしいことです。JetBrainsはすべてのIDEでしっかりとした仕事をしています。私は過去にAppCodeを使ってiOSの仕事をすることが多かった。TypeScriptのプロジェクトがある場合、WebStormはTypeScriptの言語ツールと独自のツールをミックスしてくれるので、Win-Winです。\n- JSにコンパイルされた言語-現在の例としてElm、ReScript、KotlinScriptがありますが、これらの言語はJavaScriptとの対話を中心にしています。これらはTypeScriptにとって興味深い言語であり、タイプシステムを実装するためのクリーンな環境を持っています。つまり、JSの負担がありません。競合他社としては、JavaScriptが中心ではないことや、CoffeeScriptからの移行にコミュニティが悩まされてきたことから、より細分化された市場を好む傾向があります。\n- WASM-TypeScriptの競合他社としてのWASMの見解は、WASMがJSコントロールブラウザDOMに代わる言語として機能するというものだと聞きました。これに反対する人々は、WASMにはDOMバインディングがなく、おそらく永遠に存在しないと考えている。TypeScriptにはJavaScriptの欠点が含まれていますが、JavaScriptランタイムにWASMを組み込んだことがあれば、ほぼ常にもっと好きになるでしょう。ということは、AssemblyScriptはこの点でかなり良い仕事をしているということになります。WASMはJSONと考えた方が良いかもしれません。WASMはプロジェクトを構成する別のツールであり、WASMとDOMの相互作用の仕方が変わっていない限り、JavaScriptの競合にはなりそうにありません。\n- WASMにコンパイルされた言語-たとえば、Rust、Go、Swiftなど、WASMにコンパイルできる他の言語。これらの言語はいずれもTypeScriptの現在のツールやwebのコア・ビルディング・モジュールとしての位置を占めている可能性がありますが、どうなるかわかりません。これらの言語は、さまざまな基本型を提供し、異なる目標に基づいてゼロから構築することができます。WASMやWASIが最終的に成功するのであれば、プラットフォームに関わることになると思いますが（appsなどの機能実装を考えてみてください）、その方向性を見てみると面白いと思います。本音を言えば、それらはTypeScriptの競合ではなく、JavaScriptのものです。\n\n### 1.5.3 TypeScriptは生態系の中での位置をどう見ていますか？\n\nTypeScriptは、タイプシステムやエディタツールの分野でイノベーションを起こしたいと考えています。私たちは、主流のプログラミング言語の中で最も表現力の高いタイプのシステムの1つを持っています。\n\nTypeScriptが最初に作成されたときのJavaScriptの修正プロセスは現在とはかなり異なるため、TypeScriptには実際にはTC39の領域である機能がいくつかありますが、下位互換性が必要です。これらの機能はJavaScriptに何年も存在し、何度も繰り返されることがあります。つまり、TypeScriptは、特定の言語機能の2つのバージョンを維持する必要があります。\n\nそこでTC39 JavaScript言語委員会の優秀なメンバーになり、エディタがサポートする言語特性についてフィードバックし、TypeScriptユーザーが見たい特性をサポートすることを目指しています。このコラボレーションによって、TC39はJavaScriptを制御し、TypeScriptもそれらをサポートします。\n\n### 1.5.4 TypeScriptはそのオーディエンスをどのように見ていますか。\n\nTypeScriptのオーディエンスは主に次のとおりです。\n\n- JavaScriptユーザー(言語ツールとして)\n- JS+JSDocユーザー(言語ツールとして)\n- TypeScriptユーザー(コンパイラ、言語ツールとして)\n- TypeScript strictモード(コンパイラ、言語ツールとして)\n\nbabel/swc/sucrase/esbuildなどのツールを使用してプロジェクトを構築する場合、tscはオプションですが、前述の参加者はTSリリースのたびに、または少なくとも2回ごとに新しい機能を利用できます（訳者注：babel、esbuildなどはTSの新機能をサポートするために更新されます。TSチームが直接プロジェクトに参加するか、vscodeなどの機能をtscなしで提供する場合があります。その他のリリース計画については、**TS roadmap**[10]を参照してください）。\n\n### 1.5.5 TypeScriptはJSの生態をどのように追跡しているのか。\n\nチームは、次のような方法でフィードバックを受けます：\n\n- GitHub Isuesには絶え間ないコメントの残響がある\n- Microsoftの社内チームが機能を提供するか、低速なコードベースのデバッグを私たちに依頼してきた\n- GitterまたはTypeScriptコミュニティのDiscordを介してコミュニティとつながる\n- マイクロクラスターの内部ツールを使用したアイデア/デザインのユーザーテスト\n- VS Codeと非常に密接な関係があり、多くの言語ツールからフィードバックが寄せられている\n- @TypeScriptチームのツイートを読むと\n- TypeScriptに移行されたブログ投稿とTypeScriptから移行されたブログ投稿を追跡します\n- 業界調査とプログラミング言語の概要を追跡\n\n### 特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。\n",
        "slug": "日本語/TypeScript/1-1、基本：TypeScriptの概要",
        "published": 1,
        "updated": "2024-02-14T14:03:42.489Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjanu000394v31brw0skq",
        "content": "<h2 id=\"1-1-TypeScriptとは\"><a href=\"#1-1-TypeScriptとは\" class=\"headerlink\" title=\"1.1 TypeScriptとは\"></a>1.1 TypeScriptとは</h2><p>プログラミングコミュニティへの導入から20年以上が経ち、JavaScriptは今や史上最も広く利用されているクロスプラットフォーム言語の1つとなっています。JavaScriptは当初、Webページにわずかなインタラクティブ性を加えるための小さなスクリプト言語でしたが、現在ではあらゆる規模のフロントエンドおよびバックエンドのアプリケーションに最適な言語に成長しています。JavaScriptで書かれたプログラムのサイズ、範囲、複雑さは指数関数的に増加していますが、JavaScript言語は異なるコード単位間の関係を表現する能力がありません。JavaScriptの非常に特異なランタイムセマンティクスと組み合わせると、言語とプログラムの複雑さの間のこのミスマッチは、JavaScript開発を大規模な管理が困難なタスクにしてしまいます。</p>\n<p>プログラマが書く最も一般的なエラータイプは、タイプエラーとして記述できます。タイプが異なる値が予想される場所で、あるタイプの値が使用されています。これは、単純なスペルミス、ライブラリのAPI表面を理解できない、ランタイム動作の誤った仮定、その他のエラーが原因である可能性があります。TypeScriptの目標は、JavaScriptプログラムの静的型チェッカー、つまり、コードが実行される前に実行されるツール(静的)であり、プログラムの型が正しいことを確認する(型チェック)ことです。</p>\n<p>TypeScriptはマイクロソフトによって開発された自由でオープンソースのプログラミング言語です。これはJavaScriptのスーパーセットであり、基本的にはオプションの静的型とクラスベースのオブジェクト指向プログラミングがこの言語に追加されています。</p>\n<p>TypeScriptはJavaScriptの言語拡張として非常に人気があります。既存のJavaScript構文の上に型レイヤーを追加します。このレイヤーは削除されても、実行時のパフォーマンスにはまったく影響しません。多くの人はTypeScriptを「単なるコンパイラ」と考えていますが、TypeScriptを2つの独立したシステムと考える方が良いでしょう。コンパイラ(構文を処理する部分)と言語ツール(エディタとの統合を処理する部分)です。この2つのシステムを独立して見ることで、私たちがこれまで行ってきた意思決定を説明できる2つの重要な視点を得ることができます。</p>\n<p><strong>npm</strong>[3]では、TypeScriptのダウンロード数は毎年倍増しています。2021年12月1日現在、週間ダウンロード数は2200万件を超えている。昨年12月には約1200万件だった。なお高成長傾向を維持しており、減速の兆しは見られない。</p>\n<p>バージョン2.0以降、TypeScriptでは2か月ごとに定期的にreleaseがリリースされるようになりました。しかし現在はリリースのペースを落とし、3カ月ごとのリリースに変更している。そのうち1か月かけて新しいfeaturesを書いてベータ版をリリースし、残り2か月でベータ版のテストとバグ修正を行い、その後のリリースをより安定させることができます。</p>\n<h2 id=\"1-2-JS-ES-TS-の関係\"><a href=\"#1-2-JS-ES-TS-の関係\" class=\"headerlink\" title=\"1.2 JS, ES, TS の関係\"></a>1.2 <code>JS</code>, <code>ES</code>, <code>TS</code> の関係</h2><ul>\n<li><strong>1995年：JavaScript</strong></li>\n</ul>\n<p>当時のネットスケープは、そのNavigatorブラウザによって、Web時代が始まった当時、最も有名な第1世代のインターネット企業になりつつありました。</p>\n<p>ネットスケープは、静的なHTMLページに動的な効果を追加したいと考えていたため、 <code>Brendan Eich</code> は2週間以内にJavaScript言語を設計しました。</p>\n<p>なぜJavaScriptと名付けられたのか。理由は当時Java言語が非常に人気だったので、ネットスケープ社はJavaの名を借りて普及させたいと考えていたのですが、実はJavaScriptは文法的にJavaに似ている部分以外はほとんど関係がありませんでした。</p>\n<ul>\n<li><strong>1997年：ECMAScript</strong></li>\n</ul>\n<p>ネットスケープがJavaScriptを開発し、その1年後にマイクロソフトがJavaScriptをまねてJScriptを開発したことで、JavaScriptをグローバル標準にするために、いくつかの企業がECMA（European Computer Manufacturers Association）（欧州コンピュータ製造業者協会）組織と連携してECMAScript標準と呼ばれるJavaScript言語の標準を制定したからだ。</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>发布时间</th>\n<th>一般的な呼び方</th>\n<th>简称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>第1版</td>\n<td>1997年6月</td>\n<td>ECMAScript 1</td>\n<td>ES1</td>\n</tr>\n<tr>\n<td>第2版</td>\n<td>1998年4月</td>\n<td>ECMAScript 2</td>\n<td>ES2</td>\n</tr>\n<tr>\n<td>第3版</td>\n<td>1999年12月</td>\n<td>ECMAScript 3</td>\n<td>ES3</td>\n</tr>\n<tr>\n<td>第4版</td>\n<td>2007年10月草案</td>\n<td>ECMAScript 4</td>\n<td>ES4</td>\n</tr>\n<tr>\n<td>第5版</td>\n<td>2009年12月</td>\n<td>ECMAScript 5</td>\n<td>ES5</td>\n</tr>\n<tr>\n<td>第6版</td>\n<td>2015年6月</td>\n<td>ECMAScript 2015</td>\n<td>ES6</td>\n</tr>\n<tr>\n<td>第7版</td>\n<td>2016年6月</td>\n<td>ECMAScript 2016</td>\n<td>ES7</td>\n</tr>\n<tr>\n<td>第8版</td>\n<td>2017年6月</td>\n<td>ECMAScript 2017</td>\n<td>ES8</td>\n</tr>\n<tr>\n<td>第9版</td>\n<td>2018年6月</td>\n<td>ECMAScript 2018</td>\n<td>ES9</td>\n</tr>\n<tr>\n<td>第10版</td>\n<td>2019年6月</td>\n<td>ECMAScript 2019</td>\n<td>ES10</td>\n</tr>\n<tr>\n<td>第11版</td>\n<td>2020年6月</td>\n<td>ECMAScript 2020</td>\n<td>ES11</td>\n</tr>\n<tr>\n<td>第12版</td>\n<td>2021年6月</td>\n<td>ECMAScript 2021</td>\n<td>ES12</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>2015年：TypeScript</strong></li>\n</ul>\n<p>TypeScriptは、JavaScriptのスーパーセットです。JavaScriptのすべての要素を含み、JavaScriptを実行するコードで、JavaScriptの構文を拡張します。JavaScriptよりも静的型、クラス、モジュール、インタフェース、型注釈の機能が追加され、大規模プロジェクトの開発が容易になりました。</p>\n<p>TypeScriptは、2015年のECMAScriptや、非同期機能やDecoratorsなどの将来的な提案など、最新のJavaScript機能を提供し、堅牢なコンポーネントの構築を支援しています。次の図に、TypeScriptとES5、ES2015+の関係を示します：</p>\n<img src=\"https://s2.loli.net/2022/02/22/KVoCdwp5rB31zxm.png\" alt=\"image-20211109122048861\" style=\"zoom:50%;\" />\n\n<h2 id=\"1-3-TypeScriptとJavaScriptの違い\"><a href=\"#1-3-TypeScriptとJavaScriptの違い\" class=\"headerlink\" title=\"1.3 TypeScriptとJavaScriptの違い\"></a>1.3 TypeScriptとJavaScriptの違い</h2><table>\n<thead>\n<tr>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JavaScriptのスーパーセットは、大規模プロジェクトのコードの複雑さを解決するために使用されます</td>\n<td>一种脚本语言，用于创建动态网页</td>\n</tr>\n<tr>\n<td>コンパイル中にエラーを発見して修正できる</td>\n<td>作为一种解释型语言，只能在运行时发现错误</td>\n</tr>\n<tr>\n<td>静的タイプと動的タイプの両方をサポートする強力タイプ</td>\n<td>弱类型，没有静态类型选项</td>\n</tr>\n<tr>\n<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>\n<td>ブラウザで直接使用可能</td>\n</tr>\n<tr>\n<td>モジュール、汎用、インターフェイスのサポート</td>\n<td>不支持模块、泛型或接口</td>\n</tr>\n<tr>\n<td>ES3、ES4、ES5、およびES6+の機能をサポート</td>\n<td>不支持编译其他 ES3，ES4，ES5 或 ES6+ 功能</td>\n</tr>\n<tr>\n<td>地域社会の支援は増え続けており、まだそれほど大きくはない</td>\n<td>大量的社区支持以及大量文档和解决问题的支持</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-4-TypeScriptの競合他社について教えてください。\"><a href=\"#1-4-TypeScriptの競合他社について教えてください。\" class=\"headerlink\" title=\"1.4 TypeScriptの競合他社について教えてください。\"></a>1.4 TypeScriptの競合他社について教えてください。</h2><p>TypeScriptの目標は、大規模なJavaScriptプロジェクトを作成し、ポストメンテナンスに自信のあるツールを人々に提供することです。JavaScript自体にはないシンタックスサポートは、JavaScriptを実行して実行時に検出しない限り、各識別子のタイプを表します。この問題を解決するために、TypeScriptにシンタックスが追加されました。</p>\n<p>つまり、ツールとしてサポートすることを目標としているのであれば、TypeScriptではこの分野では競争できない競合他社が少数存在します：</p>\n<ul>\n<li>ESLintとTSLint：TypeScriptと同じように、コード内で発生する可能性のあるエラーを強調するために使用されますが、チェックプロセスに新しい構文は追加されません。どちらもIDE統合のためのツールとして動作するつもりはなく、またTSやTS&#x2F;ESLintは、プロジェクトにとって意味のない特性を「相手の領域だ」と言うことが多い。最新のコードでは、TS&#x2F;ESLintの存在により、TypeScriptはすべてのコードベースに適用されるわけではないチェックを少なくすることができます。いくつかの機能が重なってしまいましたが、それらを良い補完ツールとして活用することができます。</li>\n<li>CoffeeScript：おい、TypeScriptは2012年にリリースされたんだ！CoffeeScriptとTypeScriptの違いは、CoffeeScriptがJavaScriptにいくつかの機能を追加するなど、JavaScript言語を改善したいという点です。これは、CoffeeScriptと書き出されるJavaScriptの違いを理解することを意味します。時間の経過とともに、CoffeeScriptのベストコンセプトが逆に別のJavaScriptにしてしまい、ほとんどJavaScriptになってしまったCoffeeScriptに困ってしまう。</li>\n<li>Flow：これは、FacebookのJavaScript型検査ツールおよびIDEツール言語です。TypeScriptと同じように、FlowはJavaScriptにいくつかのシンタックスサポートを追加して、より豊富なタイプのシステムを手に入れ、コンパイル時に削除します。JavaScriptを書き始めた頃、Flowは標準的なJavaScriptに近いツールだったので、最初に使ったツールです。Flowは素晴らしいタイプのシステムで、TypeScriptとは異なる目標を持っています。目に見えないタイプ層システムは「正しい」あるいは「十分に正しいと感じる」決定をし続けなければならず、Flowの目標は「正しい」（訳者注：Flowは<strong>soundness</strong>[6]に偏っており、タイプ判断においてより悲観的である）であり、TypeScriptの目標は「感覚的にはほとんどの場合が正しい」（訳者注：TS公式は<strong>TSは完全なタイプではありません</strong>[7]と主張しており、unsound行動を許容し、completenessに偏っており、タイプ判断においてより楽観的である）である。魚と熊の掌は両方を得ることができなくて、完備な類型導出、良好な開発体験と完璧なJS協同（Perfect JavaScript Interop）はその2つしか取れない。</li>\n</ul>\n<p>では、オープンソースのFlowコードベースのほとんどが最終的にTypeScriptに移行したのはなぜでしょうか。私の中では、2つのチームの異なるサイドポイントで決められている部分が大きいと思います。FlowはFacebookのコードベースを維持するために作られていますが、TypeScriptは独立した言語として作られています。ここには2つの証拠があります：</p>\n<ol>\n<li>Facebookのコードベースは分割できない巨大なモノレポであるが、Flowチームはこのような<strong>大規模コードベース</strong>[8]の下で型を実行するために<strong>信じられないほど多くの仕事が</strong>[9]を作成した。一方、TypeScriptは「小さなコードベースサービスを構築するため（use projects to make sets of smaller codebases）」と言えるが、これは人々がオープンソースコミュニティでJavaScriptモジュールを書く方法に合致しているからだ。そう言うのは理にかなっていると思いますが、TypeScriptはFlowのようにFacebookのコードベースでは動作せず、Facebookのコードを大量に書き直してプロジェクトを構築するか、TypeScriptに大量の修正を加える必要があり、TypeScript全体の開発者の体験に影響を与える可能性があります。</li>\n<li>タイプに対するDefinitelyTypedとFlowのアプローチを比較すると、TypeScriptチームはコンパイラエンジニアをローテーションで配置し、DefinitelyTypedのビルドツールをサポートし、コミュニティの管理を支援します。そしてFlowは、ほぼ完全にコミュニティによって維持されています。DTは現在、非Facebookコードの開発に注力してきたため、より規模が大きくなっており、Flowチームからの資金支援を得るのは困難になるだろう。</li>\n</ol>\n<p>マイクロソフトがTypeScriptに社内で作成した独立した環境により、TypeScriptは、特別に難しい問題の解決だけに集中するのではなく、ツール開発やエコシステム全体のメンテナンスに自由に集中できるようになりました。これにより、TypeScriptチームは多くの人と協力し、コミュニティが望む機能を次々とリリースできるようになりました。時間の経過とともに、外部からの需要の伸びが鈍化しているため、Flowチームはコミュニティの仕事に時間を割くことがますます難しくなっているのではないかと推測しています。これが悪循環となっている。これにより、FlowはTypeScriptの直接的な「競合者」ではなく、さまざまな角度から、さまざまな制約を使って、類似の問題を解決する方法について興味深い視点を持つようになりました。</p>\n<h2 id=\"1-5-TypeScriptの今後\"><a href=\"#1-5-TypeScriptの今後\" class=\"headerlink\" title=\"1.5 TypeScriptの今後\"></a>1.5 TypeScriptの今後</h2><h3 id=\"1-5-1TypeScriptの今後についてどう考えていますか。\"><a href=\"#1-5-1TypeScriptの今後についてどう考えていますか。\" class=\"headerlink\" title=\"1.5.1TypeScriptの今後についてどう考えていますか。\"></a>1.5.1<strong>TypeScriptの今後についてどう考えていますか。</strong></h3><p>現在、TypeScriptの使用を妨げている最大の障害は、ビルドツールが必要であることです。型文法がJavaScriptに組み込まれる可能性は低いと思いますが、JavaScriptでは「型をアノテーションで定義する」可能性は十分にあります。</p>\n<p>このアイデアは、TypeScriptのようなタイプのシステムのシンタックスのセットを作成することですが、JSの実行時に何が起こるかは定義されていません。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;1234&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将会变成这样</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a <span class=\"comment\">/*: string */</span> = <span class=\"string\">&quot;1234&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入 JS 引擎</span></span><br></pre></td></tr></table></figure>\n\n<p>この例では、JSエンジンは、stringが&#x3D;で終わる型注釈であることを認識します。この実際の働き方は複雑で、解明に時間がかかる。しかし、JavaScriptでTypeScriptを「ネイティブに」実行できるようにすることで、TypeScriptが使用される際の障壁が低くなります。BabelがTypeScriptサポートを追加したときと同じように、TypeScriptにいくつかの制約を適用します。でもそれだけの価値はあると思う。</p>\n<p>Denoは、現在のJavaScriptエンジンによるネイティブTypeScriptのサポートをシミュレートしたRustで書かれたツールを実行することで、TSのJSへのコンパイルを非常に迅速に行うことができる、すべてのTSの障害を取り除く重要な例です。</p>\n<h3 id=\"1-5-2今日の競合他社\"><a href=\"#1-5-2今日の競合他社\" class=\"headerlink\" title=\"1.5.2今日の競合他社\"></a>1.5.2今日の競合他社</h3><ul>\n<li>JetBrains WebStorm-高度なJavaScriptツールをサポートするIDEです。リファクタリング、コードフロー解析、JavaScript構文のチェックを行う独自のエンジンがあります。これはすばらしいことです。JetBrainsはすべてのIDEでしっかりとした仕事をしています。私は過去にAppCodeを使ってiOSの仕事をすることが多かった。TypeScriptのプロジェクトがある場合、WebStormはTypeScriptの言語ツールと独自のツールをミックスしてくれるので、Win-Winです。</li>\n<li>JSにコンパイルされた言語-現在の例としてElm、ReScript、KotlinScriptがありますが、これらの言語はJavaScriptとの対話を中心にしています。これらはTypeScriptにとって興味深い言語であり、タイプシステムを実装するためのクリーンな環境を持っています。つまり、JSの負担がありません。競合他社としては、JavaScriptが中心ではないことや、CoffeeScriptからの移行にコミュニティが悩まされてきたことから、より細分化された市場を好む傾向があります。</li>\n<li>WASM-TypeScriptの競合他社としてのWASMの見解は、WASMがJSコントロールブラウザDOMに代わる言語として機能するというものだと聞きました。これに反対する人々は、WASMにはDOMバインディングがなく、おそらく永遠に存在しないと考えている。TypeScriptにはJavaScriptの欠点が含まれていますが、JavaScriptランタイムにWASMを組み込んだことがあれば、ほぼ常にもっと好きになるでしょう。ということは、AssemblyScriptはこの点でかなり良い仕事をしているということになります。WASMはJSONと考えた方が良いかもしれません。WASMはプロジェクトを構成する別のツールであり、WASMとDOMの相互作用の仕方が変わっていない限り、JavaScriptの競合にはなりそうにありません。</li>\n<li>WASMにコンパイルされた言語-たとえば、Rust、Go、Swiftなど、WASMにコンパイルできる他の言語。これらの言語はいずれもTypeScriptの現在のツールやwebのコア・ビルディング・モジュールとしての位置を占めている可能性がありますが、どうなるかわかりません。これらの言語は、さまざまな基本型を提供し、異なる目標に基づいてゼロから構築することができます。WASMやWASIが最終的に成功するのであれば、プラットフォームに関わることになると思いますが（appsなどの機能実装を考えてみてください）、その方向性を見てみると面白いと思います。本音を言えば、それらはTypeScriptの競合ではなく、JavaScriptのものです。</li>\n</ul>\n<h3 id=\"1-5-3-TypeScriptは生態系の中での位置をどう見ていますか？\"><a href=\"#1-5-3-TypeScriptは生態系の中での位置をどう見ていますか？\" class=\"headerlink\" title=\"1.5.3 TypeScriptは生態系の中での位置をどう見ていますか？\"></a>1.5.3 TypeScriptは生態系の中での位置をどう見ていますか？</h3><p>TypeScriptは、タイプシステムやエディタツールの分野でイノベーションを起こしたいと考えています。私たちは、主流のプログラミング言語の中で最も表現力の高いタイプのシステムの1つを持っています。</p>\n<p>TypeScriptが最初に作成されたときのJavaScriptの修正プロセスは現在とはかなり異なるため、TypeScriptには実際にはTC39の領域である機能がいくつかありますが、下位互換性が必要です。これらの機能はJavaScriptに何年も存在し、何度も繰り返されることがあります。つまり、TypeScriptは、特定の言語機能の2つのバージョンを維持する必要があります。</p>\n<p>そこでTC39 JavaScript言語委員会の優秀なメンバーになり、エディタがサポートする言語特性についてフィードバックし、TypeScriptユーザーが見たい特性をサポートすることを目指しています。このコラボレーションによって、TC39はJavaScriptを制御し、TypeScriptもそれらをサポートします。</p>\n<h3 id=\"1-5-4-TypeScriptはそのオーディエンスをどのように見ていますか。\"><a href=\"#1-5-4-TypeScriptはそのオーディエンスをどのように見ていますか。\" class=\"headerlink\" title=\"1.5.4 TypeScriptはそのオーディエンスをどのように見ていますか。\"></a>1.5.4 TypeScriptはそのオーディエンスをどのように見ていますか。</h3><p>TypeScriptのオーディエンスは主に次のとおりです。</p>\n<ul>\n<li>JavaScriptユーザー(言語ツールとして)</li>\n<li>JS+JSDocユーザー(言語ツールとして)</li>\n<li>TypeScriptユーザー(コンパイラ、言語ツールとして)</li>\n<li>TypeScript strictモード(コンパイラ、言語ツールとして)</li>\n</ul>\n<p>babel&#x2F;swc&#x2F;sucrase&#x2F;esbuildなどのツールを使用してプロジェクトを構築する場合、tscはオプションですが、前述の参加者はTSリリースのたびに、または少なくとも2回ごとに新しい機能を利用できます（訳者注：babel、esbuildなどはTSの新機能をサポートするために更新されます。TSチームが直接プロジェクトに参加するか、vscodeなどの機能をtscなしで提供する場合があります。その他のリリース計画については、<strong>TS roadmap</strong>[10]を参照してください）。</p>\n<h3 id=\"1-5-5-TypeScriptはJSの生態をどのように追跡しているのか。\"><a href=\"#1-5-5-TypeScriptはJSの生態をどのように追跡しているのか。\" class=\"headerlink\" title=\"1.5.5 TypeScriptはJSの生態をどのように追跡しているのか。\"></a>1.5.5 TypeScriptはJSの生態をどのように追跡しているのか。</h3><p>チームは、次のような方法でフィードバックを受けます：</p>\n<ul>\n<li>GitHub Isuesには絶え間ないコメントの残響がある</li>\n<li>Microsoftの社内チームが機能を提供するか、低速なコードベースのデバッグを私たちに依頼してきた</li>\n<li>GitterまたはTypeScriptコミュニティのDiscordを介してコミュニティとつながる</li>\n<li>マイクロクラスターの内部ツールを使用したアイデア&#x2F;デザインのユーザーテスト</li>\n<li>VS Codeと非常に密接な関係があり、多くの言語ツールからフィードバックが寄せられている</li>\n<li>@TypeScriptチームのツイートを読むと</li>\n<li>TypeScriptに移行されたブログ投稿とTypeScriptから移行されたブログ投稿を追跡します</li>\n<li>業界調査とプログラミング言語の概要を追跡</li>\n</ul>\n<h3 id=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"><a href=\"#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\" class=\"headerlink\" title=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"></a>特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h2 id=\"1-1-TypeScriptとは\"><a href=\"#1-1-TypeScriptとは\" class=\"headerlink\" title=\"1.1 TypeScriptとは\"></a>1.1 TypeScriptとは</h2><p>プログラミングコミュニティへの導入から20年以上が経ち、JavaScriptは今や史上最も広く利用されているクロスプラットフォーム言語の1つとなっています。JavaScriptは当初、Webページにわずかなインタラクティブ性を加えるための小さなスクリプト言語でしたが、現在ではあらゆる規模のフロントエンドおよびバックエンドのアプリケーションに最適な言語に成長しています。JavaScriptで書かれたプログラムのサイズ、範囲、複雑さは指数関数的に増加していますが、JavaScript言語は異なるコード単位間の関係を表現する能力がありません。JavaScriptの非常に特異なランタイムセマンティクスと組み合わせると、言語とプログラムの複雑さの間のこのミスマッチは、JavaScript開発を大規模な管理が困難なタスクにしてしまいます。</p>\n<p>プログラマが書く最も一般的なエラータイプは、タイプエラーとして記述できます。タイプが異なる値が予想される場所で、あるタイプの値が使用されています。これは、単純なスペルミス、ライブラリのAPI表面を理解できない、ランタイム動作の誤った仮定、その他のエラーが原因である可能性があります。TypeScriptの目標は、JavaScriptプログラムの静的型チェッカー、つまり、コードが実行される前に実行されるツール(静的)であり、プログラムの型が正しいことを確認する(型チェック)ことです。</p>\n<p>TypeScriptはマイクロソフトによって開発された自由でオープンソースのプログラミング言語です。これはJavaScriptのスーパーセットであり、基本的にはオプションの静的型とクラスベースのオブジェクト指向プログラミングがこの言語に追加されています。</p>\n<p>TypeScriptはJavaScriptの言語拡張として非常に人気があります。既存のJavaScript構文の上に型レイヤーを追加します。このレイヤーは削除されても、実行時のパフォーマンスにはまったく影響しません。多くの人はTypeScriptを「単なるコンパイラ」と考えていますが、TypeScriptを2つの独立したシステムと考える方が良いでしょう。コンパイラ(構文を処理する部分)と言語ツール(エディタとの統合を処理する部分)です。この2つのシステムを独立して見ることで、私たちがこれまで行ってきた意思決定を説明できる2つの重要な視点を得ることができます。</p>\n<p><strong>npm</strong>[3]では、TypeScriptのダウンロード数は毎年倍増しています。2021年12月1日現在、週間ダウンロード数は2200万件を超えている。昨年12月には約1200万件だった。なお高成長傾向を維持しており、減速の兆しは見られない。</p>\n<p>バージョン2.0以降、TypeScriptでは2か月ごとに定期的にreleaseがリリースされるようになりました。しかし現在はリリースのペースを落とし、3カ月ごとのリリースに変更している。そのうち1か月かけて新しいfeaturesを書いてベータ版をリリースし、残り2か月でベータ版のテストとバグ修正を行い、その後のリリースをより安定させることができます。</p>\n<h2 id=\"1-2-JS-ES-TS-の関係\"><a href=\"#1-2-JS-ES-TS-の関係\" class=\"headerlink\" title=\"1.2 JS, ES, TS の関係\"></a>1.2 <code>JS</code>, <code>ES</code>, <code>TS</code> の関係</h2><ul>\n<li><strong>1995年：JavaScript</strong></li>\n</ul>\n<p>当時のネットスケープは、そのNavigatorブラウザによって、Web時代が始まった当時、最も有名な第1世代のインターネット企業になりつつありました。</p>\n<p>ネットスケープは、静的なHTMLページに動的な効果を追加したいと考えていたため、 <code>Brendan Eich</code> は2週間以内にJavaScript言語を設計しました。</p>\n<p>なぜJavaScriptと名付けられたのか。理由は当時Java言語が非常に人気だったので、ネットスケープ社はJavaの名を借りて普及させたいと考えていたのですが、実はJavaScriptは文法的にJavaに似ている部分以外はほとんど関係がありませんでした。</p>\n<ul>\n<li><strong>1997年：ECMAScript</strong></li>\n</ul>\n<p>ネットスケープがJavaScriptを開発し、その1年後にマイクロソフトがJavaScriptをまねてJScriptを開発したことで、JavaScriptをグローバル標準にするために、いくつかの企業がECMA（European Computer Manufacturers Association）（欧州コンピュータ製造業者協会）組織と連携してECMAScript標準と呼ばれるJavaScript言語の標準を制定したからだ。</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>发布时间</th>\n<th>一般的な呼び方</th>\n<th>简称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>第1版</td>\n<td>1997年6月</td>\n<td>ECMAScript 1</td>\n<td>ES1</td>\n</tr>\n<tr>\n<td>第2版</td>\n<td>1998年4月</td>\n<td>ECMAScript 2</td>\n<td>ES2</td>\n</tr>\n<tr>\n<td>第3版</td>\n<td>1999年12月</td>\n<td>ECMAScript 3</td>\n<td>ES3</td>\n</tr>\n<tr>\n<td>第4版</td>\n<td>2007年10月草案</td>\n<td>ECMAScript 4</td>\n<td>ES4</td>\n</tr>\n<tr>\n<td>第5版</td>\n<td>2009年12月</td>\n<td>ECMAScript 5</td>\n<td>ES5</td>\n</tr>\n<tr>\n<td>第6版</td>\n<td>2015年6月</td>\n<td>ECMAScript 2015</td>\n<td>ES6</td>\n</tr>\n<tr>\n<td>第7版</td>\n<td>2016年6月</td>\n<td>ECMAScript 2016</td>\n<td>ES7</td>\n</tr>\n<tr>\n<td>第8版</td>\n<td>2017年6月</td>\n<td>ECMAScript 2017</td>\n<td>ES8</td>\n</tr>\n<tr>\n<td>第9版</td>\n<td>2018年6月</td>\n<td>ECMAScript 2018</td>\n<td>ES9</td>\n</tr>\n<tr>\n<td>第10版</td>\n<td>2019年6月</td>\n<td>ECMAScript 2019</td>\n<td>ES10</td>\n</tr>\n<tr>\n<td>第11版</td>\n<td>2020年6月</td>\n<td>ECMAScript 2020</td>\n<td>ES11</td>\n</tr>\n<tr>\n<td>第12版</td>\n<td>2021年6月</td>\n<td>ECMAScript 2021</td>\n<td>ES12</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>2015年：TypeScript</strong></li>\n</ul>\n<p>TypeScriptは、JavaScriptのスーパーセットです。JavaScriptのすべての要素を含み、JavaScriptを実行するコードで、JavaScriptの構文を拡張します。JavaScriptよりも静的型、クラス、モジュール、インタフェース、型注釈の機能が追加され、大規模プロジェクトの開発が容易になりました。</p>\n<p>TypeScriptは、2015年のECMAScriptや、非同期機能やDecoratorsなどの将来的な提案など、最新のJavaScript機能を提供し、堅牢なコンポーネントの構築を支援しています。次の図に、TypeScriptとES5、ES2015+の関係を示します：</p>\n<img src=\"https://s2.loli.net/2022/02/22/KVoCdwp5rB31zxm.png\" alt=\"image-20211109122048861\" style=\"zoom:50%;\" />\n\n<h2 id=\"1-3-TypeScriptとJavaScriptの違い\"><a href=\"#1-3-TypeScriptとJavaScriptの違い\" class=\"headerlink\" title=\"1.3 TypeScriptとJavaScriptの違い\"></a>1.3 TypeScriptとJavaScriptの違い</h2><table>\n<thead>\n<tr>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JavaScriptのスーパーセットは、大規模プロジェクトのコードの複雑さを解決するために使用されます</td>\n<td>一种脚本语言，用于创建动态网页</td>\n</tr>\n<tr>\n<td>コンパイル中にエラーを発見して修正できる</td>\n<td>作为一种解释型语言，只能在运行时发现错误</td>\n</tr>\n<tr>\n<td>静的タイプと動的タイプの両方をサポートする強力タイプ</td>\n<td>弱类型，没有静态类型选项</td>\n</tr>\n<tr>\n<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>\n<td>ブラウザで直接使用可能</td>\n</tr>\n<tr>\n<td>モジュール、汎用、インターフェイスのサポート</td>\n<td>不支持模块、泛型或接口</td>\n</tr>\n<tr>\n<td>ES3、ES4、ES5、およびES6+の機能をサポート</td>\n<td>不支持编译其他 ES3，ES4，ES5 或 ES6+ 功能</td>\n</tr>\n<tr>\n<td>地域社会の支援は増え続けており、まだそれほど大きくはない</td>\n<td>大量的社区支持以及大量文档和解决问题的支持</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-4-TypeScriptの競合他社について教えてください。\"><a href=\"#1-4-TypeScriptの競合他社について教えてください。\" class=\"headerlink\" title=\"1.4 TypeScriptの競合他社について教えてください。\"></a>1.4 TypeScriptの競合他社について教えてください。</h2><p>TypeScriptの目標は、大規模なJavaScriptプロジェクトを作成し、ポストメンテナンスに自信のあるツールを人々に提供することです。JavaScript自体にはないシンタックスサポートは、JavaScriptを実行して実行時に検出しない限り、各識別子のタイプを表します。この問題を解決するために、TypeScriptにシンタックスが追加されました。</p>\n<p>つまり、ツールとしてサポートすることを目標としているのであれば、TypeScriptではこの分野では競争できない競合他社が少数存在します：</p>\n<ul>\n<li>ESLintとTSLint：TypeScriptと同じように、コード内で発生する可能性のあるエラーを強調するために使用されますが、チェックプロセスに新しい構文は追加されません。どちらもIDE統合のためのツールとして動作するつもりはなく、またTSやTS&#x2F;ESLintは、プロジェクトにとって意味のない特性を「相手の領域だ」と言うことが多い。最新のコードでは、TS&#x2F;ESLintの存在により、TypeScriptはすべてのコードベースに適用されるわけではないチェックを少なくすることができます。いくつかの機能が重なってしまいましたが、それらを良い補完ツールとして活用することができます。</li>\n<li>CoffeeScript：おい、TypeScriptは2012年にリリースされたんだ！CoffeeScriptとTypeScriptの違いは、CoffeeScriptがJavaScriptにいくつかの機能を追加するなど、JavaScript言語を改善したいという点です。これは、CoffeeScriptと書き出されるJavaScriptの違いを理解することを意味します。時間の経過とともに、CoffeeScriptのベストコンセプトが逆に別のJavaScriptにしてしまい、ほとんどJavaScriptになってしまったCoffeeScriptに困ってしまう。</li>\n<li>Flow：これは、FacebookのJavaScript型検査ツールおよびIDEツール言語です。TypeScriptと同じように、FlowはJavaScriptにいくつかのシンタックスサポートを追加して、より豊富なタイプのシステムを手に入れ、コンパイル時に削除します。JavaScriptを書き始めた頃、Flowは標準的なJavaScriptに近いツールだったので、最初に使ったツールです。Flowは素晴らしいタイプのシステムで、TypeScriptとは異なる目標を持っています。目に見えないタイプ層システムは「正しい」あるいは「十分に正しいと感じる」決定をし続けなければならず、Flowの目標は「正しい」（訳者注：Flowは<strong>soundness</strong>[6]に偏っており、タイプ判断においてより悲観的である）であり、TypeScriptの目標は「感覚的にはほとんどの場合が正しい」（訳者注：TS公式は<strong>TSは完全なタイプではありません</strong>[7]と主張しており、unsound行動を許容し、completenessに偏っており、タイプ判断においてより楽観的である）である。魚と熊の掌は両方を得ることができなくて、完備な類型導出、良好な開発体験と完璧なJS協同（Perfect JavaScript Interop）はその2つしか取れない。</li>\n</ul>\n<p>では、オープンソースのFlowコードベースのほとんどが最終的にTypeScriptに移行したのはなぜでしょうか。私の中では、2つのチームの異なるサイドポイントで決められている部分が大きいと思います。FlowはFacebookのコードベースを維持するために作られていますが、TypeScriptは独立した言語として作られています。ここには2つの証拠があります：</p>\n<ol>\n<li>Facebookのコードベースは分割できない巨大なモノレポであるが、Flowチームはこのような<strong>大規模コードベース</strong>[8]の下で型を実行するために<strong>信じられないほど多くの仕事が</strong>[9]を作成した。一方、TypeScriptは「小さなコードベースサービスを構築するため（use projects to make sets of smaller codebases）」と言えるが、これは人々がオープンソースコミュニティでJavaScriptモジュールを書く方法に合致しているからだ。そう言うのは理にかなっていると思いますが、TypeScriptはFlowのようにFacebookのコードベースでは動作せず、Facebookのコードを大量に書き直してプロジェクトを構築するか、TypeScriptに大量の修正を加える必要があり、TypeScript全体の開発者の体験に影響を与える可能性があります。</li>\n<li>タイプに対するDefinitelyTypedとFlowのアプローチを比較すると、TypeScriptチームはコンパイラエンジニアをローテーションで配置し、DefinitelyTypedのビルドツールをサポートし、コミュニティの管理を支援します。そしてFlowは、ほぼ完全にコミュニティによって維持されています。DTは現在、非Facebookコードの開発に注力してきたため、より規模が大きくなっており、Flowチームからの資金支援を得るのは困難になるだろう。</li>\n</ol>\n<p>マイクロソフトがTypeScriptに社内で作成した独立した環境により、TypeScriptは、特別に難しい問題の解決だけに集中するのではなく、ツール開発やエコシステム全体のメンテナンスに自由に集中できるようになりました。これにより、TypeScriptチームは多くの人と協力し、コミュニティが望む機能を次々とリリースできるようになりました。時間の経過とともに、外部からの需要の伸びが鈍化しているため、Flowチームはコミュニティの仕事に時間を割くことがますます難しくなっているのではないかと推測しています。これが悪循環となっている。これにより、FlowはTypeScriptの直接的な「競合者」ではなく、さまざまな角度から、さまざまな制約を使って、類似の問題を解決する方法について興味深い視点を持つようになりました。</p>\n<h2 id=\"1-5-TypeScriptの今後\"><a href=\"#1-5-TypeScriptの今後\" class=\"headerlink\" title=\"1.5 TypeScriptの今後\"></a>1.5 TypeScriptの今後</h2><h3 id=\"1-5-1TypeScriptの今後についてどう考えていますか。\"><a href=\"#1-5-1TypeScriptの今後についてどう考えていますか。\" class=\"headerlink\" title=\"1.5.1TypeScriptの今後についてどう考えていますか。\"></a>1.5.1<strong>TypeScriptの今後についてどう考えていますか。</strong></h3><p>現在、TypeScriptの使用を妨げている最大の障害は、ビルドツールが必要であることです。型文法がJavaScriptに組み込まれる可能性は低いと思いますが、JavaScriptでは「型をアノテーションで定義する」可能性は十分にあります。</p>\n<p>このアイデアは、TypeScriptのようなタイプのシステムのシンタックスのセットを作成することですが、JSの実行時に何が起こるかは定義されていません。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;1234&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将会变成这样</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a <span class=\"comment\">/*: string */</span> = <span class=\"string\">&quot;1234&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入 JS 引擎</span></span><br></pre></td></tr></table></figure>\n\n<p>この例では、JSエンジンは、stringが&#x3D;で終わる型注釈であることを認識します。この実際の働き方は複雑で、解明に時間がかかる。しかし、JavaScriptでTypeScriptを「ネイティブに」実行できるようにすることで、TypeScriptが使用される際の障壁が低くなります。BabelがTypeScriptサポートを追加したときと同じように、TypeScriptにいくつかの制約を適用します。でもそれだけの価値はあると思う。</p>\n<p>Denoは、現在のJavaScriptエンジンによるネイティブTypeScriptのサポートをシミュレートしたRustで書かれたツールを実行することで、TSのJSへのコンパイルを非常に迅速に行うことができる、すべてのTSの障害を取り除く重要な例です。</p>\n<h3 id=\"1-5-2今日の競合他社\"><a href=\"#1-5-2今日の競合他社\" class=\"headerlink\" title=\"1.5.2今日の競合他社\"></a>1.5.2今日の競合他社</h3><ul>\n<li>JetBrains WebStorm-高度なJavaScriptツールをサポートするIDEです。リファクタリング、コードフロー解析、JavaScript構文のチェックを行う独自のエンジンがあります。これはすばらしいことです。JetBrainsはすべてのIDEでしっかりとした仕事をしています。私は過去にAppCodeを使ってiOSの仕事をすることが多かった。TypeScriptのプロジェクトがある場合、WebStormはTypeScriptの言語ツールと独自のツールをミックスしてくれるので、Win-Winです。</li>\n<li>JSにコンパイルされた言語-現在の例としてElm、ReScript、KotlinScriptがありますが、これらの言語はJavaScriptとの対話を中心にしています。これらはTypeScriptにとって興味深い言語であり、タイプシステムを実装するためのクリーンな環境を持っています。つまり、JSの負担がありません。競合他社としては、JavaScriptが中心ではないことや、CoffeeScriptからの移行にコミュニティが悩まされてきたことから、より細分化された市場を好む傾向があります。</li>\n<li>WASM-TypeScriptの競合他社としてのWASMの見解は、WASMがJSコントロールブラウザDOMに代わる言語として機能するというものだと聞きました。これに反対する人々は、WASMにはDOMバインディングがなく、おそらく永遠に存在しないと考えている。TypeScriptにはJavaScriptの欠点が含まれていますが、JavaScriptランタイムにWASMを組み込んだことがあれば、ほぼ常にもっと好きになるでしょう。ということは、AssemblyScriptはこの点でかなり良い仕事をしているということになります。WASMはJSONと考えた方が良いかもしれません。WASMはプロジェクトを構成する別のツールであり、WASMとDOMの相互作用の仕方が変わっていない限り、JavaScriptの競合にはなりそうにありません。</li>\n<li>WASMにコンパイルされた言語-たとえば、Rust、Go、Swiftなど、WASMにコンパイルできる他の言語。これらの言語はいずれもTypeScriptの現在のツールやwebのコア・ビルディング・モジュールとしての位置を占めている可能性がありますが、どうなるかわかりません。これらの言語は、さまざまな基本型を提供し、異なる目標に基づいてゼロから構築することができます。WASMやWASIが最終的に成功するのであれば、プラットフォームに関わることになると思いますが（appsなどの機能実装を考えてみてください）、その方向性を見てみると面白いと思います。本音を言えば、それらはTypeScriptの競合ではなく、JavaScriptのものです。</li>\n</ul>\n<h3 id=\"1-5-3-TypeScriptは生態系の中での位置をどう見ていますか？\"><a href=\"#1-5-3-TypeScriptは生態系の中での位置をどう見ていますか？\" class=\"headerlink\" title=\"1.5.3 TypeScriptは生態系の中での位置をどう見ていますか？\"></a>1.5.3 TypeScriptは生態系の中での位置をどう見ていますか？</h3><p>TypeScriptは、タイプシステムやエディタツールの分野でイノベーションを起こしたいと考えています。私たちは、主流のプログラミング言語の中で最も表現力の高いタイプのシステムの1つを持っています。</p>\n<p>TypeScriptが最初に作成されたときのJavaScriptの修正プロセスは現在とはかなり異なるため、TypeScriptには実際にはTC39の領域である機能がいくつかありますが、下位互換性が必要です。これらの機能はJavaScriptに何年も存在し、何度も繰り返されることがあります。つまり、TypeScriptは、特定の言語機能の2つのバージョンを維持する必要があります。</p>\n<p>そこでTC39 JavaScript言語委員会の優秀なメンバーになり、エディタがサポートする言語特性についてフィードバックし、TypeScriptユーザーが見たい特性をサポートすることを目指しています。このコラボレーションによって、TC39はJavaScriptを制御し、TypeScriptもそれらをサポートします。</p>\n<h3 id=\"1-5-4-TypeScriptはそのオーディエンスをどのように見ていますか。\"><a href=\"#1-5-4-TypeScriptはそのオーディエンスをどのように見ていますか。\" class=\"headerlink\" title=\"1.5.4 TypeScriptはそのオーディエンスをどのように見ていますか。\"></a>1.5.4 TypeScriptはそのオーディエンスをどのように見ていますか。</h3><p>TypeScriptのオーディエンスは主に次のとおりです。</p>\n<ul>\n<li>JavaScriptユーザー(言語ツールとして)</li>\n<li>JS+JSDocユーザー(言語ツールとして)</li>\n<li>TypeScriptユーザー(コンパイラ、言語ツールとして)</li>\n<li>TypeScript strictモード(コンパイラ、言語ツールとして)</li>\n</ul>\n<p>babel&#x2F;swc&#x2F;sucrase&#x2F;esbuildなどのツールを使用してプロジェクトを構築する場合、tscはオプションですが、前述の参加者はTSリリースのたびに、または少なくとも2回ごとに新しい機能を利用できます（訳者注：babel、esbuildなどはTSの新機能をサポートするために更新されます。TSチームが直接プロジェクトに参加するか、vscodeなどの機能をtscなしで提供する場合があります。その他のリリース計画については、<strong>TS roadmap</strong>[10]を参照してください）。</p>\n<h3 id=\"1-5-5-TypeScriptはJSの生態をどのように追跡しているのか。\"><a href=\"#1-5-5-TypeScriptはJSの生態をどのように追跡しているのか。\" class=\"headerlink\" title=\"1.5.5 TypeScriptはJSの生態をどのように追跡しているのか。\"></a>1.5.5 TypeScriptはJSの生態をどのように追跡しているのか。</h3><p>チームは、次のような方法でフィードバックを受けます：</p>\n<ul>\n<li>GitHub Isuesには絶え間ないコメントの残響がある</li>\n<li>Microsoftの社内チームが機能を提供するか、低速なコードベースのデバッグを私たちに依頼してきた</li>\n<li>GitterまたはTypeScriptコミュニティのDiscordを介してコミュニティとつながる</li>\n<li>マイクロクラスターの内部ツールを使用したアイデア&#x2F;デザインのユーザーテスト</li>\n<li>VS Codeと非常に密接な関係があり、多くの言語ツールからフィードバックが寄せられている</li>\n<li>@TypeScriptチームのツイートを読むと</li>\n<li>TypeScriptに移行されたブログ投稿とTypeScriptから移行されたブログ投稿を追跡します</li>\n<li>業界調査とプログラミング言語の概要を追跡</li>\n</ul>\n<h3 id=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"><a href=\"#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\" class=\"headerlink\" title=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"></a>特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3>"
      },
      {
        "title": "ホバリング時のジッターの原因と解決策",
        "toc": true,
        "abbrlink": 6338,
        "date": "2024-01-28T13:20:06.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n## 1. 発生の原因\n\n```text\nCSSのhover時に揺れが生じる原因は通常、ボックスモデルやレイアウトに関連しており、要素がhover状態で一部のスタイルが追加され、要素のサイズや位置が変化することによって揺れが発生する可能性があります。\n```\n\n## 2. 解決方法\n\n### 2.1ボーダーの影響\n\n```css\n/* もしhover状態でボーダーが追加され、非hover状態でボーダーの幅が考慮されていない場合、揺れの原因となる可能性があります。非hover状態でも十分なスペースを要素に確保するようにしてください。 */\n/* 悪い例 */\n.box {\n  border: 1px solid transparent;\n  transition: border-color 0.3s;\n}\n\n.box:hover {\n  border-color: red;\n}\n\n/* 良い例 */\n.box {\n  border: 1px solid transparent;\n  transition: border-color 0.3s;\n  box-sizing: border-box;\n}\n\n.box:hover {\n  border-color: red;\n}\n```\n\n### 2.2幅と高さの変化\n\n```css\n/* もしhover状態で要素の幅や高さが変化し、非hover状態で適切に設定されていない場合、揺れの原因となる可能性があります。 */\n/* 悪い例 */\n.box {\n  width: 100px;\n  height: 100px;\n  transition: width 0.3s;\n}\n\n.box:hover {\n  width: 120px;\n}\n\n/* 良い例 */\n.box {\n  width: 100px;\n  height: 100px;\n  transition: width 0.3s;\n  box-sizing: border-box;\n}\n\n.box:hover {\n  width: 120px;\n}\n```\n\n### 2.3透明度の変更\n\n```css\n/* いくつかのケースでは、要素の透明度を変更すると揺れが生じることがあります。非hover状態でも透明度を設定するようにしてください。 */\n/* 悪い例 */\n.box {\n  opacity: 1;\n  transition: opacity 0.3s;\n}\n\n.box:hover {\n  opacity: 0.8;\n}\n\n/* 良い例 */\n.box {\n  opacity: 1;\n  transition: opacity 0.3s;\n}\n\n.box:hover {\n  opacity: 0.8;\n}\n```\n\n### 2.4 transformプロパティーの使用\n\n```css\n/* 一部のケースでは、transformプロパティを使用する方が効果的かもしれません。これはレイアウトに起因する揺れを避けるため、文書フローに影響を与えません。 */\n.box {\n  transition: transform 0.3s;\n}\n\n.box:hover {\n  transform: scale(1.1);\n}\n```\n",
        "source": "_posts/日本語/Css/1-1、ホバリング時のジッターの原因と解決策.md",
        "raw": "---\ntitle: ホバリング時のジッターの原因と解決策\ntoc: true\ncategories:\n  - 日本語\n  - Css\ntags:\n  - Css\n  - フロントエンド\nabbrlink: 6338\ndate: 2024-01-28 21:20:06\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n## 1. 発生の原因\n\n```text\nCSSのhover時に揺れが生じる原因は通常、ボックスモデルやレイアウトに関連しており、要素がhover状態で一部のスタイルが追加され、要素のサイズや位置が変化することによって揺れが発生する可能性があります。\n```\n\n## 2. 解決方法\n\n### 2.1ボーダーの影響\n\n```css\n/* もしhover状態でボーダーが追加され、非hover状態でボーダーの幅が考慮されていない場合、揺れの原因となる可能性があります。非hover状態でも十分なスペースを要素に確保するようにしてください。 */\n/* 悪い例 */\n.box {\n  border: 1px solid transparent;\n  transition: border-color 0.3s;\n}\n\n.box:hover {\n  border-color: red;\n}\n\n/* 良い例 */\n.box {\n  border: 1px solid transparent;\n  transition: border-color 0.3s;\n  box-sizing: border-box;\n}\n\n.box:hover {\n  border-color: red;\n}\n```\n\n### 2.2幅と高さの変化\n\n```css\n/* もしhover状態で要素の幅や高さが変化し、非hover状態で適切に設定されていない場合、揺れの原因となる可能性があります。 */\n/* 悪い例 */\n.box {\n  width: 100px;\n  height: 100px;\n  transition: width 0.3s;\n}\n\n.box:hover {\n  width: 120px;\n}\n\n/* 良い例 */\n.box {\n  width: 100px;\n  height: 100px;\n  transition: width 0.3s;\n  box-sizing: border-box;\n}\n\n.box:hover {\n  width: 120px;\n}\n```\n\n### 2.3透明度の変更\n\n```css\n/* いくつかのケースでは、要素の透明度を変更すると揺れが生じることがあります。非hover状態でも透明度を設定するようにしてください。 */\n/* 悪い例 */\n.box {\n  opacity: 1;\n  transition: opacity 0.3s;\n}\n\n.box:hover {\n  opacity: 0.8;\n}\n\n/* 良い例 */\n.box {\n  opacity: 1;\n  transition: opacity 0.3s;\n}\n\n.box:hover {\n  opacity: 0.8;\n}\n```\n\n### 2.4 transformプロパティーの使用\n\n```css\n/* 一部のケースでは、transformプロパティを使用する方が効果的かもしれません。これはレイアウトに起因する揺れを避けるため、文書フローに影響を与えません。 */\n.box {\n  transition: transform 0.3s;\n}\n\n.box:hover {\n  transform: scale(1.1);\n}\n```\n",
        "slug": "日本語/Css/1-1、ホバリング時のジッターの原因と解決策",
        "published": 1,
        "updated": "2024-02-15T07:47:27.068Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjanx000794v315qwgjgv",
        "content": "<h2 id=\"1-発生の原因\"><a href=\"#1-発生の原因\" class=\"headerlink\" title=\"1. 発生の原因\"></a>1. 発生の原因</h2><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">CSSのhover時に揺れが生じる原因は通常、ボックスモデルやレイアウトに関連しており、要素がhover状態で一部のスタイルが追加され、要素のサイズや位置が変化することによって揺れが発生する可能性があります。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-解決方法\"><a href=\"#2-解決方法\" class=\"headerlink\" title=\"2. 解決方法\"></a>2. 解決方法</h2><h3 id=\"2-1ボーダーの影響\"><a href=\"#2-1ボーダーの影響\" class=\"headerlink\" title=\"2.1ボーダーの影響\"></a>2.1ボーダーの影響</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* もしhover状態でボーダーが追加され、非hover状態でボーダーの幅が考慮されていない場合、揺れの原因となる可能性があります。非hover状態でも十分なスペースを要素に確保するようにしてください。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 悪い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-color <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 良い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-color <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2幅と高さの変化\"><a href=\"#2-2幅と高さの変化\" class=\"headerlink\" title=\"2.2幅と高さの変化\"></a>2.2幅と高さの変化</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* もしhover状態で要素の幅や高さが変化し、非hover状態で適切に設定されていない場合、揺れの原因となる可能性があります。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 悪い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: width <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">120px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 良い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: width <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">120px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3透明度の変更\"><a href=\"#2-3透明度の変更\" class=\"headerlink\" title=\"2.3透明度の変更\"></a>2.3透明度の変更</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* いくつかのケースでは、要素の透明度を変更すると揺れが生じることがあります。非hover状態でも透明度を設定するようにしてください。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 悪い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 良い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-transformプロパティーの使用\"><a href=\"#2-4-transformプロパティーの使用\" class=\"headerlink\" title=\"2.4 transformプロパティーの使用\"></a>2.4 transformプロパティーの使用</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 一部のケースでは、transformプロパティを使用する方が効果的かもしれません。これはレイアウトに起因する揺れを避けるため、文書フローに影響を与えません。 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: transform <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h2 id=\"1-発生の原因\"><a href=\"#1-発生の原因\" class=\"headerlink\" title=\"1. 発生の原因\"></a>1. 発生の原因</h2><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">CSSのhover時に揺れが生じる原因は通常、ボックスモデルやレイアウトに関連しており、要素がhover状態で一部のスタイルが追加され、要素のサイズや位置が変化することによって揺れが発生する可能性があります。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-解決方法\"><a href=\"#2-解決方法\" class=\"headerlink\" title=\"2. 解決方法\"></a>2. 解決方法</h2><h3 id=\"2-1ボーダーの影響\"><a href=\"#2-1ボーダーの影響\" class=\"headerlink\" title=\"2.1ボーダーの影響\"></a>2.1ボーダーの影響</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* もしhover状態でボーダーが追加され、非hover状態でボーダーの幅が考慮されていない場合、揺れの原因となる可能性があります。非hover状態でも十分なスペースを要素に確保するようにしてください。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 悪い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-color <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 良い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-color <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2幅と高さの変化\"><a href=\"#2-2幅と高さの変化\" class=\"headerlink\" title=\"2.2幅と高さの変化\"></a>2.2幅と高さの変化</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* もしhover状態で要素の幅や高さが変化し、非hover状態で適切に設定されていない場合、揺れの原因となる可能性があります。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 悪い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: width <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">120px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 良い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: width <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">120px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3透明度の変更\"><a href=\"#2-3透明度の変更\" class=\"headerlink\" title=\"2.3透明度の変更\"></a>2.3透明度の変更</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* いくつかのケースでは、要素の透明度を変更すると揺れが生じることがあります。非hover状態でも透明度を設定するようにしてください。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 悪い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 良い例 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-transformプロパティーの使用\"><a href=\"#2-4-transformプロパティーの使用\" class=\"headerlink\" title=\"2.4 transformプロパティーの使用\"></a>2.4 transformプロパティーの使用</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 一部のケースでは、transformプロパティを使用する方が効果的かもしれません。これはレイアウトに起因する揺れを避けるため、文書フローに影響を与えません。 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: transform <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"
      },
      {
        "title": "1-3、TypeScriptのよくある種類",
        "toc": true,
        "abbrlink": 17422,
        "date": "2024-02-14T14:05:56.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 三、よく使われるタイプ\n\nこの章では、JavaScriptコードで最も一般的な値の型をいくつか紹介し、これらの型をTypeScriptで説明するための適切な方法について説明します。これは詳細なリストではありませんが、今後の章では、他の種類の名前を付けて使用するためのより多くの方法について説明します。\n\nタイプは、タイプコメントだけでなく、他の*地方、*にも表示されます。型自体を理解すると、新しい構造を形成するためにそれらの型を参照できる場所についても理解していきます。\n\n最初に、JavaScriptまたはTypeScriptコードを書くときに遭遇するであろう最も基本的で一般的な型を見てみましょう。これは、より複雑な型を形成するコア構成要素です。\n\n## 3.0 TypeScript設定ファイル\n\n学習を容易にするために、コマンドラインの引数を別の構成ファイルに保存し、 `tsc` を適用して構成ファイルを生成します：\n\n<img src=\"https://s2.loli.net/2022/02/22/1dAfz2imrs3CMbL.png\" alt=\"image-20211113170722654\" style=\"zoom: 50%;\"/>\n\n構成ファイル `tsconfig.json` がプロジェクトのルートディレクトリに構築されました。ここでは、独自の構成について説明します：\n\n```json\n{\n  \"compilerOptions\": {\n    /* Language and Environment */\n    \"target\": \"es6\",\n    /* Modules */\n    \"rootDir\": \"./src\",\n    /* Emit */\n    \"outDir\": \"./dist\",\n    /* Type Checking */\n    \"strict\": true\n  }\n}\n```\n\n## 3.1プリミティブ型 `string`, `number`,および `boolean`\n\nJavaScriptには3つの非常に一般的な[原语](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)があります。 `string`、 `number`、および `boolean` です。TypeScriptには、それぞれに対応するタイプがあります。これらの名前は、JavaScriptアプリケーション `typeof` で返された型の名前と同じであることがわかりました：\n\n- `string` は、 `\"Hello, world\"` のような文字列値を表します。\n- `number` は、 `42` などの数値を表します。JavaScriptには特別な整数ランタイム値がないので、 `int` または `float` 型と等価ではありません。すべては `number` のみです。\n- `boolean` 2つの値のみ `true` と `false`\n\n> 型名 `String`, `Number`,および `Boolean` (大文字で始まる)は合法ですが、コードにはあまり表示されない特殊な組み込み型を指します。タイプの場合、*始終*は `string`, `number`,または `boolean` を使用します。\n\n```js\nlet str: string = 'hello typescript'\nlet num: number = 100\nlet bool: boolean = true\n```\n\n## 3.2配列\n\n配列は、 `[1, 2, 3]` データのように指定された形であり、構文 `number[]` を使用して定義できます;この構文は、任意の型(たとえば、 `string[]`、文字列配列など)に適用されます。\n\n`Array<number>` と書くこともできます。 `T<U>` この構文については、*はんぷくがた*を参照してください。\n\n**02-everyday-types/src/02-array.ts**\n\n```ts\nlet arr: number[] = [1, 2, 3];\nlet arr2: Array<number> = [1, 2, 3];\n```\n\n## 3.3 any\n\nTypeScriptには特殊な型 `any` もあり、特定の値で型チェックエラーが発生したくない場合に使用できます。\n\n値の型が `any` の場合は、その属性にアクセスし、どの型の値にもそれを割り当てることができます。その他のほとんどの構文的なものは、正当なものとなります：\n\n```tsx\nlet obj: any = { x: 0 };\n// 次のコード行はいずれもコンパイラ エラーをスローしません。\n// 「any」を使用すると、それ以降の型チェックがすべて無効になります\nobj.foo();\nobj();\nobj.bar = 100;\nobj = \"hello\";\nconst n: number = obj;\n```\n\nただし、実行環境でコードを実行すると、エラーになることがあります：\n\n<img src=\"/img/TypeScript/03-02.png\" alt=\"image-20211113182543401\" style=\"zoom:50%;\" />\n\n`dist` ディレクトリに移動し、node環境でコードを実行しましたが、やはりエラーが発生しました。\n\n`any` 型は、TypeScriptが特定のコード行が大丈夫であることを確信するためだけに、長い型を書きたくない場合に便利です。\n\n- **noImplicitAny**\n\n型が指定されておらず、TypeScriptがコンテキストから推測できない場合、コンパイラは通常、デフォルトで `any` に設定されます。\n\nただし、 `any` は型チェックを行わないので、このような状況は避けたいのが一般的です。コンパイラフラグ[ `noImplicitAny`]（https://www.typescriptlang.org/tsconfig#noImplicitAny）を使用して、暗黙的なフラグ `any` をエラーにします。この構成は前にも述べました。\n\n## 3.4変数の型コメント\n\n`const`, `var`,または `let` を使用して変数を宣言する場合は、型コメントを追加して変数の型を明示的に指定できます：\n\n```ts\nlet myName: string = \"Felixlu\";\n```\n\n> TypeScriptは「左の型」スタイルの宣言を使用しません。たとえば、 `int x = 0;` 型注釈は常に*在る*入力されたもの*後*です。\n\nしかし、ほとんどの場合、これは必須ではありません。可能な限り、TypeScriptは自動*推論*コード内の型を試します。たとえば、変数の型は、その初期化子の型から推測されます：\n\n```tsx\n// 型定義は必要ありません -- 「myName」は「string」型であると推論されます\nlet myName = \"Felixlu\";\n```\n\n多くの場合、推論規則を明示的に学習する必要はない。始めたばかりの方は、思ったよりも少ないタイプの注釈を使ってみてください。驚くかもしれませんが、TypeScriptは何が起こっているかを完全に理解しています。\n\n## 3.5関数\n\n関数は、JavaScriptでデータを渡す主要な方法です。TypeScriptを使用すると、関数の入力値と出力値のタイプを指定できます。\n\n- パラメータタイプの注記\n\n関数を宣言するときは、各引数の後に型注記を追加して、関数が受け入れる引数の型を宣言できます。パラメータタイプの注記は、パラメータ名の後に表示されます：\n\n```tsx\n// パラメータの型の定義\nfunction greet(name: string) {\n  console.log(\"Hello, \" + name.toUpperCase() + \"!!\");\n}\n```\n\nパラメータに型コメントがある場合、関数のパラメータがチェックされます：\n\n```tsx\n// 実行すると実行時エラーになります。\ngreet(42);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/SR9okXs1ez7ThC6.png\" alt=\"image-20211114072314780\" style=\"zoom: 50%;\" />\n\n> パラメータに型コメントがない場合でも、正しい数のパラメータが渡されているかどうかがチェックされます。\n\n- 戻り値型コメント\n\n返り型コメントを追加することもできます。戻り値の型に関するコメントは、引数リストの後に表示されます：\n\n```tsx\nfunction getFavoriteNumber(): number {\n  return 26;\n}\n```\n\nTypeScriptは関数の戻り値の型を `return` ステートメントに基づいて推定するので、変数型コメントと同様に、戻り値型コメントは通常必要ありません。上記の例のタイプ注釈は何も変わりません。一部のコードベースでは、意図しない変更や個人的な好みを防ぐために、マニュアル用に戻り値の型を明示的に指定しています。\n\n- 匿名関数\n\n匿名関数は関数宣言とは少し異なります。TypeScriptがどのように呼び出されるかを判断できる場所に関数が現れると、その関数の引数によって自動的に型が指定されます。\n\n次に例を示します：\n\n```tsx\n// ここには型の注釈はありませんが、TypeScript はエラーをキャッチできます。\nconst names = [\"Alice\", \"Bob\", \"Eve\"];\n\n// 関数コンテキスト型\nnames.forEach(function (s) {\n  console.log(s.toUppercase());\n});\n\n// コンテキストタイプはアロー関数でも機能します\nnames.forEach((s) => {\n  console.log(s.toUppercase());\n});\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qMkb8YQzxUw2Xnc.png\" alt=\"image-20211114073444596\" style=\"zoom:50%;\" />\n\nパラメータ `s` に型コメントがない場合でも、TypeScriptは `forEach` 関数の型と配列の推定型を使用して `s` の型を決定します。\n\nこのプロセスは*を選択して、*と呼ばれ、関数が発生する*コンテキスト*は、その関数がどのような型を持つべきかを通知するためです。\n\n推論規則と同様に、これがどのように起こるのかを明確に理解する必要はありませんが、そのメカニズム*確かに*を理解することで、型注釈が必要ないときに注意を払うことができます。あとで、*値が表示されるコンテキスト*がその型にどのように影響するかについて、さらに例を示します。\n\n## 3.6オブジェクトタイプ\n\n`string`, `number`, `boolean` 型(プリミティブ型とも呼ばれる)のほかに、最も一般的な型は*オブジェクトタイプ*です。これは、ほとんどすべてのプロパティを持つJavaScript値を指します！オブジェクトタイプを定義するには、その属性とそのタイプをリストします。\n\nたとえば、点状のオブジェクトを受け取る関数です：\n\n```tsx\n// パラメータの型アノテーションがオブジェクト型である\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"座標のx値： \" + pt.x);\n  console.log(\"座標のy値： \" + pt.y);\n}\nprintCoord({ x: 3, y: 7 });\n```\n\nここでは、2つの属性( `x` および `y`)を持つタイプ注釈パラメータを使用します。どちらも `number` タイプです。属性は、 `,` または `;` を使用して区切ることができます。最後の区切り文字はオプションです。\n\n各プロパティのタイプ部分もオプションです。型を指定しない場合は、 `any` とみなされます。\n\n- オプション属性\n\nオブジェクトタイプでは、プロパティの一部またはすべてが*オプション*であることも指定できます。これを行うには、属性名の後に `?` を追加します。\n\n**02-everyday-types/src/05-object.ts**\n\n```tsx\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// どちらの方法でパラメータを渡しても問題ありません\nprintName({ first: \"Felix\" });\nprintName({ first: \"Felix\", last: \"Lu\" });\n```\n\nJavaScriptでは、存在しないプロパティーにアクセスすると、実行時エラーではなく `undefined` の値が取得されます。したがって、オプション属性*読み取り*を使用する場合は、その属性を使用する前に `undefined` でチェックする必要があります。\n\n```tsx\nfunction printName(obj: { first: string; last?: string }) {\n  // × -「obj.last」が存在しない可能性があります。\n  console.log(obj.last.toUpperCase());\n\n  if (obj.last !== undefined) {\n    // √\n    console.log(obj.last.toUpperCase());\n  }\n\n  // 最新の JavaScript 構文を使用した安全な代替手段:\n  console.log(obj.last?.toUpperCase());\n}\n```\n\n## 3.7統合タイプ\n\nTypeScriptの型システムでは、複数の演算子を使用して既存の型から新しい型を構築できます。いくつかのタイプを書く方法がわかったので、それを面白おかしく*くみあわせ*始める時が来ました。\n\n- 連合タイプの定義\n\n型を結合する最初の方法は、*連合*型です。結合型は、2つ以上の他の型からなる型であり、これらの型の*いずれか*の値である可能性があることを示します。これらの各タイプを*結合タイプのメンバー*と呼びます。\n\n文字列または数値を操作する関数を作成します：\n\n```tsx\nfunction printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// √\nprintId(101);\n// √\nprintId(\"202\");\n// ×\nprintId({ myID: 22342 });\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qkOvn9DrVdCRSBc.png\" alt=\"image-20211114081646215\" style=\"zoom:50%;\" />\n\n- 結合タイプの使用\n\n*提供*結合タイプの値を一致させるのは簡単です。結合メンバーのタイプを指定するだけで済みます。もしあなたが*ある*結合型の値を持っていたら、どのようにそれを使いますか？\n\n連合の*それぞれ*メンバーがすべて有効であれば、TypeScriptは連合を使って何かをすることだけを許可します。たとえば、結合型 `string | number` がある場合、 `string` のように1つの型の操作のみを使用することはできません。\n\n```tsx\nfunction printId(id: number | string) {\n  console.log(id.toUpperCase());\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/TnuapbGVlOE2BYw.png\" alt=\"image-20211114085508715\" style=\"zoom:50%;\" />\n\n解決策は、型注釈のないJavaScriptと同様に、コード*縮小*を使用して結合することです。*縮小*は、TypeScriptがコード構造に基づいて値のより具体的な型を推定できる場合に発生します。\n\nたとえば、TypeScriptは、1つの `string` の値だけが `typeof` の値 `\"string\"` を持つことを知っています：\n\n```tsx\nfunction printId(id: number | string) {\n  if (typeof id === \"string\") {\n    // このブランチでは、ID のタイプ “string”\n    console.log(id.toUpperCase());\n  } else {\n    // ここでのIDの種類 “number”\n    console.log(id);\n  }\n}\n```\n\n別の例として、次の関数 `Array.isArray` を使用します。\n\n```tsx\nfunction welcomePeople(x: string[] | string) {\n  if (Array.isArray(x)) {\n    // ここ:「x」のタイプ 'string[]'\n    console.log(\"Hello, \" + x.join(\" and \"));\n  } else {\n    // ここ:「x」のタイプ 'string'\n    console.log(\"Welcome lone traveler \" + x);\n  }\n}\n```\n\n`else` ブランチでは特別なことをする必要はありません。 `x` が `string[]` でなければ、 `string` になります。\n\n時には `union` を持ち、メンバー全員に共通点があることもあります。たとえば、配列と文字列の両方に `slice` メソッドがあります。連合内の各メンバーに共通のプロパティがある場合は、そのプロパティを絞り込むことなく使用できます：\n\n```tsx\n// 戻り値の型は、number[] | string として推論されます。\nfunction getFirstThree(x: number[] | string) {\n  return x.slice(0, 3);\n}\n```\n\n## 3.8型エイリアス\n\nオブジェクト型と結合型は、型注釈に直接記述することで使用してきました。これは便利ですが、同じ型を何度も使い、名前を付けて参照したいというのはよくあります。\n\n*型エイリアス*は、任意の*タイプ*に対する*名前*の定義です。型エイリアスの構文は次のとおりです：\n\n```tsx\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// 前の例とまったく同じ\nfunction printCoord(pt: Point) {\n  console.log(\"座標 x の値： \" + pt.x);\n  console.log(\"座標 y の値： \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\n実際には、オブジェクトタイプだけでなく、タイプエイリアスを使用して任意のタイプに名前を付けることができます。たとえば、型エイリアスは連合型に名前を付けることができます：\n\n```tsx\ntype ID = number | string;\n```\n\nエイリアス*ただ*エイリアス-タイプエイリアスを使用して、同じタイプの異なる「バージョン」を作成することはできません。エイリアスを使うときは、エイリアスの型を書いたのと同じです。言い換えれば、このコード*そうは見えない*は有効かもしれませんが、TypeScriptに基づいて可能です。どちらのタイプも同じエイリアスなので、次のようになります：\n\n```tsx\ntype UserInputSanitizedString = string;\n\nfunction sanitizeInput(str: string): UserInputSanitizedString {\n  return str.slice(0, 2);\n}\n\n// サニタイズされた入力を作成する\nlet userInput = sanitizeInput(\"hello\");\n\n// ただし、文字列を使用して値を再割り当てすることは可能です\nuserInput = \"new input\";\n```\n\n## 3.9コネクタ\n\n*インタフェース宣言*は、オブジェクトタイプに名前を付ける別の方法です：\n\n```tsx\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printCoord(pt: Point) {\n  console.log(\"座標 x の値： \" + pt.x);\n  console.log(\"座標 y の値： \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\n上記でタイプエイリアスを使用した場合と同様に、この例は匿名オブジェクトタイプを使用した場合と同様に動作します。TypeScriptは、渡された値の*構造* `printCoord` だけを対象とします。これは、期待されるプロパティがあるかどうかだけを対象とします。型の構造と機能のみに注目することが、TypeScriptを*構造型*型システムと呼ぶ理由である。\n\n- 型エイリアスとインタフェースの違い\n\n型エイリアスとインタフェースは非常によく似ており、多くの場合、自由に選択することができます。ほとんどすべての機能が `interface` `type` で使用できます。主な違いは、新しいタイプの拡張方法です：\n\n```tsx\n// 拡張ポート\ninterface Animal {\n  name: string;\n}\n\ninterface Bear extends Animal {\n  honey: boolean;\n}\n\nconst bear: Bear = {\n  name: \"winnie\",\n  honey: true,\n};\nbear.name;\nbear.honey;\n// 交差点ごとにタイプを展開\ntype Animal = {\n  name: string;\n};\n\ntype Bear = Animal & {\n  honey: boolean;\n};\n\nconst bear: Bear = {\n  name: \"winnie\",\n  honey: true,\n};\nbear.name;\nbear.honey;\n// 既存のインターフェースに新しいフィールドを追加する\ninterface MyWindow {\n  title: string;\n}\n\ninterface MyWindow {\n  count: number;\n}\n\nconst w: MyWindow = {\n  title: \"hello ts\",\n  count: 100,\n};\n// 作成後にタイプを変更することはできません。\ntype MyWindow = {\n  title: string;\n};\n\ntype MyWindow = {\n  count: number;\n};\n```\n\n<img src=\"/img/TypeScript/03-07.png\" alt=\"image-20211114094240585\" style=\"zoom:50%;\" />\n\n> - TypeScriptバージョン4.2より前のバージョンでは、型エイリアス[*エラー・メッセージに*が表示される可能性があります](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA)は、同等の匿名型の代わりに使用されることがありました(これは望ましい場合と望ましくない場合があります)。インタフェースには常にエラーメッセージ内の名前が付けられます。\n> - 型エイリアスは[声明合并，但接口可以](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA)に関係しない可能性があります。\n> - インタフェースは[オブジェクトの形状を宣言します。プリミティブの名前は変更できません](https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA)でのみ使用できます。\n> - インタフェース名は[*常に*元の形式で](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA)エラーメッセージに表示されますが、名前で使用されている場合は*のみ*。\n>\n> ほとんどの場合、好みに合わせて選ぶことができますが、TypeScriptは別の種類の宣言が必要かどうかを教えてくれます。ヒューリスティックを使用する場合は、 `interface` を使用し、必要に応じて `type` を使用します。\n\n## 3.10型アサーション\n\nTypeScriptが知らない値の種類に関する情報が得られることがあります。\n\nたとえば、 `document.getElementById` を使用している場合、TypeScriptはこれが*ある種*型の `HTMLElement` を返すことだけを知っていますが、ページが常に `HTMLCanvasElement` 指定されたIDの値を持つことを知っているかもしれません。\n\nこの場合、*タイプアサーション*を使用して、より具体的な型を指定できます：\n\n```tsx\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;\n```\n\n型コメントと同様に、型アサーションはコンパイラによって削除され、コードの実行時動作には影響しません。\n\n山括弧構文も使用できます( `.tsx` ファイルにコードが含まれていない場合)。これは同等です：\n\n```tsx\nconst myCanvas = <HTMLCanvasElement>document.getElementById(\"main_canvas\");\n```\n\n> 注意：型アサーションはコンパイル時に削除されるため、型アサーションに関連付けられた実行時チェックはありません。 `null` 型アサーションが間違っている場合、例外は発生しません。\n\nTypeScriptでは、型アサーションは*より具体的な*または*あまり具体的ではない*の型バージョンにのみ変換できます。このルールは、次のような「不可能」の強制を防止します：\n\n```tsx\nconst x = \"hello\" as number;\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qNWktG6hBmzVZaC.png\" alt=\"image-20211114095324614\" style=\"zoom:50%;\" />\n\n型 `string` を型 `number` に変換すると、両方の型が十分に重複していないため、正しく変換されない可能性があります。意図的な場合は、式を `any` または `unknown` ( `unknown` (後述)に変換してから、必要な型を指定します：\n\n```tsx\nconst x = \"hello\" as unknown as number;\n```\n\n## 3.11文字タイプ\n\n一般的な型 `string` および `number` に加えて、型の位置で*特定の*文字列および数値を参照できます。\n\n1つの方法は、JavaScriptがどのようにさまざまな方法で変数を宣言するかを検討することです。 `var` と `let` のどちらも、変数に保存されているコンテンツの変更を許可します。 `const` は許可しません。これは、TypeScriptがテキストの型を作成する方法に反映されています。\n\n```tsx\nlet testString = \"Hello World\";\ntestString = \"Olá Mundo\";\n\n//'testString'あらゆる文字列を表すことができますが、TypeScript ではそれを型システムでどのように記述するのでしょうか?\ntestString;\n\nconst constantString = \"Hello World\";\n//「constantString」は 1 つの可能な文字列のみを表すことができるため、\n//テキスト型表現がある\nconstantString;\n```\n\nリテラルタイプは、それ自体にはあまり価値がありません：\n\n```tsx\nlet x: \"hello\" = \"hello\";\n// √\nx = \"hello\";\n// ×\nx = \"howdy\";\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/kcOHJ74TKSvuq1h.png\" alt=\"image-20211114102648519\" style=\"zoom:50%;\" />\n\n1つの値しか持たない変数を持っていても、あまり役に立ちません！\n\nしかし、*将*リテラル*くみあわせ*を結合することで、より有用な概念を表すことができます。たとえば、特定の既知の値のセットだけを受け入れる関数などです：\n\n```tsx\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  // ...\n}\nprintText(\"Hello, world\", \"left\");\nprintText(\"G'day, mate\", \"centre\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/SrcPeBsQvOUkDfw.png\" alt=\"image-20211114103049870\" style=\"zoom:50%;\" />\n\n数値リテラル型も同様に機能します：\n\n```tsx\nfunction compare(a: string, b: string): -1 | 0 | 1 {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n```\n\nもちろん、これらをリテラル以外のタイプと組み合わせて使用することもできます：\n\n```tsx\ninterface Options {\n  width: number;\n}\nfunction configure(x: Options | \"auto\") {\n  // ...\n}\nconfigure({ width: 100 });\nconfigure(\"auto\");\nconfigure(\"automatic\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/YZQwUvRlCtkzcTL.png\" alt=\"image-20211114103530209\" style=\"zoom:50%;\" />\n\nBoolean型の文字もあります。booleanリテラルには、型 `true` と `false` の2種類しかありません。型 `boolean` 自体は、実際には結合型 `union` のエイリアス `true | false` にすぎません。\n\n- 文字推論\n\nオブジェクトを使用して変数を初期化する場合、TypeScriptはそのオブジェクトのプロパティの値が後で変更される可能性があると仮定します。例えば、次のようなコードを書いたとします：\n\n```tsx\nconst obj = { counter: 0 };\nif (someCondition) {\n  obj.counter = 1;\n}\n```\n\nTypeScriptでは、以前に `0` というフィールド値があり、その後に `1` を割り当てることが間違っているとは想定されません。別の説として、 `obj.counter` は `0` ではなく `number` 属性を持つ必要があります。これは、タイプが*読み取り*および*書き込み*動作を決定するためです。\n\nこれは、文字列にも当てはまります：\n\n```tsx\nfunction handleRequest(url: string, method: \"GET\" | \"POST\" | \"GUESS\") {\n  // ...\n}\n\nconst req = { url: \"https://example.com\", method: \"GET\" };\nhandleRequest(req.url, req.method);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/hmLQKWoi4kVtBFD.png\" alt=\"image-20211114105814002\" style=\"zoom:50%;\" />\n\n上の例 `req.method` では `string` と推定され、 `\"GET\"` ではない。コードは `req` の作成と呼び出しの間で評価されるため、TypeScriptではこのコードにエラーがあると考えられます。\n\nこの問題を解決するには2つの方法があります。\n\n**1. 任意の場所に型アサーションを追加することで、投機を変更できます：**\n\n```tsx\n// 方案 1:\nconst req = { url: \"https://example.com\", method: \"GET\" as \"GET\" };\n// 方案 2\nhandleRequest(req.url, req.method as \"GET\");\n```\n\nシナリオ1では、「 `req.method` は常に*テキストの種類* `\"GET\"` を所有するようにします。これにより、後でこのフィールドに `\"GUESS\"` が割り当てられないようにします。\n\n案2は、「他の原因 `req.method` が `\"GET\"` の値を持つことを知っている」という意味である。\n\n**2. `as const` を使用して、オブジェクト全体を型リテラルに変換できます。**\n\n```tsx\nconst req = { url: \"https://example.com\", method: \"GET\" } as const;\nhandleRequest(req.url, req.method);\n```\n\nこの接尾辞 `as const` は、 `const` のように定義され、より一般的な `string` や `number` ではなく、すべての属性にテキスト型が割り当てられることを保証します。\n\n## 3.12 `null` および `undefined`\n\nJavaScriptには、存在しないか初期化されていない値を表す2つの元の値があります。 `null` と `undefined` です。\n\nTypeScriptには、2つの同じ名前があります*タイプ*。これらのタイプの動作は、[ `strictNullChecks`]（https://www.typescriptlang.org/tsconfig#strictNullChecks）オプションを設定しているかどうかによって異なります。\n\n- `strictNullChecks` オフ\n\n*false*を使用すると、の値は通常どおりにアクセスでき、どのタイプの属性にも値を割り当てることができます。これは、空のチェックがない言語(C#、Javaなど)の動作に似ています。これらの値のチェックが不足していることが、多くの場合、誤りの主要な原因である。もし彼らのコードベースでそれが可能であれば、私たちはいつもそれを開くことをお勧めします。\n\n- `strictNullChecks` オープン\n\n*true*では、メソッドまたはプロパティを使用する前に値をテストする必要があります。オプション属性を使用する前と同様に、*縮小*を使用して、可能な値を確認できます：\n\n```tsx\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    //何かをする\n  } else {\n    console.log(\"Hello, \" + x.toUpperCase());\n  }\n}\n```\n\n- 空でないアサーション演算子( `!` 接尾辞)\n\nTypeScriptには特殊な構文 `null`、 `undefined` もあり、明示的なチェックを行わずにタイプを削除したり、タイプから削除したりすることができます。 `!` 式の後に書き込むことは、実際には型のアサーションです。つまり、値は `null` or `undefined` ではありません：\n\n```tsx\nfunction liveDangerously(x?: number | null) {\n  // 正解\n  console.log(x!.toFixed());\n}\n```\n\n他の型のアサーションと同様に、これはコードの実行時動作を変更しません。したがって、 `!` は、*できない*が `null` または `undefined` であることがわかっている場合にのみ使用することが重要です。\n\n## 3.13列挙\n\n列挙は、TypeScriptがJavaScriptに追加する機能で、名前付き定数の可能なセットの1つである可能性のある値を記述できます。ほとんどのTypeScript機能とは異なり、この*いいえ*JavaScriptの型レベルの追加は、言語とランタイムのコンテンツに追加されます。したがって、列挙が何かをしている必要があることを確認してください。そうでない場合は使用しないでください。列挙の詳細については、[Enum 参考页 中](https://www.typescriptlang.org/docs/handbook/enums.html)を参照してください。\n\n```tsx\n// ts ソースコード\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\nconsole.log(Direction.Up); // 1\n// コンパイルされたjsコード\n(\"use strict\");\nvar Direction;\n(function (Direction) {\n  Direction[(Direction[\"Up\"] = 1)] = \"Up\";\n  Direction[(Direction[\"Down\"] = 2)] = \"Down\";\n  Direction[(Direction[\"Left\"] = 3)] = \"Left\";\n  Direction[(Direction[\"Right\"] = 4)] = \"Right\";\n})(Direction || (Direction = {}));\nconsole.log(Direction.Up);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/dvthyFIPKAuBR1s.png\" alt=\"image-20211114112554381\" style=\"zoom:33%;\" />\n\n## 3.14あまり一般的ではない原語\n\n特に、JavaScriptの新しいプリミティブのいくつかは、TypeScriptタイプのシステムでも実装されています。まず簡単に2つの例を見てみましょう：\n\n- #### `bigint`\n\nES2020以降、JavaScriptには、非常に大きな整数のプリミティブ `BigInt` があります。\n\n```tsx\n// bigint 関数を使用して bigint を作成する\nconst oneHundred: bigint = BigInt(100);\n\n// テキスト構文を使用して BigInt を作成する\nconst anotherHundred: bigint = 100n;\n```\n\nBigIntの詳細については[TypeScript 3.2リリースノート](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint)を参照してください。\n\n- #### `symbol`\n\nJavaScriptには、関数からグローバル一意参照を作成するためのプリミティブ `Symbol()` があります：\n\n```tsx\nconst firstName = Symbol(\"name\");\nconst secondName = Symbol(\"name\");\n\nif (firstName === secondName) {\n  // ここのコードは実行できません\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/ORATaxUgEjrPL9V.png\" alt=\"image-20211114113536948\" style=\"zoom:40%;\" />\n\nタイプ `typeof firstName` と `typeof secondName` は重複していないので、この条件は常に `false` を返します。\n\n### 特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。\n",
        "source": "_posts/日本語/TypeScript/1-3、基本：TypeScriptのよくある種類.md",
        "raw": "---\ntitle: 1-3、TypeScriptのよくある種類\ntoc: true\ncategories:\n  - 日本語\n  - TypeScript\ntags:\n  - フロントエンド\n  - TypeScript\nabbrlink: 17422\ndate: 2024-02-14 22:05:56\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 三、よく使われるタイプ\n\nこの章では、JavaScriptコードで最も一般的な値の型をいくつか紹介し、これらの型をTypeScriptで説明するための適切な方法について説明します。これは詳細なリストではありませんが、今後の章では、他の種類の名前を付けて使用するためのより多くの方法について説明します。\n\nタイプは、タイプコメントだけでなく、他の*地方、*にも表示されます。型自体を理解すると、新しい構造を形成するためにそれらの型を参照できる場所についても理解していきます。\n\n最初に、JavaScriptまたはTypeScriptコードを書くときに遭遇するであろう最も基本的で一般的な型を見てみましょう。これは、より複雑な型を形成するコア構成要素です。\n\n## 3.0 TypeScript設定ファイル\n\n学習を容易にするために、コマンドラインの引数を別の構成ファイルに保存し、 `tsc` を適用して構成ファイルを生成します：\n\n<img src=\"https://s2.loli.net/2022/02/22/1dAfz2imrs3CMbL.png\" alt=\"image-20211113170722654\" style=\"zoom: 50%;\"/>\n\n構成ファイル `tsconfig.json` がプロジェクトのルートディレクトリに構築されました。ここでは、独自の構成について説明します：\n\n```json\n{\n  \"compilerOptions\": {\n    /* Language and Environment */\n    \"target\": \"es6\",\n    /* Modules */\n    \"rootDir\": \"./src\",\n    /* Emit */\n    \"outDir\": \"./dist\",\n    /* Type Checking */\n    \"strict\": true\n  }\n}\n```\n\n## 3.1プリミティブ型 `string`, `number`,および `boolean`\n\nJavaScriptには3つの非常に一般的な[原语](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)があります。 `string`、 `number`、および `boolean` です。TypeScriptには、それぞれに対応するタイプがあります。これらの名前は、JavaScriptアプリケーション `typeof` で返された型の名前と同じであることがわかりました：\n\n- `string` は、 `\"Hello, world\"` のような文字列値を表します。\n- `number` は、 `42` などの数値を表します。JavaScriptには特別な整数ランタイム値がないので、 `int` または `float` 型と等価ではありません。すべては `number` のみです。\n- `boolean` 2つの値のみ `true` と `false`\n\n> 型名 `String`, `Number`,および `Boolean` (大文字で始まる)は合法ですが、コードにはあまり表示されない特殊な組み込み型を指します。タイプの場合、*始終*は `string`, `number`,または `boolean` を使用します。\n\n```js\nlet str: string = 'hello typescript'\nlet num: number = 100\nlet bool: boolean = true\n```\n\n## 3.2配列\n\n配列は、 `[1, 2, 3]` データのように指定された形であり、構文 `number[]` を使用して定義できます;この構文は、任意の型(たとえば、 `string[]`、文字列配列など)に適用されます。\n\n`Array<number>` と書くこともできます。 `T<U>` この構文については、*はんぷくがた*を参照してください。\n\n**02-everyday-types/src/02-array.ts**\n\n```ts\nlet arr: number[] = [1, 2, 3];\nlet arr2: Array<number> = [1, 2, 3];\n```\n\n## 3.3 any\n\nTypeScriptには特殊な型 `any` もあり、特定の値で型チェックエラーが発生したくない場合に使用できます。\n\n値の型が `any` の場合は、その属性にアクセスし、どの型の値にもそれを割り当てることができます。その他のほとんどの構文的なものは、正当なものとなります：\n\n```tsx\nlet obj: any = { x: 0 };\n// 次のコード行はいずれもコンパイラ エラーをスローしません。\n// 「any」を使用すると、それ以降の型チェックがすべて無効になります\nobj.foo();\nobj();\nobj.bar = 100;\nobj = \"hello\";\nconst n: number = obj;\n```\n\nただし、実行環境でコードを実行すると、エラーになることがあります：\n\n<img src=\"/img/TypeScript/03-02.png\" alt=\"image-20211113182543401\" style=\"zoom:50%;\" />\n\n`dist` ディレクトリに移動し、node環境でコードを実行しましたが、やはりエラーが発生しました。\n\n`any` 型は、TypeScriptが特定のコード行が大丈夫であることを確信するためだけに、長い型を書きたくない場合に便利です。\n\n- **noImplicitAny**\n\n型が指定されておらず、TypeScriptがコンテキストから推測できない場合、コンパイラは通常、デフォルトで `any` に設定されます。\n\nただし、 `any` は型チェックを行わないので、このような状況は避けたいのが一般的です。コンパイラフラグ[ `noImplicitAny`]（https://www.typescriptlang.org/tsconfig#noImplicitAny）を使用して、暗黙的なフラグ `any` をエラーにします。この構成は前にも述べました。\n\n## 3.4変数の型コメント\n\n`const`, `var`,または `let` を使用して変数を宣言する場合は、型コメントを追加して変数の型を明示的に指定できます：\n\n```ts\nlet myName: string = \"Felixlu\";\n```\n\n> TypeScriptは「左の型」スタイルの宣言を使用しません。たとえば、 `int x = 0;` 型注釈は常に*在る*入力されたもの*後*です。\n\nしかし、ほとんどの場合、これは必須ではありません。可能な限り、TypeScriptは自動*推論*コード内の型を試します。たとえば、変数の型は、その初期化子の型から推測されます：\n\n```tsx\n// 型定義は必要ありません -- 「myName」は「string」型であると推論されます\nlet myName = \"Felixlu\";\n```\n\n多くの場合、推論規則を明示的に学習する必要はない。始めたばかりの方は、思ったよりも少ないタイプの注釈を使ってみてください。驚くかもしれませんが、TypeScriptは何が起こっているかを完全に理解しています。\n\n## 3.5関数\n\n関数は、JavaScriptでデータを渡す主要な方法です。TypeScriptを使用すると、関数の入力値と出力値のタイプを指定できます。\n\n- パラメータタイプの注記\n\n関数を宣言するときは、各引数の後に型注記を追加して、関数が受け入れる引数の型を宣言できます。パラメータタイプの注記は、パラメータ名の後に表示されます：\n\n```tsx\n// パラメータの型の定義\nfunction greet(name: string) {\n  console.log(\"Hello, \" + name.toUpperCase() + \"!!\");\n}\n```\n\nパラメータに型コメントがある場合、関数のパラメータがチェックされます：\n\n```tsx\n// 実行すると実行時エラーになります。\ngreet(42);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/SR9okXs1ez7ThC6.png\" alt=\"image-20211114072314780\" style=\"zoom: 50%;\" />\n\n> パラメータに型コメントがない場合でも、正しい数のパラメータが渡されているかどうかがチェックされます。\n\n- 戻り値型コメント\n\n返り型コメントを追加することもできます。戻り値の型に関するコメントは、引数リストの後に表示されます：\n\n```tsx\nfunction getFavoriteNumber(): number {\n  return 26;\n}\n```\n\nTypeScriptは関数の戻り値の型を `return` ステートメントに基づいて推定するので、変数型コメントと同様に、戻り値型コメントは通常必要ありません。上記の例のタイプ注釈は何も変わりません。一部のコードベースでは、意図しない変更や個人的な好みを防ぐために、マニュアル用に戻り値の型を明示的に指定しています。\n\n- 匿名関数\n\n匿名関数は関数宣言とは少し異なります。TypeScriptがどのように呼び出されるかを判断できる場所に関数が現れると、その関数の引数によって自動的に型が指定されます。\n\n次に例を示します：\n\n```tsx\n// ここには型の注釈はありませんが、TypeScript はエラーをキャッチできます。\nconst names = [\"Alice\", \"Bob\", \"Eve\"];\n\n// 関数コンテキスト型\nnames.forEach(function (s) {\n  console.log(s.toUppercase());\n});\n\n// コンテキストタイプはアロー関数でも機能します\nnames.forEach((s) => {\n  console.log(s.toUppercase());\n});\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qMkb8YQzxUw2Xnc.png\" alt=\"image-20211114073444596\" style=\"zoom:50%;\" />\n\nパラメータ `s` に型コメントがない場合でも、TypeScriptは `forEach` 関数の型と配列の推定型を使用して `s` の型を決定します。\n\nこのプロセスは*を選択して、*と呼ばれ、関数が発生する*コンテキスト*は、その関数がどのような型を持つべきかを通知するためです。\n\n推論規則と同様に、これがどのように起こるのかを明確に理解する必要はありませんが、そのメカニズム*確かに*を理解することで、型注釈が必要ないときに注意を払うことができます。あとで、*値が表示されるコンテキスト*がその型にどのように影響するかについて、さらに例を示します。\n\n## 3.6オブジェクトタイプ\n\n`string`, `number`, `boolean` 型(プリミティブ型とも呼ばれる)のほかに、最も一般的な型は*オブジェクトタイプ*です。これは、ほとんどすべてのプロパティを持つJavaScript値を指します！オブジェクトタイプを定義するには、その属性とそのタイプをリストします。\n\nたとえば、点状のオブジェクトを受け取る関数です：\n\n```tsx\n// パラメータの型アノテーションがオブジェクト型である\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"座標のx値： \" + pt.x);\n  console.log(\"座標のy値： \" + pt.y);\n}\nprintCoord({ x: 3, y: 7 });\n```\n\nここでは、2つの属性( `x` および `y`)を持つタイプ注釈パラメータを使用します。どちらも `number` タイプです。属性は、 `,` または `;` を使用して区切ることができます。最後の区切り文字はオプションです。\n\n各プロパティのタイプ部分もオプションです。型を指定しない場合は、 `any` とみなされます。\n\n- オプション属性\n\nオブジェクトタイプでは、プロパティの一部またはすべてが*オプション*であることも指定できます。これを行うには、属性名の後に `?` を追加します。\n\n**02-everyday-types/src/05-object.ts**\n\n```tsx\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// どちらの方法でパラメータを渡しても問題ありません\nprintName({ first: \"Felix\" });\nprintName({ first: \"Felix\", last: \"Lu\" });\n```\n\nJavaScriptでは、存在しないプロパティーにアクセスすると、実行時エラーではなく `undefined` の値が取得されます。したがって、オプション属性*読み取り*を使用する場合は、その属性を使用する前に `undefined` でチェックする必要があります。\n\n```tsx\nfunction printName(obj: { first: string; last?: string }) {\n  // × -「obj.last」が存在しない可能性があります。\n  console.log(obj.last.toUpperCase());\n\n  if (obj.last !== undefined) {\n    // √\n    console.log(obj.last.toUpperCase());\n  }\n\n  // 最新の JavaScript 構文を使用した安全な代替手段:\n  console.log(obj.last?.toUpperCase());\n}\n```\n\n## 3.7統合タイプ\n\nTypeScriptの型システムでは、複数の演算子を使用して既存の型から新しい型を構築できます。いくつかのタイプを書く方法がわかったので、それを面白おかしく*くみあわせ*始める時が来ました。\n\n- 連合タイプの定義\n\n型を結合する最初の方法は、*連合*型です。結合型は、2つ以上の他の型からなる型であり、これらの型の*いずれか*の値である可能性があることを示します。これらの各タイプを*結合タイプのメンバー*と呼びます。\n\n文字列または数値を操作する関数を作成します：\n\n```tsx\nfunction printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// √\nprintId(101);\n// √\nprintId(\"202\");\n// ×\nprintId({ myID: 22342 });\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qkOvn9DrVdCRSBc.png\" alt=\"image-20211114081646215\" style=\"zoom:50%;\" />\n\n- 結合タイプの使用\n\n*提供*結合タイプの値を一致させるのは簡単です。結合メンバーのタイプを指定するだけで済みます。もしあなたが*ある*結合型の値を持っていたら、どのようにそれを使いますか？\n\n連合の*それぞれ*メンバーがすべて有効であれば、TypeScriptは連合を使って何かをすることだけを許可します。たとえば、結合型 `string | number` がある場合、 `string` のように1つの型の操作のみを使用することはできません。\n\n```tsx\nfunction printId(id: number | string) {\n  console.log(id.toUpperCase());\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/TnuapbGVlOE2BYw.png\" alt=\"image-20211114085508715\" style=\"zoom:50%;\" />\n\n解決策は、型注釈のないJavaScriptと同様に、コード*縮小*を使用して結合することです。*縮小*は、TypeScriptがコード構造に基づいて値のより具体的な型を推定できる場合に発生します。\n\nたとえば、TypeScriptは、1つの `string` の値だけが `typeof` の値 `\"string\"` を持つことを知っています：\n\n```tsx\nfunction printId(id: number | string) {\n  if (typeof id === \"string\") {\n    // このブランチでは、ID のタイプ “string”\n    console.log(id.toUpperCase());\n  } else {\n    // ここでのIDの種類 “number”\n    console.log(id);\n  }\n}\n```\n\n別の例として、次の関数 `Array.isArray` を使用します。\n\n```tsx\nfunction welcomePeople(x: string[] | string) {\n  if (Array.isArray(x)) {\n    // ここ:「x」のタイプ 'string[]'\n    console.log(\"Hello, \" + x.join(\" and \"));\n  } else {\n    // ここ:「x」のタイプ 'string'\n    console.log(\"Welcome lone traveler \" + x);\n  }\n}\n```\n\n`else` ブランチでは特別なことをする必要はありません。 `x` が `string[]` でなければ、 `string` になります。\n\n時には `union` を持ち、メンバー全員に共通点があることもあります。たとえば、配列と文字列の両方に `slice` メソッドがあります。連合内の各メンバーに共通のプロパティがある場合は、そのプロパティを絞り込むことなく使用できます：\n\n```tsx\n// 戻り値の型は、number[] | string として推論されます。\nfunction getFirstThree(x: number[] | string) {\n  return x.slice(0, 3);\n}\n```\n\n## 3.8型エイリアス\n\nオブジェクト型と結合型は、型注釈に直接記述することで使用してきました。これは便利ですが、同じ型を何度も使い、名前を付けて参照したいというのはよくあります。\n\n*型エイリアス*は、任意の*タイプ*に対する*名前*の定義です。型エイリアスの構文は次のとおりです：\n\n```tsx\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// 前の例とまったく同じ\nfunction printCoord(pt: Point) {\n  console.log(\"座標 x の値： \" + pt.x);\n  console.log(\"座標 y の値： \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\n実際には、オブジェクトタイプだけでなく、タイプエイリアスを使用して任意のタイプに名前を付けることができます。たとえば、型エイリアスは連合型に名前を付けることができます：\n\n```tsx\ntype ID = number | string;\n```\n\nエイリアス*ただ*エイリアス-タイプエイリアスを使用して、同じタイプの異なる「バージョン」を作成することはできません。エイリアスを使うときは、エイリアスの型を書いたのと同じです。言い換えれば、このコード*そうは見えない*は有効かもしれませんが、TypeScriptに基づいて可能です。どちらのタイプも同じエイリアスなので、次のようになります：\n\n```tsx\ntype UserInputSanitizedString = string;\n\nfunction sanitizeInput(str: string): UserInputSanitizedString {\n  return str.slice(0, 2);\n}\n\n// サニタイズされた入力を作成する\nlet userInput = sanitizeInput(\"hello\");\n\n// ただし、文字列を使用して値を再割り当てすることは可能です\nuserInput = \"new input\";\n```\n\n## 3.9コネクタ\n\n*インタフェース宣言*は、オブジェクトタイプに名前を付ける別の方法です：\n\n```tsx\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printCoord(pt: Point) {\n  console.log(\"座標 x の値： \" + pt.x);\n  console.log(\"座標 y の値： \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\n上記でタイプエイリアスを使用した場合と同様に、この例は匿名オブジェクトタイプを使用した場合と同様に動作します。TypeScriptは、渡された値の*構造* `printCoord` だけを対象とします。これは、期待されるプロパティがあるかどうかだけを対象とします。型の構造と機能のみに注目することが、TypeScriptを*構造型*型システムと呼ぶ理由である。\n\n- 型エイリアスとインタフェースの違い\n\n型エイリアスとインタフェースは非常によく似ており、多くの場合、自由に選択することができます。ほとんどすべての機能が `interface` `type` で使用できます。主な違いは、新しいタイプの拡張方法です：\n\n```tsx\n// 拡張ポート\ninterface Animal {\n  name: string;\n}\n\ninterface Bear extends Animal {\n  honey: boolean;\n}\n\nconst bear: Bear = {\n  name: \"winnie\",\n  honey: true,\n};\nbear.name;\nbear.honey;\n// 交差点ごとにタイプを展開\ntype Animal = {\n  name: string;\n};\n\ntype Bear = Animal & {\n  honey: boolean;\n};\n\nconst bear: Bear = {\n  name: \"winnie\",\n  honey: true,\n};\nbear.name;\nbear.honey;\n// 既存のインターフェースに新しいフィールドを追加する\ninterface MyWindow {\n  title: string;\n}\n\ninterface MyWindow {\n  count: number;\n}\n\nconst w: MyWindow = {\n  title: \"hello ts\",\n  count: 100,\n};\n// 作成後にタイプを変更することはできません。\ntype MyWindow = {\n  title: string;\n};\n\ntype MyWindow = {\n  count: number;\n};\n```\n\n<img src=\"/img/TypeScript/03-07.png\" alt=\"image-20211114094240585\" style=\"zoom:50%;\" />\n\n> - TypeScriptバージョン4.2より前のバージョンでは、型エイリアス[*エラー・メッセージに*が表示される可能性があります](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA)は、同等の匿名型の代わりに使用されることがありました(これは望ましい場合と望ましくない場合があります)。インタフェースには常にエラーメッセージ内の名前が付けられます。\n> - 型エイリアスは[声明合并，但接口可以](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA)に関係しない可能性があります。\n> - インタフェースは[オブジェクトの形状を宣言します。プリミティブの名前は変更できません](https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA)でのみ使用できます。\n> - インタフェース名は[*常に*元の形式で](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA)エラーメッセージに表示されますが、名前で使用されている場合は*のみ*。\n>\n> ほとんどの場合、好みに合わせて選ぶことができますが、TypeScriptは別の種類の宣言が必要かどうかを教えてくれます。ヒューリスティックを使用する場合は、 `interface` を使用し、必要に応じて `type` を使用します。\n\n## 3.10型アサーション\n\nTypeScriptが知らない値の種類に関する情報が得られることがあります。\n\nたとえば、 `document.getElementById` を使用している場合、TypeScriptはこれが*ある種*型の `HTMLElement` を返すことだけを知っていますが、ページが常に `HTMLCanvasElement` 指定されたIDの値を持つことを知っているかもしれません。\n\nこの場合、*タイプアサーション*を使用して、より具体的な型を指定できます：\n\n```tsx\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;\n```\n\n型コメントと同様に、型アサーションはコンパイラによって削除され、コードの実行時動作には影響しません。\n\n山括弧構文も使用できます( `.tsx` ファイルにコードが含まれていない場合)。これは同等です：\n\n```tsx\nconst myCanvas = <HTMLCanvasElement>document.getElementById(\"main_canvas\");\n```\n\n> 注意：型アサーションはコンパイル時に削除されるため、型アサーションに関連付けられた実行時チェックはありません。 `null` 型アサーションが間違っている場合、例外は発生しません。\n\nTypeScriptでは、型アサーションは*より具体的な*または*あまり具体的ではない*の型バージョンにのみ変換できます。このルールは、次のような「不可能」の強制を防止します：\n\n```tsx\nconst x = \"hello\" as number;\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qNWktG6hBmzVZaC.png\" alt=\"image-20211114095324614\" style=\"zoom:50%;\" />\n\n型 `string` を型 `number` に変換すると、両方の型が十分に重複していないため、正しく変換されない可能性があります。意図的な場合は、式を `any` または `unknown` ( `unknown` (後述)に変換してから、必要な型を指定します：\n\n```tsx\nconst x = \"hello\" as unknown as number;\n```\n\n## 3.11文字タイプ\n\n一般的な型 `string` および `number` に加えて、型の位置で*特定の*文字列および数値を参照できます。\n\n1つの方法は、JavaScriptがどのようにさまざまな方法で変数を宣言するかを検討することです。 `var` と `let` のどちらも、変数に保存されているコンテンツの変更を許可します。 `const` は許可しません。これは、TypeScriptがテキストの型を作成する方法に反映されています。\n\n```tsx\nlet testString = \"Hello World\";\ntestString = \"Olá Mundo\";\n\n//'testString'あらゆる文字列を表すことができますが、TypeScript ではそれを型システムでどのように記述するのでしょうか?\ntestString;\n\nconst constantString = \"Hello World\";\n//「constantString」は 1 つの可能な文字列のみを表すことができるため、\n//テキスト型表現がある\nconstantString;\n```\n\nリテラルタイプは、それ自体にはあまり価値がありません：\n\n```tsx\nlet x: \"hello\" = \"hello\";\n// √\nx = \"hello\";\n// ×\nx = \"howdy\";\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/kcOHJ74TKSvuq1h.png\" alt=\"image-20211114102648519\" style=\"zoom:50%;\" />\n\n1つの値しか持たない変数を持っていても、あまり役に立ちません！\n\nしかし、*将*リテラル*くみあわせ*を結合することで、より有用な概念を表すことができます。たとえば、特定の既知の値のセットだけを受け入れる関数などです：\n\n```tsx\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  // ...\n}\nprintText(\"Hello, world\", \"left\");\nprintText(\"G'day, mate\", \"centre\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/SrcPeBsQvOUkDfw.png\" alt=\"image-20211114103049870\" style=\"zoom:50%;\" />\n\n数値リテラル型も同様に機能します：\n\n```tsx\nfunction compare(a: string, b: string): -1 | 0 | 1 {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n```\n\nもちろん、これらをリテラル以外のタイプと組み合わせて使用することもできます：\n\n```tsx\ninterface Options {\n  width: number;\n}\nfunction configure(x: Options | \"auto\") {\n  // ...\n}\nconfigure({ width: 100 });\nconfigure(\"auto\");\nconfigure(\"automatic\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/YZQwUvRlCtkzcTL.png\" alt=\"image-20211114103530209\" style=\"zoom:50%;\" />\n\nBoolean型の文字もあります。booleanリテラルには、型 `true` と `false` の2種類しかありません。型 `boolean` 自体は、実際には結合型 `union` のエイリアス `true | false` にすぎません。\n\n- 文字推論\n\nオブジェクトを使用して変数を初期化する場合、TypeScriptはそのオブジェクトのプロパティの値が後で変更される可能性があると仮定します。例えば、次のようなコードを書いたとします：\n\n```tsx\nconst obj = { counter: 0 };\nif (someCondition) {\n  obj.counter = 1;\n}\n```\n\nTypeScriptでは、以前に `0` というフィールド値があり、その後に `1` を割り当てることが間違っているとは想定されません。別の説として、 `obj.counter` は `0` ではなく `number` 属性を持つ必要があります。これは、タイプが*読み取り*および*書き込み*動作を決定するためです。\n\nこれは、文字列にも当てはまります：\n\n```tsx\nfunction handleRequest(url: string, method: \"GET\" | \"POST\" | \"GUESS\") {\n  // ...\n}\n\nconst req = { url: \"https://example.com\", method: \"GET\" };\nhandleRequest(req.url, req.method);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/hmLQKWoi4kVtBFD.png\" alt=\"image-20211114105814002\" style=\"zoom:50%;\" />\n\n上の例 `req.method` では `string` と推定され、 `\"GET\"` ではない。コードは `req` の作成と呼び出しの間で評価されるため、TypeScriptではこのコードにエラーがあると考えられます。\n\nこの問題を解決するには2つの方法があります。\n\n**1. 任意の場所に型アサーションを追加することで、投機を変更できます：**\n\n```tsx\n// 方案 1:\nconst req = { url: \"https://example.com\", method: \"GET\" as \"GET\" };\n// 方案 2\nhandleRequest(req.url, req.method as \"GET\");\n```\n\nシナリオ1では、「 `req.method` は常に*テキストの種類* `\"GET\"` を所有するようにします。これにより、後でこのフィールドに `\"GUESS\"` が割り当てられないようにします。\n\n案2は、「他の原因 `req.method` が `\"GET\"` の値を持つことを知っている」という意味である。\n\n**2. `as const` を使用して、オブジェクト全体を型リテラルに変換できます。**\n\n```tsx\nconst req = { url: \"https://example.com\", method: \"GET\" } as const;\nhandleRequest(req.url, req.method);\n```\n\nこの接尾辞 `as const` は、 `const` のように定義され、より一般的な `string` や `number` ではなく、すべての属性にテキスト型が割り当てられることを保証します。\n\n## 3.12 `null` および `undefined`\n\nJavaScriptには、存在しないか初期化されていない値を表す2つの元の値があります。 `null` と `undefined` です。\n\nTypeScriptには、2つの同じ名前があります*タイプ*。これらのタイプの動作は、[ `strictNullChecks`]（https://www.typescriptlang.org/tsconfig#strictNullChecks）オプションを設定しているかどうかによって異なります。\n\n- `strictNullChecks` オフ\n\n*false*を使用すると、の値は通常どおりにアクセスでき、どのタイプの属性にも値を割り当てることができます。これは、空のチェックがない言語(C#、Javaなど)の動作に似ています。これらの値のチェックが不足していることが、多くの場合、誤りの主要な原因である。もし彼らのコードベースでそれが可能であれば、私たちはいつもそれを開くことをお勧めします。\n\n- `strictNullChecks` オープン\n\n*true*では、メソッドまたはプロパティを使用する前に値をテストする必要があります。オプション属性を使用する前と同様に、*縮小*を使用して、可能な値を確認できます：\n\n```tsx\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    //何かをする\n  } else {\n    console.log(\"Hello, \" + x.toUpperCase());\n  }\n}\n```\n\n- 空でないアサーション演算子( `!` 接尾辞)\n\nTypeScriptには特殊な構文 `null`、 `undefined` もあり、明示的なチェックを行わずにタイプを削除したり、タイプから削除したりすることができます。 `!` 式の後に書き込むことは、実際には型のアサーションです。つまり、値は `null` or `undefined` ではありません：\n\n```tsx\nfunction liveDangerously(x?: number | null) {\n  // 正解\n  console.log(x!.toFixed());\n}\n```\n\n他の型のアサーションと同様に、これはコードの実行時動作を変更しません。したがって、 `!` は、*できない*が `null` または `undefined` であることがわかっている場合にのみ使用することが重要です。\n\n## 3.13列挙\n\n列挙は、TypeScriptがJavaScriptに追加する機能で、名前付き定数の可能なセットの1つである可能性のある値を記述できます。ほとんどのTypeScript機能とは異なり、この*いいえ*JavaScriptの型レベルの追加は、言語とランタイムのコンテンツに追加されます。したがって、列挙が何かをしている必要があることを確認してください。そうでない場合は使用しないでください。列挙の詳細については、[Enum 参考页 中](https://www.typescriptlang.org/docs/handbook/enums.html)を参照してください。\n\n```tsx\n// ts ソースコード\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\nconsole.log(Direction.Up); // 1\n// コンパイルされたjsコード\n(\"use strict\");\nvar Direction;\n(function (Direction) {\n  Direction[(Direction[\"Up\"] = 1)] = \"Up\";\n  Direction[(Direction[\"Down\"] = 2)] = \"Down\";\n  Direction[(Direction[\"Left\"] = 3)] = \"Left\";\n  Direction[(Direction[\"Right\"] = 4)] = \"Right\";\n})(Direction || (Direction = {}));\nconsole.log(Direction.Up);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/dvthyFIPKAuBR1s.png\" alt=\"image-20211114112554381\" style=\"zoom:33%;\" />\n\n## 3.14あまり一般的ではない原語\n\n特に、JavaScriptの新しいプリミティブのいくつかは、TypeScriptタイプのシステムでも実装されています。まず簡単に2つの例を見てみましょう：\n\n- #### `bigint`\n\nES2020以降、JavaScriptには、非常に大きな整数のプリミティブ `BigInt` があります。\n\n```tsx\n// bigint 関数を使用して bigint を作成する\nconst oneHundred: bigint = BigInt(100);\n\n// テキスト構文を使用して BigInt を作成する\nconst anotherHundred: bigint = 100n;\n```\n\nBigIntの詳細については[TypeScript 3.2リリースノート](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint)を参照してください。\n\n- #### `symbol`\n\nJavaScriptには、関数からグローバル一意参照を作成するためのプリミティブ `Symbol()` があります：\n\n```tsx\nconst firstName = Symbol(\"name\");\nconst secondName = Symbol(\"name\");\n\nif (firstName === secondName) {\n  // ここのコードは実行できません\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/ORATaxUgEjrPL9V.png\" alt=\"image-20211114113536948\" style=\"zoom:40%;\" />\n\nタイプ `typeof firstName` と `typeof secondName` は重複していないので、この条件は常に `false` を返します。\n\n### 特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。\n",
        "slug": "日本語/TypeScript/1-3、基本：TypeScriptのよくある種類",
        "published": 1,
        "updated": "2024-02-15T08:02:08.453Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjany000894v3c4n6f43f",
        "content": "<h1 id=\"三、よく使われるタイプ\"><a href=\"#三、よく使われるタイプ\" class=\"headerlink\" title=\"三、よく使われるタイプ\"></a>三、よく使われるタイプ</h1><p>この章では、JavaScriptコードで最も一般的な値の型をいくつか紹介し、これらの型をTypeScriptで説明するための適切な方法について説明します。これは詳細なリストではありませんが、今後の章では、他の種類の名前を付けて使用するためのより多くの方法について説明します。</p>\n<p>タイプは、タイプコメントだけでなく、他の<em>地方、</em>にも表示されます。型自体を理解すると、新しい構造を形成するためにそれらの型を参照できる場所についても理解していきます。</p>\n<p>最初に、JavaScriptまたはTypeScriptコードを書くときに遭遇するであろう最も基本的で一般的な型を見てみましょう。これは、より複雑な型を形成するコア構成要素です。</p>\n<h2 id=\"3-0-TypeScript設定ファイル\"><a href=\"#3-0-TypeScript設定ファイル\" class=\"headerlink\" title=\"3.0 TypeScript設定ファイル\"></a>3.0 TypeScript設定ファイル</h2><p>学習を容易にするために、コマンドラインの引数を別の構成ファイルに保存し、 <code>tsc</code> を適用して構成ファイルを生成します：</p>\n<img src=\"https://s2.loli.net/2022/02/22/1dAfz2imrs3CMbL.png\" alt=\"image-20211113170722654\" style=\"zoom: 50%;\"/>\n\n<p>構成ファイル <code>tsconfig.json</code> がプロジェクトのルートディレクトリに構築されました。ここでは、独自の構成について説明します：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Language and Environment */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Modules */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./src&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Emit */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Type Checking */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;strict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-1プリミティブ型-string-number-および-boolean\"><a href=\"#3-1プリミティブ型-string-number-および-boolean\" class=\"headerlink\" title=\"3.1プリミティブ型 string, number,および boolean\"></a>3.1プリミティブ型 <code>string</code>, <code>number</code>,および <code>boolean</code></h2><p>JavaScriptには3つの非常に一般的な<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">原语</a>があります。 <code>string</code>、 <code>number</code>、および <code>boolean</code> です。TypeScriptには、それぞれに対応するタイプがあります。これらの名前は、JavaScriptアプリケーション <code>typeof</code> で返された型の名前と同じであることがわかりました：</p>\n<ul>\n<li><code>string</code> は、 <code>&quot;Hello, world&quot;</code> のような文字列値を表します。</li>\n<li><code>number</code> は、 <code>42</code> などの数値を表します。JavaScriptには特別な整数ランタイム値がないので、 <code>int</code> または <code>float</code> 型と等価ではありません。すべては <code>number</code> のみです。</li>\n<li><code>boolean</code> 2つの値のみ <code>true</code> と <code>false</code></li>\n</ul>\n<blockquote>\n<p>型名 <code>String</code>, <code>Number</code>,および <code>Boolean</code> (大文字で始まる)は合法ですが、コードにはあまり表示されない特殊な組み込み型を指します。タイプの場合、<em>始終</em>は <code>string</code>, <code>number</code>,または <code>boolean</code> を使用します。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str</span>: string = <span class=\"string\">&#x27;hello typescript&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">num</span>: number = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">bool</span>: boolean = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2配列\"><a href=\"#3-2配列\" class=\"headerlink\" title=\"3.2配列\"></a>3.2配列</h2><p>配列は、 <code>[1, 2, 3]</code> データのように指定された形であり、構文 <code>number[]</code> を使用して定義できます;この構文は、任意の型(たとえば、 <code>string[]</code>、文字列配列など)に適用されます。</p>\n<p><code>Array&lt;number&gt;</code> と書くこともできます。 <code>T&lt;U&gt;</code> この構文については、<em>はんぷくがた</em>を参照してください。</p>\n<p><strong>02-everyday-types&#x2F;src&#x2F;02-array.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">arr</span>: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">arr2</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-any\"><a href=\"#3-3-any\" class=\"headerlink\" title=\"3.3 any\"></a>3.3 any</h2><p>TypeScriptには特殊な型 <code>any</code> もあり、特定の値で型チェックエラーが発生したくない場合に使用できます。</p>\n<p>値の型が <code>any</code> の場合は、その属性にアクセスし、どの型の値にもそれを割り当てることができます。その他のほとんどの構文的なものは、正当なものとなります：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">obj</span>: <span class=\"built_in\">any</span> = &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 次のコード行はいずれもコンパイラ エラーをスローしません。</span></span><br><span class=\"line\"><span class=\"comment\">// 「any」を使用すると、それ以降の型チェックがすべて無効になります</span></span><br><span class=\"line\">obj.<span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"title function_\">obj</span>();</span><br><span class=\"line\">obj.<span class=\"property\">bar</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\">obj = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">n</span>: <span class=\"built_in\">number</span> = obj;</span><br></pre></td></tr></table></figure>\n\n<p>ただし、実行環境でコードを実行すると、エラーになることがあります：</p>\n<img src=\"/img/TypeScript/03-02.png\" alt=\"image-20211113182543401\" style=\"zoom:50%;\" />\n\n<p><code>dist</code> ディレクトリに移動し、node環境でコードを実行しましたが、やはりエラーが発生しました。</p>\n<p><code>any</code> 型は、TypeScriptが特定のコード行が大丈夫であることを確信するためだけに、長い型を書きたくない場合に便利です。</p>\n<ul>\n<li><strong>noImplicitAny</strong></li>\n</ul>\n<p>型が指定されておらず、TypeScriptがコンテキストから推測できない場合、コンパイラは通常、デフォルトで <code>any</code> に設定されます。</p>\n<p>ただし、 <code>any</code> は型チェックを行わないので、このような状況は避けたいのが一般的です。コンパイラフラグ[ <code>noImplicitAny</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny%EF%BC%89%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%80%81%E6%9A%97%E9%BB%99%E7%9A%84%E3%81%AA%E3%83%95%E3%83%A9%E3%82%B0\">https://www.typescriptlang.org/tsconfig#noImplicitAny）を使用して、暗黙的なフラグ</a> <code>any</code> をエラーにします。この構成は前にも述べました。</p>\n<h2 id=\"3-4変数の型コメント\"><a href=\"#3-4変数の型コメント\" class=\"headerlink\" title=\"3.4変数の型コメント\"></a>3.4変数の型コメント</h2><p><code>const</code>, <code>var</code>,または <code>let</code> を使用して変数を宣言する場合は、型コメントを追加して変数の型を明示的に指定できます：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myName</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;Felixlu&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>TypeScriptは「左の型」スタイルの宣言を使用しません。たとえば、 <code>int x = 0;</code> 型注釈は常に<em>在る</em>入力されたもの<em>後</em>です。</p>\n</blockquote>\n<p>しかし、ほとんどの場合、これは必須ではありません。可能な限り、TypeScriptは自動<em>推論</em>コード内の型を試します。たとえば、変数の型は、その初期化子の型から推測されます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 型定義は必要ありません -- 「myName」は「string」型であると推論されます</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">&quot;Felixlu&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>多くの場合、推論規則を明示的に学習する必要はない。始めたばかりの方は、思ったよりも少ないタイプの注釈を使ってみてください。驚くかもしれませんが、TypeScriptは何が起こっているかを完全に理解しています。</p>\n<h2 id=\"3-5関数\"><a href=\"#3-5関数\" class=\"headerlink\" title=\"3.5関数\"></a>3.5関数</h2><p>関数は、JavaScriptでデータを渡す主要な方法です。TypeScriptを使用すると、関数の入力値と出力値のタイプを指定できます。</p>\n<ul>\n<li>パラメータタイプの注記</li>\n</ul>\n<p>関数を宣言するときは、各引数の後に型注記を追加して、関数が受け入れる引数の型を宣言できます。パラメータタイプの注記は、パラメータ名の後に表示されます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// パラメータの型の定義</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + name.<span class=\"title function_\">toUpperCase</span>() + <span class=\"string\">&quot;!!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>パラメータに型コメントがある場合、関数のパラメータがチェックされます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 実行すると実行時エラーになります。</span></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"number\">42</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/SR9okXs1ez7ThC6.png\" alt=\"image-20211114072314780\" style=\"zoom: 50%;\" />\n\n<blockquote>\n<p>パラメータに型コメントがない場合でも、正しい数のパラメータが渡されているかどうかがチェックされます。</p>\n</blockquote>\n<ul>\n<li>戻り値型コメント</li>\n</ul>\n<p>返り型コメントを追加することもできます。戻り値の型に関するコメントは、引数リストの後に表示されます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFavoriteNumber</span>(<span class=\"params\"></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">26</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScriptは関数の戻り値の型を <code>return</code> ステートメントに基づいて推定するので、変数型コメントと同様に、戻り値型コメントは通常必要ありません。上記の例のタイプ注釈は何も変わりません。一部のコードベースでは、意図しない変更や個人的な好みを防ぐために、マニュアル用に戻り値の型を明示的に指定しています。</p>\n<ul>\n<li>匿名関数</li>\n</ul>\n<p>匿名関数は関数宣言とは少し異なります。TypeScriptがどのように呼び出されるかを判断できる場所に関数が現れると、その関数の引数によって自動的に型が指定されます。</p>\n<p>次に例を示します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ここには型の注釈はありませんが、TypeScript はエラーをキャッチできます。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Eve&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 関数コンテキスト型</span></span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"title function_\">toUppercase</span>());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// コンテキストタイプはアロー関数でも機能します</span></span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"title function_\">toUppercase</span>());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qMkb8YQzxUw2Xnc.png\" alt=\"image-20211114073444596\" style=\"zoom:50%;\" />\n\n<p>パラメータ <code>s</code> に型コメントがない場合でも、TypeScriptは <code>forEach</code> 関数の型と配列の推定型を使用して <code>s</code> の型を決定します。</p>\n<p>このプロセスは<em>を選択して、</em>と呼ばれ、関数が発生する<em>コンテキスト</em>は、その関数がどのような型を持つべきかを通知するためです。</p>\n<p>推論規則と同様に、これがどのように起こるのかを明確に理解する必要はありませんが、そのメカニズム<em>確かに</em>を理解することで、型注釈が必要ないときに注意を払うことができます。あとで、<em>値が表示されるコンテキスト</em>がその型にどのように影響するかについて、さらに例を示します。</p>\n<h2 id=\"3-6オブジェクトタイプ\"><a href=\"#3-6オブジェクトタイプ\" class=\"headerlink\" title=\"3.6オブジェクトタイプ\"></a>3.6オブジェクトタイプ</h2><p><code>string</code>, <code>number</code>, <code>boolean</code> 型(プリミティブ型とも呼ばれる)のほかに、最も一般的な型は<em>オブジェクトタイプ</em>です。これは、ほとんどすべてのプロパティを持つJavaScript値を指します！オブジェクトタイプを定義するには、その属性とそのタイプをリストします。</p>\n<p>たとえば、点状のオブジェクトを受け取る関数です：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// パラメータの型アノテーションがオブジェクト型である</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: &#123; x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標のx値： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標のy値： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">7</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>ここでは、2つの属性( <code>x</code> および <code>y</code>)を持つタイプ注釈パラメータを使用します。どちらも <code>number</code> タイプです。属性は、 <code>,</code> または <code>;</code> を使用して区切ることができます。最後の区切り文字はオプションです。</p>\n<p>各プロパティのタイプ部分もオプションです。型を指定しない場合は、 <code>any</code> とみなされます。</p>\n<ul>\n<li>オプション属性</li>\n</ul>\n<p>オブジェクトタイプでは、プロパティの一部またはすべてが<em>オプション</em>であることも指定できます。これを行うには、属性名の後に <code>?</code> を追加します。</p>\n<p><strong>02-everyday-types&#x2F;src&#x2F;05-object.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printName</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; first: <span class=\"built_in\">string</span>; last?: <span class=\"built_in\">string</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// どちらの方法でパラメータを渡しても問題ありません</span></span><br><span class=\"line\"><span class=\"title function_\">printName</span>(&#123; <span class=\"attr\">first</span>: <span class=\"string\">&quot;Felix&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">printName</span>(&#123; <span class=\"attr\">first</span>: <span class=\"string\">&quot;Felix&quot;</span>, <span class=\"attr\">last</span>: <span class=\"string\">&quot;Lu&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>JavaScriptでは、存在しないプロパティーにアクセスすると、実行時エラーではなく <code>undefined</code> の値が取得されます。したがって、オプション属性<em>読み取り</em>を使用する場合は、その属性を使用する前に <code>undefined</code> でチェックする必要があります。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printName</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; first: <span class=\"built_in\">string</span>; last?: <span class=\"built_in\">string</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// × -「obj.last」が存在しない可能性があります。</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.<span class=\"property\">last</span> !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// √</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 最新の JavaScript 構文を使用した安全な代替手段:</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>?.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7統合タイプ\"><a href=\"#3-7統合タイプ\" class=\"headerlink\" title=\"3.7統合タイプ\"></a>3.7統合タイプ</h2><p>TypeScriptの型システムでは、複数の演算子を使用して既存の型から新しい型を構築できます。いくつかのタイプを書く方法がわかったので、それを面白おかしく<em>くみあわせ</em>始める時が来ました。</p>\n<ul>\n<li>連合タイプの定義</li>\n</ul>\n<p>型を結合する最初の方法は、<em>連合</em>型です。結合型は、2つ以上の他の型からなる型であり、これらの型の<em>いずれか</em>の値である可能性があることを示します。これらの各タイプを<em>結合タイプのメンバー</em>と呼びます。</p>\n<p>文字列または数値を操作する関数を作成します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Your ID is: &quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// √</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(<span class=\"number\">101</span>);</span><br><span class=\"line\"><span class=\"comment\">// √</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(<span class=\"string\">&quot;202&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// ×</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(&#123; <span class=\"attr\">myID</span>: <span class=\"number\">22342</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qkOvn9DrVdCRSBc.png\" alt=\"image-20211114081646215\" style=\"zoom:50%;\" />\n\n<ul>\n<li>結合タイプの使用</li>\n</ul>\n<p><em>提供</em>結合タイプの値を一致させるのは簡単です。結合メンバーのタイプを指定するだけで済みます。もしあなたが<em>ある</em>結合型の値を持っていたら、どのようにそれを使いますか？</p>\n<p>連合の<em>それぞれ</em>メンバーがすべて有効であれば、TypeScriptは連合を使って何かをすることだけを許可します。たとえば、結合型 <code>string | number</code> がある場合、 <code>string</code> のように1つの型の操作のみを使用することはできません。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/TnuapbGVlOE2BYw.png\" alt=\"image-20211114085508715\" style=\"zoom:50%;\" />\n\n<p>解決策は、型注釈のないJavaScriptと同様に、コード<em>縮小</em>を使用して結合することです。<em>縮小</em>は、TypeScriptがコード構造に基づいて値のより具体的な型を推定できる場合に発生します。</p>\n<p>たとえば、TypeScriptは、1つの <code>string</code> の値だけが <code>typeof</code> の値 <code>&quot;string&quot;</code> を持つことを知っています：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> id === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// このブランチでは、ID のタイプ “string”</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ここでのIDの種類 “number”</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>別の例として、次の関数 <code>Array.isArray</code> を使用します。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">welcomePeople</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(x)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ここ:「x」のタイプ &#x27;string[]&#x27;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + x.<span class=\"title function_\">join</span>(<span class=\"string\">&quot; and &quot;</span>));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ここ:「x」のタイプ &#x27;string&#x27;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Welcome lone traveler &quot;</span> + x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>else</code> ブランチでは特別なことをする必要はありません。 <code>x</code> が <code>string[]</code> でなければ、 <code>string</code> になります。</p>\n<p>時には <code>union</code> を持ち、メンバー全員に共通点があることもあります。たとえば、配列と文字列の両方に <code>slice</code> メソッドがあります。連合内の各メンバーに共通のプロパティがある場合は、そのプロパティを絞り込むことなく使用できます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 戻り値の型は、number[] | string として推論されます。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFirstThree</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-8型エイリアス\"><a href=\"#3-8型エイリアス\" class=\"headerlink\" title=\"3.8型エイリアス\"></a>3.8型エイリアス</h2><p>オブジェクト型と結合型は、型注釈に直接記述することで使用してきました。これは便利ですが、同じ型を何度も使い、名前を付けて参照したいというのはよくあります。</p>\n<p><em>型エイリアス</em>は、任意の<em>タイプ</em>に対する<em>名前</em>の定義です。型エイリアスの構文は次のとおりです：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Point</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前の例とまったく同じ</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標 x の値： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標 y の値： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>実際には、オブジェクトタイプだけでなく、タイプエイリアスを使用して任意のタイプに名前を付けることができます。たとえば、型エイリアスは連合型に名前を付けることができます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">ID</span> = <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n\n<p>エイリアス<em>ただ</em>エイリアス-タイプエイリアスを使用して、同じタイプの異なる「バージョン」を作成することはできません。エイリアスを使うときは、エイリアスの型を書いたのと同じです。言い換えれば、このコード<em>そうは見えない</em>は有効かもしれませんが、TypeScriptに基づいて可能です。どちらのタイプも同じエイリアスなので、次のようになります：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UserInputSanitizedString</span> = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sanitizeInput</span>(<span class=\"params\"><span class=\"attr\">str</span>: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">UserInputSanitizedString</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// サニタイズされた入力を作成する</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userInput = <span class=\"title function_\">sanitizeInput</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ただし、文字列を使用して値を再割り当てすることは可能です</span></span><br><span class=\"line\">userInput = <span class=\"string\">&quot;new input&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-9コネクタ\"><a href=\"#3-9コネクタ\" class=\"headerlink\" title=\"3.9コネクタ\"></a>3.9コネクタ</h2><p><em>インタフェース宣言</em>は、オブジェクトタイプに名前を付ける別の方法です：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標 x の値： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標 y の値： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上記でタイプエイリアスを使用した場合と同様に、この例は匿名オブジェクトタイプを使用した場合と同様に動作します。TypeScriptは、渡された値の<em>構造</em> <code>printCoord</code> だけを対象とします。これは、期待されるプロパティがあるかどうかだけを対象とします。型の構造と機能のみに注目することが、TypeScriptを<em>構造型</em>型システムと呼ぶ理由である。</p>\n<ul>\n<li>型エイリアスとインタフェースの違い</li>\n</ul>\n<p>型エイリアスとインタフェースは非常によく似ており、多くの場合、自由に選択することができます。ほとんどすべての機能が <code>interface</code> <code>type</code> で使用できます。主な違いは、新しいタイプの拡張方法です：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拡張ポート</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bear</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">bear</span>: <span class=\"title class_\">Bear</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;winnie&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bear.<span class=\"property\">name</span>;</span><br><span class=\"line\">bear.<span class=\"property\">honey</span>;</span><br><span class=\"line\"><span class=\"comment\">// 交差点ごとにタイプを展開</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Animal</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bear</span> = <span class=\"title class_\">Animal</span> &amp; &#123;</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">bear</span>: <span class=\"title class_\">Bear</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;winnie&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bear.<span class=\"property\">name</span>;</span><br><span class=\"line\">bear.<span class=\"property\">honey</span>;</span><br><span class=\"line\"><span class=\"comment\">// 既存のインターフェースに新しいフィールドを追加する</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyWindow</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyWindow</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">w</span>: <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;hello ts&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 作成後にタイプを変更することはできません。</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/03-07.png\" alt=\"image-20211114094240585\" style=\"zoom:50%;\" />\n\n<blockquote>\n<ul>\n<li>TypeScriptバージョン4.2より前のバージョンでは、型エイリアス<a href=\"https://www.typescriptlang.org/play#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA\"><em>エラー・メッセージに</em>が表示される可能性があります</a>は、同等の匿名型の代わりに使用されることがありました(これは望ましい場合と望ましくない場合があります)。インタフェースには常にエラーメッセージ内の名前が付けられます。</li>\n<li>型エイリアスは<a href=\"https://www.typescriptlang.org/play#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA\">声明合并，但接口可以</a>に関係しない可能性があります。</li>\n<li>インタフェースは<a href=\"https://www.typescriptlang.org/play#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA\">オブジェクトの形状を宣言します。プリミティブの名前は変更できません</a>でのみ使用できます。</li>\n<li>インタフェース名は<a href=\"https://www.typescriptlang.org/play#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA\"><em>常に</em>元の形式で</a>エラーメッセージに表示されますが、名前で使用されている場合は<em>のみ</em>。</li>\n</ul>\n<p>ほとんどの場合、好みに合わせて選ぶことができますが、TypeScriptは別の種類の宣言が必要かどうかを教えてくれます。ヒューリスティックを使用する場合は、 <code>interface</code> を使用し、必要に応じて <code>type</code> を使用します。</p>\n</blockquote>\n<h2 id=\"3-10型アサーション\"><a href=\"#3-10型アサーション\" class=\"headerlink\" title=\"3.10型アサーション\"></a>3.10型アサーション</h2><p>TypeScriptが知らない値の種類に関する情報が得られることがあります。</p>\n<p>たとえば、 <code>document.getElementById</code> を使用している場合、TypeScriptはこれが<em>ある種</em>型の <code>HTMLElement</code> を返すことだけを知っていますが、ページが常に <code>HTMLCanvasElement</code> 指定されたIDの値を持つことを知っているかもしれません。</p>\n<p>この場合、<em>タイプアサーション</em>を使用して、より具体的な型を指定できます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;main_canvas&quot;</span>) <span class=\"keyword\">as</span> <span class=\"title class_\">HTMLCanvasElement</span>;</span><br></pre></td></tr></table></figure>\n\n<p>型コメントと同様に、型アサーションはコンパイラによって削除され、コードの実行時動作には影響しません。</p>\n<p>山括弧構文も使用できます( <code>.tsx</code> ファイルにコードが含まれていない場合)。これは同等です：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = &lt;<span class=\"title class_\">HTMLCanvasElement</span>&gt;<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;main_canvas&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：型アサーションはコンパイル時に削除されるため、型アサーションに関連付けられた実行時チェックはありません。 <code>null</code> 型アサーションが間違っている場合、例外は発生しません。</p>\n</blockquote>\n<p>TypeScriptでは、型アサーションは<em>より具体的な</em>または<em>あまり具体的ではない</em>の型バージョンにのみ変換できます。このルールは、次のような「不可能」の強制を防止します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qNWktG6hBmzVZaC.png\" alt=\"image-20211114095324614\" style=\"zoom:50%;\" />\n\n<p>型 <code>string</code> を型 <code>number</code> に変換すると、両方の型が十分に重複していないため、正しく変換されない可能性があります。意図的な場合は、式を <code>any</code> または <code>unknown</code> ( <code>unknown</code> (後述)に変換してから、必要な型を指定します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">unknown</span> <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-11文字タイプ\"><a href=\"#3-11文字タイプ\" class=\"headerlink\" title=\"3.11文字タイプ\"></a>3.11文字タイプ</h2><p>一般的な型 <code>string</code> および <code>number</code> に加えて、型の位置で<em>特定の</em>文字列および数値を参照できます。</p>\n<p>1つの方法は、JavaScriptがどのようにさまざまな方法で変数を宣言するかを検討することです。 <code>var</code> と <code>let</code> のどちらも、変数に保存されているコンテンツの変更を許可します。 <code>const</code> は許可しません。これは、TypeScriptがテキストの型を作成する方法に反映されています。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> testString = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">testString = <span class=\"string\">&quot;Olá Mundo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//&#x27;testString&#x27;あらゆる文字列を表すことができますが、TypeScript ではそれを型システムでどのように記述するのでしょうか?</span></span><br><span class=\"line\">testString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> constantString = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//「constantString」は 1 つの可能な文字列のみを表すことができるため、</span></span><br><span class=\"line\"><span class=\"comment\">//テキスト型表現がある</span></span><br><span class=\"line\">constantString;</span><br></pre></td></tr></table></figure>\n\n<p>リテラルタイプは、それ自体にはあまり価値がありません：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"string\">&quot;hello&quot;</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// √</span></span><br><span class=\"line\">x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ×</span></span><br><span class=\"line\">x = <span class=\"string\">&quot;howdy&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/kcOHJ74TKSvuq1h.png\" alt=\"image-20211114102648519\" style=\"zoom:50%;\" />\n\n<p>1つの値しか持たない変数を持っていても、あまり役に立ちません！</p>\n<p>しかし、<em>将</em>リテラル<em>くみあわせ</em>を結合することで、より有用な概念を表すことができます。たとえば、特定の既知の値のセットだけを受け入れる関数などです：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printText</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">alignment</span>: <span class=\"string\">&quot;left&quot;</span> | <span class=\"string\">&quot;right&quot;</span> | <span class=\"string\">&quot;center&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printText</span>(<span class=\"string\">&quot;Hello, world&quot;</span>, <span class=\"string\">&quot;left&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">printText</span>(<span class=\"string\">&quot;G&#x27;day, mate&quot;</span>, <span class=\"string\">&quot;centre&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/SrcPeBsQvOUkDfw.png\" alt=\"image-20211114103049870\" style=\"zoom:50%;\" />\n\n<p>数値リテラル型も同様に機能します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compare</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span></span>): -<span class=\"number\">1</span> | <span class=\"number\">0</span> | <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === b ? <span class=\"number\">0</span> : a &gt; b ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>もちろん、これらをリテラル以外のタイプと組み合わせて使用することもできます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Options</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">width</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">configure</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Options</span> | <span class=\"string\">&quot;auto&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(&#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(<span class=\"string\">&quot;auto&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(<span class=\"string\">&quot;automatic&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/YZQwUvRlCtkzcTL.png\" alt=\"image-20211114103530209\" style=\"zoom:50%;\" />\n\n<p>Boolean型の文字もあります。booleanリテラルには、型 <code>true</code> と <code>false</code> の2種類しかありません。型 <code>boolean</code> 自体は、実際には結合型 <code>union</code> のエイリアス <code>true | false</code> にすぎません。</p>\n<ul>\n<li>文字推論</li>\n</ul>\n<p>オブジェクトを使用して変数を初期化する場合、TypeScriptはそのオブジェクトのプロパティの値が後で変更される可能性があると仮定します。例えば、次のようなコードを書いたとします：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">counter</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (someCondition) &#123;</span><br><span class=\"line\">  obj.<span class=\"property\">counter</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScriptでは、以前に <code>0</code> というフィールド値があり、その後に <code>1</code> を割り当てることが間違っているとは想定されません。別の説として、 <code>obj.counter</code> は <code>0</code> ではなく <code>number</code> 属性を持つ必要があります。これは、タイプが<em>読み取り</em>および<em>書き込み</em>動作を決定するためです。</p>\n<p>これは、文字列にも当てはまります：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleRequest</span>(<span class=\"params\"><span class=\"attr\">url</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> | <span class=\"string\">&quot;POST&quot;</span> | <span class=\"string\">&quot;GUESS&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/hmLQKWoi4kVtBFD.png\" alt=\"image-20211114105814002\" style=\"zoom:50%;\" />\n\n<p>上の例 <code>req.method</code> では <code>string</code> と推定され、 <code>&quot;GET&quot;</code> ではない。コードは <code>req</code> の作成と呼び出しの間で評価されるため、TypeScriptではこのコードにエラーがあると考えられます。</p>\n<p>この問題を解決するには2つの方法があります。</p>\n<p><strong>1. 任意の場所に型アサーションを追加することで、投機を変更できます：</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案 1:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> <span class=\"keyword\">as</span> <span class=\"string\">&quot;GET&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 方案 2</span></span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span> <span class=\"keyword\">as</span> <span class=\"string\">&quot;GET&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>シナリオ1では、「 <code>req.method</code> は常に<em>テキストの種類</em> <code>&quot;GET&quot;</code> を所有するようにします。これにより、後でこのフィールドに <code>&quot;GUESS&quot;</code> が割り当てられないようにします。</p>\n<p>案2は、「他の原因 <code>req.method</code> が <code>&quot;GET&quot;</code> の値を持つことを知っている」という意味である。</p>\n<p><strong>2. <code>as const</code> を使用して、オブジェクト全体を型リテラルに変換できます。</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> &#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span>);</span><br></pre></td></tr></table></figure>\n\n<p>この接尾辞 <code>as const</code> は、 <code>const</code> のように定義され、より一般的な <code>string</code> や <code>number</code> ではなく、すべての属性にテキスト型が割り当てられることを保証します。</p>\n<h2 id=\"3-12-null-および-undefined\"><a href=\"#3-12-null-および-undefined\" class=\"headerlink\" title=\"3.12 null および undefined\"></a>3.12 <code>null</code> および <code>undefined</code></h2><p>JavaScriptには、存在しないか初期化されていない値を表す2つの元の値があります。 <code>null</code> と <code>undefined</code> です。</p>\n<p>TypeScriptには、2つの同じ名前があります<em>タイプ</em>。これらのタイプの動作は、[ <code>strictNullChecks</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks%EF%BC%89%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E7%95%B0%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82\">https://www.typescriptlang.org/tsconfig#strictNullChecks）オプションを設定しているかどうかによって異なります。</a></p>\n<ul>\n<li><code>strictNullChecks</code> オフ</li>\n</ul>\n<p><em>false</em>を使用すると、の値は通常どおりにアクセスでき、どのタイプの属性にも値を割り当てることができます。これは、空のチェックがない言語(C#、Javaなど)の動作に似ています。これらの値のチェックが不足していることが、多くの場合、誤りの主要な原因である。もし彼らのコードベースでそれが可能であれば、私たちはいつもそれを開くことをお勧めします。</p>\n<ul>\n<li><code>strictNullChecks</code> オープン</li>\n</ul>\n<p><em>true</em>では、メソッドまたはプロパティを使用する前に値をテストする必要があります。オプション属性を使用する前と同様に、<em>縮小</em>を使用して、可能な値を確認できます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//何かをする</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + x.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>空でないアサーション演算子( <code>!</code> 接尾辞)</li>\n</ul>\n<p>TypeScriptには特殊な構文 <code>null</code>、 <code>undefined</code> もあり、明示的なチェックを行わずにタイプを削除したり、タイプから削除したりすることができます。 <code>!</code> 式の後に書き込むことは、実際には型のアサーションです。つまり、値は <code>null</code> or <code>undefined</code> ではありません：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">liveDangerously</span>(<span class=\"params\"><span class=\"attr\">x</span>?: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正解</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x!.<span class=\"title function_\">toFixed</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>他の型のアサーションと同様に、これはコードの実行時動作を変更しません。したがって、 <code>!</code> は、<em>できない</em>が <code>null</code> または <code>undefined</code> であることがわかっている場合にのみ使用することが重要です。</p>\n<h2 id=\"3-13列挙\"><a href=\"#3-13列挙\" class=\"headerlink\" title=\"3.13列挙\"></a>3.13列挙</h2><p>列挙は、TypeScriptがJavaScriptに追加する機能で、名前付き定数の可能なセットの1つである可能性のある値を記述できます。ほとんどのTypeScript機能とは異なり、この<em>いいえ</em>JavaScriptの型レベルの追加は、言語とランタイムのコンテンツに追加されます。したがって、列挙が何かをしている必要があることを確認してください。そうでない場合は使用しないでください。列挙の詳細については、<a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">Enum 参考页 中</a>を参照してください。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ts ソースコード</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// コンパイルされたjsコード</span></span><br><span class=\"line\">(<span class=\"string\">&quot;use strict&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Direction</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"title class_\">Direction</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Up&quot;</span>] = <span class=\"number\">1</span>)] = <span class=\"string\">&quot;Up&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Down&quot;</span>] = <span class=\"number\">2</span>)] = <span class=\"string\">&quot;Down&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Left&quot;</span>] = <span class=\"number\">3</span>)] = <span class=\"string\">&quot;Left&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Right&quot;</span>] = <span class=\"number\">4</span>)] = <span class=\"string\">&quot;Right&quot;</span>;</span><br><span class=\"line\">&#125;)(<span class=\"title class_\">Direction</span> || (<span class=\"title class_\">Direction</span> = &#123;&#125;));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/dvthyFIPKAuBR1s.png\" alt=\"image-20211114112554381\" style=\"zoom:33%;\" />\n\n<h2 id=\"3-14あまり一般的ではない原語\"><a href=\"#3-14あまり一般的ではない原語\" class=\"headerlink\" title=\"3.14あまり一般的ではない原語\"></a>3.14あまり一般的ではない原語</h2><p>特に、JavaScriptの新しいプリミティブのいくつかは、TypeScriptタイプのシステムでも実装されています。まず簡単に2つの例を見てみましょう：</p>\n<ul>\n<li><h4 id=\"bigint\"><a href=\"#bigint\" class=\"headerlink\" title=\"bigint\"></a><code>bigint</code></h4></li>\n</ul>\n<p>ES2020以降、JavaScriptには、非常に大きな整数のプリミティブ <code>BigInt</code> があります。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bigint 関数を使用して bigint を作成する</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">oneHundred</span>: <span class=\"built_in\">bigint</span> = <span class=\"title class_\">BigInt</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// テキスト構文を使用して BigInt を作成する</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">anotherHundred</span>: <span class=\"built_in\">bigint</span> = <span class=\"number\">100n</span>;</span><br></pre></td></tr></table></figure>\n\n<p>BigIntの詳細については<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint\">TypeScript 3.2リリースノート</a>を参照してください。</p>\n<ul>\n<li><h4 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a><code>symbol</code></h4></li>\n</ul>\n<p>JavaScriptには、関数からグローバル一意参照を作成するためのプリミティブ <code>Symbol()</code> があります：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> firstName = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> secondName = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (firstName === secondName) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ここのコードは実行できません</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/ORATaxUgEjrPL9V.png\" alt=\"image-20211114113536948\" style=\"zoom:40%;\" />\n\n<p>タイプ <code>typeof firstName</code> と <code>typeof secondName</code> は重複していないので、この条件は常に <code>false</code> を返します。</p>\n<h3 id=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"><a href=\"#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\" class=\"headerlink\" title=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"></a>特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"三、よく使われるタイプ\"><a href=\"#三、よく使われるタイプ\" class=\"headerlink\" title=\"三、よく使われるタイプ\"></a>三、よく使われるタイプ</h1><p>この章では、JavaScriptコードで最も一般的な値の型をいくつか紹介し、これらの型をTypeScriptで説明するための適切な方法について説明します。これは詳細なリストではありませんが、今後の章では、他の種類の名前を付けて使用するためのより多くの方法について説明します。</p>\n<p>タイプは、タイプコメントだけでなく、他の<em>地方、</em>にも表示されます。型自体を理解すると、新しい構造を形成するためにそれらの型を参照できる場所についても理解していきます。</p>\n<p>最初に、JavaScriptまたはTypeScriptコードを書くときに遭遇するであろう最も基本的で一般的な型を見てみましょう。これは、より複雑な型を形成するコア構成要素です。</p>\n<h2 id=\"3-0-TypeScript設定ファイル\"><a href=\"#3-0-TypeScript設定ファイル\" class=\"headerlink\" title=\"3.0 TypeScript設定ファイル\"></a>3.0 TypeScript設定ファイル</h2><p>学習を容易にするために、コマンドラインの引数を別の構成ファイルに保存し、 <code>tsc</code> を適用して構成ファイルを生成します：</p>\n<img src=\"https://s2.loli.net/2022/02/22/1dAfz2imrs3CMbL.png\" alt=\"image-20211113170722654\" style=\"zoom: 50%;\"/>\n\n<p>構成ファイル <code>tsconfig.json</code> がプロジェクトのルートディレクトリに構築されました。ここでは、独自の構成について説明します：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Language and Environment */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Modules */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./src&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Emit */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Type Checking */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;strict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-1プリミティブ型-string-number-および-boolean\"><a href=\"#3-1プリミティブ型-string-number-および-boolean\" class=\"headerlink\" title=\"3.1プリミティブ型 string, number,および boolean\"></a>3.1プリミティブ型 <code>string</code>, <code>number</code>,および <code>boolean</code></h2><p>JavaScriptには3つの非常に一般的な<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">原语</a>があります。 <code>string</code>、 <code>number</code>、および <code>boolean</code> です。TypeScriptには、それぞれに対応するタイプがあります。これらの名前は、JavaScriptアプリケーション <code>typeof</code> で返された型の名前と同じであることがわかりました：</p>\n<ul>\n<li><code>string</code> は、 <code>&quot;Hello, world&quot;</code> のような文字列値を表します。</li>\n<li><code>number</code> は、 <code>42</code> などの数値を表します。JavaScriptには特別な整数ランタイム値がないので、 <code>int</code> または <code>float</code> 型と等価ではありません。すべては <code>number</code> のみです。</li>\n<li><code>boolean</code> 2つの値のみ <code>true</code> と <code>false</code></li>\n</ul>\n<blockquote>\n<p>型名 <code>String</code>, <code>Number</code>,および <code>Boolean</code> (大文字で始まる)は合法ですが、コードにはあまり表示されない特殊な組み込み型を指します。タイプの場合、<em>始終</em>は <code>string</code>, <code>number</code>,または <code>boolean</code> を使用します。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str</span>: string = <span class=\"string\">&#x27;hello typescript&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">num</span>: number = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">bool</span>: boolean = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2配列\"><a href=\"#3-2配列\" class=\"headerlink\" title=\"3.2配列\"></a>3.2配列</h2><p>配列は、 <code>[1, 2, 3]</code> データのように指定された形であり、構文 <code>number[]</code> を使用して定義できます;この構文は、任意の型(たとえば、 <code>string[]</code>、文字列配列など)に適用されます。</p>\n<p><code>Array&lt;number&gt;</code> と書くこともできます。 <code>T&lt;U&gt;</code> この構文については、<em>はんぷくがた</em>を参照してください。</p>\n<p><strong>02-everyday-types&#x2F;src&#x2F;02-array.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">arr</span>: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">arr2</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-any\"><a href=\"#3-3-any\" class=\"headerlink\" title=\"3.3 any\"></a>3.3 any</h2><p>TypeScriptには特殊な型 <code>any</code> もあり、特定の値で型チェックエラーが発生したくない場合に使用できます。</p>\n<p>値の型が <code>any</code> の場合は、その属性にアクセスし、どの型の値にもそれを割り当てることができます。その他のほとんどの構文的なものは、正当なものとなります：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">obj</span>: <span class=\"built_in\">any</span> = &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 次のコード行はいずれもコンパイラ エラーをスローしません。</span></span><br><span class=\"line\"><span class=\"comment\">// 「any」を使用すると、それ以降の型チェックがすべて無効になります</span></span><br><span class=\"line\">obj.<span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"title function_\">obj</span>();</span><br><span class=\"line\">obj.<span class=\"property\">bar</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\">obj = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">n</span>: <span class=\"built_in\">number</span> = obj;</span><br></pre></td></tr></table></figure>\n\n<p>ただし、実行環境でコードを実行すると、エラーになることがあります：</p>\n<img src=\"/img/TypeScript/03-02.png\" alt=\"image-20211113182543401\" style=\"zoom:50%;\" />\n\n<p><code>dist</code> ディレクトリに移動し、node環境でコードを実行しましたが、やはりエラーが発生しました。</p>\n<p><code>any</code> 型は、TypeScriptが特定のコード行が大丈夫であることを確信するためだけに、長い型を書きたくない場合に便利です。</p>\n<ul>\n<li><strong>noImplicitAny</strong></li>\n</ul>\n<p>型が指定されておらず、TypeScriptがコンテキストから推測できない場合、コンパイラは通常、デフォルトで <code>any</code> に設定されます。</p>\n<p>ただし、 <code>any</code> は型チェックを行わないので、このような状況は避けたいのが一般的です。コンパイラフラグ[ <code>noImplicitAny</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny%EF%BC%89%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%80%81%E6%9A%97%E9%BB%99%E7%9A%84%E3%81%AA%E3%83%95%E3%83%A9%E3%82%B0\">https://www.typescriptlang.org/tsconfig#noImplicitAny）を使用して、暗黙的なフラグ</a> <code>any</code> をエラーにします。この構成は前にも述べました。</p>\n<h2 id=\"3-4変数の型コメント\"><a href=\"#3-4変数の型コメント\" class=\"headerlink\" title=\"3.4変数の型コメント\"></a>3.4変数の型コメント</h2><p><code>const</code>, <code>var</code>,または <code>let</code> を使用して変数を宣言する場合は、型コメントを追加して変数の型を明示的に指定できます：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myName</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;Felixlu&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>TypeScriptは「左の型」スタイルの宣言を使用しません。たとえば、 <code>int x = 0;</code> 型注釈は常に<em>在る</em>入力されたもの<em>後</em>です。</p>\n</blockquote>\n<p>しかし、ほとんどの場合、これは必須ではありません。可能な限り、TypeScriptは自動<em>推論</em>コード内の型を試します。たとえば、変数の型は、その初期化子の型から推測されます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 型定義は必要ありません -- 「myName」は「string」型であると推論されます</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">&quot;Felixlu&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>多くの場合、推論規則を明示的に学習する必要はない。始めたばかりの方は、思ったよりも少ないタイプの注釈を使ってみてください。驚くかもしれませんが、TypeScriptは何が起こっているかを完全に理解しています。</p>\n<h2 id=\"3-5関数\"><a href=\"#3-5関数\" class=\"headerlink\" title=\"3.5関数\"></a>3.5関数</h2><p>関数は、JavaScriptでデータを渡す主要な方法です。TypeScriptを使用すると、関数の入力値と出力値のタイプを指定できます。</p>\n<ul>\n<li>パラメータタイプの注記</li>\n</ul>\n<p>関数を宣言するときは、各引数の後に型注記を追加して、関数が受け入れる引数の型を宣言できます。パラメータタイプの注記は、パラメータ名の後に表示されます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// パラメータの型の定義</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + name.<span class=\"title function_\">toUpperCase</span>() + <span class=\"string\">&quot;!!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>パラメータに型コメントがある場合、関数のパラメータがチェックされます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 実行すると実行時エラーになります。</span></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"number\">42</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/SR9okXs1ez7ThC6.png\" alt=\"image-20211114072314780\" style=\"zoom: 50%;\" />\n\n<blockquote>\n<p>パラメータに型コメントがない場合でも、正しい数のパラメータが渡されているかどうかがチェックされます。</p>\n</blockquote>\n<ul>\n<li>戻り値型コメント</li>\n</ul>\n<p>返り型コメントを追加することもできます。戻り値の型に関するコメントは、引数リストの後に表示されます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFavoriteNumber</span>(<span class=\"params\"></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">26</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScriptは関数の戻り値の型を <code>return</code> ステートメントに基づいて推定するので、変数型コメントと同様に、戻り値型コメントは通常必要ありません。上記の例のタイプ注釈は何も変わりません。一部のコードベースでは、意図しない変更や個人的な好みを防ぐために、マニュアル用に戻り値の型を明示的に指定しています。</p>\n<ul>\n<li>匿名関数</li>\n</ul>\n<p>匿名関数は関数宣言とは少し異なります。TypeScriptがどのように呼び出されるかを判断できる場所に関数が現れると、その関数の引数によって自動的に型が指定されます。</p>\n<p>次に例を示します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ここには型の注釈はありませんが、TypeScript はエラーをキャッチできます。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Eve&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 関数コンテキスト型</span></span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"title function_\">toUppercase</span>());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// コンテキストタイプはアロー関数でも機能します</span></span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"title function_\">toUppercase</span>());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qMkb8YQzxUw2Xnc.png\" alt=\"image-20211114073444596\" style=\"zoom:50%;\" />\n\n<p>パラメータ <code>s</code> に型コメントがない場合でも、TypeScriptは <code>forEach</code> 関数の型と配列の推定型を使用して <code>s</code> の型を決定します。</p>\n<p>このプロセスは<em>を選択して、</em>と呼ばれ、関数が発生する<em>コンテキスト</em>は、その関数がどのような型を持つべきかを通知するためです。</p>\n<p>推論規則と同様に、これがどのように起こるのかを明確に理解する必要はありませんが、そのメカニズム<em>確かに</em>を理解することで、型注釈が必要ないときに注意を払うことができます。あとで、<em>値が表示されるコンテキスト</em>がその型にどのように影響するかについて、さらに例を示します。</p>\n<h2 id=\"3-6オブジェクトタイプ\"><a href=\"#3-6オブジェクトタイプ\" class=\"headerlink\" title=\"3.6オブジェクトタイプ\"></a>3.6オブジェクトタイプ</h2><p><code>string</code>, <code>number</code>, <code>boolean</code> 型(プリミティブ型とも呼ばれる)のほかに、最も一般的な型は<em>オブジェクトタイプ</em>です。これは、ほとんどすべてのプロパティを持つJavaScript値を指します！オブジェクトタイプを定義するには、その属性とそのタイプをリストします。</p>\n<p>たとえば、点状のオブジェクトを受け取る関数です：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// パラメータの型アノテーションがオブジェクト型である</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: &#123; x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標のx値： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標のy値： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">7</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>ここでは、2つの属性( <code>x</code> および <code>y</code>)を持つタイプ注釈パラメータを使用します。どちらも <code>number</code> タイプです。属性は、 <code>,</code> または <code>;</code> を使用して区切ることができます。最後の区切り文字はオプションです。</p>\n<p>各プロパティのタイプ部分もオプションです。型を指定しない場合は、 <code>any</code> とみなされます。</p>\n<ul>\n<li>オプション属性</li>\n</ul>\n<p>オブジェクトタイプでは、プロパティの一部またはすべてが<em>オプション</em>であることも指定できます。これを行うには、属性名の後に <code>?</code> を追加します。</p>\n<p><strong>02-everyday-types&#x2F;src&#x2F;05-object.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printName</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; first: <span class=\"built_in\">string</span>; last?: <span class=\"built_in\">string</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// どちらの方法でパラメータを渡しても問題ありません</span></span><br><span class=\"line\"><span class=\"title function_\">printName</span>(&#123; <span class=\"attr\">first</span>: <span class=\"string\">&quot;Felix&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">printName</span>(&#123; <span class=\"attr\">first</span>: <span class=\"string\">&quot;Felix&quot;</span>, <span class=\"attr\">last</span>: <span class=\"string\">&quot;Lu&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>JavaScriptでは、存在しないプロパティーにアクセスすると、実行時エラーではなく <code>undefined</code> の値が取得されます。したがって、オプション属性<em>読み取り</em>を使用する場合は、その属性を使用する前に <code>undefined</code> でチェックする必要があります。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printName</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; first: <span class=\"built_in\">string</span>; last?: <span class=\"built_in\">string</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// × -「obj.last」が存在しない可能性があります。</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.<span class=\"property\">last</span> !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// √</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 最新の JavaScript 構文を使用した安全な代替手段:</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>?.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7統合タイプ\"><a href=\"#3-7統合タイプ\" class=\"headerlink\" title=\"3.7統合タイプ\"></a>3.7統合タイプ</h2><p>TypeScriptの型システムでは、複数の演算子を使用して既存の型から新しい型を構築できます。いくつかのタイプを書く方法がわかったので、それを面白おかしく<em>くみあわせ</em>始める時が来ました。</p>\n<ul>\n<li>連合タイプの定義</li>\n</ul>\n<p>型を結合する最初の方法は、<em>連合</em>型です。結合型は、2つ以上の他の型からなる型であり、これらの型の<em>いずれか</em>の値である可能性があることを示します。これらの各タイプを<em>結合タイプのメンバー</em>と呼びます。</p>\n<p>文字列または数値を操作する関数を作成します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Your ID is: &quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// √</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(<span class=\"number\">101</span>);</span><br><span class=\"line\"><span class=\"comment\">// √</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(<span class=\"string\">&quot;202&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// ×</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(&#123; <span class=\"attr\">myID</span>: <span class=\"number\">22342</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qkOvn9DrVdCRSBc.png\" alt=\"image-20211114081646215\" style=\"zoom:50%;\" />\n\n<ul>\n<li>結合タイプの使用</li>\n</ul>\n<p><em>提供</em>結合タイプの値を一致させるのは簡単です。結合メンバーのタイプを指定するだけで済みます。もしあなたが<em>ある</em>結合型の値を持っていたら、どのようにそれを使いますか？</p>\n<p>連合の<em>それぞれ</em>メンバーがすべて有効であれば、TypeScriptは連合を使って何かをすることだけを許可します。たとえば、結合型 <code>string | number</code> がある場合、 <code>string</code> のように1つの型の操作のみを使用することはできません。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/TnuapbGVlOE2BYw.png\" alt=\"image-20211114085508715\" style=\"zoom:50%;\" />\n\n<p>解決策は、型注釈のないJavaScriptと同様に、コード<em>縮小</em>を使用して結合することです。<em>縮小</em>は、TypeScriptがコード構造に基づいて値のより具体的な型を推定できる場合に発生します。</p>\n<p>たとえば、TypeScriptは、1つの <code>string</code> の値だけが <code>typeof</code> の値 <code>&quot;string&quot;</code> を持つことを知っています：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> id === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// このブランチでは、ID のタイプ “string”</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ここでのIDの種類 “number”</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>別の例として、次の関数 <code>Array.isArray</code> を使用します。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">welcomePeople</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(x)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ここ:「x」のタイプ &#x27;string[]&#x27;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + x.<span class=\"title function_\">join</span>(<span class=\"string\">&quot; and &quot;</span>));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ここ:「x」のタイプ &#x27;string&#x27;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Welcome lone traveler &quot;</span> + x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>else</code> ブランチでは特別なことをする必要はありません。 <code>x</code> が <code>string[]</code> でなければ、 <code>string</code> になります。</p>\n<p>時には <code>union</code> を持ち、メンバー全員に共通点があることもあります。たとえば、配列と文字列の両方に <code>slice</code> メソッドがあります。連合内の各メンバーに共通のプロパティがある場合は、そのプロパティを絞り込むことなく使用できます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 戻り値の型は、number[] | string として推論されます。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFirstThree</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-8型エイリアス\"><a href=\"#3-8型エイリアス\" class=\"headerlink\" title=\"3.8型エイリアス\"></a>3.8型エイリアス</h2><p>オブジェクト型と結合型は、型注釈に直接記述することで使用してきました。これは便利ですが、同じ型を何度も使い、名前を付けて参照したいというのはよくあります。</p>\n<p><em>型エイリアス</em>は、任意の<em>タイプ</em>に対する<em>名前</em>の定義です。型エイリアスの構文は次のとおりです：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Point</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前の例とまったく同じ</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標 x の値： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標 y の値： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>実際には、オブジェクトタイプだけでなく、タイプエイリアスを使用して任意のタイプに名前を付けることができます。たとえば、型エイリアスは連合型に名前を付けることができます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">ID</span> = <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n\n<p>エイリアス<em>ただ</em>エイリアス-タイプエイリアスを使用して、同じタイプの異なる「バージョン」を作成することはできません。エイリアスを使うときは、エイリアスの型を書いたのと同じです。言い換えれば、このコード<em>そうは見えない</em>は有効かもしれませんが、TypeScriptに基づいて可能です。どちらのタイプも同じエイリアスなので、次のようになります：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UserInputSanitizedString</span> = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sanitizeInput</span>(<span class=\"params\"><span class=\"attr\">str</span>: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">UserInputSanitizedString</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// サニタイズされた入力を作成する</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userInput = <span class=\"title function_\">sanitizeInput</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ただし、文字列を使用して値を再割り当てすることは可能です</span></span><br><span class=\"line\">userInput = <span class=\"string\">&quot;new input&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-9コネクタ\"><a href=\"#3-9コネクタ\" class=\"headerlink\" title=\"3.9コネクタ\"></a>3.9コネクタ</h2><p><em>インタフェース宣言</em>は、オブジェクトタイプに名前を付ける別の方法です：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標 x の値： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;座標 y の値： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上記でタイプエイリアスを使用した場合と同様に、この例は匿名オブジェクトタイプを使用した場合と同様に動作します。TypeScriptは、渡された値の<em>構造</em> <code>printCoord</code> だけを対象とします。これは、期待されるプロパティがあるかどうかだけを対象とします。型の構造と機能のみに注目することが、TypeScriptを<em>構造型</em>型システムと呼ぶ理由である。</p>\n<ul>\n<li>型エイリアスとインタフェースの違い</li>\n</ul>\n<p>型エイリアスとインタフェースは非常によく似ており、多くの場合、自由に選択することができます。ほとんどすべての機能が <code>interface</code> <code>type</code> で使用できます。主な違いは、新しいタイプの拡張方法です：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拡張ポート</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bear</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">bear</span>: <span class=\"title class_\">Bear</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;winnie&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bear.<span class=\"property\">name</span>;</span><br><span class=\"line\">bear.<span class=\"property\">honey</span>;</span><br><span class=\"line\"><span class=\"comment\">// 交差点ごとにタイプを展開</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Animal</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bear</span> = <span class=\"title class_\">Animal</span> &amp; &#123;</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">bear</span>: <span class=\"title class_\">Bear</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;winnie&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bear.<span class=\"property\">name</span>;</span><br><span class=\"line\">bear.<span class=\"property\">honey</span>;</span><br><span class=\"line\"><span class=\"comment\">// 既存のインターフェースに新しいフィールドを追加する</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyWindow</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyWindow</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">w</span>: <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;hello ts&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 作成後にタイプを変更することはできません。</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/03-07.png\" alt=\"image-20211114094240585\" style=\"zoom:50%;\" />\n\n<blockquote>\n<ul>\n<li>TypeScriptバージョン4.2より前のバージョンでは、型エイリアス<a href=\"https://www.typescriptlang.org/play#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA\"><em>エラー・メッセージに</em>が表示される可能性があります</a>は、同等の匿名型の代わりに使用されることがありました(これは望ましい場合と望ましくない場合があります)。インタフェースには常にエラーメッセージ内の名前が付けられます。</li>\n<li>型エイリアスは<a href=\"https://www.typescriptlang.org/play#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA\">声明合并，但接口可以</a>に関係しない可能性があります。</li>\n<li>インタフェースは<a href=\"https://www.typescriptlang.org/play#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA\">オブジェクトの形状を宣言します。プリミティブの名前は変更できません</a>でのみ使用できます。</li>\n<li>インタフェース名は<a href=\"https://www.typescriptlang.org/play#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA\"><em>常に</em>元の形式で</a>エラーメッセージに表示されますが、名前で使用されている場合は<em>のみ</em>。</li>\n</ul>\n<p>ほとんどの場合、好みに合わせて選ぶことができますが、TypeScriptは別の種類の宣言が必要かどうかを教えてくれます。ヒューリスティックを使用する場合は、 <code>interface</code> を使用し、必要に応じて <code>type</code> を使用します。</p>\n</blockquote>\n<h2 id=\"3-10型アサーション\"><a href=\"#3-10型アサーション\" class=\"headerlink\" title=\"3.10型アサーション\"></a>3.10型アサーション</h2><p>TypeScriptが知らない値の種類に関する情報が得られることがあります。</p>\n<p>たとえば、 <code>document.getElementById</code> を使用している場合、TypeScriptはこれが<em>ある種</em>型の <code>HTMLElement</code> を返すことだけを知っていますが、ページが常に <code>HTMLCanvasElement</code> 指定されたIDの値を持つことを知っているかもしれません。</p>\n<p>この場合、<em>タイプアサーション</em>を使用して、より具体的な型を指定できます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;main_canvas&quot;</span>) <span class=\"keyword\">as</span> <span class=\"title class_\">HTMLCanvasElement</span>;</span><br></pre></td></tr></table></figure>\n\n<p>型コメントと同様に、型アサーションはコンパイラによって削除され、コードの実行時動作には影響しません。</p>\n<p>山括弧構文も使用できます( <code>.tsx</code> ファイルにコードが含まれていない場合)。これは同等です：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = &lt;<span class=\"title class_\">HTMLCanvasElement</span>&gt;<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;main_canvas&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：型アサーションはコンパイル時に削除されるため、型アサーションに関連付けられた実行時チェックはありません。 <code>null</code> 型アサーションが間違っている場合、例外は発生しません。</p>\n</blockquote>\n<p>TypeScriptでは、型アサーションは<em>より具体的な</em>または<em>あまり具体的ではない</em>の型バージョンにのみ変換できます。このルールは、次のような「不可能」の強制を防止します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qNWktG6hBmzVZaC.png\" alt=\"image-20211114095324614\" style=\"zoom:50%;\" />\n\n<p>型 <code>string</code> を型 <code>number</code> に変換すると、両方の型が十分に重複していないため、正しく変換されない可能性があります。意図的な場合は、式を <code>any</code> または <code>unknown</code> ( <code>unknown</code> (後述)に変換してから、必要な型を指定します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">unknown</span> <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-11文字タイプ\"><a href=\"#3-11文字タイプ\" class=\"headerlink\" title=\"3.11文字タイプ\"></a>3.11文字タイプ</h2><p>一般的な型 <code>string</code> および <code>number</code> に加えて、型の位置で<em>特定の</em>文字列および数値を参照できます。</p>\n<p>1つの方法は、JavaScriptがどのようにさまざまな方法で変数を宣言するかを検討することです。 <code>var</code> と <code>let</code> のどちらも、変数に保存されているコンテンツの変更を許可します。 <code>const</code> は許可しません。これは、TypeScriptがテキストの型を作成する方法に反映されています。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> testString = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">testString = <span class=\"string\">&quot;Olá Mundo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//&#x27;testString&#x27;あらゆる文字列を表すことができますが、TypeScript ではそれを型システムでどのように記述するのでしょうか?</span></span><br><span class=\"line\">testString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> constantString = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//「constantString」は 1 つの可能な文字列のみを表すことができるため、</span></span><br><span class=\"line\"><span class=\"comment\">//テキスト型表現がある</span></span><br><span class=\"line\">constantString;</span><br></pre></td></tr></table></figure>\n\n<p>リテラルタイプは、それ自体にはあまり価値がありません：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"string\">&quot;hello&quot;</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// √</span></span><br><span class=\"line\">x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// ×</span></span><br><span class=\"line\">x = <span class=\"string\">&quot;howdy&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/kcOHJ74TKSvuq1h.png\" alt=\"image-20211114102648519\" style=\"zoom:50%;\" />\n\n<p>1つの値しか持たない変数を持っていても、あまり役に立ちません！</p>\n<p>しかし、<em>将</em>リテラル<em>くみあわせ</em>を結合することで、より有用な概念を表すことができます。たとえば、特定の既知の値のセットだけを受け入れる関数などです：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printText</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">alignment</span>: <span class=\"string\">&quot;left&quot;</span> | <span class=\"string\">&quot;right&quot;</span> | <span class=\"string\">&quot;center&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printText</span>(<span class=\"string\">&quot;Hello, world&quot;</span>, <span class=\"string\">&quot;left&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">printText</span>(<span class=\"string\">&quot;G&#x27;day, mate&quot;</span>, <span class=\"string\">&quot;centre&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/SrcPeBsQvOUkDfw.png\" alt=\"image-20211114103049870\" style=\"zoom:50%;\" />\n\n<p>数値リテラル型も同様に機能します：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compare</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span></span>): -<span class=\"number\">1</span> | <span class=\"number\">0</span> | <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === b ? <span class=\"number\">0</span> : a &gt; b ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>もちろん、これらをリテラル以外のタイプと組み合わせて使用することもできます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Options</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">width</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">configure</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Options</span> | <span class=\"string\">&quot;auto&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(&#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(<span class=\"string\">&quot;auto&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(<span class=\"string\">&quot;automatic&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/YZQwUvRlCtkzcTL.png\" alt=\"image-20211114103530209\" style=\"zoom:50%;\" />\n\n<p>Boolean型の文字もあります。booleanリテラルには、型 <code>true</code> と <code>false</code> の2種類しかありません。型 <code>boolean</code> 自体は、実際には結合型 <code>union</code> のエイリアス <code>true | false</code> にすぎません。</p>\n<ul>\n<li>文字推論</li>\n</ul>\n<p>オブジェクトを使用して変数を初期化する場合、TypeScriptはそのオブジェクトのプロパティの値が後で変更される可能性があると仮定します。例えば、次のようなコードを書いたとします：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">counter</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (someCondition) &#123;</span><br><span class=\"line\">  obj.<span class=\"property\">counter</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScriptでは、以前に <code>0</code> というフィールド値があり、その後に <code>1</code> を割り当てることが間違っているとは想定されません。別の説として、 <code>obj.counter</code> は <code>0</code> ではなく <code>number</code> 属性を持つ必要があります。これは、タイプが<em>読み取り</em>および<em>書き込み</em>動作を決定するためです。</p>\n<p>これは、文字列にも当てはまります：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleRequest</span>(<span class=\"params\"><span class=\"attr\">url</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> | <span class=\"string\">&quot;POST&quot;</span> | <span class=\"string\">&quot;GUESS&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/hmLQKWoi4kVtBFD.png\" alt=\"image-20211114105814002\" style=\"zoom:50%;\" />\n\n<p>上の例 <code>req.method</code> では <code>string</code> と推定され、 <code>&quot;GET&quot;</code> ではない。コードは <code>req</code> の作成と呼び出しの間で評価されるため、TypeScriptではこのコードにエラーがあると考えられます。</p>\n<p>この問題を解決するには2つの方法があります。</p>\n<p><strong>1. 任意の場所に型アサーションを追加することで、投機を変更できます：</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案 1:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> <span class=\"keyword\">as</span> <span class=\"string\">&quot;GET&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 方案 2</span></span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span> <span class=\"keyword\">as</span> <span class=\"string\">&quot;GET&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>シナリオ1では、「 <code>req.method</code> は常に<em>テキストの種類</em> <code>&quot;GET&quot;</code> を所有するようにします。これにより、後でこのフィールドに <code>&quot;GUESS&quot;</code> が割り当てられないようにします。</p>\n<p>案2は、「他の原因 <code>req.method</code> が <code>&quot;GET&quot;</code> の値を持つことを知っている」という意味である。</p>\n<p><strong>2. <code>as const</code> を使用して、オブジェクト全体を型リテラルに変換できます。</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> &#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span>);</span><br></pre></td></tr></table></figure>\n\n<p>この接尾辞 <code>as const</code> は、 <code>const</code> のように定義され、より一般的な <code>string</code> や <code>number</code> ではなく、すべての属性にテキスト型が割り当てられることを保証します。</p>\n<h2 id=\"3-12-null-および-undefined\"><a href=\"#3-12-null-および-undefined\" class=\"headerlink\" title=\"3.12 null および undefined\"></a>3.12 <code>null</code> および <code>undefined</code></h2><p>JavaScriptには、存在しないか初期化されていない値を表す2つの元の値があります。 <code>null</code> と <code>undefined</code> です。</p>\n<p>TypeScriptには、2つの同じ名前があります<em>タイプ</em>。これらのタイプの動作は、[ <code>strictNullChecks</code>]（<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks%EF%BC%89%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E7%95%B0%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82\">https://www.typescriptlang.org/tsconfig#strictNullChecks）オプションを設定しているかどうかによって異なります。</a></p>\n<ul>\n<li><code>strictNullChecks</code> オフ</li>\n</ul>\n<p><em>false</em>を使用すると、の値は通常どおりにアクセスでき、どのタイプの属性にも値を割り当てることができます。これは、空のチェックがない言語(C#、Javaなど)の動作に似ています。これらの値のチェックが不足していることが、多くの場合、誤りの主要な原因である。もし彼らのコードベースでそれが可能であれば、私たちはいつもそれを開くことをお勧めします。</p>\n<ul>\n<li><code>strictNullChecks</code> オープン</li>\n</ul>\n<p><em>true</em>では、メソッドまたはプロパティを使用する前に値をテストする必要があります。オプション属性を使用する前と同様に、<em>縮小</em>を使用して、可能な値を確認できます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//何かをする</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + x.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>空でないアサーション演算子( <code>!</code> 接尾辞)</li>\n</ul>\n<p>TypeScriptには特殊な構文 <code>null</code>、 <code>undefined</code> もあり、明示的なチェックを行わずにタイプを削除したり、タイプから削除したりすることができます。 <code>!</code> 式の後に書き込むことは、実際には型のアサーションです。つまり、値は <code>null</code> or <code>undefined</code> ではありません：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">liveDangerously</span>(<span class=\"params\"><span class=\"attr\">x</span>?: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正解</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x!.<span class=\"title function_\">toFixed</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>他の型のアサーションと同様に、これはコードの実行時動作を変更しません。したがって、 <code>!</code> は、<em>できない</em>が <code>null</code> または <code>undefined</code> であることがわかっている場合にのみ使用することが重要です。</p>\n<h2 id=\"3-13列挙\"><a href=\"#3-13列挙\" class=\"headerlink\" title=\"3.13列挙\"></a>3.13列挙</h2><p>列挙は、TypeScriptがJavaScriptに追加する機能で、名前付き定数の可能なセットの1つである可能性のある値を記述できます。ほとんどのTypeScript機能とは異なり、この<em>いいえ</em>JavaScriptの型レベルの追加は、言語とランタイムのコンテンツに追加されます。したがって、列挙が何かをしている必要があることを確認してください。そうでない場合は使用しないでください。列挙の詳細については、<a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">Enum 参考页 中</a>を参照してください。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ts ソースコード</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// コンパイルされたjsコード</span></span><br><span class=\"line\">(<span class=\"string\">&quot;use strict&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Direction</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"title class_\">Direction</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Up&quot;</span>] = <span class=\"number\">1</span>)] = <span class=\"string\">&quot;Up&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Down&quot;</span>] = <span class=\"number\">2</span>)] = <span class=\"string\">&quot;Down&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Left&quot;</span>] = <span class=\"number\">3</span>)] = <span class=\"string\">&quot;Left&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Right&quot;</span>] = <span class=\"number\">4</span>)] = <span class=\"string\">&quot;Right&quot;</span>;</span><br><span class=\"line\">&#125;)(<span class=\"title class_\">Direction</span> || (<span class=\"title class_\">Direction</span> = &#123;&#125;));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/dvthyFIPKAuBR1s.png\" alt=\"image-20211114112554381\" style=\"zoom:33%;\" />\n\n<h2 id=\"3-14あまり一般的ではない原語\"><a href=\"#3-14あまり一般的ではない原語\" class=\"headerlink\" title=\"3.14あまり一般的ではない原語\"></a>3.14あまり一般的ではない原語</h2><p>特に、JavaScriptの新しいプリミティブのいくつかは、TypeScriptタイプのシステムでも実装されています。まず簡単に2つの例を見てみましょう：</p>\n<ul>\n<li><h4 id=\"bigint\"><a href=\"#bigint\" class=\"headerlink\" title=\"bigint\"></a><code>bigint</code></h4></li>\n</ul>\n<p>ES2020以降、JavaScriptには、非常に大きな整数のプリミティブ <code>BigInt</code> があります。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bigint 関数を使用して bigint を作成する</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">oneHundred</span>: <span class=\"built_in\">bigint</span> = <span class=\"title class_\">BigInt</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// テキスト構文を使用して BigInt を作成する</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">anotherHundred</span>: <span class=\"built_in\">bigint</span> = <span class=\"number\">100n</span>;</span><br></pre></td></tr></table></figure>\n\n<p>BigIntの詳細については<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint\">TypeScript 3.2リリースノート</a>を参照してください。</p>\n<ul>\n<li><h4 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a><code>symbol</code></h4></li>\n</ul>\n<p>JavaScriptには、関数からグローバル一意参照を作成するためのプリミティブ <code>Symbol()</code> があります：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> firstName = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> secondName = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (firstName === secondName) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ここのコードは実行できません</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/ORATaxUgEjrPL9V.png\" alt=\"image-20211114113536948\" style=\"zoom:40%;\" />\n\n<p>タイプ <code>typeof firstName</code> と <code>typeof secondName</code> は重複していないので、この条件は常に <code>false</code> を返します。</p>\n<h3 id=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"><a href=\"#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\" class=\"headerlink\" title=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"></a>特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3>"
      },
      {
        "title": "1-4、基本：TypeScriptの型削減.md",
        "toc": true,
        "abbrlink": 53859,
        "date": "2024-02-15T07:49:54.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 四、類型縮小\n\n`padLeft` という関数があるとします：\n\n```tsx\nfunction padLeft(padding: number | string, input: string): string {\n  throw new Error(\"まだ実装されていません！\");\n}\n```\n\n機能を拡張してみましょう。 `padding` が `number` の場合、 `input` に追加するスペースの数として扱われます、 `padding` が `string` であれば、 `input` 上にのみ `padding` を実行する。次のことを実現してみましょう：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  return new Array(padding + 1).join(\" \") + input;\n}\n```\n\n![image-20211114161343249](/img/TypeScript/04-01.png)\n\nああ、 `padding + 1` でエラーが発生しました。TypeScriptは、演算子 `+` をタイプ `string | number` および `number` に適用できないことを警告していますが、これは正しいです。言い換えれば、 `padding` が `number` であるかどうかを明確にチェックしたり、 `string` である場合に対処したりしていないので、このようにします：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return new Array(padding + 1).join(\" \") + input;\n  }\n  return padding + input;\n}\n```\n\nこのほとんどが面白くないJavaScriptコードのように見えるなら、これもポイントになるでしょう。設定した注釈を除けば、このTypeScriptコードはJavaScriptのように見えます。私たちの考えでは、TypeScriptの型システムは、型セキュリティを獲得するために身をかがめる必要がなく、典型的なJavaScriptコードをできるだけ簡単に記述できるように設計されています。\n\nあまり多くないように見えますが、実はたくさんのものがここにあります。TypeScriptが静的型を使用して実行時の値を分析するのと同様に、JavaScriptの実行時制御フロー構造に、if/else、条件トリプル、ループ、信頼性チェックなどの型の分析を重ねます。\n\n私たちのifチェックでは、TypeScriptは `typeof padding ===\"number\"` と認識し、タイプ保護と呼ばれる特殊な形式のコードとして認識します。TypeScriptは、特定の場所にある値の最も具体的な型を分析するために、プログラムが取り得る実行パスに従います。これらの特殊なチェック(型保護と呼ばれる)と代入を見て、宣言された型よりも具体的な型に型を細分化するプロセスを絞り込みと呼びます。多くのエディタでは、これらの種類の変化を見ることができますし、私たちの例でもそうします。\n\nTypeScriptは、いくつかの異なる縮小構造を理解することができます。\n\n## 4.1 `typeof` タイプガード\n\nここまで見てきたように、JavaScriptは `typeof` 演算子をサポートしています。この演算子は、実行時に所有する値の種類に関する非常に基本的な情報を提供します。TypeScriptは、特定の文字列のセットを返すことを期待します：\n\n- `\"string\"`\n- `\"number\"`\n- `\"bigint\"`\n- `\"boolean\"`\n- `\"symbol\"`\n- `\"undefined\"`\n- `\"object\"`\n- `\"function\"`\n\n`padLeft` に見られるように、この演算子は多くのJavaScriptライブラリによく登場します。TypeScriptは、さまざまな分岐にある型を絞り込むものとして理解できます。\n\nTypeScriptでは、 `typeof` の戻り値をチェックすることが保護型です。TypeScriptは、 `typeof` アクションをエンコードして異なる値を返すので、JavaScriptに何が行われたかを知っています。たとえば、上のリストでは、 `typeof` はstring `null` を返さないことに注意してください。次の例を参照してください：\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  } else {\n    // do something\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png\" alt=\"image-20211114164143361\" style=\"zoom:50%;\" />\n\n関数 `printAll` では、配列型であるかどうかを調べる代わりに、 `strs` がオブジェクトであるかどうかを調べてみます(配列がJavaScriptのオブジェクト型であることを強調するのに適したタイミングかもしれません)。しかし、JavaScriptでは、 `typeof null` も実際には `\"object\"` であることが判明しました。歴史上の不幸な事故の一つだ。\n\n十分な経験を持つユーザーは驚かないかもしれませんが、誰もがJavaScriptでこのような状況に遭遇したことがあるわけではありません。幸いなことに、typescriptは、 `strs` が `string[]` だけではなく、 `string[] | null` に縮小されることを示しています。\n\nこれは、いわゆる「真正性」チェックへの良い移行といえるかもしれません。\n\n## 4.2真理値の縮小\n\n真理値チェックはJavaScriptでよくやっていることです。JavaScriptでは、条件、 `&&`、 `||`、 `if` ステートメント、ブール否定( `!`)などの任意の式を使用できます。たとえば、 `if` ステートメントでは、条件が常に `boolean` 型になることは想定していません。\n\n```tsx\nfunction getUsersOnlineMessage(numUsersOnline: number) {\n  if (numUsersOnline) {\n    return `「合計 ${numUsersOnline} 人が現在オンラインです!」`;\n  }\n  return \"今は誰もオンラインにいません. :(\";\n}\n```\n\nJavaScriptでは、このような `if` 条件ステートメントは、まず条件「強制」を `boolean` に変換して意味を持たせ、その結果が `true` であるか `false` であるかによって分岐を選択します。このような面の値は次のようになります：\n\n- `0`\n- `NaN`\n- `\"\"` (空の文字列)\n- `0n` ( `bigint` ゼロのバージョン)\n- `null`\n- `undefined`\n\nこれらの値は強制的に `false` に変換され、その他の値は強制的に `true` に変換されます。関数 `Boolean` で値を実行して `boolean` を取得するか、短い二重ブール否定を使用して値を強制的に `boolean` に変換することができます。(後者の利点は、TypeScriptが狭いリテラルのboolean型 `true` を推定し、最初の型を `boolean` と推定することです)。\n\n```tsx\n// どちらの結果も true を返します\nBoolean(\"hello\"); // type: boolean, value: true\n!!\"world\"; // type: true, value: true\n```\n\nこの動作を利用することは、特に `null` や `undefined` などの値を防ぐ場合には、非常に一般的である。たとえば、この関数を `printAll` 関数で使用してみましょう。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (strs && typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  }\n}\n```\n\n`strs` が真であるかどうかをチェックすることで、上記のエラーを解消したことにお気づきでしょう。これにより、コードの実行時に次のような恐ろしいエラーが発生するのを防ぐことができます：\n\n```shell\nTypeError: null is not iterable\n```\n\nただし、プリミティブの真理値チェックはしばしば誤りやすいことを覚えておいてください。たとえば、 `printAll` を上書きすることを考えてみましょう。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  // !!!!!!!!!!!!!!!!\n  // そんなことしたらダメ！\n  // 理由は以下の通り\n  // !!!!!!!!!!!!!!!!\n  if (strs) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\n関数本体全体を実際の検査でラッピングしましたが、空の文字列を正しく処理できなくなるという小さな欠点があります。\n\nTypeScriptはここではまったく間違いを報告しませんが、JavaScriptに詳しくない方は注意すべき行動です。TypeScriptは通常、エラーを早期に発見するのに役立ちますが、ある値を*任意*処理しないように選択した場合には、論理的な問題をあまり考慮することなく、これだけのことができます。必要に応じて、linter(プログラムの正規化)を使用してこのような状況に対処することができます。\n\n真正性による絞り込みの最後の点については、論理を否定枝からブール否定 `!` でフィルタリングすることである。\n\n```tsx\nfunction multiplyAll(\n  values: number[] | undefined,\n  factor: number,\n): number[] | undefined {\n  if (!values) {\n    return values;\n  } else {\n    return values.map((x) => x * factor);\n  }\n}\n```\n\n## 4.3等価縮小\n\ntypescriptも分岐文を用いて `===`、 `!==`、 `==`、および `!=` などの値検査を行い、型の絞り込みを実現している。例：\n\n```tsx\nfunction example(x: string | number, y: string | boolean) {\n  if (x === y) {\n    // これで、x、y で文字列型のメソッドを呼び出すことができます。\n    x.toUpperCase();\n    y.toLowerCase();\n  } else {\n    console.log(x);\n    console.log(y);\n  }\n}\n```\n\n上記の例で `x` と `y` が等しいかどうかを調べたとき、TypeScriptはそれらの型も等しくなければならないことを認識しています。 `string` は、 `x` と `y` の両方で使用できる唯一の一般的な型なので、TypeScriptは、 `x` と `y` がいずれも `string` の場合、プログラムは最初の分岐に進みます。\n\n変数ではなく、特定のリテラル値をチェックすることも有効です。真理値の絞り込みについてのセクションでは、空の文字列を正しく処理していないため、エラーが発生しやすい関数 `printAll` を書きました。代わりに、特定のチェックをして `null` をブロックし、TypeScriptが `strs` から `null` を正しく削除したままにすることができます。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (strs !== null) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\nJavaScriptのより緩やかな同等性チェック `==` および `!=` も、適切に縮小されます。変数が `== null` であるかどうかを調べる方法に慣れていない場合は、それが特定の値 `null` であるかどうかだけでなく、 `undefined` であるかもしれないかどうかも調べる必要があるので、どのようにして `== null` であるかどうかを調べる必要があります。これは `== undefined` にも当てはまります。値が `null` または `undefined` であるかどうかがチェックされます。ここでは、この `==` と `!=` だけで済ませることができます。\n\n```tsx\ninterface Container {\n  value: number | null | undefined;\n}\n\nfunction multiplyValue(container: Container, factor: number) {\n  // 未定義と null を型から除外しました\n  if (container.value != null) {\n    console.log(container.value);\n    // これで、「container.value」を安全に乗算できるようになりました。\n    container.value *= factor;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png\" alt=\"image-20211115154532180\" style=\"zoom:50%;\" />\n\n最初の3つの印刷はパスしましたが、4番目に問題がありました。\n\n## 4.4 `in` オペレータ縮小\n\nJavaScriptには、 `in` 演算子を使用して、オブジェクトに属性名があるかどうかを判断する演算子があります。TypeScriptはこの点を考慮して、潜在的なタイプを絞り込んでいます。\n\nたとえば、コード `\"value\" in x` を使用します。ここで、 `\"value\"` は文字列リテラルであり、 `x` は結合型である。値が「true」の分岐は縮小されます。 `x` オプションまたは必須属性を持つタイプの値が必要です。値が「false」の分岐は縮小され、オプションまたは欠落した属性を持つタイプの値が必要になります。\n\n```tsx\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n\nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    return animal.swim();\n  }\n\n  return animal.fly();\n}\n```\n\nまた、オプション属性は縮小の両側にも存在します。たとえば、人間は（適切な装置を使用して）泳いだり飛んだりできるため、 `in` チェックの両側に表示されます：\n\n```tsx\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ntype Human = { swim?: () => void; fly?: () => void };\n\nfunction move(animal: Fish | Bird | Human) {\n  if (\"swim\" in animal) {\n    // animal: Fish | Human\n    animal;\n  } else {\n    // animal: Bird | Human\n    animal;\n  }\n}\n```\n\n## 4.5 `instanceof` オペレータ縮小\n\nJavaScriptには、ある値が別の値の「インスタンス」であるかどうかをチェックする演算子 `instanceof` があります。具体的には、JavaScriptの `x instanceof Foo` で、 `x` の*プロトタイプチェーン*に `Foo.prototype` が含まれているかどうかをチェックします。ここでは詳しく説明しませんが、 `类(class)` の学習に入ると、その多くが `new` キーワードを使ってインスタンス化できることがわかります。すでにお気づきのように、 `instanceof` も型保護であり、TypeScriptは `instanceof` で保護されたブランチの縮小を実装します。\n\n```tsx\nfunction logValue(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toUTCString());\n  } else {\n    console.log(x.toUpperCase());\n  }\n}\n\nlogValue(new Date()); // Mon, 15 Nov 2021 22:34:37 GMT\nlogValue(\"hello ts\"); // HELLO TS\n```\n\n## 4.6配分の縮小\n\n前述したように、任意の変数に値を割り当てると、TypeScriptは割り当てられた値の右側を確認し、左側を適切に縮小します。\n\n```tsx\n// let x: string | number\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\n\nx = 1;\n// let x: number\nconsole.log(x);\n\nx = \"goodbye!\";\n// let x: string\nconsole.log(x);\n```\n\nこれらの割り当てはそれぞれ有効であることに注意してください。最初の代入後に観測されたタイプ `x` が `number` に変更された場合でも、 `string` を `x` に代入することができます。これは、*宣言型*の `x` -このタイプ `x` は `string | number` で始まるためです。\n\n`x` に `boolean` を割り当てると、宣言型の一部ではないため、エラーが表示されます。\n\n```tsx\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\n\n// let x: string | number\nx = 1;\n\n// let x: number\nconsole.log(x);\n\n// エラー！\nx = true;\n\n// let x: string | number\nconsole.log(x);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png\" alt=\"image-20211116065026159\" style=\"zoom: 50%;\" />\n\n## 4.7制御フロー解析\n\nここまで、いくつかの基本的な例を使って、TypeScriptが特定のブランチでどのように絞り込むかを説明してきました。しかし、各変数から出てきて、 `if`、 `while`、条件などで型保護を探す以外にも、やるべきことはたくさんあります。例：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return new Array(padding + 1).join(\" \") + input;\n  }\n  return padding + input;\n}\n```\n\n`padLeft` は、その最初の `if` ブロックから返されます。TypeScriptはこのコードを解析し、paddingが数値の場合、ボディの残りの部分( `return padding + input;`)が到達不可能であることを確認します。このため、関数の残りの部分で使用される `padding` 型から数値を削除(文字列数値から文字列に絞り込む)できます。\n\nこの到達可能性ベースのコード解析は制御フロー解析と呼ばれ、TypeScriptはタイプガードと代入に遭遇するため、このフロー解析を使用してタイプを絞り込みます。各点で異なる型が観察され得る変数を解析すると、制御フローを何度も分割して再結合することができる。\n\n```tsx\nfunction example() {\n  let x: string | number | boolean;\n\n  x = Math.random() < 0.5;\n\n  // let x: boolean\n  console.log(x);\n\n  if (Math.random() < 0.5) {\n    x = \"hello\";\n    // let x: string\n    console.log(x);\n  } else {\n    x = 100;\n    // let x: number\n    console.log(x);\n  }\n\n  // let x: string | number\n  return x;\n}\n\nlet x = example();\nx = \"hello\";\nx = 100;\nx = true; // error\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png\" alt=\"image-20211117203742503\" style=\"zoom:50%;\" />\n\n## 4.8型述語の使用\n\nここまで、我々は既存のJavaScript構造体を用いてナローディングの問題に対処してきましたが、時にはコード全体の型の変化をより直接的に制御したいと思うことがあります。\n\nユーザ定義型保護を定義するには、戻り型が型述語である関数を定義するだけです。\n\n```tsx\ntype Fish = {\n  name: string;\n  swim: () => void;\n};\n\ntype Bird = {\n  name: string;\n  fly: () => void;\n};\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\nこの例では、 `pet is Fish` が型述語です。述語の形式は `parameterName is Type` です。 `parameterName` は、現在の関数のシグネチャ内のパラメータ名である必要があります。\n\n`isFish` が呼び出されるたびに、TypeScriptは元の型が互換性を持っている場合、その変数を特定の型に絞り込みます。\n\n```tsx\nfunction getSmallPet(): Fish | Bird {\n  let fish: Fish = {\n    name: \"gold fish\",\n    swim: () => {},\n  };\n\n  let bird: Bird = {\n    name: \"sparrow\",\n    fly: () => {},\n  };\n\n  return true ? bird : fish;\n}\n\n// ペットのスイムとフライの両方にアクセスできます。\nlet pet = getSmallPet();\nif (isFish(pet)) {\n  pet.swim();\n} else {\n  pet.fly();\n}\n```\n\nTypeScriptは、 `pet` が `if` 分岐で魚であることを知っているだけではないことに注意してください。また、 `else` 枝に `Fish` がないことも知っているので、 `Bird` があるはずです。\n\n型ガード `isFish` を使用して、 `Fish | Bird` の配列をフィルタリングし、 `Fish` の配列を得ることができます。\n\n```tsx\nconst zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];\nconst underWater1: Fish[] = zoo.filter(isFish);\n// または、以下と同等\nconst underWater2: Fish[] = zoo.filter(isFish) as Fish[];\n\n// より複雑な例では、述語を再利用する必要がある場合があります。\nconst underWatch3: Fish[] = zoo.filter((pet): pet is Fish => {\n  if (pet.name === \"frog\") {\n    return false;\n  }\n  return isFish(pet);\n});\n```\n\n## 4.9差別された `unions`\n\nこれまで見てきた例のほとんどは、単純な型( `string`、 `boolean`、 `number` など)を使って個々の変数を絞り込むことを中心にしています。よくあることですが、JavaScriptでは少し複雑な構造体を扱うことが多いです。\n\nインスピレーションを引き出すために、円形や四角などの形をコード化しようとしていると想像してみましょう。円は半径を表し、四角形は辺の長さを表します。 `kind` というフィールドを使用して、どの形状を扱っているかを示します。ここでは、 `Shape` を定義する最初の試みを行います。\n\n```tsx\ninterface Shape {\n  kind: \"circle\" | \"square\";\n  radius?: number;\n  sideLength?: number;\n}\n```\n\n文字列リテラル型の結合を使用していることに注意してください。 `\"circle \"` と ` \"square \"` はそれぞれ、この形状を円形とみなすべきか正方形とみなすべきかを示しています。 `string` ではなく `\"circle\" | \"square \"` を使用することで、スペルミスの問題を回避できます。\n\n```tsx\nfunction handleShape(shape: Shape) {\n  // oops!\n  if (shape.kind === \"rect\") {\n    // ...\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png\" alt=\"image-20211118090404099\" style=\"zoom:50%;\" />\n\n関数 `getArea` を書いて、それが円か正方形かに応じて正しい論理を適用することができます。まず円形を試してみましょう。\n\n```tsx\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png\" alt=\"image-20211118091637002\" style=\"zoom:50%;\" />\n\n`strictNullChecks` では、これは私たちに間違いを与えます。 `radius` が定義されていない可能性があるので、これは適切です。しかし、 `kind` 属性を適切にチェックしたらどうでしょうか。\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png\" alt=\"image-20211118093134890\" style=\"zoom:50%;\" />\n\nまあ、TypeScriptはまだどうすればいいのかわかりません。私たちは、タイプチェッカーが知っている以上に値を知っているという問題に直面しました。空ではないアサーション( `radius` の後にある感嘆符 `!`)を使用して、 `radius` が存在することを示すことができます。\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius! ** 2;\n  }\n}\n```\n\nしかしこの感じは理想的ではありません。空ではないアサーションを使用して、型チェッカーに感嘆符( `！`)を宣言し、 `shape.radius` が定義されていることを納得させる必要がありますが、コードを動かし始めると、これらのアサーションは間違いやすいでしょう。また、 `strictNullChecks` 以外では、これらのフィールドに誤ってアクセスすることもできます(これらのフィールドが読み込まれると、オプション属性が常に存在すると見なされるからです)。私たちは絶対にもっとうまくやることができます。\n\nこのような `Shape` のエンコーディングの問題は、タイプチェッカーが、クラス属性に基づいて `radius` または `sideLength` の存在を知る方法がないことです。私たちが知っていることをタイプチェッカーに伝える必要があります。そのことを考えて、Shapeをもう一度定義してみましょう。\n\n```tsx\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\ninterface Square {\n  kind: \"square\";\n  sideLength: number;\n}\n\ntype Shape = Circle | Square;\n```\n\nここでは、 `Shape` を2つのタイプに正しく分類し、 `kind` 属性に異なる値を設定していますが、 `radius` と `sideLength` はそれぞれのタイプで必須属性として宣言されています。\n\n半径 `Shape` にアクセスしようとするとどうなるか見てみましょう。\n\n```tsx\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png\" alt=\"image-20211118180452972\" style=\"zoom:50%;\" />\n\n最初に定義した `Shape` と同様に、これはまだ間違いです。半径がオプションの場合、TypeScriptではこのアトリビュートが存在するかどうかを判断できないため、エラーが発生しました( `strictNullChecks` のみ)。これで `Shape` がコンソーシアムになり、TypeScriptは `shape` が `Square` である可能性があることを示していますが、Squareは半径 `radius` を定義していません。どちらの解釈も正しいのですが、 `Shape` の新しいエンコーディングだけが、まだ `strictNullChecks` の外側でエラーが発生しています。\n\nしかし、もう一度kind属性をチェックしてみたらどうでしょうか。\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    // shape: Circle\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\nこれで間違いから脱した！ `union` の各型にリテラル型と同じプロパティが含まれている場合、TypeScriptはそれを `union` と見なし、 `union` のメンバーを絞り込むことができます。\n\nこの場合、 `kind` がその共通属性である（これが `Shape` の判別属性である）。 `kind` 属性が `\"circle\"` であることを確認すると、 `Shape` 内の ` \"circle\"` 型属性を持たないすべての型を除外できます。これにより、 `Shape` の範囲は `Circle` というタイプに絞られる。\n\n`switch` 文にも同じチェック方法が適用されます。ここでは、 `！` 空でないアサーションという嫌な感嘆符を付けずに、完全な `getArea` を書いてみましょう。\n\n```tsx\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    // shape: Circle\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n\n    // shape: Square\n    case \"square\":\n      return shape.sideLength ** 2;\n  }\n}\n```\n\nここで最も重要なのは、 `Shape` のエンコーディングである。 `Circle` と `Square` は、実際には特定の種類のフィールドを持つ2つの独立したタイプであるという正しい情報をTypeScriptに伝えることが重要です。このようにすることで、本来書くJavaScriptと変わらないように見えるタイプ安全なTypeScriptコードを書き出すことができます。そこから、型システムは「正しい」ことを行い、私たちの `switch` 文の各分岐内の型を見つけることができます。\n\n> 傍観者として、上記の例をプレイして、リターンキーワードをいくつか外してみてください。型チェックは、switchステートメントの中で誤って別の節に落とし込まれるバグを回避するのに役立ちます。\n\n弁証法的な連合体は、円形と四角の話をするだけではありません。ネットワーク上でメッセージを送信したり( `client/server` トラフィック)、状態管理フレームワークで突然変異をエンコードしたりするなど、JavaScriptであらゆるタイプのメッセージングスキームを表現するのに適しています。\n\n## 4.10 `never` タイプおよび網羅性チェック\n\n絞り込む際には、コンソーシアムの選択肢を、すべての可能性を削除して何も残らない程度に減らすことができます。このような場合、TypeScriptは `never` 型を使用して、存在してはならない状態を表します。\n\n`never` 型は各型に割り当てることができます。ただし、neverに割り当てることができる型はありません(never自体を除く)。つまり、 `switch` 文では、縮小して `never` に依存する出現を使用して詳細なチェックを行うことができます。\n\nたとえば、関数 `getArea` にデフォルト値を追加して、形状を `never` に割り当てようとすると、可能なすべての状況が処理されなかったときに送出されます。\n\n```tsx\ntype Shape = Circle | Square;\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n`Shape` フェデレーションに新しいメンバを追加すると、TypeScriptエラーが発生します。\n\n```tsx\ninterface Triangle {\n  kind: \"triangle\";\n  sideLength: number;\n}\n\ntype Shape = Circle | Square | Triangle;\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png\" alt=\"image-20211118183410201\" style=\"zoom:50%;\" />\n\n### 特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。\n",
        "source": "_posts/日本語/TypeScript/1-4、基本：TypeScriptの型削減.md",
        "raw": "---\ntitle: 1-4、基本：TypeScriptの型削減.md\ntoc: true\ncategories:\n  - 日本語\n  - TypeScript\ntags:\n  - フロントエンド\n  - TypeScript\nabbrlink: 53859\ndate: 2024-02-15 15:49:54\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 四、類型縮小\n\n`padLeft` という関数があるとします：\n\n```tsx\nfunction padLeft(padding: number | string, input: string): string {\n  throw new Error(\"まだ実装されていません！\");\n}\n```\n\n機能を拡張してみましょう。 `padding` が `number` の場合、 `input` に追加するスペースの数として扱われます、 `padding` が `string` であれば、 `input` 上にのみ `padding` を実行する。次のことを実現してみましょう：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  return new Array(padding + 1).join(\" \") + input;\n}\n```\n\n![image-20211114161343249](/img/TypeScript/04-01.png)\n\nああ、 `padding + 1` でエラーが発生しました。TypeScriptは、演算子 `+` をタイプ `string | number` および `number` に適用できないことを警告していますが、これは正しいです。言い換えれば、 `padding` が `number` であるかどうかを明確にチェックしたり、 `string` である場合に対処したりしていないので、このようにします：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return new Array(padding + 1).join(\" \") + input;\n  }\n  return padding + input;\n}\n```\n\nこのほとんどが面白くないJavaScriptコードのように見えるなら、これもポイントになるでしょう。設定した注釈を除けば、このTypeScriptコードはJavaScriptのように見えます。私たちの考えでは、TypeScriptの型システムは、型セキュリティを獲得するために身をかがめる必要がなく、典型的なJavaScriptコードをできるだけ簡単に記述できるように設計されています。\n\nあまり多くないように見えますが、実はたくさんのものがここにあります。TypeScriptが静的型を使用して実行時の値を分析するのと同様に、JavaScriptの実行時制御フロー構造に、if/else、条件トリプル、ループ、信頼性チェックなどの型の分析を重ねます。\n\n私たちのifチェックでは、TypeScriptは `typeof padding ===\"number\"` と認識し、タイプ保護と呼ばれる特殊な形式のコードとして認識します。TypeScriptは、特定の場所にある値の最も具体的な型を分析するために、プログラムが取り得る実行パスに従います。これらの特殊なチェック(型保護と呼ばれる)と代入を見て、宣言された型よりも具体的な型に型を細分化するプロセスを絞り込みと呼びます。多くのエディタでは、これらの種類の変化を見ることができますし、私たちの例でもそうします。\n\nTypeScriptは、いくつかの異なる縮小構造を理解することができます。\n\n## 4.1 `typeof` タイプガード\n\nここまで見てきたように、JavaScriptは `typeof` 演算子をサポートしています。この演算子は、実行時に所有する値の種類に関する非常に基本的な情報を提供します。TypeScriptは、特定の文字列のセットを返すことを期待します：\n\n- `\"string\"`\n- `\"number\"`\n- `\"bigint\"`\n- `\"boolean\"`\n- `\"symbol\"`\n- `\"undefined\"`\n- `\"object\"`\n- `\"function\"`\n\n`padLeft` に見られるように、この演算子は多くのJavaScriptライブラリによく登場します。TypeScriptは、さまざまな分岐にある型を絞り込むものとして理解できます。\n\nTypeScriptでは、 `typeof` の戻り値をチェックすることが保護型です。TypeScriptは、 `typeof` アクションをエンコードして異なる値を返すので、JavaScriptに何が行われたかを知っています。たとえば、上のリストでは、 `typeof` はstring `null` を返さないことに注意してください。次の例を参照してください：\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  } else {\n    // do something\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png\" alt=\"image-20211114164143361\" style=\"zoom:50%;\" />\n\n関数 `printAll` では、配列型であるかどうかを調べる代わりに、 `strs` がオブジェクトであるかどうかを調べてみます(配列がJavaScriptのオブジェクト型であることを強調するのに適したタイミングかもしれません)。しかし、JavaScriptでは、 `typeof null` も実際には `\"object\"` であることが判明しました。歴史上の不幸な事故の一つだ。\n\n十分な経験を持つユーザーは驚かないかもしれませんが、誰もがJavaScriptでこのような状況に遭遇したことがあるわけではありません。幸いなことに、typescriptは、 `strs` が `string[]` だけではなく、 `string[] | null` に縮小されることを示しています。\n\nこれは、いわゆる「真正性」チェックへの良い移行といえるかもしれません。\n\n## 4.2真理値の縮小\n\n真理値チェックはJavaScriptでよくやっていることです。JavaScriptでは、条件、 `&&`、 `||`、 `if` ステートメント、ブール否定( `!`)などの任意の式を使用できます。たとえば、 `if` ステートメントでは、条件が常に `boolean` 型になることは想定していません。\n\n```tsx\nfunction getUsersOnlineMessage(numUsersOnline: number) {\n  if (numUsersOnline) {\n    return `「合計 ${numUsersOnline} 人が現在オンラインです!」`;\n  }\n  return \"今は誰もオンラインにいません. :(\";\n}\n```\n\nJavaScriptでは、このような `if` 条件ステートメントは、まず条件「強制」を `boolean` に変換して意味を持たせ、その結果が `true` であるか `false` であるかによって分岐を選択します。このような面の値は次のようになります：\n\n- `0`\n- `NaN`\n- `\"\"` (空の文字列)\n- `0n` ( `bigint` ゼロのバージョン)\n- `null`\n- `undefined`\n\nこれらの値は強制的に `false` に変換され、その他の値は強制的に `true` に変換されます。関数 `Boolean` で値を実行して `boolean` を取得するか、短い二重ブール否定を使用して値を強制的に `boolean` に変換することができます。(後者の利点は、TypeScriptが狭いリテラルのboolean型 `true` を推定し、最初の型を `boolean` と推定することです)。\n\n```tsx\n// どちらの結果も true を返します\nBoolean(\"hello\"); // type: boolean, value: true\n!!\"world\"; // type: true, value: true\n```\n\nこの動作を利用することは、特に `null` や `undefined` などの値を防ぐ場合には、非常に一般的である。たとえば、この関数を `printAll` 関数で使用してみましょう。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (strs && typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  }\n}\n```\n\n`strs` が真であるかどうかをチェックすることで、上記のエラーを解消したことにお気づきでしょう。これにより、コードの実行時に次のような恐ろしいエラーが発生するのを防ぐことができます：\n\n```shell\nTypeError: null is not iterable\n```\n\nただし、プリミティブの真理値チェックはしばしば誤りやすいことを覚えておいてください。たとえば、 `printAll` を上書きすることを考えてみましょう。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  // !!!!!!!!!!!!!!!!\n  // そんなことしたらダメ！\n  // 理由は以下の通り\n  // !!!!!!!!!!!!!!!!\n  if (strs) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\n関数本体全体を実際の検査でラッピングしましたが、空の文字列を正しく処理できなくなるという小さな欠点があります。\n\nTypeScriptはここではまったく間違いを報告しませんが、JavaScriptに詳しくない方は注意すべき行動です。TypeScriptは通常、エラーを早期に発見するのに役立ちますが、ある値を*任意*処理しないように選択した場合には、論理的な問題をあまり考慮することなく、これだけのことができます。必要に応じて、linter(プログラムの正規化)を使用してこのような状況に対処することができます。\n\n真正性による絞り込みの最後の点については、論理を否定枝からブール否定 `!` でフィルタリングすることである。\n\n```tsx\nfunction multiplyAll(\n  values: number[] | undefined,\n  factor: number,\n): number[] | undefined {\n  if (!values) {\n    return values;\n  } else {\n    return values.map((x) => x * factor);\n  }\n}\n```\n\n## 4.3等価縮小\n\ntypescriptも分岐文を用いて `===`、 `!==`、 `==`、および `!=` などの値検査を行い、型の絞り込みを実現している。例：\n\n```tsx\nfunction example(x: string | number, y: string | boolean) {\n  if (x === y) {\n    // これで、x、y で文字列型のメソッドを呼び出すことができます。\n    x.toUpperCase();\n    y.toLowerCase();\n  } else {\n    console.log(x);\n    console.log(y);\n  }\n}\n```\n\n上記の例で `x` と `y` が等しいかどうかを調べたとき、TypeScriptはそれらの型も等しくなければならないことを認識しています。 `string` は、 `x` と `y` の両方で使用できる唯一の一般的な型なので、TypeScriptは、 `x` と `y` がいずれも `string` の場合、プログラムは最初の分岐に進みます。\n\n変数ではなく、特定のリテラル値をチェックすることも有効です。真理値の絞り込みについてのセクションでは、空の文字列を正しく処理していないため、エラーが発生しやすい関数 `printAll` を書きました。代わりに、特定のチェックをして `null` をブロックし、TypeScriptが `strs` から `null` を正しく削除したままにすることができます。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (strs !== null) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\nJavaScriptのより緩やかな同等性チェック `==` および `!=` も、適切に縮小されます。変数が `== null` であるかどうかを調べる方法に慣れていない場合は、それが特定の値 `null` であるかどうかだけでなく、 `undefined` であるかもしれないかどうかも調べる必要があるので、どのようにして `== null` であるかどうかを調べる必要があります。これは `== undefined` にも当てはまります。値が `null` または `undefined` であるかどうかがチェックされます。ここでは、この `==` と `!=` だけで済ませることができます。\n\n```tsx\ninterface Container {\n  value: number | null | undefined;\n}\n\nfunction multiplyValue(container: Container, factor: number) {\n  // 未定義と null を型から除外しました\n  if (container.value != null) {\n    console.log(container.value);\n    // これで、「container.value」を安全に乗算できるようになりました。\n    container.value *= factor;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png\" alt=\"image-20211115154532180\" style=\"zoom:50%;\" />\n\n最初の3つの印刷はパスしましたが、4番目に問題がありました。\n\n## 4.4 `in` オペレータ縮小\n\nJavaScriptには、 `in` 演算子を使用して、オブジェクトに属性名があるかどうかを判断する演算子があります。TypeScriptはこの点を考慮して、潜在的なタイプを絞り込んでいます。\n\nたとえば、コード `\"value\" in x` を使用します。ここで、 `\"value\"` は文字列リテラルであり、 `x` は結合型である。値が「true」の分岐は縮小されます。 `x` オプションまたは必須属性を持つタイプの値が必要です。値が「false」の分岐は縮小され、オプションまたは欠落した属性を持つタイプの値が必要になります。\n\n```tsx\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n\nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    return animal.swim();\n  }\n\n  return animal.fly();\n}\n```\n\nまた、オプション属性は縮小の両側にも存在します。たとえば、人間は（適切な装置を使用して）泳いだり飛んだりできるため、 `in` チェックの両側に表示されます：\n\n```tsx\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ntype Human = { swim?: () => void; fly?: () => void };\n\nfunction move(animal: Fish | Bird | Human) {\n  if (\"swim\" in animal) {\n    // animal: Fish | Human\n    animal;\n  } else {\n    // animal: Bird | Human\n    animal;\n  }\n}\n```\n\n## 4.5 `instanceof` オペレータ縮小\n\nJavaScriptには、ある値が別の値の「インスタンス」であるかどうかをチェックする演算子 `instanceof` があります。具体的には、JavaScriptの `x instanceof Foo` で、 `x` の*プロトタイプチェーン*に `Foo.prototype` が含まれているかどうかをチェックします。ここでは詳しく説明しませんが、 `类(class)` の学習に入ると、その多くが `new` キーワードを使ってインスタンス化できることがわかります。すでにお気づきのように、 `instanceof` も型保護であり、TypeScriptは `instanceof` で保護されたブランチの縮小を実装します。\n\n```tsx\nfunction logValue(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toUTCString());\n  } else {\n    console.log(x.toUpperCase());\n  }\n}\n\nlogValue(new Date()); // Mon, 15 Nov 2021 22:34:37 GMT\nlogValue(\"hello ts\"); // HELLO TS\n```\n\n## 4.6配分の縮小\n\n前述したように、任意の変数に値を割り当てると、TypeScriptは割り当てられた値の右側を確認し、左側を適切に縮小します。\n\n```tsx\n// let x: string | number\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\n\nx = 1;\n// let x: number\nconsole.log(x);\n\nx = \"goodbye!\";\n// let x: string\nconsole.log(x);\n```\n\nこれらの割り当てはそれぞれ有効であることに注意してください。最初の代入後に観測されたタイプ `x` が `number` に変更された場合でも、 `string` を `x` に代入することができます。これは、*宣言型*の `x` -このタイプ `x` は `string | number` で始まるためです。\n\n`x` に `boolean` を割り当てると、宣言型の一部ではないため、エラーが表示されます。\n\n```tsx\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\n\n// let x: string | number\nx = 1;\n\n// let x: number\nconsole.log(x);\n\n// エラー！\nx = true;\n\n// let x: string | number\nconsole.log(x);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png\" alt=\"image-20211116065026159\" style=\"zoom: 50%;\" />\n\n## 4.7制御フロー解析\n\nここまで、いくつかの基本的な例を使って、TypeScriptが特定のブランチでどのように絞り込むかを説明してきました。しかし、各変数から出てきて、 `if`、 `while`、条件などで型保護を探す以外にも、やるべきことはたくさんあります。例：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return new Array(padding + 1).join(\" \") + input;\n  }\n  return padding + input;\n}\n```\n\n`padLeft` は、その最初の `if` ブロックから返されます。TypeScriptはこのコードを解析し、paddingが数値の場合、ボディの残りの部分( `return padding + input;`)が到達不可能であることを確認します。このため、関数の残りの部分で使用される `padding` 型から数値を削除(文字列数値から文字列に絞り込む)できます。\n\nこの到達可能性ベースのコード解析は制御フロー解析と呼ばれ、TypeScriptはタイプガードと代入に遭遇するため、このフロー解析を使用してタイプを絞り込みます。各点で異なる型が観察され得る変数を解析すると、制御フローを何度も分割して再結合することができる。\n\n```tsx\nfunction example() {\n  let x: string | number | boolean;\n\n  x = Math.random() < 0.5;\n\n  // let x: boolean\n  console.log(x);\n\n  if (Math.random() < 0.5) {\n    x = \"hello\";\n    // let x: string\n    console.log(x);\n  } else {\n    x = 100;\n    // let x: number\n    console.log(x);\n  }\n\n  // let x: string | number\n  return x;\n}\n\nlet x = example();\nx = \"hello\";\nx = 100;\nx = true; // error\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png\" alt=\"image-20211117203742503\" style=\"zoom:50%;\" />\n\n## 4.8型述語の使用\n\nここまで、我々は既存のJavaScript構造体を用いてナローディングの問題に対処してきましたが、時にはコード全体の型の変化をより直接的に制御したいと思うことがあります。\n\nユーザ定義型保護を定義するには、戻り型が型述語である関数を定義するだけです。\n\n```tsx\ntype Fish = {\n  name: string;\n  swim: () => void;\n};\n\ntype Bird = {\n  name: string;\n  fly: () => void;\n};\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\nこの例では、 `pet is Fish` が型述語です。述語の形式は `parameterName is Type` です。 `parameterName` は、現在の関数のシグネチャ内のパラメータ名である必要があります。\n\n`isFish` が呼び出されるたびに、TypeScriptは元の型が互換性を持っている場合、その変数を特定の型に絞り込みます。\n\n```tsx\nfunction getSmallPet(): Fish | Bird {\n  let fish: Fish = {\n    name: \"gold fish\",\n    swim: () => {},\n  };\n\n  let bird: Bird = {\n    name: \"sparrow\",\n    fly: () => {},\n  };\n\n  return true ? bird : fish;\n}\n\n// ペットのスイムとフライの両方にアクセスできます。\nlet pet = getSmallPet();\nif (isFish(pet)) {\n  pet.swim();\n} else {\n  pet.fly();\n}\n```\n\nTypeScriptは、 `pet` が `if` 分岐で魚であることを知っているだけではないことに注意してください。また、 `else` 枝に `Fish` がないことも知っているので、 `Bird` があるはずです。\n\n型ガード `isFish` を使用して、 `Fish | Bird` の配列をフィルタリングし、 `Fish` の配列を得ることができます。\n\n```tsx\nconst zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];\nconst underWater1: Fish[] = zoo.filter(isFish);\n// または、以下と同等\nconst underWater2: Fish[] = zoo.filter(isFish) as Fish[];\n\n// より複雑な例では、述語を再利用する必要がある場合があります。\nconst underWatch3: Fish[] = zoo.filter((pet): pet is Fish => {\n  if (pet.name === \"frog\") {\n    return false;\n  }\n  return isFish(pet);\n});\n```\n\n## 4.9差別された `unions`\n\nこれまで見てきた例のほとんどは、単純な型( `string`、 `boolean`、 `number` など)を使って個々の変数を絞り込むことを中心にしています。よくあることですが、JavaScriptでは少し複雑な構造体を扱うことが多いです。\n\nインスピレーションを引き出すために、円形や四角などの形をコード化しようとしていると想像してみましょう。円は半径を表し、四角形は辺の長さを表します。 `kind` というフィールドを使用して、どの形状を扱っているかを示します。ここでは、 `Shape` を定義する最初の試みを行います。\n\n```tsx\ninterface Shape {\n  kind: \"circle\" | \"square\";\n  radius?: number;\n  sideLength?: number;\n}\n```\n\n文字列リテラル型の結合を使用していることに注意してください。 `\"circle \"` と ` \"square \"` はそれぞれ、この形状を円形とみなすべきか正方形とみなすべきかを示しています。 `string` ではなく `\"circle\" | \"square \"` を使用することで、スペルミスの問題を回避できます。\n\n```tsx\nfunction handleShape(shape: Shape) {\n  // oops!\n  if (shape.kind === \"rect\") {\n    // ...\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png\" alt=\"image-20211118090404099\" style=\"zoom:50%;\" />\n\n関数 `getArea` を書いて、それが円か正方形かに応じて正しい論理を適用することができます。まず円形を試してみましょう。\n\n```tsx\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png\" alt=\"image-20211118091637002\" style=\"zoom:50%;\" />\n\n`strictNullChecks` では、これは私たちに間違いを与えます。 `radius` が定義されていない可能性があるので、これは適切です。しかし、 `kind` 属性を適切にチェックしたらどうでしょうか。\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png\" alt=\"image-20211118093134890\" style=\"zoom:50%;\" />\n\nまあ、TypeScriptはまだどうすればいいのかわかりません。私たちは、タイプチェッカーが知っている以上に値を知っているという問題に直面しました。空ではないアサーション( `radius` の後にある感嘆符 `!`)を使用して、 `radius` が存在することを示すことができます。\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius! ** 2;\n  }\n}\n```\n\nしかしこの感じは理想的ではありません。空ではないアサーションを使用して、型チェッカーに感嘆符( `！`)を宣言し、 `shape.radius` が定義されていることを納得させる必要がありますが、コードを動かし始めると、これらのアサーションは間違いやすいでしょう。また、 `strictNullChecks` 以外では、これらのフィールドに誤ってアクセスすることもできます(これらのフィールドが読み込まれると、オプション属性が常に存在すると見なされるからです)。私たちは絶対にもっとうまくやることができます。\n\nこのような `Shape` のエンコーディングの問題は、タイプチェッカーが、クラス属性に基づいて `radius` または `sideLength` の存在を知る方法がないことです。私たちが知っていることをタイプチェッカーに伝える必要があります。そのことを考えて、Shapeをもう一度定義してみましょう。\n\n```tsx\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\ninterface Square {\n  kind: \"square\";\n  sideLength: number;\n}\n\ntype Shape = Circle | Square;\n```\n\nここでは、 `Shape` を2つのタイプに正しく分類し、 `kind` 属性に異なる値を設定していますが、 `radius` と `sideLength` はそれぞれのタイプで必須属性として宣言されています。\n\n半径 `Shape` にアクセスしようとするとどうなるか見てみましょう。\n\n```tsx\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png\" alt=\"image-20211118180452972\" style=\"zoom:50%;\" />\n\n最初に定義した `Shape` と同様に、これはまだ間違いです。半径がオプションの場合、TypeScriptではこのアトリビュートが存在するかどうかを判断できないため、エラーが発生しました( `strictNullChecks` のみ)。これで `Shape` がコンソーシアムになり、TypeScriptは `shape` が `Square` である可能性があることを示していますが、Squareは半径 `radius` を定義していません。どちらの解釈も正しいのですが、 `Shape` の新しいエンコーディングだけが、まだ `strictNullChecks` の外側でエラーが発生しています。\n\nしかし、もう一度kind属性をチェックしてみたらどうでしょうか。\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    // shape: Circle\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\nこれで間違いから脱した！ `union` の各型にリテラル型と同じプロパティが含まれている場合、TypeScriptはそれを `union` と見なし、 `union` のメンバーを絞り込むことができます。\n\nこの場合、 `kind` がその共通属性である（これが `Shape` の判別属性である）。 `kind` 属性が `\"circle\"` であることを確認すると、 `Shape` 内の ` \"circle\"` 型属性を持たないすべての型を除外できます。これにより、 `Shape` の範囲は `Circle` というタイプに絞られる。\n\n`switch` 文にも同じチェック方法が適用されます。ここでは、 `！` 空でないアサーションという嫌な感嘆符を付けずに、完全な `getArea` を書いてみましょう。\n\n```tsx\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    // shape: Circle\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n\n    // shape: Square\n    case \"square\":\n      return shape.sideLength ** 2;\n  }\n}\n```\n\nここで最も重要なのは、 `Shape` のエンコーディングである。 `Circle` と `Square` は、実際には特定の種類のフィールドを持つ2つの独立したタイプであるという正しい情報をTypeScriptに伝えることが重要です。このようにすることで、本来書くJavaScriptと変わらないように見えるタイプ安全なTypeScriptコードを書き出すことができます。そこから、型システムは「正しい」ことを行い、私たちの `switch` 文の各分岐内の型を見つけることができます。\n\n> 傍観者として、上記の例をプレイして、リターンキーワードをいくつか外してみてください。型チェックは、switchステートメントの中で誤って別の節に落とし込まれるバグを回避するのに役立ちます。\n\n弁証法的な連合体は、円形と四角の話をするだけではありません。ネットワーク上でメッセージを送信したり( `client/server` トラフィック)、状態管理フレームワークで突然変異をエンコードしたりするなど、JavaScriptであらゆるタイプのメッセージングスキームを表現するのに適しています。\n\n## 4.10 `never` タイプおよび網羅性チェック\n\n絞り込む際には、コンソーシアムの選択肢を、すべての可能性を削除して何も残らない程度に減らすことができます。このような場合、TypeScriptは `never` 型を使用して、存在してはならない状態を表します。\n\n`never` 型は各型に割り当てることができます。ただし、neverに割り当てることができる型はありません(never自体を除く)。つまり、 `switch` 文では、縮小して `never` に依存する出現を使用して詳細なチェックを行うことができます。\n\nたとえば、関数 `getArea` にデフォルト値を追加して、形状を `never` に割り当てようとすると、可能なすべての状況が処理されなかったときに送出されます。\n\n```tsx\ntype Shape = Circle | Square;\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n`Shape` フェデレーションに新しいメンバを追加すると、TypeScriptエラーが発生します。\n\n```tsx\ninterface Triangle {\n  kind: \"triangle\";\n  sideLength: number;\n}\n\ntype Shape = Circle | Square | Triangle;\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png\" alt=\"image-20211118183410201\" style=\"zoom:50%;\" />\n\n### 特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。\n",
        "slug": "日本語/TypeScript/1-4、基本：TypeScriptの型削減",
        "published": 1,
        "updated": "2024-02-15T08:24:18.086Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjany000994v3aur521wh",
        "content": "<h1 id=\"四、類型縮小\"><a href=\"#四、類型縮小\" class=\"headerlink\" title=\"四、類型縮小\"></a>四、類型縮小</h1><p><code>padLeft</code> という関数があるとします：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;まだ実装されていません！&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>機能を拡張してみましょう。 <code>padding</code> が <code>number</code> の場合、 <code>input</code> に追加するスペースの数として扱われます、 <code>padding</code> が <code>string</code> であれば、 <code>input</code> 上にのみ <code>padding</code> を実行する。次のことを実現してみましょう：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/04-01.png\" alt=\"image-20211114161343249\"></p>\n<p>ああ、 <code>padding + 1</code> でエラーが発生しました。TypeScriptは、演算子 <code>+</code> をタイプ <code>string | number</code> および <code>number</code> に適用できないことを警告していますが、これは正しいです。言い換えれば、 <code>padding</code> が <code>number</code> であるかどうかを明確にチェックしたり、 <code>string</code> である場合に対処したりしていないので、このようにします：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> padding + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>このほとんどが面白くないJavaScriptコードのように見えるなら、これもポイントになるでしょう。設定した注釈を除けば、このTypeScriptコードはJavaScriptのように見えます。私たちの考えでは、TypeScriptの型システムは、型セキュリティを獲得するために身をかがめる必要がなく、典型的なJavaScriptコードをできるだけ簡単に記述できるように設計されています。</p>\n<p>あまり多くないように見えますが、実はたくさんのものがここにあります。TypeScriptが静的型を使用して実行時の値を分析するのと同様に、JavaScriptの実行時制御フロー構造に、if&#x2F;else、条件トリプル、ループ、信頼性チェックなどの型の分析を重ねます。</p>\n<p>私たちのifチェックでは、TypeScriptは <code>typeof padding ===&quot;number&quot;</code> と認識し、タイプ保護と呼ばれる特殊な形式のコードとして認識します。TypeScriptは、特定の場所にある値の最も具体的な型を分析するために、プログラムが取り得る実行パスに従います。これらの特殊なチェック(型保護と呼ばれる)と代入を見て、宣言された型よりも具体的な型に型を細分化するプロセスを絞り込みと呼びます。多くのエディタでは、これらの種類の変化を見ることができますし、私たちの例でもそうします。</p>\n<p>TypeScriptは、いくつかの異なる縮小構造を理解することができます。</p>\n<h2 id=\"4-1-typeof-タイプガード\"><a href=\"#4-1-typeof-タイプガード\" class=\"headerlink\" title=\"4.1 typeof タイプガード\"></a>4.1 <code>typeof</code> タイプガード</h2><p>ここまで見てきたように、JavaScriptは <code>typeof</code> 演算子をサポートしています。この演算子は、実行時に所有する値の種類に関する非常に基本的な情報を提供します。TypeScriptは、特定の文字列のセットを返すことを期待します：</p>\n<ul>\n<li><code>&quot;string&quot;</code></li>\n<li><code>&quot;number&quot;</code></li>\n<li><code>&quot;bigint&quot;</code></li>\n<li><code>&quot;boolean&quot;</code></li>\n<li><code>&quot;symbol&quot;</code></li>\n<li><code>&quot;undefined&quot;</code></li>\n<li><code>&quot;object&quot;</code></li>\n<li><code>&quot;function&quot;</code></li>\n</ul>\n<p><code>padLeft</code> に見られるように、この演算子は多くのJavaScriptライブラリによく登場します。TypeScriptは、さまざまな分岐にある型を絞り込むものとして理解できます。</p>\n<p>TypeScriptでは、 <code>typeof</code> の戻り値をチェックすることが保護型です。TypeScriptは、 <code>typeof</code> アクションをエンコードして異なる値を返すので、JavaScriptに何が行われたかを知っています。たとえば、上のリストでは、 <code>typeof</code> はstring <code>null</code> を返さないことに注意してください。次の例を参照してください：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png\" alt=\"image-20211114164143361\" style=\"zoom:50%;\" />\n\n<p>関数 <code>printAll</code> では、配列型であるかどうかを調べる代わりに、 <code>strs</code> がオブジェクトであるかどうかを調べてみます(配列がJavaScriptのオブジェクト型であることを強調するのに適したタイミングかもしれません)。しかし、JavaScriptでは、 <code>typeof null</code> も実際には <code>&quot;object&quot;</code> であることが判明しました。歴史上の不幸な事故の一つだ。</p>\n<p>十分な経験を持つユーザーは驚かないかもしれませんが、誰もがJavaScriptでこのような状況に遭遇したことがあるわけではありません。幸いなことに、typescriptは、 <code>strs</code> が <code>string[]</code> だけではなく、 <code>string[] | null</code> に縮小されることを示しています。</p>\n<p>これは、いわゆる「真正性」チェックへの良い移行といえるかもしれません。</p>\n<h2 id=\"4-2真理値の縮小\"><a href=\"#4-2真理値の縮小\" class=\"headerlink\" title=\"4.2真理値の縮小\"></a>4.2真理値の縮小</h2><p>真理値チェックはJavaScriptでよくやっていることです。JavaScriptでは、条件、 <code>&amp;&amp;</code>、 <code>||</code>、 <code>if</code> ステートメント、ブール否定( <code>!</code>)などの任意の式を使用できます。たとえば、 <code>if</code> ステートメントでは、条件が常に <code>boolean</code> 型になることは想定していません。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getUsersOnlineMessage</span>(<span class=\"params\"><span class=\"attr\">numUsersOnline</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numUsersOnline) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`「合計 <span class=\"subst\">$&#123;numUsersOnline&#125;</span> 人が現在オンラインです!」`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;今は誰もオンラインにいません. :(&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScriptでは、このような <code>if</code> 条件ステートメントは、まず条件「強制」を <code>boolean</code> に変換して意味を持たせ、その結果が <code>true</code> であるか <code>false</code> であるかによって分岐を選択します。このような面の値は次のようになります：</p>\n<ul>\n<li><code>0</code></li>\n<li><code>NaN</code></li>\n<li><code>&quot;&quot;</code> (空の文字列)</li>\n<li><code>0n</code> ( <code>bigint</code> ゼロのバージョン)</li>\n<li><code>null</code></li>\n<li><code>undefined</code></li>\n</ul>\n<p>これらの値は強制的に <code>false</code> に変換され、その他の値は強制的に <code>true</code> に変換されます。関数 <code>Boolean</code> で値を実行して <code>boolean</code> を取得するか、短い二重ブール否定を使用して値を強制的に <code>boolean</code> に変換することができます。(後者の利点は、TypeScriptが狭いリテラルのboolean型 <code>true</code> を推定し、最初の型を <code>boolean</code> と推定することです)。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// どちらの結果も true を返します</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"string\">&quot;hello&quot;</span>); <span class=\"comment\">// type: boolean, value: true</span></span><br><span class=\"line\">!!<span class=\"string\">&quot;world&quot;</span>; <span class=\"comment\">// type: true, value: true</span></span><br></pre></td></tr></table></figure>\n\n<p>この動作を利用することは、特に <code>null</code> や <code>undefined</code> などの値を防ぐ場合には、非常に一般的である。たとえば、この関数を <code>printAll</code> 関数で使用してみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs &amp;&amp; <span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>strs</code> が真であるかどうかをチェックすることで、上記のエラーを解消したことにお気づきでしょう。これにより、コードの実行時に次のような恐ろしいエラーが発生するのを防ぐことができます：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: null is not iterable</span><br></pre></td></tr></table></figure>\n\n<p>ただし、プリミティブの真理値チェックはしばしば誤りやすいことを覚えておいてください。たとえば、 <code>printAll</code> を上書きすることを考えてみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// !!!!!!!!!!!!!!!!</span></span><br><span class=\"line\">  <span class=\"comment\">// そんなことしたらダメ！</span></span><br><span class=\"line\">  <span class=\"comment\">// 理由は以下の通り</span></span><br><span class=\"line\">  <span class=\"comment\">// !!!!!!!!!!!!!!!!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>関数本体全体を実際の検査でラッピングしましたが、空の文字列を正しく処理できなくなるという小さな欠点があります。</p>\n<p>TypeScriptはここではまったく間違いを報告しませんが、JavaScriptに詳しくない方は注意すべき行動です。TypeScriptは通常、エラーを早期に発見するのに役立ちますが、ある値を<em>任意</em>処理しないように選択した場合には、論理的な問題をあまり考慮することなく、これだけのことができます。必要に応じて、linter(プログラムの正規化)を使用してこのような状況に対処することができます。</p>\n<p>真正性による絞り込みの最後の点については、論理を否定枝からブール否定 <code>!</code> でフィルタリングすることである。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiplyAll</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">values</span>: <span class=\"built_in\">number</span>[] | <span class=\"literal\">undefined</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">factor</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"built_in\">number</span>[] | <span class=\"literal\">undefined</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!values) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * factor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3等価縮小\"><a href=\"#4-3等価縮小\" class=\"headerlink\" title=\"4.3等価縮小\"></a>4.3等価縮小</h2><p>typescriptも分岐文を用いて <code>===</code>、 <code>!==</code>、 <code>==</code>、および <code>!=</code> などの値検査を行い、型の絞り込みを実現している。例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// これで、x、y で文字列型のメソッドを呼び出すことができます。</span></span><br><span class=\"line\">    x.<span class=\"title function_\">toUpperCase</span>();</span><br><span class=\"line\">    y.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上記の例で <code>x</code> と <code>y</code> が等しいかどうかを調べたとき、TypeScriptはそれらの型も等しくなければならないことを認識しています。 <code>string</code> は、 <code>x</code> と <code>y</code> の両方で使用できる唯一の一般的な型なので、TypeScriptは、 <code>x</code> と <code>y</code> がいずれも <code>string</code> の場合、プログラムは最初の分岐に進みます。</p>\n<p>変数ではなく、特定のリテラル値をチェックすることも有効です。真理値の絞り込みについてのセクションでは、空の文字列を正しく処理していないため、エラーが発生しやすい関数 <code>printAll</code> を書きました。代わりに、特定のチェックをして <code>null</code> をブロックし、TypeScriptが <code>strs</code> から <code>null</code> を正しく削除したままにすることができます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScriptのより緩やかな同等性チェック <code>==</code> および <code>!=</code> も、適切に縮小されます。変数が <code>== null</code> であるかどうかを調べる方法に慣れていない場合は、それが特定の値 <code>null</code> であるかどうかだけでなく、 <code>undefined</code> であるかもしれないかどうかも調べる必要があるので、どのようにして <code>== null</code> であるかどうかを調べる必要があります。これは <code>== undefined</code> にも当てはまります。値が <code>null</code> または <code>undefined</code> であるかどうかがチェックされます。ここでは、この <code>==</code> と <code>!=</code> だけで済ませることができます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Container</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiplyValue</span>(<span class=\"params\"><span class=\"attr\">container</span>: <span class=\"title class_\">Container</span>, <span class=\"attr\">factor</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 未定義と null を型から除外しました</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (container.<span class=\"property\">value</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(container.<span class=\"property\">value</span>);</span><br><span class=\"line\">    <span class=\"comment\">// これで、「container.value」を安全に乗算できるようになりました。</span></span><br><span class=\"line\">    container.<span class=\"property\">value</span> *= factor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png\" alt=\"image-20211115154532180\" style=\"zoom:50%;\" />\n\n<p>最初の3つの印刷はパスしましたが、4番目に問題がありました。</p>\n<h2 id=\"4-4-in-オペレータ縮小\"><a href=\"#4-4-in-オペレータ縮小\" class=\"headerlink\" title=\"4.4 in オペレータ縮小\"></a>4.4 <code>in</code> オペレータ縮小</h2><p>JavaScriptには、 <code>in</code> 演算子を使用して、オブジェクトに属性名があるかどうかを判断する演算子があります。TypeScriptはこの点を考慮して、潜在的なタイプを絞り込んでいます。</p>\n<p>たとえば、コード <code>&quot;value&quot; in x</code> を使用します。ここで、 <code>&quot;value&quot;</code> は文字列リテラルであり、 <code>x</code> は結合型である。値が「true」の分岐は縮小されます。 <code>x</code> オプションまたは必須属性を持つタイプの値が必要です。値が「false」の分岐は縮小され、オプションまたは欠落した属性を持つタイプの値が必要になります。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123; <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123; <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">move</span>(<span class=\"params\"><span class=\"attr\">animal</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&quot;swim&quot;</span> <span class=\"keyword\">in</span> animal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> animal.<span class=\"title function_\">swim</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> animal.<span class=\"title function_\">fly</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>また、オプション属性は縮小の両側にも存在します。たとえば、人間は（適切な装置を使用して）泳いだり飛んだりできるため、 <code>in</code> チェックの両側に表示されます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123; <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123; <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Human</span> = &#123; <span class=\"attr\">swim</span>?: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>; <span class=\"attr\">fly</span>?: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">move</span>(<span class=\"params\"><span class=\"attr\">animal</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span> | <span class=\"title class_\">Human</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&quot;swim&quot;</span> <span class=\"keyword\">in</span> animal) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// animal: Fish | Human</span></span><br><span class=\"line\">    animal;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// animal: Bird | Human</span></span><br><span class=\"line\">    animal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-5-instanceof-オペレータ縮小\"><a href=\"#4-5-instanceof-オペレータ縮小\" class=\"headerlink\" title=\"4.5 instanceof オペレータ縮小\"></a>4.5 <code>instanceof</code> オペレータ縮小</h2><p>JavaScriptには、ある値が別の値の「インスタンス」であるかどうかをチェックする演算子 <code>instanceof</code> があります。具体的には、JavaScriptの <code>x instanceof Foo</code> で、 <code>x</code> の<em>プロトタイプチェーン</em>に <code>Foo.prototype</code> が含まれているかどうかをチェックします。ここでは詳しく説明しませんが、 <code>类(class)</code> の学習に入ると、その多くが <code>new</code> キーワードを使ってインスタンス化できることがわかります。すでにお気づきのように、 <code>instanceof</code> も型保護であり、TypeScriptは <code>instanceof</code> で保護されたブランチの縮小を実装します。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logValue</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Date</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Date</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"title function_\">toUTCString</span>());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">logValue</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()); <span class=\"comment\">// Mon, 15 Nov 2021 22:34:37 GMT</span></span><br><span class=\"line\"><span class=\"title function_\">logValue</span>(<span class=\"string\">&quot;hello ts&quot;</span>); <span class=\"comment\">// HELLO TS</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-6配分の縮小\"><a href=\"#4-6配分の縮小\" class=\"headerlink\" title=\"4.6配分の縮小\"></a>4.6配分の縮小</h2><p>前述したように、任意の変数に値を割り当てると、TypeScriptは割り当てられた値の右側を確認し、左側を適切に縮小します。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span> ? <span class=\"number\">10</span> : <span class=\"string\">&quot;hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&quot;goodbye!&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// let x: string</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<p>これらの割り当てはそれぞれ有効であることに注意してください。最初の代入後に観測されたタイプ <code>x</code> が <code>number</code> に変更された場合でも、 <code>string</code> を <code>x</code> に代入することができます。これは、<em>宣言型</em>の <code>x</code> -このタイプ <code>x</code> は <code>string | number</code> で始まるためです。</p>\n<p><code>x</code> に <code>boolean</code> を割り当てると、宣言型の一部ではないため、エラーが表示されます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span> ? <span class=\"number\">10</span> : <span class=\"string\">&quot;hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// エラー！</span></span><br><span class=\"line\">x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png\" alt=\"image-20211116065026159\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-7制御フロー解析\"><a href=\"#4-7制御フロー解析\" class=\"headerlink\" title=\"4.7制御フロー解析\"></a>4.7制御フロー解析</h2><p>ここまで、いくつかの基本的な例を使って、TypeScriptが特定のブランチでどのように絞り込むかを説明してきました。しかし、各変数から出てきて、 <code>if</code>、 <code>while</code>、条件などで型保護を探す以外にも、やるべきことはたくさんあります。例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> padding + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>padLeft</code> は、その最初の <code>if</code> ブロックから返されます。TypeScriptはこのコードを解析し、paddingが数値の場合、ボディの残りの部分( <code>return padding + input;</code>)が到達不可能であることを確認します。このため、関数の残りの部分で使用される <code>padding</code> 型から数値を削除(文字列数値から文字列に絞り込む)できます。</p>\n<p>この到達可能性ベースのコード解析は制御フロー解析と呼ばれ、TypeScriptはタイプガードと代入に遭遇するため、このフロー解析を使用してタイプを絞り込みます。各点で異なる型が観察され得る変数を解析すると、制御フローを何度も分割して再結合することができる。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// let x: boolean</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span>) &#123;</span><br><span class=\"line\">    x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// let x: string</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">// let x: number</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title function_\">example</span>();</span><br><span class=\"line\">x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">x = <span class=\"number\">100</span>;</span><br><span class=\"line\">x = <span class=\"literal\">true</span>; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png\" alt=\"image-20211117203742503\" style=\"zoom:50%;\" />\n\n<h2 id=\"4-8型述語の使用\"><a href=\"#4-8型述語の使用\" class=\"headerlink\" title=\"4.8型述語の使用\"></a>4.8型述語の使用</h2><p>ここまで、我々は既存のJavaScript構造体を用いてナローディングの問題に対処してきましたが、時にはコード全体の型の変化をより直接的に制御したいと思うことがあります。</p>\n<p>ユーザ定義型保護を定義するには、戻り型が型述語である関数を定義するだけです。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isFish</span>(<span class=\"params\"><span class=\"attr\">pet</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span></span>): pet is <span class=\"title class_\">Fish</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> <span class=\"title class_\">Fish</span>).<span class=\"property\">swim</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>この例では、 <code>pet is Fish</code> が型述語です。述語の形式は <code>parameterName is Type</code> です。 <code>parameterName</code> は、現在の関数のシグネチャ内のパラメータ名である必要があります。</p>\n<p><code>isFish</code> が呼び出されるたびに、TypeScriptは元の型が互換性を持っている場合、その変数を特定の型に絞り込みます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">fish</span>: <span class=\"title class_\">Fish</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;gold fish&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">bird</span>: <span class=\"title class_\">Bird</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;sparrow&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span> ? bird : fish;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ペットのスイムとフライの両方にアクセスできます。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"title function_\">getSmallPet</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"title function_\">isFish</span>(pet)) &#123;</span><br><span class=\"line\">  pet.<span class=\"title function_\">swim</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.<span class=\"title function_\">fly</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScriptは、 <code>pet</code> が <code>if</code> 分岐で魚であることを知っているだけではないことに注意してください。また、 <code>else</code> 枝に <code>Fish</code> がないことも知っているので、 <code>Bird</code> があるはずです。</p>\n<p>型ガード <code>isFish</code> を使用して、 <code>Fish | Bird</code> の配列をフィルタリングし、 <code>Fish</code> の配列を得ることができます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">zoo</span>: (<span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span>)[] = [<span class=\"title function_\">getSmallPet</span>(), <span class=\"title function_\">getSmallPet</span>(), <span class=\"title function_\">getSmallPet</span>()];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWater1</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>(isFish);</span><br><span class=\"line\"><span class=\"comment\">// または、以下と同等</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWater2</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>(isFish) <span class=\"keyword\">as</span> <span class=\"title class_\">Fish</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// より複雑な例では、述語を再利用する必要がある場合があります。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWatch3</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>((pet): pet is <span class=\"title class_\">Fish</span> =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pet.<span class=\"property\">name</span> === <span class=\"string\">&quot;frog&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isFish</span>(pet);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-9差別された-unions\"><a href=\"#4-9差別された-unions\" class=\"headerlink\" title=\"4.9差別された unions\"></a>4.9差別された <code>unions</code></h2><p>これまで見てきた例のほとんどは、単純な型( <code>string</code>、 <code>boolean</code>、 <code>number</code> など)を使って個々の変数を絞り込むことを中心にしています。よくあることですが、JavaScriptでは少し複雑な構造体を扱うことが多いです。</p>\n<p>インスピレーションを引き出すために、円形や四角などの形をコード化しようとしていると想像してみましょう。円は半径を表し、四角形は辺の長さを表します。 <code>kind</code> というフィールドを使用して、どの形状を扱っているかを示します。ここでは、 <code>Shape</code> を定義する最初の試みを行います。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span> | <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>文字列リテラル型の結合を使用していることに注意してください。 <code>&quot;circle &quot;</code> と <code> &quot;square &quot;</code> はそれぞれ、この形状を円形とみなすべきか正方形とみなすべきかを示しています。 <code>string</code> ではなく <code>&quot;circle&quot; | &quot;square &quot;</code> を使用することで、スペルミスの問題を回避できます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleShape</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// oops!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;rect&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png\" alt=\"image-20211118090404099\" style=\"zoom:50%;\" />\n\n<p>関数 <code>getArea</code> を書いて、それが円か正方形かに応じて正しい論理を適用することができます。まず円形を試してみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png\" alt=\"image-20211118091637002\" style=\"zoom:50%;\" />\n\n<p><code>strictNullChecks</code> では、これは私たちに間違いを与えます。 <code>radius</code> が定義されていない可能性があるので、これは適切です。しかし、 <code>kind</code> 属性を適切にチェックしたらどうでしょうか。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png\" alt=\"image-20211118093134890\" style=\"zoom:50%;\" />\n\n<p>まあ、TypeScriptはまだどうすればいいのかわかりません。私たちは、タイプチェッカーが知っている以上に値を知っているという問題に直面しました。空ではないアサーション( <code>radius</code> の後にある感嘆符 <code>!</code>)を使用して、 <code>radius</code> が存在することを示すことができます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span>! ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>しかしこの感じは理想的ではありません。空ではないアサーションを使用して、型チェッカーに感嘆符( <code>！</code>)を宣言し、 <code>shape.radius</code> が定義されていることを納得させる必要がありますが、コードを動かし始めると、これらのアサーションは間違いやすいでしょう。また、 <code>strictNullChecks</code> 以外では、これらのフィールドに誤ってアクセスすることもできます(これらのフィールドが読み込まれると、オプション属性が常に存在すると見なされるからです)。私たちは絶対にもっとうまくやることができます。</p>\n<p>このような <code>Shape</code> のエンコーディングの問題は、タイプチェッカーが、クラス属性に基づいて <code>radius</code> または <code>sideLength</code> の存在を知る方法がないことです。私たちが知っていることをタイプチェッカーに伝える必要があります。そのことを考えて、Shapeをもう一度定義してみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span>;</span><br></pre></td></tr></table></figure>\n\n<p>ここでは、 <code>Shape</code> を2つのタイプに正しく分類し、 <code>kind</code> 属性に異なる値を設定していますが、 <code>radius</code> と <code>sideLength</code> はそれぞれのタイプで必須属性として宣言されています。</p>\n<p>半径 <code>Shape</code> にアクセスしようとするとどうなるか見てみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png\" alt=\"image-20211118180452972\" style=\"zoom:50%;\" />\n\n<p>最初に定義した <code>Shape</code> と同様に、これはまだ間違いです。半径がオプションの場合、TypeScriptではこのアトリビュートが存在するかどうかを判断できないため、エラーが発生しました( <code>strictNullChecks</code> のみ)。これで <code>Shape</code> がコンソーシアムになり、TypeScriptは <code>shape</code> が <code>Square</code> である可能性があることを示していますが、Squareは半径 <code>radius</code> を定義していません。どちらの解釈も正しいのですが、 <code>Shape</code> の新しいエンコーディングだけが、まだ <code>strictNullChecks</code> の外側でエラーが発生しています。</p>\n<p>しかし、もう一度kind属性をチェックしてみたらどうでしょうか。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// shape: Circle</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>これで間違いから脱した！ <code>union</code> の各型にリテラル型と同じプロパティが含まれている場合、TypeScriptはそれを <code>union</code> と見なし、 <code>union</code> のメンバーを絞り込むことができます。</p>\n<p>この場合、 <code>kind</code> がその共通属性である（これが <code>Shape</code> の判別属性である）。 <code>kind</code> 属性が <code>&quot;circle&quot;</code> であることを確認すると、 <code>Shape</code> 内の <code> &quot;circle&quot;</code> 型属性を持たないすべての型を除外できます。これにより、 <code>Shape</code> の範囲は <code>Circle</code> というタイプに絞られる。</p>\n<p><code>switch</code> 文にも同じチェック方法が適用されます。ここでは、 <code>！</code> 空でないアサーションという嫌な感嘆符を付けずに、完全な <code>getArea</code> を書いてみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// shape: Circle</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// shape: Square</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ここで最も重要なのは、 <code>Shape</code> のエンコーディングである。 <code>Circle</code> と <code>Square</code> は、実際には特定の種類のフィールドを持つ2つの独立したタイプであるという正しい情報をTypeScriptに伝えることが重要です。このようにすることで、本来書くJavaScriptと変わらないように見えるタイプ安全なTypeScriptコードを書き出すことができます。そこから、型システムは「正しい」ことを行い、私たちの <code>switch</code> 文の各分岐内の型を見つけることができます。</p>\n<blockquote>\n<p>傍観者として、上記の例をプレイして、リターンキーワードをいくつか外してみてください。型チェックは、switchステートメントの中で誤って別の節に落とし込まれるバグを回避するのに役立ちます。</p>\n</blockquote>\n<p>弁証法的な連合体は、円形と四角の話をするだけではありません。ネットワーク上でメッセージを送信したり( <code>client/server</code> トラフィック)、状態管理フレームワークで突然変異をエンコードしたりするなど、JavaScriptであらゆるタイプのメッセージングスキームを表現するのに適しています。</p>\n<h2 id=\"4-10-never-タイプおよび網羅性チェック\"><a href=\"#4-10-never-タイプおよび網羅性チェック\" class=\"headerlink\" title=\"4.10 never タイプおよび網羅性チェック\"></a>4.10 <code>never</code> タイプおよび網羅性チェック</h2><p>絞り込む際には、コンソーシアムの選択肢を、すべての可能性を削除して何も残らない程度に減らすことができます。このような場合、TypeScriptは <code>never</code> 型を使用して、存在してはならない状態を表します。</p>\n<p><code>never</code> 型は各型に割り当てることができます。ただし、neverに割り当てることができる型はありません(never自体を除く)。つまり、 <code>switch</code> 文では、縮小して <code>never</code> に依存する出現を使用して詳細なチェックを行うことができます。</p>\n<p>たとえば、関数 <code>getArea</code> にデフォルト値を追加して、形状を <code>never</code> に割り当てようとすると、可能なすべての状況が処理されなかったときに送出されます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">_exhaustiveCheck</span>: <span class=\"built_in\">never</span> = shape;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _exhaustiveCheck;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Shape</code> フェデレーションに新しいメンバを追加すると、TypeScriptエラーが発生します。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;triangle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span> | <span class=\"title class_\">Triangle</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">_exhaustiveCheck</span>: <span class=\"built_in\">never</span> = shape;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _exhaustiveCheck;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png\" alt=\"image-20211118183410201\" style=\"zoom:50%;\" />\n\n<h3 id=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"><a href=\"#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\" class=\"headerlink\" title=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"></a>特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"四、類型縮小\"><a href=\"#四、類型縮小\" class=\"headerlink\" title=\"四、類型縮小\"></a>四、類型縮小</h1><p><code>padLeft</code> という関数があるとします：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;まだ実装されていません！&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>機能を拡張してみましょう。 <code>padding</code> が <code>number</code> の場合、 <code>input</code> に追加するスペースの数として扱われます、 <code>padding</code> が <code>string</code> であれば、 <code>input</code> 上にのみ <code>padding</code> を実行する。次のことを実現してみましょう：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/04-01.png\" alt=\"image-20211114161343249\"></p>\n<p>ああ、 <code>padding + 1</code> でエラーが発生しました。TypeScriptは、演算子 <code>+</code> をタイプ <code>string | number</code> および <code>number</code> に適用できないことを警告していますが、これは正しいです。言い換えれば、 <code>padding</code> が <code>number</code> であるかどうかを明確にチェックしたり、 <code>string</code> である場合に対処したりしていないので、このようにします：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> padding + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>このほとんどが面白くないJavaScriptコードのように見えるなら、これもポイントになるでしょう。設定した注釈を除けば、このTypeScriptコードはJavaScriptのように見えます。私たちの考えでは、TypeScriptの型システムは、型セキュリティを獲得するために身をかがめる必要がなく、典型的なJavaScriptコードをできるだけ簡単に記述できるように設計されています。</p>\n<p>あまり多くないように見えますが、実はたくさんのものがここにあります。TypeScriptが静的型を使用して実行時の値を分析するのと同様に、JavaScriptの実行時制御フロー構造に、if&#x2F;else、条件トリプル、ループ、信頼性チェックなどの型の分析を重ねます。</p>\n<p>私たちのifチェックでは、TypeScriptは <code>typeof padding ===&quot;number&quot;</code> と認識し、タイプ保護と呼ばれる特殊な形式のコードとして認識します。TypeScriptは、特定の場所にある値の最も具体的な型を分析するために、プログラムが取り得る実行パスに従います。これらの特殊なチェック(型保護と呼ばれる)と代入を見て、宣言された型よりも具体的な型に型を細分化するプロセスを絞り込みと呼びます。多くのエディタでは、これらの種類の変化を見ることができますし、私たちの例でもそうします。</p>\n<p>TypeScriptは、いくつかの異なる縮小構造を理解することができます。</p>\n<h2 id=\"4-1-typeof-タイプガード\"><a href=\"#4-1-typeof-タイプガード\" class=\"headerlink\" title=\"4.1 typeof タイプガード\"></a>4.1 <code>typeof</code> タイプガード</h2><p>ここまで見てきたように、JavaScriptは <code>typeof</code> 演算子をサポートしています。この演算子は、実行時に所有する値の種類に関する非常に基本的な情報を提供します。TypeScriptは、特定の文字列のセットを返すことを期待します：</p>\n<ul>\n<li><code>&quot;string&quot;</code></li>\n<li><code>&quot;number&quot;</code></li>\n<li><code>&quot;bigint&quot;</code></li>\n<li><code>&quot;boolean&quot;</code></li>\n<li><code>&quot;symbol&quot;</code></li>\n<li><code>&quot;undefined&quot;</code></li>\n<li><code>&quot;object&quot;</code></li>\n<li><code>&quot;function&quot;</code></li>\n</ul>\n<p><code>padLeft</code> に見られるように、この演算子は多くのJavaScriptライブラリによく登場します。TypeScriptは、さまざまな分岐にある型を絞り込むものとして理解できます。</p>\n<p>TypeScriptでは、 <code>typeof</code> の戻り値をチェックすることが保護型です。TypeScriptは、 <code>typeof</code> アクションをエンコードして異なる値を返すので、JavaScriptに何が行われたかを知っています。たとえば、上のリストでは、 <code>typeof</code> はstring <code>null</code> を返さないことに注意してください。次の例を参照してください：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png\" alt=\"image-20211114164143361\" style=\"zoom:50%;\" />\n\n<p>関数 <code>printAll</code> では、配列型であるかどうかを調べる代わりに、 <code>strs</code> がオブジェクトであるかどうかを調べてみます(配列がJavaScriptのオブジェクト型であることを強調するのに適したタイミングかもしれません)。しかし、JavaScriptでは、 <code>typeof null</code> も実際には <code>&quot;object&quot;</code> であることが判明しました。歴史上の不幸な事故の一つだ。</p>\n<p>十分な経験を持つユーザーは驚かないかもしれませんが、誰もがJavaScriptでこのような状況に遭遇したことがあるわけではありません。幸いなことに、typescriptは、 <code>strs</code> が <code>string[]</code> だけではなく、 <code>string[] | null</code> に縮小されることを示しています。</p>\n<p>これは、いわゆる「真正性」チェックへの良い移行といえるかもしれません。</p>\n<h2 id=\"4-2真理値の縮小\"><a href=\"#4-2真理値の縮小\" class=\"headerlink\" title=\"4.2真理値の縮小\"></a>4.2真理値の縮小</h2><p>真理値チェックはJavaScriptでよくやっていることです。JavaScriptでは、条件、 <code>&amp;&amp;</code>、 <code>||</code>、 <code>if</code> ステートメント、ブール否定( <code>!</code>)などの任意の式を使用できます。たとえば、 <code>if</code> ステートメントでは、条件が常に <code>boolean</code> 型になることは想定していません。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getUsersOnlineMessage</span>(<span class=\"params\"><span class=\"attr\">numUsersOnline</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numUsersOnline) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`「合計 <span class=\"subst\">$&#123;numUsersOnline&#125;</span> 人が現在オンラインです!」`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;今は誰もオンラインにいません. :(&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScriptでは、このような <code>if</code> 条件ステートメントは、まず条件「強制」を <code>boolean</code> に変換して意味を持たせ、その結果が <code>true</code> であるか <code>false</code> であるかによって分岐を選択します。このような面の値は次のようになります：</p>\n<ul>\n<li><code>0</code></li>\n<li><code>NaN</code></li>\n<li><code>&quot;&quot;</code> (空の文字列)</li>\n<li><code>0n</code> ( <code>bigint</code> ゼロのバージョン)</li>\n<li><code>null</code></li>\n<li><code>undefined</code></li>\n</ul>\n<p>これらの値は強制的に <code>false</code> に変換され、その他の値は強制的に <code>true</code> に変換されます。関数 <code>Boolean</code> で値を実行して <code>boolean</code> を取得するか、短い二重ブール否定を使用して値を強制的に <code>boolean</code> に変換することができます。(後者の利点は、TypeScriptが狭いリテラルのboolean型 <code>true</code> を推定し、最初の型を <code>boolean</code> と推定することです)。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// どちらの結果も true を返します</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"string\">&quot;hello&quot;</span>); <span class=\"comment\">// type: boolean, value: true</span></span><br><span class=\"line\">!!<span class=\"string\">&quot;world&quot;</span>; <span class=\"comment\">// type: true, value: true</span></span><br></pre></td></tr></table></figure>\n\n<p>この動作を利用することは、特に <code>null</code> や <code>undefined</code> などの値を防ぐ場合には、非常に一般的である。たとえば、この関数を <code>printAll</code> 関数で使用してみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs &amp;&amp; <span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>strs</code> が真であるかどうかをチェックすることで、上記のエラーを解消したことにお気づきでしょう。これにより、コードの実行時に次のような恐ろしいエラーが発生するのを防ぐことができます：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: null is not iterable</span><br></pre></td></tr></table></figure>\n\n<p>ただし、プリミティブの真理値チェックはしばしば誤りやすいことを覚えておいてください。たとえば、 <code>printAll</code> を上書きすることを考えてみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// !!!!!!!!!!!!!!!!</span></span><br><span class=\"line\">  <span class=\"comment\">// そんなことしたらダメ！</span></span><br><span class=\"line\">  <span class=\"comment\">// 理由は以下の通り</span></span><br><span class=\"line\">  <span class=\"comment\">// !!!!!!!!!!!!!!!!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>関数本体全体を実際の検査でラッピングしましたが、空の文字列を正しく処理できなくなるという小さな欠点があります。</p>\n<p>TypeScriptはここではまったく間違いを報告しませんが、JavaScriptに詳しくない方は注意すべき行動です。TypeScriptは通常、エラーを早期に発見するのに役立ちますが、ある値を<em>任意</em>処理しないように選択した場合には、論理的な問題をあまり考慮することなく、これだけのことができます。必要に応じて、linter(プログラムの正規化)を使用してこのような状況に対処することができます。</p>\n<p>真正性による絞り込みの最後の点については、論理を否定枝からブール否定 <code>!</code> でフィルタリングすることである。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiplyAll</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">values</span>: <span class=\"built_in\">number</span>[] | <span class=\"literal\">undefined</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">factor</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"built_in\">number</span>[] | <span class=\"literal\">undefined</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!values) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * factor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3等価縮小\"><a href=\"#4-3等価縮小\" class=\"headerlink\" title=\"4.3等価縮小\"></a>4.3等価縮小</h2><p>typescriptも分岐文を用いて <code>===</code>、 <code>!==</code>、 <code>==</code>、および <code>!=</code> などの値検査を行い、型の絞り込みを実現している。例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// これで、x、y で文字列型のメソッドを呼び出すことができます。</span></span><br><span class=\"line\">    x.<span class=\"title function_\">toUpperCase</span>();</span><br><span class=\"line\">    y.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上記の例で <code>x</code> と <code>y</code> が等しいかどうかを調べたとき、TypeScriptはそれらの型も等しくなければならないことを認識しています。 <code>string</code> は、 <code>x</code> と <code>y</code> の両方で使用できる唯一の一般的な型なので、TypeScriptは、 <code>x</code> と <code>y</code> がいずれも <code>string</code> の場合、プログラムは最初の分岐に進みます。</p>\n<p>変数ではなく、特定のリテラル値をチェックすることも有効です。真理値の絞り込みについてのセクションでは、空の文字列を正しく処理していないため、エラーが発生しやすい関数 <code>printAll</code> を書きました。代わりに、特定のチェックをして <code>null</code> をブロックし、TypeScriptが <code>strs</code> から <code>null</code> を正しく削除したままにすることができます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScriptのより緩やかな同等性チェック <code>==</code> および <code>!=</code> も、適切に縮小されます。変数が <code>== null</code> であるかどうかを調べる方法に慣れていない場合は、それが特定の値 <code>null</code> であるかどうかだけでなく、 <code>undefined</code> であるかもしれないかどうかも調べる必要があるので、どのようにして <code>== null</code> であるかどうかを調べる必要があります。これは <code>== undefined</code> にも当てはまります。値が <code>null</code> または <code>undefined</code> であるかどうかがチェックされます。ここでは、この <code>==</code> と <code>!=</code> だけで済ませることができます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Container</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiplyValue</span>(<span class=\"params\"><span class=\"attr\">container</span>: <span class=\"title class_\">Container</span>, <span class=\"attr\">factor</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 未定義と null を型から除外しました</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (container.<span class=\"property\">value</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(container.<span class=\"property\">value</span>);</span><br><span class=\"line\">    <span class=\"comment\">// これで、「container.value」を安全に乗算できるようになりました。</span></span><br><span class=\"line\">    container.<span class=\"property\">value</span> *= factor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png\" alt=\"image-20211115154532180\" style=\"zoom:50%;\" />\n\n<p>最初の3つの印刷はパスしましたが、4番目に問題がありました。</p>\n<h2 id=\"4-4-in-オペレータ縮小\"><a href=\"#4-4-in-オペレータ縮小\" class=\"headerlink\" title=\"4.4 in オペレータ縮小\"></a>4.4 <code>in</code> オペレータ縮小</h2><p>JavaScriptには、 <code>in</code> 演算子を使用して、オブジェクトに属性名があるかどうかを判断する演算子があります。TypeScriptはこの点を考慮して、潜在的なタイプを絞り込んでいます。</p>\n<p>たとえば、コード <code>&quot;value&quot; in x</code> を使用します。ここで、 <code>&quot;value&quot;</code> は文字列リテラルであり、 <code>x</code> は結合型である。値が「true」の分岐は縮小されます。 <code>x</code> オプションまたは必須属性を持つタイプの値が必要です。値が「false」の分岐は縮小され、オプションまたは欠落した属性を持つタイプの値が必要になります。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123; <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123; <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">move</span>(<span class=\"params\"><span class=\"attr\">animal</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&quot;swim&quot;</span> <span class=\"keyword\">in</span> animal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> animal.<span class=\"title function_\">swim</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> animal.<span class=\"title function_\">fly</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>また、オプション属性は縮小の両側にも存在します。たとえば、人間は（適切な装置を使用して）泳いだり飛んだりできるため、 <code>in</code> チェックの両側に表示されます：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123; <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123; <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Human</span> = &#123; <span class=\"attr\">swim</span>?: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>; <span class=\"attr\">fly</span>?: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">move</span>(<span class=\"params\"><span class=\"attr\">animal</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span> | <span class=\"title class_\">Human</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&quot;swim&quot;</span> <span class=\"keyword\">in</span> animal) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// animal: Fish | Human</span></span><br><span class=\"line\">    animal;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// animal: Bird | Human</span></span><br><span class=\"line\">    animal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-5-instanceof-オペレータ縮小\"><a href=\"#4-5-instanceof-オペレータ縮小\" class=\"headerlink\" title=\"4.5 instanceof オペレータ縮小\"></a>4.5 <code>instanceof</code> オペレータ縮小</h2><p>JavaScriptには、ある値が別の値の「インスタンス」であるかどうかをチェックする演算子 <code>instanceof</code> があります。具体的には、JavaScriptの <code>x instanceof Foo</code> で、 <code>x</code> の<em>プロトタイプチェーン</em>に <code>Foo.prototype</code> が含まれているかどうかをチェックします。ここでは詳しく説明しませんが、 <code>类(class)</code> の学習に入ると、その多くが <code>new</code> キーワードを使ってインスタンス化できることがわかります。すでにお気づきのように、 <code>instanceof</code> も型保護であり、TypeScriptは <code>instanceof</code> で保護されたブランチの縮小を実装します。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logValue</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Date</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Date</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"title function_\">toUTCString</span>());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">logValue</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()); <span class=\"comment\">// Mon, 15 Nov 2021 22:34:37 GMT</span></span><br><span class=\"line\"><span class=\"title function_\">logValue</span>(<span class=\"string\">&quot;hello ts&quot;</span>); <span class=\"comment\">// HELLO TS</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-6配分の縮小\"><a href=\"#4-6配分の縮小\" class=\"headerlink\" title=\"4.6配分の縮小\"></a>4.6配分の縮小</h2><p>前述したように、任意の変数に値を割り当てると、TypeScriptは割り当てられた値の右側を確認し、左側を適切に縮小します。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span> ? <span class=\"number\">10</span> : <span class=\"string\">&quot;hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&quot;goodbye!&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// let x: string</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<p>これらの割り当てはそれぞれ有効であることに注意してください。最初の代入後に観測されたタイプ <code>x</code> が <code>number</code> に変更された場合でも、 <code>string</code> を <code>x</code> に代入することができます。これは、<em>宣言型</em>の <code>x</code> -このタイプ <code>x</code> は <code>string | number</code> で始まるためです。</p>\n<p><code>x</code> に <code>boolean</code> を割り当てると、宣言型の一部ではないため、エラーが表示されます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span> ? <span class=\"number\">10</span> : <span class=\"string\">&quot;hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// エラー！</span></span><br><span class=\"line\">x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png\" alt=\"image-20211116065026159\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-7制御フロー解析\"><a href=\"#4-7制御フロー解析\" class=\"headerlink\" title=\"4.7制御フロー解析\"></a>4.7制御フロー解析</h2><p>ここまで、いくつかの基本的な例を使って、TypeScriptが特定のブランチでどのように絞り込むかを説明してきました。しかし、各変数から出てきて、 <code>if</code>、 <code>while</code>、条件などで型保護を探す以外にも、やるべきことはたくさんあります。例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> padding + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>padLeft</code> は、その最初の <code>if</code> ブロックから返されます。TypeScriptはこのコードを解析し、paddingが数値の場合、ボディの残りの部分( <code>return padding + input;</code>)が到達不可能であることを確認します。このため、関数の残りの部分で使用される <code>padding</code> 型から数値を削除(文字列数値から文字列に絞り込む)できます。</p>\n<p>この到達可能性ベースのコード解析は制御フロー解析と呼ばれ、TypeScriptはタイプガードと代入に遭遇するため、このフロー解析を使用してタイプを絞り込みます。各点で異なる型が観察され得る変数を解析すると、制御フローを何度も分割して再結合することができる。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// let x: boolean</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span>) &#123;</span><br><span class=\"line\">    x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// let x: string</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">// let x: number</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title function_\">example</span>();</span><br><span class=\"line\">x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">x = <span class=\"number\">100</span>;</span><br><span class=\"line\">x = <span class=\"literal\">true</span>; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png\" alt=\"image-20211117203742503\" style=\"zoom:50%;\" />\n\n<h2 id=\"4-8型述語の使用\"><a href=\"#4-8型述語の使用\" class=\"headerlink\" title=\"4.8型述語の使用\"></a>4.8型述語の使用</h2><p>ここまで、我々は既存のJavaScript構造体を用いてナローディングの問題に対処してきましたが、時にはコード全体の型の変化をより直接的に制御したいと思うことがあります。</p>\n<p>ユーザ定義型保護を定義するには、戻り型が型述語である関数を定義するだけです。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isFish</span>(<span class=\"params\"><span class=\"attr\">pet</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span></span>): pet is <span class=\"title class_\">Fish</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> <span class=\"title class_\">Fish</span>).<span class=\"property\">swim</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>この例では、 <code>pet is Fish</code> が型述語です。述語の形式は <code>parameterName is Type</code> です。 <code>parameterName</code> は、現在の関数のシグネチャ内のパラメータ名である必要があります。</p>\n<p><code>isFish</code> が呼び出されるたびに、TypeScriptは元の型が互換性を持っている場合、その変数を特定の型に絞り込みます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">fish</span>: <span class=\"title class_\">Fish</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;gold fish&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">bird</span>: <span class=\"title class_\">Bird</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;sparrow&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span> ? bird : fish;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ペットのスイムとフライの両方にアクセスできます。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"title function_\">getSmallPet</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"title function_\">isFish</span>(pet)) &#123;</span><br><span class=\"line\">  pet.<span class=\"title function_\">swim</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.<span class=\"title function_\">fly</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScriptは、 <code>pet</code> が <code>if</code> 分岐で魚であることを知っているだけではないことに注意してください。また、 <code>else</code> 枝に <code>Fish</code> がないことも知っているので、 <code>Bird</code> があるはずです。</p>\n<p>型ガード <code>isFish</code> を使用して、 <code>Fish | Bird</code> の配列をフィルタリングし、 <code>Fish</code> の配列を得ることができます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">zoo</span>: (<span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span>)[] = [<span class=\"title function_\">getSmallPet</span>(), <span class=\"title function_\">getSmallPet</span>(), <span class=\"title function_\">getSmallPet</span>()];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWater1</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>(isFish);</span><br><span class=\"line\"><span class=\"comment\">// または、以下と同等</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWater2</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>(isFish) <span class=\"keyword\">as</span> <span class=\"title class_\">Fish</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// より複雑な例では、述語を再利用する必要がある場合があります。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWatch3</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>((pet): pet is <span class=\"title class_\">Fish</span> =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pet.<span class=\"property\">name</span> === <span class=\"string\">&quot;frog&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isFish</span>(pet);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-9差別された-unions\"><a href=\"#4-9差別された-unions\" class=\"headerlink\" title=\"4.9差別された unions\"></a>4.9差別された <code>unions</code></h2><p>これまで見てきた例のほとんどは、単純な型( <code>string</code>、 <code>boolean</code>、 <code>number</code> など)を使って個々の変数を絞り込むことを中心にしています。よくあることですが、JavaScriptでは少し複雑な構造体を扱うことが多いです。</p>\n<p>インスピレーションを引き出すために、円形や四角などの形をコード化しようとしていると想像してみましょう。円は半径を表し、四角形は辺の長さを表します。 <code>kind</code> というフィールドを使用して、どの形状を扱っているかを示します。ここでは、 <code>Shape</code> を定義する最初の試みを行います。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span> | <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>文字列リテラル型の結合を使用していることに注意してください。 <code>&quot;circle &quot;</code> と <code> &quot;square &quot;</code> はそれぞれ、この形状を円形とみなすべきか正方形とみなすべきかを示しています。 <code>string</code> ではなく <code>&quot;circle&quot; | &quot;square &quot;</code> を使用することで、スペルミスの問題を回避できます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleShape</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// oops!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;rect&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png\" alt=\"image-20211118090404099\" style=\"zoom:50%;\" />\n\n<p>関数 <code>getArea</code> を書いて、それが円か正方形かに応じて正しい論理を適用することができます。まず円形を試してみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png\" alt=\"image-20211118091637002\" style=\"zoom:50%;\" />\n\n<p><code>strictNullChecks</code> では、これは私たちに間違いを与えます。 <code>radius</code> が定義されていない可能性があるので、これは適切です。しかし、 <code>kind</code> 属性を適切にチェックしたらどうでしょうか。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png\" alt=\"image-20211118093134890\" style=\"zoom:50%;\" />\n\n<p>まあ、TypeScriptはまだどうすればいいのかわかりません。私たちは、タイプチェッカーが知っている以上に値を知っているという問題に直面しました。空ではないアサーション( <code>radius</code> の後にある感嘆符 <code>!</code>)を使用して、 <code>radius</code> が存在することを示すことができます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span>! ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>しかしこの感じは理想的ではありません。空ではないアサーションを使用して、型チェッカーに感嘆符( <code>！</code>)を宣言し、 <code>shape.radius</code> が定義されていることを納得させる必要がありますが、コードを動かし始めると、これらのアサーションは間違いやすいでしょう。また、 <code>strictNullChecks</code> 以外では、これらのフィールドに誤ってアクセスすることもできます(これらのフィールドが読み込まれると、オプション属性が常に存在すると見なされるからです)。私たちは絶対にもっとうまくやることができます。</p>\n<p>このような <code>Shape</code> のエンコーディングの問題は、タイプチェッカーが、クラス属性に基づいて <code>radius</code> または <code>sideLength</code> の存在を知る方法がないことです。私たちが知っていることをタイプチェッカーに伝える必要があります。そのことを考えて、Shapeをもう一度定義してみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span>;</span><br></pre></td></tr></table></figure>\n\n<p>ここでは、 <code>Shape</code> を2つのタイプに正しく分類し、 <code>kind</code> 属性に異なる値を設定していますが、 <code>radius</code> と <code>sideLength</code> はそれぞれのタイプで必須属性として宣言されています。</p>\n<p>半径 <code>Shape</code> にアクセスしようとするとどうなるか見てみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png\" alt=\"image-20211118180452972\" style=\"zoom:50%;\" />\n\n<p>最初に定義した <code>Shape</code> と同様に、これはまだ間違いです。半径がオプションの場合、TypeScriptではこのアトリビュートが存在するかどうかを判断できないため、エラーが発生しました( <code>strictNullChecks</code> のみ)。これで <code>Shape</code> がコンソーシアムになり、TypeScriptは <code>shape</code> が <code>Square</code> である可能性があることを示していますが、Squareは半径 <code>radius</code> を定義していません。どちらの解釈も正しいのですが、 <code>Shape</code> の新しいエンコーディングだけが、まだ <code>strictNullChecks</code> の外側でエラーが発生しています。</p>\n<p>しかし、もう一度kind属性をチェックしてみたらどうでしょうか。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// shape: Circle</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>これで間違いから脱した！ <code>union</code> の各型にリテラル型と同じプロパティが含まれている場合、TypeScriptはそれを <code>union</code> と見なし、 <code>union</code> のメンバーを絞り込むことができます。</p>\n<p>この場合、 <code>kind</code> がその共通属性である（これが <code>Shape</code> の判別属性である）。 <code>kind</code> 属性が <code>&quot;circle&quot;</code> であることを確認すると、 <code>Shape</code> 内の <code> &quot;circle&quot;</code> 型属性を持たないすべての型を除外できます。これにより、 <code>Shape</code> の範囲は <code>Circle</code> というタイプに絞られる。</p>\n<p><code>switch</code> 文にも同じチェック方法が適用されます。ここでは、 <code>！</code> 空でないアサーションという嫌な感嘆符を付けずに、完全な <code>getArea</code> を書いてみましょう。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// shape: Circle</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// shape: Square</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ここで最も重要なのは、 <code>Shape</code> のエンコーディングである。 <code>Circle</code> と <code>Square</code> は、実際には特定の種類のフィールドを持つ2つの独立したタイプであるという正しい情報をTypeScriptに伝えることが重要です。このようにすることで、本来書くJavaScriptと変わらないように見えるタイプ安全なTypeScriptコードを書き出すことができます。そこから、型システムは「正しい」ことを行い、私たちの <code>switch</code> 文の各分岐内の型を見つけることができます。</p>\n<blockquote>\n<p>傍観者として、上記の例をプレイして、リターンキーワードをいくつか外してみてください。型チェックは、switchステートメントの中で誤って別の節に落とし込まれるバグを回避するのに役立ちます。</p>\n</blockquote>\n<p>弁証法的な連合体は、円形と四角の話をするだけではありません。ネットワーク上でメッセージを送信したり( <code>client/server</code> トラフィック)、状態管理フレームワークで突然変異をエンコードしたりするなど、JavaScriptであらゆるタイプのメッセージングスキームを表現するのに適しています。</p>\n<h2 id=\"4-10-never-タイプおよび網羅性チェック\"><a href=\"#4-10-never-タイプおよび網羅性チェック\" class=\"headerlink\" title=\"4.10 never タイプおよび網羅性チェック\"></a>4.10 <code>never</code> タイプおよび網羅性チェック</h2><p>絞り込む際には、コンソーシアムの選択肢を、すべての可能性を削除して何も残らない程度に減らすことができます。このような場合、TypeScriptは <code>never</code> 型を使用して、存在してはならない状態を表します。</p>\n<p><code>never</code> 型は各型に割り当てることができます。ただし、neverに割り当てることができる型はありません(never自体を除く)。つまり、 <code>switch</code> 文では、縮小して <code>never</code> に依存する出現を使用して詳細なチェックを行うことができます。</p>\n<p>たとえば、関数 <code>getArea</code> にデフォルト値を追加して、形状を <code>never</code> に割り当てようとすると、可能なすべての状況が処理されなかったときに送出されます。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">_exhaustiveCheck</span>: <span class=\"built_in\">never</span> = shape;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _exhaustiveCheck;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Shape</code> フェデレーションに新しいメンバを追加すると、TypeScriptエラーが発生します。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;triangle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span> | <span class=\"title class_\">Triangle</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">_exhaustiveCheck</span>: <span class=\"built_in\">never</span> = shape;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _exhaustiveCheck;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png\" alt=\"image-20211118183410201\" style=\"zoom:50%;\" />\n\n<h3 id=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"><a href=\"#特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\" class=\"headerlink\" title=\"特別声明：この記事は古艺散人先生から転自し、必要があれば原文のプレビューで閲覧することができます。\"></a>特別声明：この記事は<a href=\"https://github.com/lurongtao/TypeScript\">古艺散人先生</a>から転自し、必要があれば原文のプレビューで閲覧することができます。</h3>"
      },
      {
        "title": "1-1、CSS中hover时出现抖动的原因和解决方法",
        "toc": true,
        "abbrlink": 16495,
        "date": "2024-01-28T11:36:14.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_01.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n## 1. 出现的原因\n\n```text\nCSS hover时出现抖动的原因通常与盒模型和布局有关，可能是由于元素在hover状态下增加了一些样式，导致元素的尺寸或位置发生了变化，从而引发抖动。\n```\n\n## 2. 解决方式\n\n### 2.1边框的影响\n\n```css\n/* 如果在hover状态下添加了边框，而没有在非hover状态下考虑到边框的宽度，可能导致抖动。确保在非hover状态下也为元素预留足够的空间。 */\n/* 不好的例子 */\n.box {\n  border: 1px solid transparent;\n  transition: border-color 0.3s;\n}\n\n.box:hover {\n  border-color: red;\n}\n\n/* 好的例子 */\n.box {\n  border: 1px solid transparent;\n  transition: border-color 0.3s;\n  box-sizing: border-box;\n}\n\n.box:hover {\n  border-color: red;\n}\n```\n\n### 2.2 宽度和高度的变化\n\n```css\n/* 如果在hover状态下改变了元素的宽度或高度，而在非hover状态下没有合适地设置，也可能导致抖动。 */\n/* 不好的例子 */\n.box {\n  width: 100px;\n  height: 100px;\n  transition: width 0.3s;\n}\n\n.box:hover {\n  width: 120px;\n}\n\n/* 好的例子 */\n.box {\n  width: 100px;\n  height: 100px;\n  transition: width 0.3s;\n  box-sizing: border-box;\n}\n\n.box:hover {\n  width: 120px;\n}\n```\n\n### 2.3 改变透明度\n\n```css\n/* 在某些情况下，改变元素透明度可能导致抖动。确保在非hover状态下也设置透明度。 */\n/* 不好的例子 */\n.box {\n  opacity: 1;\n  transition: opacity 0.3s;\n}\n\n.box:hover {\n  opacity: 0.8;\n}\n\n/* 好的例子 */\n.box {\n  opacity: 1;\n  transition: opacity 0.3s;\n}\n\n.box:hover {\n  opacity: 0.8;\n}\n```\n\n### 2.4 使用 transform 属性\n\n```css\n/* 在一些情况下，使用 transform 属性可能更有效，因为它不会影响文档流，避免了一些布局引起的抖动。 */\n.box {\n  transition: transform 0.3s;\n}\n\n.box:hover {\n  transform: scale(1.1);\n}\n```\n",
        "source": "_posts/简体中文/Css/1-1、CSS中hover时出现抖动的原因和解决方法.md",
        "raw": "---\ntitle: 1-1、CSS中hover时出现抖动的原因和解决方法\ntoc: true\ncategories:\n  - 简体中文\n  - Css\ntags:\n  - 前端\n  - Css\nabbrlink: 16495\ndate: 2024-01-28 19:36:14\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n## 1. 出现的原因\n\n```text\nCSS hover时出现抖动的原因通常与盒模型和布局有关，可能是由于元素在hover状态下增加了一些样式，导致元素的尺寸或位置发生了变化，从而引发抖动。\n```\n\n## 2. 解决方式\n\n### 2.1边框的影响\n\n```css\n/* 如果在hover状态下添加了边框，而没有在非hover状态下考虑到边框的宽度，可能导致抖动。确保在非hover状态下也为元素预留足够的空间。 */\n/* 不好的例子 */\n.box {\n  border: 1px solid transparent;\n  transition: border-color 0.3s;\n}\n\n.box:hover {\n  border-color: red;\n}\n\n/* 好的例子 */\n.box {\n  border: 1px solid transparent;\n  transition: border-color 0.3s;\n  box-sizing: border-box;\n}\n\n.box:hover {\n  border-color: red;\n}\n```\n\n### 2.2 宽度和高度的变化\n\n```css\n/* 如果在hover状态下改变了元素的宽度或高度，而在非hover状态下没有合适地设置，也可能导致抖动。 */\n/* 不好的例子 */\n.box {\n  width: 100px;\n  height: 100px;\n  transition: width 0.3s;\n}\n\n.box:hover {\n  width: 120px;\n}\n\n/* 好的例子 */\n.box {\n  width: 100px;\n  height: 100px;\n  transition: width 0.3s;\n  box-sizing: border-box;\n}\n\n.box:hover {\n  width: 120px;\n}\n```\n\n### 2.3 改变透明度\n\n```css\n/* 在某些情况下，改变元素透明度可能导致抖动。确保在非hover状态下也设置透明度。 */\n/* 不好的例子 */\n.box {\n  opacity: 1;\n  transition: opacity 0.3s;\n}\n\n.box:hover {\n  opacity: 0.8;\n}\n\n/* 好的例子 */\n.box {\n  opacity: 1;\n  transition: opacity 0.3s;\n}\n\n.box:hover {\n  opacity: 0.8;\n}\n```\n\n### 2.4 使用 transform 属性\n\n```css\n/* 在一些情况下，使用 transform 属性可能更有效，因为它不会影响文档流，避免了一些布局引起的抖动。 */\n.box {\n  transition: transform 0.3s;\n}\n\n.box:hover {\n  transform: scale(1.1);\n}\n```\n",
        "slug": "简体中文/Css/1-1、CSS中hover时出现抖动的原因和解决方法",
        "published": 1,
        "updated": "2024-02-15T07:47:05.700Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjanz000c94v3ctvv98jf",
        "content": "<h2 id=\"1-出现的原因\"><a href=\"#1-出现的原因\" class=\"headerlink\" title=\"1. 出现的原因\"></a>1. 出现的原因</h2><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">CSS hover时出现抖动的原因通常与盒模型和布局有关，可能是由于元素在hover状态下增加了一些样式，导致元素的尺寸或位置发生了变化，从而引发抖动。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-解决方式\"><a href=\"#2-解决方式\" class=\"headerlink\" title=\"2. 解决方式\"></a>2. 解决方式</h2><h3 id=\"2-1边框的影响\"><a href=\"#2-1边框的影响\" class=\"headerlink\" title=\"2.1边框的影响\"></a>2.1边框的影响</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 如果在hover状态下添加了边框，而没有在非hover状态下考虑到边框的宽度，可能导致抖动。确保在非hover状态下也为元素预留足够的空间。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 不好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-color <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-color <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-宽度和高度的变化\"><a href=\"#2-2-宽度和高度的变化\" class=\"headerlink\" title=\"2.2 宽度和高度的变化\"></a>2.2 宽度和高度的变化</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 如果在hover状态下改变了元素的宽度或高度，而在非hover状态下没有合适地设置，也可能导致抖动。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 不好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: width <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">120px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: width <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">120px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-改变透明度\"><a href=\"#2-3-改变透明度\" class=\"headerlink\" title=\"2.3 改变透明度\"></a>2.3 改变透明度</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在某些情况下，改变元素透明度可能导致抖动。确保在非hover状态下也设置透明度。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 不好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-使用-transform-属性\"><a href=\"#2-4-使用-transform-属性\" class=\"headerlink\" title=\"2.4 使用 transform 属性\"></a>2.4 使用 transform 属性</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在一些情况下，使用 transform 属性可能更有效，因为它不会影响文档流，避免了一些布局引起的抖动。 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: transform <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h2 id=\"1-出现的原因\"><a href=\"#1-出现的原因\" class=\"headerlink\" title=\"1. 出现的原因\"></a>1. 出现的原因</h2><figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">CSS hover时出现抖动的原因通常与盒模型和布局有关，可能是由于元素在hover状态下增加了一些样式，导致元素的尺寸或位置发生了变化，从而引发抖动。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-解决方式\"><a href=\"#2-解决方式\" class=\"headerlink\" title=\"2. 解决方式\"></a>2. 解决方式</h2><h3 id=\"2-1边框的影响\"><a href=\"#2-1边框的影响\" class=\"headerlink\" title=\"2.1边框的影响\"></a>2.1边框的影响</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 如果在hover状态下添加了边框，而没有在非hover状态下考虑到边框的宽度，可能导致抖动。确保在非hover状态下也为元素预留足够的空间。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 不好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-color <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: border-color <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-宽度和高度的变化\"><a href=\"#2-2-宽度和高度的变化\" class=\"headerlink\" title=\"2.2 宽度和高度的变化\"></a>2.2 宽度和高度的变化</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 如果在hover状态下改变了元素的宽度或高度，而在非hover状态下没有合适地设置，也可能导致抖动。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 不好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: width <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">120px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: width <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">120px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-改变透明度\"><a href=\"#2-3-改变透明度\" class=\"headerlink\" title=\"2.3 改变透明度\"></a>2.3 改变透明度</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在某些情况下，改变元素透明度可能导致抖动。确保在非hover状态下也设置透明度。 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 不好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 好的例子 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-使用-transform-属性\"><a href=\"#2-4-使用-transform-属性\" class=\"headerlink\" title=\"2.4 使用 transform 属性\"></a>2.4 使用 transform 属性</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在一些情况下，使用 transform 属性可能更有效，因为它不会影响文档流，避免了一些布局引起的抖动。 */</span></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: transform <span class=\"number\">0.3s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"
      },
      {
        "title": "1-1、基础篇：TypeScript介绍",
        "toc": true,
        "swiper_index": 1,
        "swiper_cover": "/img/recommend/recommend_01.jpg",
        "swiper_desc": "1-1、基础篇：TypeScript介绍",
        "abbrlink": 8074,
        "date": "2024-01-28T11:34:45.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_01.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# （基础篇）一、TypeScript介绍\n\n## 1.1 什么是TypeScript\n\n在引入编程社区 20 多年后，JavaScript 现在已成为有史以来应用最广泛的跨平台语言之一。JavaScript 最初是一种用于向网页添加微不足道的交互性的小型脚本语言，现已发展成为各种规模的前端和后端应用程序的首选语言。虽然用 JavaScript 编写的程序的大小、范围和复杂性呈指数级增长，但 JavaScript 语言表达不同代码单元之间关系的能力却没有。结合 JavaScript 相当奇特的运行时语义，语言和程序复杂性之间的这种不匹配使得 JavaScript 开发成为一项难以大规模管理的任务。\n\n程序员编写的最常见的错误类型可以描述为类型错误：在预期不同类型的值的地方使用了某种类型的值。这可能是由于简单的拼写错误、无法理解库的 API 表面、对运行时行为的错误假设或其他错误。TypeScript 的目标是成为 JavaScript 程序的静态类型检查器——换句话说，是一个在代码运行之前运行的工具（静态）并确保程序的类型正确（类型检查）。\n\nTypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n\nTypeScript 是一种非常受欢迎的 JavaScript 语言扩展。它在现有的 JavaScript 语法之上加入了一层类型层，而这一层即使被删除，也丝毫不会影响运行时的原有表现。许多人认为 TypeScript \"只是一个编译器\"，但更好的理解其实是把 TypeScript 看作两个独立的系统：编译器（即处理语法的部分）和语言工具（即处理与编辑器集成的部分）。通过独立看待这两个系统，就可以得到能够解释我们之前所做决策的两个重要视角。\n\n在 **npm**[3] 上，TypeScript 的下载量每年都在翻倍。截止2021 年 12 月 1 日，它的每周下载量超过为 2200 万次。而在去年 12 月，这一数字约为 1200 万次。它仍保持着高速增长的趋势，没有任何放缓的迹象。\n\n从 2.0 版本开始，TypeScript 每两月定期发布一个 release。但是现在放缓了发布的节奏，改为每三个月发布一次。其中会花一个月编写新 features 并发布 beta 版本，剩下两个月对 beta 版进行测试和 bug 修复，这使得后续的发布更加稳定。\n\n## 1.2 `JS`,`ES`,`TS`的关系\n\n- **1995年：JavaScript**\n\n当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。\n\n由于网景公司希望能在静态HTML页面上添加一些动态效果，于是 `Brendan Eich` 在两周之内设计出了JavaScript语言。\n\n为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。\n\n- **1997年：ECMAScript**\n\n因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）（欧洲计算机制造商协会）组织制定了JavaScript 语言的标准，被称为ECMAScript标准。\n\n| 版本   | 发布时间       | 一般称呼        | 简称 |\n| ------ | -------------- | --------------- | ---- |\n| 第1版  | 1997年6月      | ECMAScript 1    | ES1  |\n| 第2版  | 1998年4月      | ECMAScript 2    | ES2  |\n| 第3版  | 1999年12月     | ECMAScript 3    | ES3  |\n| 第4版  | 2007年10月草案 | ECMAScript 4    | ES4  |\n| 第5版  | 2009年12月     | ECMAScript 5    | ES5  |\n| 第6版  | 2015年6月      | ECMAScript 2015 | ES6  |\n| 第7版  | 2016年6月      | ECMAScript 2016 | ES7  |\n| 第8版  | 2017年6月      | ECMAScript 2017 | ES8  |\n| 第9版  | 2018年6月      | ECMAScript 2018 | ES9  |\n| 第10版 | 2019年6月      | ECMAScript 2019 | ES10 |\n| 第11版 | 2020年6月      | ECMAScript 2020 | ES11 |\n| 第12版 | 2021年6月      | ECMAScript 2021 | ES12 |\n\n- **2015年：TypeScript**\n\nTypeScript 是 JavaScript 的超集，即包含JavaScript 的所有元素，能运行JavaScript 的代码，并扩展了JavaScript 的语法。相比于JavaScript ，它还增加了静态类型、类、模块、接口和类型注解方面的功能，更易于大项目的开发。\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015+ 之间的关系：\n\n<img src=\"https://s2.loli.net/2022/02/22/KVoCdwp5rB31zxm.png\" alt=\"image-20211109122048861\" style=\"zoom:50%;\" />\n\n## 1.3 TypeScript 与 JavaScript 的区别\n\n| TypeScript                                     | JavaScript                                 |\n| ---------------------------------------------- | ------------------------------------------ |\n| JavaScript 的超集用于解决大型项目的代码复杂性  | 一种脚本语言，用于创建动态网页             |\n| 可以在编译期间发现并纠正错误                   | 作为一种解释型语言，只能在运行时发现错误   |\n| 强类型，支持静态和动态类型                     | 弱类型，没有静态类型选项                   |\n| 最终被编译成 JavaScript 代码，使浏览器可以理解 | 可以直接在浏览器中使用                     |\n| 支持模块、泛型和接口                           | 不支持模块、泛型或接口                     |\n| 支持 ES3，ES4，ES5 和 ES6+功能                 | 不支持编译其他 ES3，ES4，ES5 或 ES6+ 功能  |\n| 社区的支持仍在增长，而且还不是很大             | 大量的社区支持以及大量文档和解决问题的支持 |\n\n## 1.4 TypeScript 的竞争者有哪些？\n\nTypeScript 的目标是为人们提供编写大型 JavaScript 项目并对后期维护有信心的工具。JavaScript 本身没有的语法支持表示每个标识符的类型，除非运行 JavaScript 并在运行时进行检测。为了解决这个问题，TypeScript 添加了额外的语法。\n\n所以，如果说我们的目标是作为工具提供支持，那么在这个领域有少数几个竞争者是 TypeScript 无法与之竞争的：\n\n- ESLint 和 TSLint：与 TypeScript 的定位相同，它们都是用来突出代码中可能出现的错误，只是没有为检查过程添加新的语法。两者都不打算作为 IDE 集成的工具运行，而且 TS 和 TS/ESLint 经常会说那些对项目没有意义的特性“是对方的领域”。在现代代码中，TS/ESLint 的存在使得 TypeScript 可以做更少的检查，这些检查并不适用于所有代码库。虽然有一些功能重叠了，但可以把它们作为很好的补充工具。\n- CoffeeScript：嘿，TypeScript 是 2012 年发布的！CoffeeScript 和 TypeScript 的区别在于 CoffeeScript 想要改进 JavaScript 语言，比如给 JavaScript 添加一些特性。这意味着要了解 CoffeeScript 与其输出的 JavaScript 的区别。随着时间推移，CoffeeScript 的最佳理念反而将其变成了另一个 JavaScript，人们为几乎成为了 JavaScript 的 CoffeeScript 感到困扰。\n- Flow：这是 Facebook 的 JavaScript 类型检查工具和 IDE 工具语言。就像 TypeScript 一样，Flow 为 JavaScript 添加了一些额外的语法支持，让你拥有了一个更加丰富的类型系统，然后在编译时再将其删除。当我刚开始写 JavaScript 时，Flow 是我最先使用的工具，因为它更接近标准的 JavaScript。Flow 是一个很棒的类型系统，它与 TypeScript 有着不同的目标。任何看不见的类型层系统都必须不断做出“正确”或者“感觉足够正确”的决定，Flow 的目标是“正确”（译者注：Flow 偏向于 **soundness**[6]，在类型判断中更加悲观），而 TypeScript 的目标是“感觉上大部分情况都是正确的”（译者注：而 TS 官方声称 **TS 不是类型完备的**[7]，允许 unsound 行为，偏向于 completeness，在类型判断中更加乐观）。鱼和熊掌不可兼得，完备的类型推导、良好的开发体验和完美的 JS 协同（Perfect JavaScript Interop）只能取其二。\n\n那么，为什么大多数开源 Flow 代码库最终都迁移到了 TypeScript 呢？在我看来，很大程度上是由两个团队不同的侧重点决定。Flow 是为了维护 Facebook 的代码库而建立的，而 TypeScript 是作为一种独立的语言建立的。这里有两个证据可以证明：\n\n1. Facebook 的代码库是一个不能被分割的巨大的 monorepo，而 Flow 团队为了使类型运行在这样的**大代码库**[8]下做了**大量令人难以置信的工作**[9]。另一方面，TypeScript 可以说是“为构建小代码库服务（use projects to make sets of smaller codebases）”，因为这符合人们在开源社区中编写 JavaScript 模块的方式。我认为这么说很合理，TypeScript 不能像 Flow 一样运行在 Facebook 的代码库上，它要么需要大量重写 Facebook 的代码来构建项目，要么需要对 TypeScript 进行大量修改，这可能会影响到 TypeScript 整体开发者的体验。\n2. 对比 DefinitelyTyped 和 Flow 对类型的做法，TypeScript 团队会轮值一名编译器工程师为 DefinitelyTyped 支持我们的构建工具，并帮助管理社区。而 Flow，它几乎完全由社区维护。DT 现在规模更大了，因为它们一直致力于非 Facebook 代码的开发，这将很难获得 Flow 团队的资金支持。\n\n微软给 TypeScript 在内部创造的独立环境让它可以自由专注于工具开发和整个生态系统的维护，而不是只专注于解决某个特别困难的问题。这让 TypeScript 团队能够与许多人合作，不断发布社区想要的功能。随着时间的推移，我猜想因为外部的需求增长放缓，Flow 团队越来越难为社区工作分配时间。这就形成了一个恶性循环。这使得 Flow 今天不再是 TypeScript 的直接“竞争者”，而是一个关于如何从不同的角度，使用不同的约束去解决类似的问题的有趣视角。\n\n## 1.5 TypeScript的未来\n\n### 1.5.1 **对 TypeScript 的未来怎么看？**\n\n目前阻碍人们使用 TypeScript 的最大障碍是它需要构建工具。我认为类型语法不太可能被加入 JavaScript 中，但是在 JavaScript 中“用注释的方式定义类型”的可能性非常大。\n\n这个想法是为 TypeScript 这样的类型系统创建一套语法，但是不定义 JS 运行时会发生什么。\n\n```tsx\nconst a: string = \"1234\";\n\n// 将会变成这样\nconst a /*: string */ = \"1234\";\n\n// 传入 JS 引擎\n```\n\n在这个例子中，JS 引擎会知道 : string 是一个类型注释，在 = 处结尾。这实际的工作方式是复杂的，需要时间来弄清楚。然而，让 TypeScript 能在 JavaScript 中“原生地”运行将降低它被使用的障碍。它会像 Babel 添加 TypeScript 支持时一样对 TypeScript 施加一些约束。但我觉得这是值得的。\n\nDeno 是一个消除所有 TS 障碍的关键例子，它通过运行一个 Rust 编写的工具，能够非常快速地将 TS 编译到 JS，模拟了当前 JavaScript 引擎对原生 TypeScript 的支持。\n\n### 1.5.2 如今的竞争者\n\n- JetBrains WebStorm - 这是一个有高级 JavaScript 工具支持的 IDE。他们有自己的引擎用于重构、代码流分析并对 JavaScript 语法进行检查。这很好，JetBrains 在他们所有的 IDE 上都做了扎实的工作。我过去经常使用 AppCode 处理 iOS 的工作。当你有一个 TypeScript 项目时，WebStorm 会将 TypeScript 的语言工具和自己的工具混合在一起，这对你来说是双赢的。\n- 编译到 JS 的语言 - 目前的例子有 Elm，ReScript，KotlinScript，这些语言的核心目标是与 JavaScript 交互。对于 TypeScript 来说，这些都是很有趣的语言，它们有一个干净的环境来实现类型系统 —— 也就是，没有 JS 包袱。作为竞争对手，它们倾向于更细分的市场，因为它们的核心不是 JavaScript ，并且社区也被从 CoffeeScript 迁移所困扰过。\n- WASM - 我听到 WASM 作为 TypeScript 竞争者的观点是，WASM 可以作为语言取代 JS 控制浏览器 DOM。反对这一观点的人普遍认为，WASM 没有 DOM 绑定，而且可能永远不会有。TypeScript 包含了 JavaScript 的缺点，如果你在 JavaScript 运行时中加入过 WASM 的话，你几乎总是会更加喜欢它。也就是说，AssemblyScript 在这方面做了一些很好的工作。也许把 WASM 想成 JSON 会更好，它是另一个组成项目的工具，不太可能成为 JavaScript 的竞争者，除非 WASM 和 DOM 的交互方式有所改变。\n- 编译到 WASM 的语言 - 比如 Rust，Go，Swift，等其它可以编译到 WASM 的语言。这些语言都可能占据 TypeScript 目前作为工具和 web 核心构建模块的位置，不过世事难料，谁知道会怎么样呢？这些语言能够提供各种不同的基本类型，并且基于不同的目标从头构建。如果 WASM 和 WASI 最终获得成功，那么我认为将会与平台相关（想想 apps 等功能实现），看看它们的发展方向会很有趣。说心里话，它们不会是 TypeScript 的竞争者，而是 JavaScript 的。\n\n### 1.5.3 TypeScript 怎么看它在生态中的位置？\n\nTypeScript 希望在类型系统和编辑器工具领域进行创新。我们拥有在主流编程语言中表达能力最强的类型系统之一。\n\nTypeScript 最初被创建时，对 JavaScript 进行修改的流程和现在非常不同，所以 TypeScript 中有一些特性实际上是 TC39 的领域，但仍然需要向后兼容。这些特性可能在 JavaScript 中存在很多年，并且经过了多次迭代，这意味着 TypeScript 必须维护一个特定语言特性的两种版本。\n\n所以我们的目标是成为 TC39 JavaScript 语言委员会的优秀成员，就编辑器支持的语言特性进行反馈，支持 TypeScript 用户想要看到的特性。通过这种协作方式，TC39 控制了 JavaScript，TypeScript 也支持他们。\n\n### 1.5.4 TypeScript 怎么看它的受众？\n\nTypeScript 的受众主要有:\n\n- JavaScript 用户（作为语言工具）\n- JS + JSDoc 用户（作为语言工具）\n- TypeScript 用户（作为编译器，语言工具）\n- TypeScript 严格模式（作为编译器，语言工具）\n\n虽然项目使用 babel / swc / sucrase / esbuild 等工具构建时，tsc 是可选的，但是上面的几种受众仍然可以在每次或至少每两次 TS 版本发布中获得新特性（译者注：babel、esbuild 等会更新支持 TS 新特性。可能是 TS 团队直接去这些项目里做，也可能会在没有 tsc 的情况下为这些项目提供特性，比如通过 vscode。在 **TS roadmap**[10] 中可以了解更多发布计划）。\n\n### 1.5.5 TypeScript 是如何跟踪 JS 生态的？\n\n团队从以下几个方式听取反馈：\n\n- GitHub issues 有持续不断的评论洪流\n- 微软内部团队要求提供特性，或者要求我们帮忙调试他们缓慢的代码库\n- 通过 Gitter 或者 TypeScript 社区的 Discord 与社区建立联系\n- 通过微团的内部工具对想法 / 设计进行用户测试\n- 与 VS Code 有着非常紧密的联系，许多语言工具的反馈都来自于他们\n- 我们会阅读每一条 @ TypeScript 团队的推特\n- 我们会跟踪迁移到 TypeScript 和从 TypeScript 迁走的博客文章\n- 我们会跟踪行业调查和编程语言概述\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-1、基础篇：TypeScript介绍.md",
        "raw": "---\ntitle: 1-1、基础篇：TypeScript介绍\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nswiper_index: 1\nswiper_cover: /img/recommend/recommend_01.jpg\nswiper_desc: 1-1、基础篇：TypeScript介绍\nabbrlink: 8074\ndate: 2024-01-28 19:34:45\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# （基础篇）一、TypeScript介绍\n\n## 1.1 什么是TypeScript\n\n在引入编程社区 20 多年后，JavaScript 现在已成为有史以来应用最广泛的跨平台语言之一。JavaScript 最初是一种用于向网页添加微不足道的交互性的小型脚本语言，现已发展成为各种规模的前端和后端应用程序的首选语言。虽然用 JavaScript 编写的程序的大小、范围和复杂性呈指数级增长，但 JavaScript 语言表达不同代码单元之间关系的能力却没有。结合 JavaScript 相当奇特的运行时语义，语言和程序复杂性之间的这种不匹配使得 JavaScript 开发成为一项难以大规模管理的任务。\n\n程序员编写的最常见的错误类型可以描述为类型错误：在预期不同类型的值的地方使用了某种类型的值。这可能是由于简单的拼写错误、无法理解库的 API 表面、对运行时行为的错误假设或其他错误。TypeScript 的目标是成为 JavaScript 程序的静态类型检查器——换句话说，是一个在代码运行之前运行的工具（静态）并确保程序的类型正确（类型检查）。\n\nTypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n\nTypeScript 是一种非常受欢迎的 JavaScript 语言扩展。它在现有的 JavaScript 语法之上加入了一层类型层，而这一层即使被删除，也丝毫不会影响运行时的原有表现。许多人认为 TypeScript \"只是一个编译器\"，但更好的理解其实是把 TypeScript 看作两个独立的系统：编译器（即处理语法的部分）和语言工具（即处理与编辑器集成的部分）。通过独立看待这两个系统，就可以得到能够解释我们之前所做决策的两个重要视角。\n\n在 **npm**[3] 上，TypeScript 的下载量每年都在翻倍。截止2021 年 12 月 1 日，它的每周下载量超过为 2200 万次。而在去年 12 月，这一数字约为 1200 万次。它仍保持着高速增长的趋势，没有任何放缓的迹象。\n\n从 2.0 版本开始，TypeScript 每两月定期发布一个 release。但是现在放缓了发布的节奏，改为每三个月发布一次。其中会花一个月编写新 features 并发布 beta 版本，剩下两个月对 beta 版进行测试和 bug 修复，这使得后续的发布更加稳定。\n\n## 1.2 `JS`,`ES`,`TS`的关系\n\n- **1995年：JavaScript**\n\n当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。\n\n由于网景公司希望能在静态HTML页面上添加一些动态效果，于是 `Brendan Eich` 在两周之内设计出了JavaScript语言。\n\n为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。\n\n- **1997年：ECMAScript**\n\n因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）（欧洲计算机制造商协会）组织制定了JavaScript 语言的标准，被称为ECMAScript标准。\n\n| 版本   | 发布时间       | 一般称呼        | 简称 |\n| ------ | -------------- | --------------- | ---- |\n| 第1版  | 1997年6月      | ECMAScript 1    | ES1  |\n| 第2版  | 1998年4月      | ECMAScript 2    | ES2  |\n| 第3版  | 1999年12月     | ECMAScript 3    | ES3  |\n| 第4版  | 2007年10月草案 | ECMAScript 4    | ES4  |\n| 第5版  | 2009年12月     | ECMAScript 5    | ES5  |\n| 第6版  | 2015年6月      | ECMAScript 2015 | ES6  |\n| 第7版  | 2016年6月      | ECMAScript 2016 | ES7  |\n| 第8版  | 2017年6月      | ECMAScript 2017 | ES8  |\n| 第9版  | 2018年6月      | ECMAScript 2018 | ES9  |\n| 第10版 | 2019年6月      | ECMAScript 2019 | ES10 |\n| 第11版 | 2020年6月      | ECMAScript 2020 | ES11 |\n| 第12版 | 2021年6月      | ECMAScript 2021 | ES12 |\n\n- **2015年：TypeScript**\n\nTypeScript 是 JavaScript 的超集，即包含JavaScript 的所有元素，能运行JavaScript 的代码，并扩展了JavaScript 的语法。相比于JavaScript ，它还增加了静态类型、类、模块、接口和类型注解方面的功能，更易于大项目的开发。\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015+ 之间的关系：\n\n<img src=\"https://s2.loli.net/2022/02/22/KVoCdwp5rB31zxm.png\" alt=\"image-20211109122048861\" style=\"zoom:50%;\" />\n\n## 1.3 TypeScript 与 JavaScript 的区别\n\n| TypeScript                                     | JavaScript                                 |\n| ---------------------------------------------- | ------------------------------------------ |\n| JavaScript 的超集用于解决大型项目的代码复杂性  | 一种脚本语言，用于创建动态网页             |\n| 可以在编译期间发现并纠正错误                   | 作为一种解释型语言，只能在运行时发现错误   |\n| 强类型，支持静态和动态类型                     | 弱类型，没有静态类型选项                   |\n| 最终被编译成 JavaScript 代码，使浏览器可以理解 | 可以直接在浏览器中使用                     |\n| 支持模块、泛型和接口                           | 不支持模块、泛型或接口                     |\n| 支持 ES3，ES4，ES5 和 ES6+功能                 | 不支持编译其他 ES3，ES4，ES5 或 ES6+ 功能  |\n| 社区的支持仍在增长，而且还不是很大             | 大量的社区支持以及大量文档和解决问题的支持 |\n\n## 1.4 TypeScript 的竞争者有哪些？\n\nTypeScript 的目标是为人们提供编写大型 JavaScript 项目并对后期维护有信心的工具。JavaScript 本身没有的语法支持表示每个标识符的类型，除非运行 JavaScript 并在运行时进行检测。为了解决这个问题，TypeScript 添加了额外的语法。\n\n所以，如果说我们的目标是作为工具提供支持，那么在这个领域有少数几个竞争者是 TypeScript 无法与之竞争的：\n\n- ESLint 和 TSLint：与 TypeScript 的定位相同，它们都是用来突出代码中可能出现的错误，只是没有为检查过程添加新的语法。两者都不打算作为 IDE 集成的工具运行，而且 TS 和 TS/ESLint 经常会说那些对项目没有意义的特性“是对方的领域”。在现代代码中，TS/ESLint 的存在使得 TypeScript 可以做更少的检查，这些检查并不适用于所有代码库。虽然有一些功能重叠了，但可以把它们作为很好的补充工具。\n- CoffeeScript：嘿，TypeScript 是 2012 年发布的！CoffeeScript 和 TypeScript 的区别在于 CoffeeScript 想要改进 JavaScript 语言，比如给 JavaScript 添加一些特性。这意味着要了解 CoffeeScript 与其输出的 JavaScript 的区别。随着时间推移，CoffeeScript 的最佳理念反而将其变成了另一个 JavaScript，人们为几乎成为了 JavaScript 的 CoffeeScript 感到困扰。\n- Flow：这是 Facebook 的 JavaScript 类型检查工具和 IDE 工具语言。就像 TypeScript 一样，Flow 为 JavaScript 添加了一些额外的语法支持，让你拥有了一个更加丰富的类型系统，然后在编译时再将其删除。当我刚开始写 JavaScript 时，Flow 是我最先使用的工具，因为它更接近标准的 JavaScript。Flow 是一个很棒的类型系统，它与 TypeScript 有着不同的目标。任何看不见的类型层系统都必须不断做出“正确”或者“感觉足够正确”的决定，Flow 的目标是“正确”（译者注：Flow 偏向于 **soundness**[6]，在类型判断中更加悲观），而 TypeScript 的目标是“感觉上大部分情况都是正确的”（译者注：而 TS 官方声称 **TS 不是类型完备的**[7]，允许 unsound 行为，偏向于 completeness，在类型判断中更加乐观）。鱼和熊掌不可兼得，完备的类型推导、良好的开发体验和完美的 JS 协同（Perfect JavaScript Interop）只能取其二。\n\n那么，为什么大多数开源 Flow 代码库最终都迁移到了 TypeScript 呢？在我看来，很大程度上是由两个团队不同的侧重点决定。Flow 是为了维护 Facebook 的代码库而建立的，而 TypeScript 是作为一种独立的语言建立的。这里有两个证据可以证明：\n\n1. Facebook 的代码库是一个不能被分割的巨大的 monorepo，而 Flow 团队为了使类型运行在这样的**大代码库**[8]下做了**大量令人难以置信的工作**[9]。另一方面，TypeScript 可以说是“为构建小代码库服务（use projects to make sets of smaller codebases）”，因为这符合人们在开源社区中编写 JavaScript 模块的方式。我认为这么说很合理，TypeScript 不能像 Flow 一样运行在 Facebook 的代码库上，它要么需要大量重写 Facebook 的代码来构建项目，要么需要对 TypeScript 进行大量修改，这可能会影响到 TypeScript 整体开发者的体验。\n2. 对比 DefinitelyTyped 和 Flow 对类型的做法，TypeScript 团队会轮值一名编译器工程师为 DefinitelyTyped 支持我们的构建工具，并帮助管理社区。而 Flow，它几乎完全由社区维护。DT 现在规模更大了，因为它们一直致力于非 Facebook 代码的开发，这将很难获得 Flow 团队的资金支持。\n\n微软给 TypeScript 在内部创造的独立环境让它可以自由专注于工具开发和整个生态系统的维护，而不是只专注于解决某个特别困难的问题。这让 TypeScript 团队能够与许多人合作，不断发布社区想要的功能。随着时间的推移，我猜想因为外部的需求增长放缓，Flow 团队越来越难为社区工作分配时间。这就形成了一个恶性循环。这使得 Flow 今天不再是 TypeScript 的直接“竞争者”，而是一个关于如何从不同的角度，使用不同的约束去解决类似的问题的有趣视角。\n\n## 1.5 TypeScript的未来\n\n### 1.5.1 **对 TypeScript 的未来怎么看？**\n\n目前阻碍人们使用 TypeScript 的最大障碍是它需要构建工具。我认为类型语法不太可能被加入 JavaScript 中，但是在 JavaScript 中“用注释的方式定义类型”的可能性非常大。\n\n这个想法是为 TypeScript 这样的类型系统创建一套语法，但是不定义 JS 运行时会发生什么。\n\n```tsx\nconst a: string = \"1234\";\n\n// 将会变成这样\nconst a /*: string */ = \"1234\";\n\n// 传入 JS 引擎\n```\n\n在这个例子中，JS 引擎会知道 : string 是一个类型注释，在 = 处结尾。这实际的工作方式是复杂的，需要时间来弄清楚。然而，让 TypeScript 能在 JavaScript 中“原生地”运行将降低它被使用的障碍。它会像 Babel 添加 TypeScript 支持时一样对 TypeScript 施加一些约束。但我觉得这是值得的。\n\nDeno 是一个消除所有 TS 障碍的关键例子，它通过运行一个 Rust 编写的工具，能够非常快速地将 TS 编译到 JS，模拟了当前 JavaScript 引擎对原生 TypeScript 的支持。\n\n### 1.5.2 如今的竞争者\n\n- JetBrains WebStorm - 这是一个有高级 JavaScript 工具支持的 IDE。他们有自己的引擎用于重构、代码流分析并对 JavaScript 语法进行检查。这很好，JetBrains 在他们所有的 IDE 上都做了扎实的工作。我过去经常使用 AppCode 处理 iOS 的工作。当你有一个 TypeScript 项目时，WebStorm 会将 TypeScript 的语言工具和自己的工具混合在一起，这对你来说是双赢的。\n- 编译到 JS 的语言 - 目前的例子有 Elm，ReScript，KotlinScript，这些语言的核心目标是与 JavaScript 交互。对于 TypeScript 来说，这些都是很有趣的语言，它们有一个干净的环境来实现类型系统 —— 也就是，没有 JS 包袱。作为竞争对手，它们倾向于更细分的市场，因为它们的核心不是 JavaScript ，并且社区也被从 CoffeeScript 迁移所困扰过。\n- WASM - 我听到 WASM 作为 TypeScript 竞争者的观点是，WASM 可以作为语言取代 JS 控制浏览器 DOM。反对这一观点的人普遍认为，WASM 没有 DOM 绑定，而且可能永远不会有。TypeScript 包含了 JavaScript 的缺点，如果你在 JavaScript 运行时中加入过 WASM 的话，你几乎总是会更加喜欢它。也就是说，AssemblyScript 在这方面做了一些很好的工作。也许把 WASM 想成 JSON 会更好，它是另一个组成项目的工具，不太可能成为 JavaScript 的竞争者，除非 WASM 和 DOM 的交互方式有所改变。\n- 编译到 WASM 的语言 - 比如 Rust，Go，Swift，等其它可以编译到 WASM 的语言。这些语言都可能占据 TypeScript 目前作为工具和 web 核心构建模块的位置，不过世事难料，谁知道会怎么样呢？这些语言能够提供各种不同的基本类型，并且基于不同的目标从头构建。如果 WASM 和 WASI 最终获得成功，那么我认为将会与平台相关（想想 apps 等功能实现），看看它们的发展方向会很有趣。说心里话，它们不会是 TypeScript 的竞争者，而是 JavaScript 的。\n\n### 1.5.3 TypeScript 怎么看它在生态中的位置？\n\nTypeScript 希望在类型系统和编辑器工具领域进行创新。我们拥有在主流编程语言中表达能力最强的类型系统之一。\n\nTypeScript 最初被创建时，对 JavaScript 进行修改的流程和现在非常不同，所以 TypeScript 中有一些特性实际上是 TC39 的领域，但仍然需要向后兼容。这些特性可能在 JavaScript 中存在很多年，并且经过了多次迭代，这意味着 TypeScript 必须维护一个特定语言特性的两种版本。\n\n所以我们的目标是成为 TC39 JavaScript 语言委员会的优秀成员，就编辑器支持的语言特性进行反馈，支持 TypeScript 用户想要看到的特性。通过这种协作方式，TC39 控制了 JavaScript，TypeScript 也支持他们。\n\n### 1.5.4 TypeScript 怎么看它的受众？\n\nTypeScript 的受众主要有:\n\n- JavaScript 用户（作为语言工具）\n- JS + JSDoc 用户（作为语言工具）\n- TypeScript 用户（作为编译器，语言工具）\n- TypeScript 严格模式（作为编译器，语言工具）\n\n虽然项目使用 babel / swc / sucrase / esbuild 等工具构建时，tsc 是可选的，但是上面的几种受众仍然可以在每次或至少每两次 TS 版本发布中获得新特性（译者注：babel、esbuild 等会更新支持 TS 新特性。可能是 TS 团队直接去这些项目里做，也可能会在没有 tsc 的情况下为这些项目提供特性，比如通过 vscode。在 **TS roadmap**[10] 中可以了解更多发布计划）。\n\n### 1.5.5 TypeScript 是如何跟踪 JS 生态的？\n\n团队从以下几个方式听取反馈：\n\n- GitHub issues 有持续不断的评论洪流\n- 微软内部团队要求提供特性，或者要求我们帮忙调试他们缓慢的代码库\n- 通过 Gitter 或者 TypeScript 社区的 Discord 与社区建立联系\n- 通过微团的内部工具对想法 / 设计进行用户测试\n- 与 VS Code 有着非常紧密的联系，许多语言工具的反馈都来自于他们\n- 我们会阅读每一条 @ TypeScript 团队的推特\n- 我们会跟踪迁移到 TypeScript 和从 TypeScript 迁走的博客文章\n- 我们会跟踪行业调查和编程语言概述\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-1、基础篇：TypeScript介绍",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao0000d94v3ggi9et19",
        "content": "<h1 id=\"（基础篇）一、TypeScript介绍\"><a href=\"#（基础篇）一、TypeScript介绍\" class=\"headerlink\" title=\"（基础篇）一、TypeScript介绍\"></a>（基础篇）一、TypeScript介绍</h1><h2 id=\"1-1-什么是TypeScript\"><a href=\"#1-1-什么是TypeScript\" class=\"headerlink\" title=\"1.1 什么是TypeScript\"></a>1.1 什么是TypeScript</h2><p>在引入编程社区 20 多年后，JavaScript 现在已成为有史以来应用最广泛的跨平台语言之一。JavaScript 最初是一种用于向网页添加微不足道的交互性的小型脚本语言，现已发展成为各种规模的前端和后端应用程序的首选语言。虽然用 JavaScript 编写的程序的大小、范围和复杂性呈指数级增长，但 JavaScript 语言表达不同代码单元之间关系的能力却没有。结合 JavaScript 相当奇特的运行时语义，语言和程序复杂性之间的这种不匹配使得 JavaScript 开发成为一项难以大规模管理的任务。</p>\n<p>程序员编写的最常见的错误类型可以描述为类型错误：在预期不同类型的值的地方使用了某种类型的值。这可能是由于简单的拼写错误、无法理解库的 API 表面、对运行时行为的错误假设或其他错误。TypeScript 的目标是成为 JavaScript 程序的静态类型检查器——换句话说，是一个在代码运行之前运行的工具（静态）并确保程序的类型正确（类型检查）。</p>\n<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p>\n<p>TypeScript 是一种非常受欢迎的 JavaScript 语言扩展。它在现有的 JavaScript 语法之上加入了一层类型层，而这一层即使被删除，也丝毫不会影响运行时的原有表现。许多人认为 TypeScript “只是一个编译器”，但更好的理解其实是把 TypeScript 看作两个独立的系统：编译器（即处理语法的部分）和语言工具（即处理与编辑器集成的部分）。通过独立看待这两个系统，就可以得到能够解释我们之前所做决策的两个重要视角。</p>\n<p>在 <strong>npm</strong>[3] 上，TypeScript 的下载量每年都在翻倍。截止2021 年 12 月 1 日，它的每周下载量超过为 2200 万次。而在去年 12 月，这一数字约为 1200 万次。它仍保持着高速增长的趋势，没有任何放缓的迹象。</p>\n<p>从 2.0 版本开始，TypeScript 每两月定期发布一个 release。但是现在放缓了发布的节奏，改为每三个月发布一次。其中会花一个月编写新 features 并发布 beta 版本，剩下两个月对 beta 版进行测试和 bug 修复，这使得后续的发布更加稳定。</p>\n<h2 id=\"1-2-JS-ES-TS的关系\"><a href=\"#1-2-JS-ES-TS的关系\" class=\"headerlink\" title=\"1.2 JS,ES,TS的关系\"></a>1.2 <code>JS</code>,<code>ES</code>,<code>TS</code>的关系</h2><ul>\n<li><strong>1995年：JavaScript</strong></li>\n</ul>\n<p>当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。</p>\n<p>由于网景公司希望能在静态HTML页面上添加一些动态效果，于是 <code>Brendan Eich</code> 在两周之内设计出了JavaScript语言。</p>\n<p>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p>\n<ul>\n<li><strong>1997年：ECMAScript</strong></li>\n</ul>\n<p>因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）（欧洲计算机制造商协会）组织制定了JavaScript 语言的标准，被称为ECMAScript标准。</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>发布时间</th>\n<th>一般称呼</th>\n<th>简称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>第1版</td>\n<td>1997年6月</td>\n<td>ECMAScript 1</td>\n<td>ES1</td>\n</tr>\n<tr>\n<td>第2版</td>\n<td>1998年4月</td>\n<td>ECMAScript 2</td>\n<td>ES2</td>\n</tr>\n<tr>\n<td>第3版</td>\n<td>1999年12月</td>\n<td>ECMAScript 3</td>\n<td>ES3</td>\n</tr>\n<tr>\n<td>第4版</td>\n<td>2007年10月草案</td>\n<td>ECMAScript 4</td>\n<td>ES4</td>\n</tr>\n<tr>\n<td>第5版</td>\n<td>2009年12月</td>\n<td>ECMAScript 5</td>\n<td>ES5</td>\n</tr>\n<tr>\n<td>第6版</td>\n<td>2015年6月</td>\n<td>ECMAScript 2015</td>\n<td>ES6</td>\n</tr>\n<tr>\n<td>第7版</td>\n<td>2016年6月</td>\n<td>ECMAScript 2016</td>\n<td>ES7</td>\n</tr>\n<tr>\n<td>第8版</td>\n<td>2017年6月</td>\n<td>ECMAScript 2017</td>\n<td>ES8</td>\n</tr>\n<tr>\n<td>第9版</td>\n<td>2018年6月</td>\n<td>ECMAScript 2018</td>\n<td>ES9</td>\n</tr>\n<tr>\n<td>第10版</td>\n<td>2019年6月</td>\n<td>ECMAScript 2019</td>\n<td>ES10</td>\n</tr>\n<tr>\n<td>第11版</td>\n<td>2020年6月</td>\n<td>ECMAScript 2020</td>\n<td>ES11</td>\n</tr>\n<tr>\n<td>第12版</td>\n<td>2021年6月</td>\n<td>ECMAScript 2021</td>\n<td>ES12</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>2015年：TypeScript</strong></li>\n</ul>\n<p>TypeScript 是 JavaScript 的超集，即包含JavaScript 的所有元素，能运行JavaScript 的代码，并扩展了JavaScript 的语法。相比于JavaScript ，它还增加了静态类型、类、模块、接口和类型注解方面的功能，更易于大项目的开发。</p>\n<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015+ 之间的关系：</p>\n<img src=\"https://s2.loli.net/2022/02/22/KVoCdwp5rB31zxm.png\" alt=\"image-20211109122048861\" style=\"zoom:50%;\" />\n\n<h2 id=\"1-3-TypeScript-与-JavaScript-的区别\"><a href=\"#1-3-TypeScript-与-JavaScript-的区别\" class=\"headerlink\" title=\"1.3 TypeScript 与 JavaScript 的区别\"></a>1.3 TypeScript 与 JavaScript 的区别</h2><table>\n<thead>\n<tr>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JavaScript 的超集用于解决大型项目的代码复杂性</td>\n<td>一种脚本语言，用于创建动态网页</td>\n</tr>\n<tr>\n<td>可以在编译期间发现并纠正错误</td>\n<td>作为一种解释型语言，只能在运行时发现错误</td>\n</tr>\n<tr>\n<td>强类型，支持静态和动态类型</td>\n<td>弱类型，没有静态类型选项</td>\n</tr>\n<tr>\n<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>\n<td>可以直接在浏览器中使用</td>\n</tr>\n<tr>\n<td>支持模块、泛型和接口</td>\n<td>不支持模块、泛型或接口</td>\n</tr>\n<tr>\n<td>支持 ES3，ES4，ES5 和 ES6+功能</td>\n<td>不支持编译其他 ES3，ES4，ES5 或 ES6+ 功能</td>\n</tr>\n<tr>\n<td>社区的支持仍在增长，而且还不是很大</td>\n<td>大量的社区支持以及大量文档和解决问题的支持</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-4-TypeScript-的竞争者有哪些？\"><a href=\"#1-4-TypeScript-的竞争者有哪些？\" class=\"headerlink\" title=\"1.4 TypeScript 的竞争者有哪些？\"></a>1.4 TypeScript 的竞争者有哪些？</h2><p>TypeScript 的目标是为人们提供编写大型 JavaScript 项目并对后期维护有信心的工具。JavaScript 本身没有的语法支持表示每个标识符的类型，除非运行 JavaScript 并在运行时进行检测。为了解决这个问题，TypeScript 添加了额外的语法。</p>\n<p>所以，如果说我们的目标是作为工具提供支持，那么在这个领域有少数几个竞争者是 TypeScript 无法与之竞争的：</p>\n<ul>\n<li>ESLint 和 TSLint：与 TypeScript 的定位相同，它们都是用来突出代码中可能出现的错误，只是没有为检查过程添加新的语法。两者都不打算作为 IDE 集成的工具运行，而且 TS 和 TS&#x2F;ESLint 经常会说那些对项目没有意义的特性“是对方的领域”。在现代代码中，TS&#x2F;ESLint 的存在使得 TypeScript 可以做更少的检查，这些检查并不适用于所有代码库。虽然有一些功能重叠了，但可以把它们作为很好的补充工具。</li>\n<li>CoffeeScript：嘿，TypeScript 是 2012 年发布的！CoffeeScript 和 TypeScript 的区别在于 CoffeeScript 想要改进 JavaScript 语言，比如给 JavaScript 添加一些特性。这意味着要了解 CoffeeScript 与其输出的 JavaScript 的区别。随着时间推移，CoffeeScript 的最佳理念反而将其变成了另一个 JavaScript，人们为几乎成为了 JavaScript 的 CoffeeScript 感到困扰。</li>\n<li>Flow：这是 Facebook 的 JavaScript 类型检查工具和 IDE 工具语言。就像 TypeScript 一样，Flow 为 JavaScript 添加了一些额外的语法支持，让你拥有了一个更加丰富的类型系统，然后在编译时再将其删除。当我刚开始写 JavaScript 时，Flow 是我最先使用的工具，因为它更接近标准的 JavaScript。Flow 是一个很棒的类型系统，它与 TypeScript 有着不同的目标。任何看不见的类型层系统都必须不断做出“正确”或者“感觉足够正确”的决定，Flow 的目标是“正确”（译者注：Flow 偏向于 <strong>soundness</strong>[6]，在类型判断中更加悲观），而 TypeScript 的目标是“感觉上大部分情况都是正确的”（译者注：而 TS 官方声称 <strong>TS 不是类型完备的</strong>[7]，允许 unsound 行为，偏向于 completeness，在类型判断中更加乐观）。鱼和熊掌不可兼得，完备的类型推导、良好的开发体验和完美的 JS 协同（Perfect JavaScript Interop）只能取其二。</li>\n</ul>\n<p>那么，为什么大多数开源 Flow 代码库最终都迁移到了 TypeScript 呢？在我看来，很大程度上是由两个团队不同的侧重点决定。Flow 是为了维护 Facebook 的代码库而建立的，而 TypeScript 是作为一种独立的语言建立的。这里有两个证据可以证明：</p>\n<ol>\n<li>Facebook 的代码库是一个不能被分割的巨大的 monorepo，而 Flow 团队为了使类型运行在这样的<strong>大代码库</strong>[8]下做了<strong>大量令人难以置信的工作</strong>[9]。另一方面，TypeScript 可以说是“为构建小代码库服务（use projects to make sets of smaller codebases）”，因为这符合人们在开源社区中编写 JavaScript 模块的方式。我认为这么说很合理，TypeScript 不能像 Flow 一样运行在 Facebook 的代码库上，它要么需要大量重写 Facebook 的代码来构建项目，要么需要对 TypeScript 进行大量修改，这可能会影响到 TypeScript 整体开发者的体验。</li>\n<li>对比 DefinitelyTyped 和 Flow 对类型的做法，TypeScript 团队会轮值一名编译器工程师为 DefinitelyTyped 支持我们的构建工具，并帮助管理社区。而 Flow，它几乎完全由社区维护。DT 现在规模更大了，因为它们一直致力于非 Facebook 代码的开发，这将很难获得 Flow 团队的资金支持。</li>\n</ol>\n<p>微软给 TypeScript 在内部创造的独立环境让它可以自由专注于工具开发和整个生态系统的维护，而不是只专注于解决某个特别困难的问题。这让 TypeScript 团队能够与许多人合作，不断发布社区想要的功能。随着时间的推移，我猜想因为外部的需求增长放缓，Flow 团队越来越难为社区工作分配时间。这就形成了一个恶性循环。这使得 Flow 今天不再是 TypeScript 的直接“竞争者”，而是一个关于如何从不同的角度，使用不同的约束去解决类似的问题的有趣视角。</p>\n<h2 id=\"1-5-TypeScript的未来\"><a href=\"#1-5-TypeScript的未来\" class=\"headerlink\" title=\"1.5 TypeScript的未来\"></a>1.5 TypeScript的未来</h2><h3 id=\"1-5-1-对-TypeScript-的未来怎么看？\"><a href=\"#1-5-1-对-TypeScript-的未来怎么看？\" class=\"headerlink\" title=\"1.5.1 对 TypeScript 的未来怎么看？\"></a>1.5.1 <strong>对 TypeScript 的未来怎么看？</strong></h3><p>目前阻碍人们使用 TypeScript 的最大障碍是它需要构建工具。我认为类型语法不太可能被加入 JavaScript 中，但是在 JavaScript 中“用注释的方式定义类型”的可能性非常大。</p>\n<p>这个想法是为 TypeScript 这样的类型系统创建一套语法，但是不定义 JS 运行时会发生什么。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;1234&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将会变成这样</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a <span class=\"comment\">/*: string */</span> = <span class=\"string\">&quot;1234&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入 JS 引擎</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，JS 引擎会知道 : string 是一个类型注释，在 &#x3D; 处结尾。这实际的工作方式是复杂的，需要时间来弄清楚。然而，让 TypeScript 能在 JavaScript 中“原生地”运行将降低它被使用的障碍。它会像 Babel 添加 TypeScript 支持时一样对 TypeScript 施加一些约束。但我觉得这是值得的。</p>\n<p>Deno 是一个消除所有 TS 障碍的关键例子，它通过运行一个 Rust 编写的工具，能够非常快速地将 TS 编译到 JS，模拟了当前 JavaScript 引擎对原生 TypeScript 的支持。</p>\n<h3 id=\"1-5-2-如今的竞争者\"><a href=\"#1-5-2-如今的竞争者\" class=\"headerlink\" title=\"1.5.2 如今的竞争者\"></a>1.5.2 如今的竞争者</h3><ul>\n<li>JetBrains WebStorm - 这是一个有高级 JavaScript 工具支持的 IDE。他们有自己的引擎用于重构、代码流分析并对 JavaScript 语法进行检查。这很好，JetBrains 在他们所有的 IDE 上都做了扎实的工作。我过去经常使用 AppCode 处理 iOS 的工作。当你有一个 TypeScript 项目时，WebStorm 会将 TypeScript 的语言工具和自己的工具混合在一起，这对你来说是双赢的。</li>\n<li>编译到 JS 的语言 - 目前的例子有 Elm，ReScript，KotlinScript，这些语言的核心目标是与 JavaScript 交互。对于 TypeScript 来说，这些都是很有趣的语言，它们有一个干净的环境来实现类型系统 —— 也就是，没有 JS 包袱。作为竞争对手，它们倾向于更细分的市场，因为它们的核心不是 JavaScript ，并且社区也被从 CoffeeScript 迁移所困扰过。</li>\n<li>WASM - 我听到 WASM 作为 TypeScript 竞争者的观点是，WASM 可以作为语言取代 JS 控制浏览器 DOM。反对这一观点的人普遍认为，WASM 没有 DOM 绑定，而且可能永远不会有。TypeScript 包含了 JavaScript 的缺点，如果你在 JavaScript 运行时中加入过 WASM 的话，你几乎总是会更加喜欢它。也就是说，AssemblyScript 在这方面做了一些很好的工作。也许把 WASM 想成 JSON 会更好，它是另一个组成项目的工具，不太可能成为 JavaScript 的竞争者，除非 WASM 和 DOM 的交互方式有所改变。</li>\n<li>编译到 WASM 的语言 - 比如 Rust，Go，Swift，等其它可以编译到 WASM 的语言。这些语言都可能占据 TypeScript 目前作为工具和 web 核心构建模块的位置，不过世事难料，谁知道会怎么样呢？这些语言能够提供各种不同的基本类型，并且基于不同的目标从头构建。如果 WASM 和 WASI 最终获得成功，那么我认为将会与平台相关（想想 apps 等功能实现），看看它们的发展方向会很有趣。说心里话，它们不会是 TypeScript 的竞争者，而是 JavaScript 的。</li>\n</ul>\n<h3 id=\"1-5-3-TypeScript-怎么看它在生态中的位置？\"><a href=\"#1-5-3-TypeScript-怎么看它在生态中的位置？\" class=\"headerlink\" title=\"1.5.3 TypeScript 怎么看它在生态中的位置？\"></a>1.5.3 TypeScript 怎么看它在生态中的位置？</h3><p>TypeScript 希望在类型系统和编辑器工具领域进行创新。我们拥有在主流编程语言中表达能力最强的类型系统之一。</p>\n<p>TypeScript 最初被创建时，对 JavaScript 进行修改的流程和现在非常不同，所以 TypeScript 中有一些特性实际上是 TC39 的领域，但仍然需要向后兼容。这些特性可能在 JavaScript 中存在很多年，并且经过了多次迭代，这意味着 TypeScript 必须维护一个特定语言特性的两种版本。</p>\n<p>所以我们的目标是成为 TC39 JavaScript 语言委员会的优秀成员，就编辑器支持的语言特性进行反馈，支持 TypeScript 用户想要看到的特性。通过这种协作方式，TC39 控制了 JavaScript，TypeScript 也支持他们。</p>\n<h3 id=\"1-5-4-TypeScript-怎么看它的受众？\"><a href=\"#1-5-4-TypeScript-怎么看它的受众？\" class=\"headerlink\" title=\"1.5.4 TypeScript 怎么看它的受众？\"></a>1.5.4 TypeScript 怎么看它的受众？</h3><p>TypeScript 的受众主要有:</p>\n<ul>\n<li>JavaScript 用户（作为语言工具）</li>\n<li>JS + JSDoc 用户（作为语言工具）</li>\n<li>TypeScript 用户（作为编译器，语言工具）</li>\n<li>TypeScript 严格模式（作为编译器，语言工具）</li>\n</ul>\n<p>虽然项目使用 babel &#x2F; swc &#x2F; sucrase &#x2F; esbuild 等工具构建时，tsc 是可选的，但是上面的几种受众仍然可以在每次或至少每两次 TS 版本发布中获得新特性（译者注：babel、esbuild 等会更新支持 TS 新特性。可能是 TS 团队直接去这些项目里做，也可能会在没有 tsc 的情况下为这些项目提供特性，比如通过 vscode。在 <strong>TS roadmap</strong>[10] 中可以了解更多发布计划）。</p>\n<h3 id=\"1-5-5-TypeScript-是如何跟踪-JS-生态的？\"><a href=\"#1-5-5-TypeScript-是如何跟踪-JS-生态的？\" class=\"headerlink\" title=\"1.5.5 TypeScript 是如何跟踪 JS 生态的？\"></a>1.5.5 TypeScript 是如何跟踪 JS 生态的？</h3><p>团队从以下几个方式听取反馈：</p>\n<ul>\n<li>GitHub issues 有持续不断的评论洪流</li>\n<li>微软内部团队要求提供特性，或者要求我们帮忙调试他们缓慢的代码库</li>\n<li>通过 Gitter 或者 TypeScript 社区的 Discord 与社区建立联系</li>\n<li>通过微团的内部工具对想法 &#x2F; 设计进行用户测试</li>\n<li>与 VS Code 有着非常紧密的联系，许多语言工具的反馈都来自于他们</li>\n<li>我们会阅读每一条 @ TypeScript 团队的推特</li>\n<li>我们会跟踪迁移到 TypeScript 和从 TypeScript 迁走的博客文章</li>\n<li>我们会跟踪行业调查和编程语言概述</li>\n</ul>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"（基础篇）一、TypeScript介绍\"><a href=\"#（基础篇）一、TypeScript介绍\" class=\"headerlink\" title=\"（基础篇）一、TypeScript介绍\"></a>（基础篇）一、TypeScript介绍</h1><h2 id=\"1-1-什么是TypeScript\"><a href=\"#1-1-什么是TypeScript\" class=\"headerlink\" title=\"1.1 什么是TypeScript\"></a>1.1 什么是TypeScript</h2><p>在引入编程社区 20 多年后，JavaScript 现在已成为有史以来应用最广泛的跨平台语言之一。JavaScript 最初是一种用于向网页添加微不足道的交互性的小型脚本语言，现已发展成为各种规模的前端和后端应用程序的首选语言。虽然用 JavaScript 编写的程序的大小、范围和复杂性呈指数级增长，但 JavaScript 语言表达不同代码单元之间关系的能力却没有。结合 JavaScript 相当奇特的运行时语义，语言和程序复杂性之间的这种不匹配使得 JavaScript 开发成为一项难以大规模管理的任务。</p>\n<p>程序员编写的最常见的错误类型可以描述为类型错误：在预期不同类型的值的地方使用了某种类型的值。这可能是由于简单的拼写错误、无法理解库的 API 表面、对运行时行为的错误假设或其他错误。TypeScript 的目标是成为 JavaScript 程序的静态类型检查器——换句话说，是一个在代码运行之前运行的工具（静态）并确保程序的类型正确（类型检查）。</p>\n<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p>\n<p>TypeScript 是一种非常受欢迎的 JavaScript 语言扩展。它在现有的 JavaScript 语法之上加入了一层类型层，而这一层即使被删除，也丝毫不会影响运行时的原有表现。许多人认为 TypeScript “只是一个编译器”，但更好的理解其实是把 TypeScript 看作两个独立的系统：编译器（即处理语法的部分）和语言工具（即处理与编辑器集成的部分）。通过独立看待这两个系统，就可以得到能够解释我们之前所做决策的两个重要视角。</p>\n<p>在 <strong>npm</strong>[3] 上，TypeScript 的下载量每年都在翻倍。截止2021 年 12 月 1 日，它的每周下载量超过为 2200 万次。而在去年 12 月，这一数字约为 1200 万次。它仍保持着高速增长的趋势，没有任何放缓的迹象。</p>\n<p>从 2.0 版本开始，TypeScript 每两月定期发布一个 release。但是现在放缓了发布的节奏，改为每三个月发布一次。其中会花一个月编写新 features 并发布 beta 版本，剩下两个月对 beta 版进行测试和 bug 修复，这使得后续的发布更加稳定。</p>\n<h2 id=\"1-2-JS-ES-TS的关系\"><a href=\"#1-2-JS-ES-TS的关系\" class=\"headerlink\" title=\"1.2 JS,ES,TS的关系\"></a>1.2 <code>JS</code>,<code>ES</code>,<code>TS</code>的关系</h2><ul>\n<li><strong>1995年：JavaScript</strong></li>\n</ul>\n<p>当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。</p>\n<p>由于网景公司希望能在静态HTML页面上添加一些动态效果，于是 <code>Brendan Eich</code> 在两周之内设计出了JavaScript语言。</p>\n<p>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p>\n<ul>\n<li><strong>1997年：ECMAScript</strong></li>\n</ul>\n<p>因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）（欧洲计算机制造商协会）组织制定了JavaScript 语言的标准，被称为ECMAScript标准。</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>发布时间</th>\n<th>一般称呼</th>\n<th>简称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>第1版</td>\n<td>1997年6月</td>\n<td>ECMAScript 1</td>\n<td>ES1</td>\n</tr>\n<tr>\n<td>第2版</td>\n<td>1998年4月</td>\n<td>ECMAScript 2</td>\n<td>ES2</td>\n</tr>\n<tr>\n<td>第3版</td>\n<td>1999年12月</td>\n<td>ECMAScript 3</td>\n<td>ES3</td>\n</tr>\n<tr>\n<td>第4版</td>\n<td>2007年10月草案</td>\n<td>ECMAScript 4</td>\n<td>ES4</td>\n</tr>\n<tr>\n<td>第5版</td>\n<td>2009年12月</td>\n<td>ECMAScript 5</td>\n<td>ES5</td>\n</tr>\n<tr>\n<td>第6版</td>\n<td>2015年6月</td>\n<td>ECMAScript 2015</td>\n<td>ES6</td>\n</tr>\n<tr>\n<td>第7版</td>\n<td>2016年6月</td>\n<td>ECMAScript 2016</td>\n<td>ES7</td>\n</tr>\n<tr>\n<td>第8版</td>\n<td>2017年6月</td>\n<td>ECMAScript 2017</td>\n<td>ES8</td>\n</tr>\n<tr>\n<td>第9版</td>\n<td>2018年6月</td>\n<td>ECMAScript 2018</td>\n<td>ES9</td>\n</tr>\n<tr>\n<td>第10版</td>\n<td>2019年6月</td>\n<td>ECMAScript 2019</td>\n<td>ES10</td>\n</tr>\n<tr>\n<td>第11版</td>\n<td>2020年6月</td>\n<td>ECMAScript 2020</td>\n<td>ES11</td>\n</tr>\n<tr>\n<td>第12版</td>\n<td>2021年6月</td>\n<td>ECMAScript 2021</td>\n<td>ES12</td>\n</tr>\n</tbody></table>\n<ul>\n<li><strong>2015年：TypeScript</strong></li>\n</ul>\n<p>TypeScript 是 JavaScript 的超集，即包含JavaScript 的所有元素，能运行JavaScript 的代码，并扩展了JavaScript 的语法。相比于JavaScript ，它还增加了静态类型、类、模块、接口和类型注解方面的功能，更易于大项目的开发。</p>\n<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015+ 之间的关系：</p>\n<img src=\"https://s2.loli.net/2022/02/22/KVoCdwp5rB31zxm.png\" alt=\"image-20211109122048861\" style=\"zoom:50%;\" />\n\n<h2 id=\"1-3-TypeScript-与-JavaScript-的区别\"><a href=\"#1-3-TypeScript-与-JavaScript-的区别\" class=\"headerlink\" title=\"1.3 TypeScript 与 JavaScript 的区别\"></a>1.3 TypeScript 与 JavaScript 的区别</h2><table>\n<thead>\n<tr>\n<th>TypeScript</th>\n<th>JavaScript</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JavaScript 的超集用于解决大型项目的代码复杂性</td>\n<td>一种脚本语言，用于创建动态网页</td>\n</tr>\n<tr>\n<td>可以在编译期间发现并纠正错误</td>\n<td>作为一种解释型语言，只能在运行时发现错误</td>\n</tr>\n<tr>\n<td>强类型，支持静态和动态类型</td>\n<td>弱类型，没有静态类型选项</td>\n</tr>\n<tr>\n<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>\n<td>可以直接在浏览器中使用</td>\n</tr>\n<tr>\n<td>支持模块、泛型和接口</td>\n<td>不支持模块、泛型或接口</td>\n</tr>\n<tr>\n<td>支持 ES3，ES4，ES5 和 ES6+功能</td>\n<td>不支持编译其他 ES3，ES4，ES5 或 ES6+ 功能</td>\n</tr>\n<tr>\n<td>社区的支持仍在增长，而且还不是很大</td>\n<td>大量的社区支持以及大量文档和解决问题的支持</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-4-TypeScript-的竞争者有哪些？\"><a href=\"#1-4-TypeScript-的竞争者有哪些？\" class=\"headerlink\" title=\"1.4 TypeScript 的竞争者有哪些？\"></a>1.4 TypeScript 的竞争者有哪些？</h2><p>TypeScript 的目标是为人们提供编写大型 JavaScript 项目并对后期维护有信心的工具。JavaScript 本身没有的语法支持表示每个标识符的类型，除非运行 JavaScript 并在运行时进行检测。为了解决这个问题，TypeScript 添加了额外的语法。</p>\n<p>所以，如果说我们的目标是作为工具提供支持，那么在这个领域有少数几个竞争者是 TypeScript 无法与之竞争的：</p>\n<ul>\n<li>ESLint 和 TSLint：与 TypeScript 的定位相同，它们都是用来突出代码中可能出现的错误，只是没有为检查过程添加新的语法。两者都不打算作为 IDE 集成的工具运行，而且 TS 和 TS&#x2F;ESLint 经常会说那些对项目没有意义的特性“是对方的领域”。在现代代码中，TS&#x2F;ESLint 的存在使得 TypeScript 可以做更少的检查，这些检查并不适用于所有代码库。虽然有一些功能重叠了，但可以把它们作为很好的补充工具。</li>\n<li>CoffeeScript：嘿，TypeScript 是 2012 年发布的！CoffeeScript 和 TypeScript 的区别在于 CoffeeScript 想要改进 JavaScript 语言，比如给 JavaScript 添加一些特性。这意味着要了解 CoffeeScript 与其输出的 JavaScript 的区别。随着时间推移，CoffeeScript 的最佳理念反而将其变成了另一个 JavaScript，人们为几乎成为了 JavaScript 的 CoffeeScript 感到困扰。</li>\n<li>Flow：这是 Facebook 的 JavaScript 类型检查工具和 IDE 工具语言。就像 TypeScript 一样，Flow 为 JavaScript 添加了一些额外的语法支持，让你拥有了一个更加丰富的类型系统，然后在编译时再将其删除。当我刚开始写 JavaScript 时，Flow 是我最先使用的工具，因为它更接近标准的 JavaScript。Flow 是一个很棒的类型系统，它与 TypeScript 有着不同的目标。任何看不见的类型层系统都必须不断做出“正确”或者“感觉足够正确”的决定，Flow 的目标是“正确”（译者注：Flow 偏向于 <strong>soundness</strong>[6]，在类型判断中更加悲观），而 TypeScript 的目标是“感觉上大部分情况都是正确的”（译者注：而 TS 官方声称 <strong>TS 不是类型完备的</strong>[7]，允许 unsound 行为，偏向于 completeness，在类型判断中更加乐观）。鱼和熊掌不可兼得，完备的类型推导、良好的开发体验和完美的 JS 协同（Perfect JavaScript Interop）只能取其二。</li>\n</ul>\n<p>那么，为什么大多数开源 Flow 代码库最终都迁移到了 TypeScript 呢？在我看来，很大程度上是由两个团队不同的侧重点决定。Flow 是为了维护 Facebook 的代码库而建立的，而 TypeScript 是作为一种独立的语言建立的。这里有两个证据可以证明：</p>\n<ol>\n<li>Facebook 的代码库是一个不能被分割的巨大的 monorepo，而 Flow 团队为了使类型运行在这样的<strong>大代码库</strong>[8]下做了<strong>大量令人难以置信的工作</strong>[9]。另一方面，TypeScript 可以说是“为构建小代码库服务（use projects to make sets of smaller codebases）”，因为这符合人们在开源社区中编写 JavaScript 模块的方式。我认为这么说很合理，TypeScript 不能像 Flow 一样运行在 Facebook 的代码库上，它要么需要大量重写 Facebook 的代码来构建项目，要么需要对 TypeScript 进行大量修改，这可能会影响到 TypeScript 整体开发者的体验。</li>\n<li>对比 DefinitelyTyped 和 Flow 对类型的做法，TypeScript 团队会轮值一名编译器工程师为 DefinitelyTyped 支持我们的构建工具，并帮助管理社区。而 Flow，它几乎完全由社区维护。DT 现在规模更大了，因为它们一直致力于非 Facebook 代码的开发，这将很难获得 Flow 团队的资金支持。</li>\n</ol>\n<p>微软给 TypeScript 在内部创造的独立环境让它可以自由专注于工具开发和整个生态系统的维护，而不是只专注于解决某个特别困难的问题。这让 TypeScript 团队能够与许多人合作，不断发布社区想要的功能。随着时间的推移，我猜想因为外部的需求增长放缓，Flow 团队越来越难为社区工作分配时间。这就形成了一个恶性循环。这使得 Flow 今天不再是 TypeScript 的直接“竞争者”，而是一个关于如何从不同的角度，使用不同的约束去解决类似的问题的有趣视角。</p>\n<h2 id=\"1-5-TypeScript的未来\"><a href=\"#1-5-TypeScript的未来\" class=\"headerlink\" title=\"1.5 TypeScript的未来\"></a>1.5 TypeScript的未来</h2><h3 id=\"1-5-1-对-TypeScript-的未来怎么看？\"><a href=\"#1-5-1-对-TypeScript-的未来怎么看？\" class=\"headerlink\" title=\"1.5.1 对 TypeScript 的未来怎么看？\"></a>1.5.1 <strong>对 TypeScript 的未来怎么看？</strong></h3><p>目前阻碍人们使用 TypeScript 的最大障碍是它需要构建工具。我认为类型语法不太可能被加入 JavaScript 中，但是在 JavaScript 中“用注释的方式定义类型”的可能性非常大。</p>\n<p>这个想法是为 TypeScript 这样的类型系统创建一套语法，但是不定义 JS 运行时会发生什么。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;1234&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将会变成这样</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a <span class=\"comment\">/*: string */</span> = <span class=\"string\">&quot;1234&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入 JS 引擎</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，JS 引擎会知道 : string 是一个类型注释，在 &#x3D; 处结尾。这实际的工作方式是复杂的，需要时间来弄清楚。然而，让 TypeScript 能在 JavaScript 中“原生地”运行将降低它被使用的障碍。它会像 Babel 添加 TypeScript 支持时一样对 TypeScript 施加一些约束。但我觉得这是值得的。</p>\n<p>Deno 是一个消除所有 TS 障碍的关键例子，它通过运行一个 Rust 编写的工具，能够非常快速地将 TS 编译到 JS，模拟了当前 JavaScript 引擎对原生 TypeScript 的支持。</p>\n<h3 id=\"1-5-2-如今的竞争者\"><a href=\"#1-5-2-如今的竞争者\" class=\"headerlink\" title=\"1.5.2 如今的竞争者\"></a>1.5.2 如今的竞争者</h3><ul>\n<li>JetBrains WebStorm - 这是一个有高级 JavaScript 工具支持的 IDE。他们有自己的引擎用于重构、代码流分析并对 JavaScript 语法进行检查。这很好，JetBrains 在他们所有的 IDE 上都做了扎实的工作。我过去经常使用 AppCode 处理 iOS 的工作。当你有一个 TypeScript 项目时，WebStorm 会将 TypeScript 的语言工具和自己的工具混合在一起，这对你来说是双赢的。</li>\n<li>编译到 JS 的语言 - 目前的例子有 Elm，ReScript，KotlinScript，这些语言的核心目标是与 JavaScript 交互。对于 TypeScript 来说，这些都是很有趣的语言，它们有一个干净的环境来实现类型系统 —— 也就是，没有 JS 包袱。作为竞争对手，它们倾向于更细分的市场，因为它们的核心不是 JavaScript ，并且社区也被从 CoffeeScript 迁移所困扰过。</li>\n<li>WASM - 我听到 WASM 作为 TypeScript 竞争者的观点是，WASM 可以作为语言取代 JS 控制浏览器 DOM。反对这一观点的人普遍认为，WASM 没有 DOM 绑定，而且可能永远不会有。TypeScript 包含了 JavaScript 的缺点，如果你在 JavaScript 运行时中加入过 WASM 的话，你几乎总是会更加喜欢它。也就是说，AssemblyScript 在这方面做了一些很好的工作。也许把 WASM 想成 JSON 会更好，它是另一个组成项目的工具，不太可能成为 JavaScript 的竞争者，除非 WASM 和 DOM 的交互方式有所改变。</li>\n<li>编译到 WASM 的语言 - 比如 Rust，Go，Swift，等其它可以编译到 WASM 的语言。这些语言都可能占据 TypeScript 目前作为工具和 web 核心构建模块的位置，不过世事难料，谁知道会怎么样呢？这些语言能够提供各种不同的基本类型，并且基于不同的目标从头构建。如果 WASM 和 WASI 最终获得成功，那么我认为将会与平台相关（想想 apps 等功能实现），看看它们的发展方向会很有趣。说心里话，它们不会是 TypeScript 的竞争者，而是 JavaScript 的。</li>\n</ul>\n<h3 id=\"1-5-3-TypeScript-怎么看它在生态中的位置？\"><a href=\"#1-5-3-TypeScript-怎么看它在生态中的位置？\" class=\"headerlink\" title=\"1.5.3 TypeScript 怎么看它在生态中的位置？\"></a>1.5.3 TypeScript 怎么看它在生态中的位置？</h3><p>TypeScript 希望在类型系统和编辑器工具领域进行创新。我们拥有在主流编程语言中表达能力最强的类型系统之一。</p>\n<p>TypeScript 最初被创建时，对 JavaScript 进行修改的流程和现在非常不同，所以 TypeScript 中有一些特性实际上是 TC39 的领域，但仍然需要向后兼容。这些特性可能在 JavaScript 中存在很多年，并且经过了多次迭代，这意味着 TypeScript 必须维护一个特定语言特性的两种版本。</p>\n<p>所以我们的目标是成为 TC39 JavaScript 语言委员会的优秀成员，就编辑器支持的语言特性进行反馈，支持 TypeScript 用户想要看到的特性。通过这种协作方式，TC39 控制了 JavaScript，TypeScript 也支持他们。</p>\n<h3 id=\"1-5-4-TypeScript-怎么看它的受众？\"><a href=\"#1-5-4-TypeScript-怎么看它的受众？\" class=\"headerlink\" title=\"1.5.4 TypeScript 怎么看它的受众？\"></a>1.5.4 TypeScript 怎么看它的受众？</h3><p>TypeScript 的受众主要有:</p>\n<ul>\n<li>JavaScript 用户（作为语言工具）</li>\n<li>JS + JSDoc 用户（作为语言工具）</li>\n<li>TypeScript 用户（作为编译器，语言工具）</li>\n<li>TypeScript 严格模式（作为编译器，语言工具）</li>\n</ul>\n<p>虽然项目使用 babel &#x2F; swc &#x2F; sucrase &#x2F; esbuild 等工具构建时，tsc 是可选的，但是上面的几种受众仍然可以在每次或至少每两次 TS 版本发布中获得新特性（译者注：babel、esbuild 等会更新支持 TS 新特性。可能是 TS 团队直接去这些项目里做，也可能会在没有 tsc 的情况下为这些项目提供特性，比如通过 vscode。在 <strong>TS roadmap</strong>[10] 中可以了解更多发布计划）。</p>\n<h3 id=\"1-5-5-TypeScript-是如何跟踪-JS-生态的？\"><a href=\"#1-5-5-TypeScript-是如何跟踪-JS-生态的？\" class=\"headerlink\" title=\"1.5.5 TypeScript 是如何跟踪 JS 生态的？\"></a>1.5.5 TypeScript 是如何跟踪 JS 生态的？</h3><p>团队从以下几个方式听取反馈：</p>\n<ul>\n<li>GitHub issues 有持续不断的评论洪流</li>\n<li>微软内部团队要求提供特性，或者要求我们帮忙调试他们缓慢的代码库</li>\n<li>通过 Gitter 或者 TypeScript 社区的 Discord 与社区建立联系</li>\n<li>通过微团的内部工具对想法 &#x2F; 设计进行用户测试</li>\n<li>与 VS Code 有着非常紧密的联系，许多语言工具的反馈都来自于他们</li>\n<li>我们会阅读每一条 @ TypeScript 团队的推特</li>\n<li>我们会跟踪迁移到 TypeScript 和从 TypeScript 迁走的博客文章</li>\n<li>我们会跟踪行业调查和编程语言概述</li>\n</ul>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "1-3、基础篇：常用类型",
        "toc": true,
        "swiper_index": 3,
        "swiper_cover": "/img/recommend/recommend_03.jpg",
        "swiper_desc": "1-3、基础篇：常用类型",
        "abbrlink": 19978,
        "date": "2024-01-28T11:39:24.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 三、常用类型\n\n在本章中，我们将介绍一些在 JavaScript 代码中最常见的值类型，并解释在 TypeScript 中描述这些类型的相应方法。这不是一个详尽的列表，未来的章节将描述命名和使用其他类型的更多方法。\n\n类型还可以出现在更多的*地方，*而不仅仅是类型注释。当我们了解类型本身时，我们还将了解可以引用这些类型以形成新结构的地方。\n\n我们将首先回顾你在编写 JavaScript 或 TypeScript 代码时，可能遇到的最基本和最常见的类型，它是形成更复杂类型的核心构建块。\n\n## 3.0 TypeScript配置文件\n\n为了方便学习，我们可以在一个单独的配置文件中保存命令行中的参数，应用 `tsc` 生成配置文件：\n\n<img src=\"https://s2.loli.net/2022/02/22/1dAfz2imrs3CMbL.png\" alt=\"image-20211113170722654\" style=\"zoom: 50%;\"/>\n\n在项目根目录下生成了一个配置文件 `tsconfig.json`。这里给出我们自己的配置：\n\n```json\n{\n  \"compilerOptions\": {\n    /* Language and Environment */\n    \"target\": \"es6\",\n    /* Modules */\n    \"rootDir\": \"./src\",\n    /* Emit */\n    \"outDir\": \"./dist\",\n    /* Type Checking */\n    \"strict\": true\n  }\n}\n```\n\n## 3.1 基元类型`string`,`number`, 和`boolean`\n\nJavaScript有三个非常常用的[原语](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)：`string`，`number`，和`boolean`。每个在 TypeScript 中都有对应的类型。我们发现，这些名称与我们在 JavaScript 应用`typeof`返回的类型的名称相同：\n\n- `string` 表示字符串值，如 `\"Hello, world\"`\n- `number`表示数字值，如 `42`。JavaScript 没有一个特殊的整数运行时值，所以没有等价于`int`或 `float`类型， 一切都只是`number`\n- `boolean`只有两个值`true`和`false`\n\n> 类型名称`String`, `Number`, 和`Boolean`（以大写字母开头）是合法的，但指的是一些很少出现在代码中的特殊内置类型。对于类型，*始终*使用`string`, `number`, 或`boolean`。\n\n```js\nlet str: string = 'hello typescript'\nlet num: number = 100\nlet bool: boolean = true\n```\n\n## 3.2 数组\n\n数组是指定形如`[1, 2, 3]`数据，可以使用语法`number[]`来定义; 此语法适用于任何类型（例如`string[]`，字符串数组等）。\n\n你也可以写成`Array<number>`。`T<U>`当介绍*泛型*时，我们将了解更多有关这个语法的更多信息。\n\n**02-everyday-types/src/02-array.ts**\n\n```ts\nlet arr: number[] = [1, 2, 3];\nlet arr2: Array<number> = [1, 2, 3];\n```\n\n## 3.3 any\n\nTypeScript 还有一个特殊类型 `any`，当你不希望某个特定值导致类型检查错误时，可以使用它。\n\n当一个值的类型是`any`时，可以访问它的任何属性，将它分配给任何类型的值，或者几乎任何其他语法上的东西都合法的：\n\n```tsx\nlet obj: any = { x: 0 };\n// 以下代码行都不会抛出编译器错误。\n// 使用'any'将禁用所有进一步的类型检查\nobj.foo();\nobj();\nobj.bar = 100;\nobj = \"hello\";\nconst n: number = obj;\n```\n\n但在运行环境下执行代码可能是错误的：\n\n<img src=\"/img/TypeScript/03-02.png\" alt=\"image-20211113182543401\" style=\"zoom:50%;\" />\n\n进入到 `dist`目录中，在 node 环境里运行代码，果然报错了。\n\n当你不想写出长类型只是为了让 TypeScript 相信特定的代码行没问题时，`any`类型很有用。\n\n- **noImplicitAny**\n\n当不指定类型时，并且 TypeScript 无法从上下文推断它时，编译器通常会默认为`any`.\n\n但是，您通常希望避免这种情况，因为`any`没有进行类型检查。使用编译器标志[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)将任何隐式标记`any`为错误。这个配置我们在前面讲到过。\n\n## 3.4 变量上的类型注释\n\n当你使用`const`, `var`, 或声明变量时`let`，可以选择添加类型注释来显式指定变量的类型：\n\n```ts\nlet myName: string = \"Felixlu\";\n```\n\n> TypeScript 不使用“左边的类型”风格的声明，比如`int x = 0;` 类型注解总是*在*被输入的东西*之后*。\n\n但是，在大多数情况下，这不是必需的。只要有可能，TypeScript 就会尝试自动*推断*代码中的类型。例如，变量的类型是根据其初始化器的类型推断出来的：\n\n```tsx\n// 不需要类型定义--“myName”推断为类型“string”\nlet myName = \"Felixlu\";\n```\n\n大多数情况下，不需要明确学习推理规则。如果你刚开始，请尝试使用比你想象的更少的类型注释 - 你可能会惊讶——TypeScript 完全了解正在发生的事情。\n\n## 3.5 函数\n\n函数是在 JavaScript 中传递数据的主要方式。TypeScript 允许您指定函数的输入和输出值的类型。\n\n- 参数类型注释\n\n声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型。参数类型注释位于参数名称之后：\n\n```tsx\n// 参数类型定义\nfunction greet(name: string) {\n  console.log(\"Hello, \" + name.toUpperCase() + \"!!\");\n}\n```\n\n当参数具有类型注释时，将检查该函数的参数：\n\n```tsx\n// 如果执行，将是一个运行时错误！\ngreet(42);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/SR9okXs1ez7ThC6.png\" alt=\"image-20211114072314780\" style=\"zoom: 50%;\" />\n\n> 即使您的参数上没有类型注释，TypeScript 仍会检查您是否传递了正确数量的参数。\n\n- 返回类型注释\n\n你还可以添加返回类型注释。返回类型注释出现在参数列表之后：\n\n```tsx\nfunction getFavoriteNumber(): number {\n  return 26;\n}\n```\n\n与变量类型注释非常相似，通常不需要返回类型注释，因为 TypeScript 会根据其`return`语句推断函数的返回类型。上面例子中的类型注释不会改变任何东西。某些代码库会出于文档目的明确指定返回类型，以防止意外更改或仅出于个人偏好。\n\n- 匿名函数\n\n匿名函数与函数声明有点不同。当一个函数出现在 TypeScript 可以确定它将如何被调用的地方时，该函数的参数会自动指定类型。\n\n下面是一个例子：\n\n```tsx\n// 这里没有类型注释，但是TypeScript可以发现错误\nconst names = [\"Alice\", \"Bob\", \"Eve\"];\n\n// 函数上下文类型\nnames.forEach(function (s) {\n  console.log(s.toUppercase());\n});\n\n// 上下文类型也适用于箭头函数\nnames.forEach((s) => {\n  console.log(s.toUppercase());\n});\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qMkb8YQzxUw2Xnc.png\" alt=\"image-20211114073444596\" style=\"zoom:50%;\" />\n\n即使参数`s`没有类型注释，TypeScript 也会使用`forEach`函数的类型，以及数组的推断类型来确定`s`的类型。\n\n这个过程称为*上下文类型，*因为函数发生在其中的*上下文*通知它应该具有什么类型。\n\n与推理规则类似，你不需要明确了解这是如何发生的，但了解它的机制*确实*可以帮助你注意何时不需要类型注释。稍后，我们将看到更多关于*值出现的上下文*如何影响其类型的示例。\n\n## 3.6 对象类型\n\n除了`string`，`number`，`boolean`类型（又称基元类型）外，你将遇到的最常见的类型是*对象类型*。这指的是任何带有属性的 JavaScript 值，几乎是所有属性！要定义对象类型，我们只需列出其属性及其类型。\n\n例如，这是一个接受点状对象的函数：\n\n```tsx\n// 参数的类型注释是对象类型\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"坐标的x值为： \" + pt.x);\n  console.log(\"坐标的y值为： \" + pt.y);\n}\nprintCoord({ x: 3, y: 7 });\n```\n\n在这里，我们使用具有两个属性的类型注释参数 -`x`和`y`- 这两个属性都是 `number`类型。你可以以使用`,`或`;`来分隔属性，最后一个分隔符是可选的。\n\n每个属性的类型部分也是可选的。如果你不指定类型，则将假定为`any`。\n\n- 可选属性\n\n对象类型还可以指定其部分或全部属性是*可选的*。为此，请在属性名称后添加一个`?`：\n\n**02-everyday-types/src/05-object.ts**\n\n```tsx\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// 两种传递参数都可以\nprintName({ first: \"Felix\" });\nprintName({ first: \"Felix\", last: \"Lu\" });\n```\n\n在 JavaScript 中，如果访问一个不存在的属性，将获得值`undefined`而不是运行时错误。因此，当你*读取*可选属性时，必须使用它之前用`undefined`进行检查。\n\n```tsx\nfunction printName(obj: { first: string; last?: string }) {\n  // 错误 - 'obj.last' 可能不存在!\n  console.log(obj.last.toUpperCase());\n\n  if (obj.last !== undefined) {\n    // 这样可以\n    console.log(obj.last.toUpperCase());\n  }\n\n  // 使用现代JavaScript语法的安全替代方案：\n  console.log(obj.last?.toUpperCase());\n}\n```\n\n## 3.7 联合类型\n\nTypeScript 的类型系统允许你使用多种运算符，从现有类型中构建新类型。现在我们知道如何编写几种类型，是时候开始以有趣的方式*组合*它们了。\n\n- 定义联合类型\n\n第一种组合类型的方法是*联合*类型。联合类型是由两个或多个其他类型组成的类型，表示可能是这些类型中的*任何一种*的值。我们将这些类型中的每一种称为*联合类型的成员*。\n\n让我们编写一个可以对字符串或数字进行操作的函数：\n\n```tsx\nfunction printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// 正确\nprintId(101);\n// 正确\nprintId(\"202\");\n// 错误\nprintId({ myID: 22342 });\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qkOvn9DrVdCRSBc.png\" alt=\"image-20211114081646215\" style=\"zoom:50%;\" />\n\n- 使用联合类型\n\n*提供*匹配联合类型的值很容易- 只需提供匹配任何联合成员的类型。如果你*有*一个联合类型的值，你如何使用它？\n\n如果联合的*每个*成员都有效，TypeScript 将只允许你使用联合做一些事情。例如，如果你有联合类型 `string | number`，则不能只使用一种类型的操作，比如`string`：\n\n```tsx\nfunction printId(id: number | string) {\n  console.log(id.toUpperCase());\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/TnuapbGVlOE2BYw.png\" alt=\"image-20211114085508715\" style=\"zoom:50%;\" />\n\n解决方案是用代码*缩小*联合，就像在没有类型注释的 JavaScript 中一样。 当 TypeScript 可以根据代码结构为值推断出更具体的类型时，就会发生*缩小*。\n\n例如，TypeScript 知道只有一个`string`值才会有一个`typeof`值`\"string\"`：\n\n```tsx\nfunction printId(id: number | string) {\n  if (typeof id === \"string\") {\n    // 在此分支中，id的类型为“string”\n    console.log(id.toUpperCase());\n  } else {\n    // 此处，id的类型为“number”\n    console.log(id);\n  }\n}\n```\n\n另一个例子是使用如下函数`Array.isArray`：\n\n```tsx\nfunction welcomePeople(x: string[] | string) {\n  if (Array.isArray(x)) {\n    // 此处: 'x' 的类型是 'string[]'\n    console.log(\"Hello, \" + x.join(\" and \"));\n  } else {\n    // 此处: 'x' 的类型是 'string'\n    console.log(\"Welcome lone traveler \" + x);\n  }\n}\n```\n\n请注意，在`else`分支中，我们不需要做任何特别的事情——如果`x`不是 `string[]`，那么它一定是 `string`。\n\n有时你会有一个 `union`，所有成员都有一些共同点。例如，数组和字符串都有一个`slice`方法。如果联合中的每个成员都有一个共同的属性，则可以使用该属性而不会缩小范围：\n\n```tsx\n// 返回类型推断为 number[] | string\nfunction getFirstThree(x: number[] | string) {\n  return x.slice(0, 3);\n}\n```\n\n## 3.8 类型别名\n\n我们一直在通过直接在类型注释中编写对象类型和联合类型来使用它们。这很方便，但是想要多次使用同一个类型，并用一个名称来引用它是很常见的。\n\n一个*类型别名*正是一个*名称*为任何*类型*的定义。类型别名的语法是：\n\n```tsx\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// 与前面的示例完全相同\nfunction printCoord(pt: Point) {\n  console.log(\"坐标x的值是： \" + pt.x);\n  console.log(\"坐标y的值是： \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\n实际上，你可以使用类型别名为任何类型命名，而不仅仅是对象类型。例如，类型别名可以命名联合类型：\n\n```tsx\ntype ID = number | string;\n```\n\n请注意，别名*只是*别名 - 你不能使用类型别名来创建相同类型的不同“版本”。当你使用别名时，就像你编写了别名类型一样。换句话说，这段代码可能*看起来不*合法，但根据 TypeScript 是可以的，因为这两种类型都是同一类型的别名：\n\n```tsx\ntype UserInputSanitizedString = string;\n\nfunction sanitizeInput(str: string): UserInputSanitizedString {\n  return str.slice(0, 2);\n}\n\n// 创建经过 sanitize 的输入\nlet userInput = sanitizeInput(\"hello\");\n\n// 但仍可以使用字符串重新分配值\nuserInput = \"new input\";\n```\n\n## 3.9 接口\n\n一个*接口声明*是另一种方式来命名对象类型：\n\n```tsx\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printCoord(pt: Point) {\n  console.log(\"坐标x的值是： \" + pt.x);\n  console.log(\"坐标y的值是： \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\n就像我们在上面使用类型别名时一样，该示例就像我们使用了匿名对象类型一样工作。TypeScript 只关心我们传递给的值的*结构*`printCoord`——它只关心它是否具有预期的属性。只关心类型的结构和功能，是我们将 TypeScript 称为*结构类型*类型系统的原因。\n\n- 类型别名和接口之间的差异\n\n类型别名和接口非常相似，在很多情况下你可以自由选择它们。几乎所有的功能都在`interface`中可用`type`，关键区别在于扩展新类型的方式不同：\n\n```tsx\n// 扩展接口\ninterface Animal {\n  name: string;\n}\n\ninterface Bear extends Animal {\n  honey: boolean;\n}\n\nconst bear: Bear = {\n  name: \"winnie\",\n  honey: true,\n};\nbear.name;\nbear.honey;\n```\n\n```tsx\n// 通过交叉点扩展类型\ntype Animal = {\n  name: string;\n};\n\ntype Bear = Animal & {\n  honey: boolean;\n};\n\nconst bear: Bear = {\n  name: \"winnie\",\n  honey: true,\n};\nbear.name;\nbear.honey;\n```\n\n```tsx\n// 向现有接口添加新字段\ninterface MyWindow {\n  title: string;\n}\n\ninterface MyWindow {\n  count: number;\n}\n\nconst w: MyWindow = {\n  title: \"hello ts\",\n  count: 100,\n};\n```\n\n```tsx\n// 类型创建后不可更改\ntype MyWindow = {\n  title: string;\n};\n\ntype MyWindow = {\n  count: number;\n};\n```\n\n<img src=\"/img/TypeScript/03-07.png\" alt=\"image-20211114094240585\" style=\"zoom:50%;\" />\n\n> - 在 TypeScript 4.2 版之前，类型别名[*可能*出现在错误消息中](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA)，有时会代替等效的匿名类型（这可能是可取的，也可能是不可取的）。接口将始终在错误消息中命名。\n> - 类型别名可能不参与[声明合并，但接口可以](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA)。\n> - 接口只能用于[声明对象的形状，不能重命名基元](https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA)。\n> - 接口名称将[*始终*以其原始形式出现在](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA)错误消息中，但*仅*当它们按名称使用时。\n>\n> 大多数情况下，你可以根据个人喜好进行选择，TypeScript 会告诉你是否需要其他类型的声明。如果您想要启发式，请使用`interface`，然后在需要时使用`type`。\n\n## 3.10 类型断言\n\n有时，你会获得有关 TypeScript 不知道的值类型的信息。\n\n例如，如果你正在使用`document.getElementById`，TypeScript 只知道这将返回*某种*类型的`HTMLElement`，但你可能知道你的页面将始终具有`HTMLCanvasElement`给定 ID 的值 。\n\n在这种情况下，你可以使用*类型断言*来指定更具体的类型：\n\n```tsx\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;\n```\n\n与类型注释一样，类型断言由编译器删除，不会影响代码的运行时行为。\n\n还可以使用尖括号语法（除非代码在`.tsx`文件中），它是等效的：\n\n```tsx\nconst myCanvas = <HTMLCanvasElement>document.getElementById(\"main_canvas\");\n```\n\n> 提醒：因为类型断言在编译时被移除，所以没有与类型断言相关联的运行时检查。`null`如果类型断言错误，则不会出现异常。\n\nTypeScript 只允许类型断言转换为*更具体*或*不太具体*的类型版本。此规则可防止“不可能”的强制，例如：\n\n```tsx\nconst x = \"hello\" as number;\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qNWktG6hBmzVZaC.png\" alt=\"image-20211114095324614\" style=\"zoom:50%;\" />\n\n将类型`string`转换为类型`number`可能是错误的，因为两种类型都没有充分重叠。如果这是有意的，请先将表达式转换为 `any` 或 `unknown`（`unknown`，我们将在后面介绍），然后是所需的类型：\n\n```tsx\nconst x = \"hello\" as unknown as number;\n```\n\n## 3.11 文字类型\n\n除了一般类型`string`和`number`，我们可以在类型位置引用*特定的*字符串和数字。\n\n一种方法是考虑 JavaScript 如何以不同的方式声明变量。`var`而`let`两者都允许更改变量中保存的内容，`const`不允许，这反映在 TypeScript 如何为文字创建类型上。\n\n```tsx\nlet testString = \"Hello World\";\ntestString = \"Olá Mundo\";\n\n//'testString'可以表示任何可能的字符串，那\n//TypeScript是如何在类型系统中描述它的\ntestString;\n\nconst constantString = \"Hello World\";\n//因为'constantString'只能表示1个可能的字符串，所以\n//具有文本类型表示\nconstantString;\n```\n\n就其本身而言，文字类型并不是很有价值：\n\n```tsx\nlet x: \"hello\" = \"hello\";\n// 正确\nx = \"hello\";\n// 错误\nx = \"howdy\";\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/kcOHJ74TKSvuq1h.png\" alt=\"image-20211114102648519\" style=\"zoom:50%;\" />\n\n拥有一个只能有一个值的变量并没有多大用处！\n\n但是通过*将*文字*组合*成联合，你可以表达一个更有用的概念——例如，只接受一组特定已知值的函数：\n\n```tsx\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  // ...\n}\nprintText(\"Hello, world\", \"left\");\nprintText(\"G'day, mate\", \"centre\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/SrcPeBsQvOUkDfw.png\" alt=\"image-20211114103049870\" style=\"zoom:50%;\" />\n\n数字文字类型的工作方式相同：\n\n```tsx\nfunction compare(a: string, b: string): -1 | 0 | 1 {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n```\n\n当然，你可以将这些与非文字类型结合使用：\n\n```tsx\ninterface Options {\n  width: number;\n}\nfunction configure(x: Options | \"auto\") {\n  // ...\n}\nconfigure({ width: 100 });\nconfigure(\"auto\");\nconfigure(\"automatic\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/YZQwUvRlCtkzcTL.png\" alt=\"image-20211114103530209\" style=\"zoom:50%;\" />\n\n还有一种文字类型：布尔文字。只有两种布尔文字类型，它们是类型`true`和`false`。类型`boolean`本身实际上只是联合类型 `union` 的别名`true | false`。\n\n- 文字推理\n\n当你使用对象初始化变量时，TypeScript 假定该对象的属性稍后可能会更改值。例如，如果你写了这样的代码：\n\n```tsx\nconst obj = { counter: 0 };\nif (someCondition) {\n  obj.counter = 1;\n}\n```\n\nTypeScript 不假定先前具有的字段值`0`，后又分配`1`是错误的。另一种说法是`obj.counter`必须有 `number`属性， 而非是 `0`，因为类型用于确定*读取*和*写入*行为。\n\n这同样适用于字符串：\n\n```tsx\nfunction handleRequest(url: string, method: \"GET\" | \"POST\" | \"GUESS\") {\n  // ...\n}\n\nconst req = { url: \"https://example.com\", method: \"GET\" };\nhandleRequest(req.url, req.method);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/hmLQKWoi4kVtBFD.png\" alt=\"image-20211114105814002\" style=\"zoom:50%;\" />\n\n在上面的例子`req.method`中推断是`string`，不是`\"GET\"`。因为代码可以在创建`req`和调用之间进行评估，TypeScript 认为这段代码有错误。\n\n有两种方法可以解决这个问题。\n\n**1. 可以通过在任一位置添加类型断言来更改推理：**\n\n```tsx\n// 方案 1:\nconst req = { url: \"https://example.com\", method: \"GET\" as \"GET\" };\n// 方案 2\nhandleRequest(req.url, req.method as \"GET\");\n```\n\n方案 1 表示“我打算`req.method`始终拥有*文字类型* `\"GET\"`”，从而防止之后可能分配`\"GUESS\"`给该字段。\n\n方案 2 的意思是“我知道其他原因`req.method`具有`\"GET\"`值”。\n\n**2. 可以使用`as const`将整个对象转换为类型文字：**\n\n```tsx\nconst req = { url: \"https://example.com\", method: \"GET\" } as const;\nhandleRequest(req.url, req.method);\n```\n\n该`as const`后缀就像`const`定义，确保所有属性分配的文本类型，而不是一个更一般的`string`或`number`。\n\n## 3.12 `null` 和 `undefined`\n\nJavaScript 有两个原始值用于表示不存在或未初始化的值：`null`和`undefined`.\n\nTypeScript 有两个对应的同名*类型*。这些类型的行为取决于您是否设置[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)选择。\n\n- `strictNullChecks` 关闭\n\n使用*false*，仍然可以正常访问的值，并且可以将值分配给任何类型的属性。这类似于没有空检查的语言（例如 C#、Java）的行为方式。缺乏对这些值的检查往往是错误的主要来源；如果在他们的代码库中这样做可行，我们总是建议大家打开。\n\n- `strictNullChecks` 打开\n\n使用*true*，你需要在对该值使用方法或属性之前测试这些值。就像在使用可选属性之前检查一样，我们可以使用*缩小*来检查可能的值：\n\n```tsx\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    // 做一些事\n  } else {\n    console.log(\"Hello, \" + x.toUpperCase());\n  }\n}\n```\n\n- 非空断言运算符（`!`后缀）\n\nTypeScript 也有一种特殊的语法`null`，`undefined`，可以在不进行任何显式检查的情况下，从类型中移除和移除类型。`!`在任何表达式之后写入实际上是一种类型断言，即该值不是`null`or `undefined`：\n\n```tsx\nfunction liveDangerously(x?: number | null) {\n  // 正确\n  console.log(x!.toFixed());\n}\n```\n\n就像其他类型断言一样，这不会更改代码的运行时行为，因此仅`!`当你知道该值*不能*是`null`或 `undefined`时使用才是重要的。\n\n## 3.13 枚举\n\n枚举是 TypeScript 添加到 JavaScript 的一项功能，它允许描述一个值，该值可能是一组可能的命名常量之一。与大多数 TypeScript 功能不同，这*不是*JavaScript 的类型级别的添加，而是添加到语言和运行时的内容。因此，你确定你确实需要枚举在做些事情，否则请不要使用。可以在[Enum 参考页 中](https://www.typescriptlang.org/docs/handbook/enums.html)阅读有关枚举的更多信息。\n\n```tsx\n// ts源码\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\nconsole.log(Direction.Up); // 1\n```\n\n```tsx\n// 编译后的js代码\n\"use strict\";\nvar Direction;\n(function (Direction) {\n  Direction[(Direction[\"Up\"] = 1)] = \"Up\";\n  Direction[(Direction[\"Down\"] = 2)] = \"Down\";\n  Direction[(Direction[\"Left\"] = 3)] = \"Left\";\n  Direction[(Direction[\"Right\"] = 4)] = \"Right\";\n})(Direction || (Direction = {}));\nconsole.log(Direction.Up);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/dvthyFIPKAuBR1s.png\" alt=\"image-20211114112554381\" style=\"zoom:33%;\" />\n\n## 3.14 不太常见的原语\n\n值得一提的是 JavaScript 中一些较新的原语，它们在 TypeScript 类型系统中也实现了。我们先简单的看两个例子：\n\n- #### `bigint`\n\n从 ES2020 开始，JavaScript 中有一个用于非常大的整数的原语`BigInt`：\n\n```tsx\n// 通过bigint函数创建bigint\nconst oneHundred: bigint = BigInt(100);\n\n// 通过文本语法创建BigInt\nconst anotherHundred: bigint = 100n;\n```\n\n你可以在[TypeScript 3.2 发行说明 中](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint)了解有关 BigInt 的更多信息。\n\n- #### `symbol`\n\nJavaScript 中有一个原语`Symbol()`，用于通过函数创建全局唯一引用：\n\n```tsx\nconst firstName = Symbol(\"name\");\nconst secondName = Symbol(\"name\");\n\nif (firstName === secondName) {\n  // 这里的代码不可能执行\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/ORATaxUgEjrPL9V.png\" alt=\"image-20211114113536948\" style=\"zoom:40%;\" />\n\n此条件将始终返回 `false`，因为类型 `typeof firstName`和`typeof secondName`没有重叠。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-3、基础篇：常用类型.md",
        "raw": "---\ntitle: 1-3、基础篇：常用类型\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nswiper_index: 3\nswiper_cover: /img/recommend/recommend_03.jpg\nswiper_desc: 1-3、基础篇：常用类型\nabbrlink: 19978\ndate: 2024-01-28 19:39:24\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 三、常用类型\n\n在本章中，我们将介绍一些在 JavaScript 代码中最常见的值类型，并解释在 TypeScript 中描述这些类型的相应方法。这不是一个详尽的列表，未来的章节将描述命名和使用其他类型的更多方法。\n\n类型还可以出现在更多的*地方，*而不仅仅是类型注释。当我们了解类型本身时，我们还将了解可以引用这些类型以形成新结构的地方。\n\n我们将首先回顾你在编写 JavaScript 或 TypeScript 代码时，可能遇到的最基本和最常见的类型，它是形成更复杂类型的核心构建块。\n\n## 3.0 TypeScript配置文件\n\n为了方便学习，我们可以在一个单独的配置文件中保存命令行中的参数，应用 `tsc` 生成配置文件：\n\n<img src=\"https://s2.loli.net/2022/02/22/1dAfz2imrs3CMbL.png\" alt=\"image-20211113170722654\" style=\"zoom: 50%;\"/>\n\n在项目根目录下生成了一个配置文件 `tsconfig.json`。这里给出我们自己的配置：\n\n```json\n{\n  \"compilerOptions\": {\n    /* Language and Environment */\n    \"target\": \"es6\",\n    /* Modules */\n    \"rootDir\": \"./src\",\n    /* Emit */\n    \"outDir\": \"./dist\",\n    /* Type Checking */\n    \"strict\": true\n  }\n}\n```\n\n## 3.1 基元类型`string`,`number`, 和`boolean`\n\nJavaScript有三个非常常用的[原语](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)：`string`，`number`，和`boolean`。每个在 TypeScript 中都有对应的类型。我们发现，这些名称与我们在 JavaScript 应用`typeof`返回的类型的名称相同：\n\n- `string` 表示字符串值，如 `\"Hello, world\"`\n- `number`表示数字值，如 `42`。JavaScript 没有一个特殊的整数运行时值，所以没有等价于`int`或 `float`类型， 一切都只是`number`\n- `boolean`只有两个值`true`和`false`\n\n> 类型名称`String`, `Number`, 和`Boolean`（以大写字母开头）是合法的，但指的是一些很少出现在代码中的特殊内置类型。对于类型，*始终*使用`string`, `number`, 或`boolean`。\n\n```js\nlet str: string = 'hello typescript'\nlet num: number = 100\nlet bool: boolean = true\n```\n\n## 3.2 数组\n\n数组是指定形如`[1, 2, 3]`数据，可以使用语法`number[]`来定义; 此语法适用于任何类型（例如`string[]`，字符串数组等）。\n\n你也可以写成`Array<number>`。`T<U>`当介绍*泛型*时，我们将了解更多有关这个语法的更多信息。\n\n**02-everyday-types/src/02-array.ts**\n\n```ts\nlet arr: number[] = [1, 2, 3];\nlet arr2: Array<number> = [1, 2, 3];\n```\n\n## 3.3 any\n\nTypeScript 还有一个特殊类型 `any`，当你不希望某个特定值导致类型检查错误时，可以使用它。\n\n当一个值的类型是`any`时，可以访问它的任何属性，将它分配给任何类型的值，或者几乎任何其他语法上的东西都合法的：\n\n```tsx\nlet obj: any = { x: 0 };\n// 以下代码行都不会抛出编译器错误。\n// 使用'any'将禁用所有进一步的类型检查\nobj.foo();\nobj();\nobj.bar = 100;\nobj = \"hello\";\nconst n: number = obj;\n```\n\n但在运行环境下执行代码可能是错误的：\n\n<img src=\"/img/TypeScript/03-02.png\" alt=\"image-20211113182543401\" style=\"zoom:50%;\" />\n\n进入到 `dist`目录中，在 node 环境里运行代码，果然报错了。\n\n当你不想写出长类型只是为了让 TypeScript 相信特定的代码行没问题时，`any`类型很有用。\n\n- **noImplicitAny**\n\n当不指定类型时，并且 TypeScript 无法从上下文推断它时，编译器通常会默认为`any`.\n\n但是，您通常希望避免这种情况，因为`any`没有进行类型检查。使用编译器标志[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)将任何隐式标记`any`为错误。这个配置我们在前面讲到过。\n\n## 3.4 变量上的类型注释\n\n当你使用`const`, `var`, 或声明变量时`let`，可以选择添加类型注释来显式指定变量的类型：\n\n```ts\nlet myName: string = \"Felixlu\";\n```\n\n> TypeScript 不使用“左边的类型”风格的声明，比如`int x = 0;` 类型注解总是*在*被输入的东西*之后*。\n\n但是，在大多数情况下，这不是必需的。只要有可能，TypeScript 就会尝试自动*推断*代码中的类型。例如，变量的类型是根据其初始化器的类型推断出来的：\n\n```tsx\n// 不需要类型定义--“myName”推断为类型“string”\nlet myName = \"Felixlu\";\n```\n\n大多数情况下，不需要明确学习推理规则。如果你刚开始，请尝试使用比你想象的更少的类型注释 - 你可能会惊讶——TypeScript 完全了解正在发生的事情。\n\n## 3.5 函数\n\n函数是在 JavaScript 中传递数据的主要方式。TypeScript 允许您指定函数的输入和输出值的类型。\n\n- 参数类型注释\n\n声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型。参数类型注释位于参数名称之后：\n\n```tsx\n// 参数类型定义\nfunction greet(name: string) {\n  console.log(\"Hello, \" + name.toUpperCase() + \"!!\");\n}\n```\n\n当参数具有类型注释时，将检查该函数的参数：\n\n```tsx\n// 如果执行，将是一个运行时错误！\ngreet(42);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/SR9okXs1ez7ThC6.png\" alt=\"image-20211114072314780\" style=\"zoom: 50%;\" />\n\n> 即使您的参数上没有类型注释，TypeScript 仍会检查您是否传递了正确数量的参数。\n\n- 返回类型注释\n\n你还可以添加返回类型注释。返回类型注释出现在参数列表之后：\n\n```tsx\nfunction getFavoriteNumber(): number {\n  return 26;\n}\n```\n\n与变量类型注释非常相似，通常不需要返回类型注释，因为 TypeScript 会根据其`return`语句推断函数的返回类型。上面例子中的类型注释不会改变任何东西。某些代码库会出于文档目的明确指定返回类型，以防止意外更改或仅出于个人偏好。\n\n- 匿名函数\n\n匿名函数与函数声明有点不同。当一个函数出现在 TypeScript 可以确定它将如何被调用的地方时，该函数的参数会自动指定类型。\n\n下面是一个例子：\n\n```tsx\n// 这里没有类型注释，但是TypeScript可以发现错误\nconst names = [\"Alice\", \"Bob\", \"Eve\"];\n\n// 函数上下文类型\nnames.forEach(function (s) {\n  console.log(s.toUppercase());\n});\n\n// 上下文类型也适用于箭头函数\nnames.forEach((s) => {\n  console.log(s.toUppercase());\n});\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qMkb8YQzxUw2Xnc.png\" alt=\"image-20211114073444596\" style=\"zoom:50%;\" />\n\n即使参数`s`没有类型注释，TypeScript 也会使用`forEach`函数的类型，以及数组的推断类型来确定`s`的类型。\n\n这个过程称为*上下文类型，*因为函数发生在其中的*上下文*通知它应该具有什么类型。\n\n与推理规则类似，你不需要明确了解这是如何发生的，但了解它的机制*确实*可以帮助你注意何时不需要类型注释。稍后，我们将看到更多关于*值出现的上下文*如何影响其类型的示例。\n\n## 3.6 对象类型\n\n除了`string`，`number`，`boolean`类型（又称基元类型）外，你将遇到的最常见的类型是*对象类型*。这指的是任何带有属性的 JavaScript 值，几乎是所有属性！要定义对象类型，我们只需列出其属性及其类型。\n\n例如，这是一个接受点状对象的函数：\n\n```tsx\n// 参数的类型注释是对象类型\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"坐标的x值为： \" + pt.x);\n  console.log(\"坐标的y值为： \" + pt.y);\n}\nprintCoord({ x: 3, y: 7 });\n```\n\n在这里，我们使用具有两个属性的类型注释参数 -`x`和`y`- 这两个属性都是 `number`类型。你可以以使用`,`或`;`来分隔属性，最后一个分隔符是可选的。\n\n每个属性的类型部分也是可选的。如果你不指定类型，则将假定为`any`。\n\n- 可选属性\n\n对象类型还可以指定其部分或全部属性是*可选的*。为此，请在属性名称后添加一个`?`：\n\n**02-everyday-types/src/05-object.ts**\n\n```tsx\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// 两种传递参数都可以\nprintName({ first: \"Felix\" });\nprintName({ first: \"Felix\", last: \"Lu\" });\n```\n\n在 JavaScript 中，如果访问一个不存在的属性，将获得值`undefined`而不是运行时错误。因此，当你*读取*可选属性时，必须使用它之前用`undefined`进行检查。\n\n```tsx\nfunction printName(obj: { first: string; last?: string }) {\n  // 错误 - 'obj.last' 可能不存在!\n  console.log(obj.last.toUpperCase());\n\n  if (obj.last !== undefined) {\n    // 这样可以\n    console.log(obj.last.toUpperCase());\n  }\n\n  // 使用现代JavaScript语法的安全替代方案：\n  console.log(obj.last?.toUpperCase());\n}\n```\n\n## 3.7 联合类型\n\nTypeScript 的类型系统允许你使用多种运算符，从现有类型中构建新类型。现在我们知道如何编写几种类型，是时候开始以有趣的方式*组合*它们了。\n\n- 定义联合类型\n\n第一种组合类型的方法是*联合*类型。联合类型是由两个或多个其他类型组成的类型，表示可能是这些类型中的*任何一种*的值。我们将这些类型中的每一种称为*联合类型的成员*。\n\n让我们编写一个可以对字符串或数字进行操作的函数：\n\n```tsx\nfunction printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// 正确\nprintId(101);\n// 正确\nprintId(\"202\");\n// 错误\nprintId({ myID: 22342 });\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qkOvn9DrVdCRSBc.png\" alt=\"image-20211114081646215\" style=\"zoom:50%;\" />\n\n- 使用联合类型\n\n*提供*匹配联合类型的值很容易- 只需提供匹配任何联合成员的类型。如果你*有*一个联合类型的值，你如何使用它？\n\n如果联合的*每个*成员都有效，TypeScript 将只允许你使用联合做一些事情。例如，如果你有联合类型 `string | number`，则不能只使用一种类型的操作，比如`string`：\n\n```tsx\nfunction printId(id: number | string) {\n  console.log(id.toUpperCase());\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/TnuapbGVlOE2BYw.png\" alt=\"image-20211114085508715\" style=\"zoom:50%;\" />\n\n解决方案是用代码*缩小*联合，就像在没有类型注释的 JavaScript 中一样。 当 TypeScript 可以根据代码结构为值推断出更具体的类型时，就会发生*缩小*。\n\n例如，TypeScript 知道只有一个`string`值才会有一个`typeof`值`\"string\"`：\n\n```tsx\nfunction printId(id: number | string) {\n  if (typeof id === \"string\") {\n    // 在此分支中，id的类型为“string”\n    console.log(id.toUpperCase());\n  } else {\n    // 此处，id的类型为“number”\n    console.log(id);\n  }\n}\n```\n\n另一个例子是使用如下函数`Array.isArray`：\n\n```tsx\nfunction welcomePeople(x: string[] | string) {\n  if (Array.isArray(x)) {\n    // 此处: 'x' 的类型是 'string[]'\n    console.log(\"Hello, \" + x.join(\" and \"));\n  } else {\n    // 此处: 'x' 的类型是 'string'\n    console.log(\"Welcome lone traveler \" + x);\n  }\n}\n```\n\n请注意，在`else`分支中，我们不需要做任何特别的事情——如果`x`不是 `string[]`，那么它一定是 `string`。\n\n有时你会有一个 `union`，所有成员都有一些共同点。例如，数组和字符串都有一个`slice`方法。如果联合中的每个成员都有一个共同的属性，则可以使用该属性而不会缩小范围：\n\n```tsx\n// 返回类型推断为 number[] | string\nfunction getFirstThree(x: number[] | string) {\n  return x.slice(0, 3);\n}\n```\n\n## 3.8 类型别名\n\n我们一直在通过直接在类型注释中编写对象类型和联合类型来使用它们。这很方便，但是想要多次使用同一个类型，并用一个名称来引用它是很常见的。\n\n一个*类型别名*正是一个*名称*为任何*类型*的定义。类型别名的语法是：\n\n```tsx\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// 与前面的示例完全相同\nfunction printCoord(pt: Point) {\n  console.log(\"坐标x的值是： \" + pt.x);\n  console.log(\"坐标y的值是： \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\n实际上，你可以使用类型别名为任何类型命名，而不仅仅是对象类型。例如，类型别名可以命名联合类型：\n\n```tsx\ntype ID = number | string;\n```\n\n请注意，别名*只是*别名 - 你不能使用类型别名来创建相同类型的不同“版本”。当你使用别名时，就像你编写了别名类型一样。换句话说，这段代码可能*看起来不*合法，但根据 TypeScript 是可以的，因为这两种类型都是同一类型的别名：\n\n```tsx\ntype UserInputSanitizedString = string;\n\nfunction sanitizeInput(str: string): UserInputSanitizedString {\n  return str.slice(0, 2);\n}\n\n// 创建经过 sanitize 的输入\nlet userInput = sanitizeInput(\"hello\");\n\n// 但仍可以使用字符串重新分配值\nuserInput = \"new input\";\n```\n\n## 3.9 接口\n\n一个*接口声明*是另一种方式来命名对象类型：\n\n```tsx\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printCoord(pt: Point) {\n  console.log(\"坐标x的值是： \" + pt.x);\n  console.log(\"坐标y的值是： \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n\n就像我们在上面使用类型别名时一样，该示例就像我们使用了匿名对象类型一样工作。TypeScript 只关心我们传递给的值的*结构*`printCoord`——它只关心它是否具有预期的属性。只关心类型的结构和功能，是我们将 TypeScript 称为*结构类型*类型系统的原因。\n\n- 类型别名和接口之间的差异\n\n类型别名和接口非常相似，在很多情况下你可以自由选择它们。几乎所有的功能都在`interface`中可用`type`，关键区别在于扩展新类型的方式不同：\n\n```tsx\n// 扩展接口\ninterface Animal {\n  name: string;\n}\n\ninterface Bear extends Animal {\n  honey: boolean;\n}\n\nconst bear: Bear = {\n  name: \"winnie\",\n  honey: true,\n};\nbear.name;\nbear.honey;\n```\n\n```tsx\n// 通过交叉点扩展类型\ntype Animal = {\n  name: string;\n};\n\ntype Bear = Animal & {\n  honey: boolean;\n};\n\nconst bear: Bear = {\n  name: \"winnie\",\n  honey: true,\n};\nbear.name;\nbear.honey;\n```\n\n```tsx\n// 向现有接口添加新字段\ninterface MyWindow {\n  title: string;\n}\n\ninterface MyWindow {\n  count: number;\n}\n\nconst w: MyWindow = {\n  title: \"hello ts\",\n  count: 100,\n};\n```\n\n```tsx\n// 类型创建后不可更改\ntype MyWindow = {\n  title: string;\n};\n\ntype MyWindow = {\n  count: number;\n};\n```\n\n<img src=\"/img/TypeScript/03-07.png\" alt=\"image-20211114094240585\" style=\"zoom:50%;\" />\n\n> - 在 TypeScript 4.2 版之前，类型别名[*可能*出现在错误消息中](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA)，有时会代替等效的匿名类型（这可能是可取的，也可能是不可取的）。接口将始终在错误消息中命名。\n> - 类型别名可能不参与[声明合并，但接口可以](https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA)。\n> - 接口只能用于[声明对象的形状，不能重命名基元](https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA)。\n> - 接口名称将[*始终*以其原始形式出现在](https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA)错误消息中，但*仅*当它们按名称使用时。\n>\n> 大多数情况下，你可以根据个人喜好进行选择，TypeScript 会告诉你是否需要其他类型的声明。如果您想要启发式，请使用`interface`，然后在需要时使用`type`。\n\n## 3.10 类型断言\n\n有时，你会获得有关 TypeScript 不知道的值类型的信息。\n\n例如，如果你正在使用`document.getElementById`，TypeScript 只知道这将返回*某种*类型的`HTMLElement`，但你可能知道你的页面将始终具有`HTMLCanvasElement`给定 ID 的值 。\n\n在这种情况下，你可以使用*类型断言*来指定更具体的类型：\n\n```tsx\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;\n```\n\n与类型注释一样，类型断言由编译器删除，不会影响代码的运行时行为。\n\n还可以使用尖括号语法（除非代码在`.tsx`文件中），它是等效的：\n\n```tsx\nconst myCanvas = <HTMLCanvasElement>document.getElementById(\"main_canvas\");\n```\n\n> 提醒：因为类型断言在编译时被移除，所以没有与类型断言相关联的运行时检查。`null`如果类型断言错误，则不会出现异常。\n\nTypeScript 只允许类型断言转换为*更具体*或*不太具体*的类型版本。此规则可防止“不可能”的强制，例如：\n\n```tsx\nconst x = \"hello\" as number;\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/qNWktG6hBmzVZaC.png\" alt=\"image-20211114095324614\" style=\"zoom:50%;\" />\n\n将类型`string`转换为类型`number`可能是错误的，因为两种类型都没有充分重叠。如果这是有意的，请先将表达式转换为 `any` 或 `unknown`（`unknown`，我们将在后面介绍），然后是所需的类型：\n\n```tsx\nconst x = \"hello\" as unknown as number;\n```\n\n## 3.11 文字类型\n\n除了一般类型`string`和`number`，我们可以在类型位置引用*特定的*字符串和数字。\n\n一种方法是考虑 JavaScript 如何以不同的方式声明变量。`var`而`let`两者都允许更改变量中保存的内容，`const`不允许，这反映在 TypeScript 如何为文字创建类型上。\n\n```tsx\nlet testString = \"Hello World\";\ntestString = \"Olá Mundo\";\n\n//'testString'可以表示任何可能的字符串，那\n//TypeScript是如何在类型系统中描述它的\ntestString;\n\nconst constantString = \"Hello World\";\n//因为'constantString'只能表示1个可能的字符串，所以\n//具有文本类型表示\nconstantString;\n```\n\n就其本身而言，文字类型并不是很有价值：\n\n```tsx\nlet x: \"hello\" = \"hello\";\n// 正确\nx = \"hello\";\n// 错误\nx = \"howdy\";\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/kcOHJ74TKSvuq1h.png\" alt=\"image-20211114102648519\" style=\"zoom:50%;\" />\n\n拥有一个只能有一个值的变量并没有多大用处！\n\n但是通过*将*文字*组合*成联合，你可以表达一个更有用的概念——例如，只接受一组特定已知值的函数：\n\n```tsx\nfunction printText(s: string, alignment: \"left\" | \"right\" | \"center\") {\n  // ...\n}\nprintText(\"Hello, world\", \"left\");\nprintText(\"G'day, mate\", \"centre\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/SrcPeBsQvOUkDfw.png\" alt=\"image-20211114103049870\" style=\"zoom:50%;\" />\n\n数字文字类型的工作方式相同：\n\n```tsx\nfunction compare(a: string, b: string): -1 | 0 | 1 {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n```\n\n当然，你可以将这些与非文字类型结合使用：\n\n```tsx\ninterface Options {\n  width: number;\n}\nfunction configure(x: Options | \"auto\") {\n  // ...\n}\nconfigure({ width: 100 });\nconfigure(\"auto\");\nconfigure(\"automatic\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/YZQwUvRlCtkzcTL.png\" alt=\"image-20211114103530209\" style=\"zoom:50%;\" />\n\n还有一种文字类型：布尔文字。只有两种布尔文字类型，它们是类型`true`和`false`。类型`boolean`本身实际上只是联合类型 `union` 的别名`true | false`。\n\n- 文字推理\n\n当你使用对象初始化变量时，TypeScript 假定该对象的属性稍后可能会更改值。例如，如果你写了这样的代码：\n\n```tsx\nconst obj = { counter: 0 };\nif (someCondition) {\n  obj.counter = 1;\n}\n```\n\nTypeScript 不假定先前具有的字段值`0`，后又分配`1`是错误的。另一种说法是`obj.counter`必须有 `number`属性， 而非是 `0`，因为类型用于确定*读取*和*写入*行为。\n\n这同样适用于字符串：\n\n```tsx\nfunction handleRequest(url: string, method: \"GET\" | \"POST\" | \"GUESS\") {\n  // ...\n}\n\nconst req = { url: \"https://example.com\", method: \"GET\" };\nhandleRequest(req.url, req.method);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/hmLQKWoi4kVtBFD.png\" alt=\"image-20211114105814002\" style=\"zoom:50%;\" />\n\n在上面的例子`req.method`中推断是`string`，不是`\"GET\"`。因为代码可以在创建`req`和调用之间进行评估，TypeScript 认为这段代码有错误。\n\n有两种方法可以解决这个问题。\n\n**1. 可以通过在任一位置添加类型断言来更改推理：**\n\n```tsx\n// 方案 1:\nconst req = { url: \"https://example.com\", method: \"GET\" as \"GET\" };\n// 方案 2\nhandleRequest(req.url, req.method as \"GET\");\n```\n\n方案 1 表示“我打算`req.method`始终拥有*文字类型* `\"GET\"`”，从而防止之后可能分配`\"GUESS\"`给该字段。\n\n方案 2 的意思是“我知道其他原因`req.method`具有`\"GET\"`值”。\n\n**2. 可以使用`as const`将整个对象转换为类型文字：**\n\n```tsx\nconst req = { url: \"https://example.com\", method: \"GET\" } as const;\nhandleRequest(req.url, req.method);\n```\n\n该`as const`后缀就像`const`定义，确保所有属性分配的文本类型，而不是一个更一般的`string`或`number`。\n\n## 3.12 `null` 和 `undefined`\n\nJavaScript 有两个原始值用于表示不存在或未初始化的值：`null`和`undefined`.\n\nTypeScript 有两个对应的同名*类型*。这些类型的行为取决于您是否设置[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)选择。\n\n- `strictNullChecks` 关闭\n\n使用*false*，仍然可以正常访问的值，并且可以将值分配给任何类型的属性。这类似于没有空检查的语言（例如 C#、Java）的行为方式。缺乏对这些值的检查往往是错误的主要来源；如果在他们的代码库中这样做可行，我们总是建议大家打开。\n\n- `strictNullChecks` 打开\n\n使用*true*，你需要在对该值使用方法或属性之前测试这些值。就像在使用可选属性之前检查一样，我们可以使用*缩小*来检查可能的值：\n\n```tsx\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    // 做一些事\n  } else {\n    console.log(\"Hello, \" + x.toUpperCase());\n  }\n}\n```\n\n- 非空断言运算符（`!`后缀）\n\nTypeScript 也有一种特殊的语法`null`，`undefined`，可以在不进行任何显式检查的情况下，从类型中移除和移除类型。`!`在任何表达式之后写入实际上是一种类型断言，即该值不是`null`or `undefined`：\n\n```tsx\nfunction liveDangerously(x?: number | null) {\n  // 正确\n  console.log(x!.toFixed());\n}\n```\n\n就像其他类型断言一样，这不会更改代码的运行时行为，因此仅`!`当你知道该值*不能*是`null`或 `undefined`时使用才是重要的。\n\n## 3.13 枚举\n\n枚举是 TypeScript 添加到 JavaScript 的一项功能，它允许描述一个值，该值可能是一组可能的命名常量之一。与大多数 TypeScript 功能不同，这*不是*JavaScript 的类型级别的添加，而是添加到语言和运行时的内容。因此，你确定你确实需要枚举在做些事情，否则请不要使用。可以在[Enum 参考页 中](https://www.typescriptlang.org/docs/handbook/enums.html)阅读有关枚举的更多信息。\n\n```tsx\n// ts源码\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\nconsole.log(Direction.Up); // 1\n```\n\n```tsx\n// 编译后的js代码\n\"use strict\";\nvar Direction;\n(function (Direction) {\n  Direction[(Direction[\"Up\"] = 1)] = \"Up\";\n  Direction[(Direction[\"Down\"] = 2)] = \"Down\";\n  Direction[(Direction[\"Left\"] = 3)] = \"Left\";\n  Direction[(Direction[\"Right\"] = 4)] = \"Right\";\n})(Direction || (Direction = {}));\nconsole.log(Direction.Up);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/dvthyFIPKAuBR1s.png\" alt=\"image-20211114112554381\" style=\"zoom:33%;\" />\n\n## 3.14 不太常见的原语\n\n值得一提的是 JavaScript 中一些较新的原语，它们在 TypeScript 类型系统中也实现了。我们先简单的看两个例子：\n\n- #### `bigint`\n\n从 ES2020 开始，JavaScript 中有一个用于非常大的整数的原语`BigInt`：\n\n```tsx\n// 通过bigint函数创建bigint\nconst oneHundred: bigint = BigInt(100);\n\n// 通过文本语法创建BigInt\nconst anotherHundred: bigint = 100n;\n```\n\n你可以在[TypeScript 3.2 发行说明 中](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint)了解有关 BigInt 的更多信息。\n\n- #### `symbol`\n\nJavaScript 中有一个原语`Symbol()`，用于通过函数创建全局唯一引用：\n\n```tsx\nconst firstName = Symbol(\"name\");\nconst secondName = Symbol(\"name\");\n\nif (firstName === secondName) {\n  // 这里的代码不可能执行\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/ORATaxUgEjrPL9V.png\" alt=\"image-20211114113536948\" style=\"zoom:40%;\" />\n\n此条件将始终返回 `false`，因为类型 `typeof firstName`和`typeof secondName`没有重叠。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-3、基础篇：常用类型",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao1000g94v317xp8scm",
        "content": "<h1 id=\"三、常用类型\"><a href=\"#三、常用类型\" class=\"headerlink\" title=\"三、常用类型\"></a>三、常用类型</h1><p>在本章中，我们将介绍一些在 JavaScript 代码中最常见的值类型，并解释在 TypeScript 中描述这些类型的相应方法。这不是一个详尽的列表，未来的章节将描述命名和使用其他类型的更多方法。</p>\n<p>类型还可以出现在更多的<em>地方，</em>而不仅仅是类型注释。当我们了解类型本身时，我们还将了解可以引用这些类型以形成新结构的地方。</p>\n<p>我们将首先回顾你在编写 JavaScript 或 TypeScript 代码时，可能遇到的最基本和最常见的类型，它是形成更复杂类型的核心构建块。</p>\n<h2 id=\"3-0-TypeScript配置文件\"><a href=\"#3-0-TypeScript配置文件\" class=\"headerlink\" title=\"3.0 TypeScript配置文件\"></a>3.0 TypeScript配置文件</h2><p>为了方便学习，我们可以在一个单独的配置文件中保存命令行中的参数，应用 <code>tsc</code> 生成配置文件：</p>\n<img src=\"https://s2.loli.net/2022/02/22/1dAfz2imrs3CMbL.png\" alt=\"image-20211113170722654\" style=\"zoom: 50%;\"/>\n\n<p>在项目根目录下生成了一个配置文件 <code>tsconfig.json</code>。这里给出我们自己的配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Language and Environment */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Modules */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./src&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Emit */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Type Checking */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;strict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-1-基元类型string-number-和boolean\"><a href=\"#3-1-基元类型string-number-和boolean\" class=\"headerlink\" title=\"3.1 基元类型string,number, 和boolean\"></a>3.1 基元类型<code>string</code>,<code>number</code>, 和<code>boolean</code></h2><p>JavaScript有三个非常常用的<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">原语</a>：<code>string</code>，<code>number</code>，和<code>boolean</code>。每个在 TypeScript 中都有对应的类型。我们发现，这些名称与我们在 JavaScript 应用<code>typeof</code>返回的类型的名称相同：</p>\n<ul>\n<li><code>string</code> 表示字符串值，如 <code>&quot;Hello, world&quot;</code></li>\n<li><code>number</code>表示数字值，如 <code>42</code>。JavaScript 没有一个特殊的整数运行时值，所以没有等价于<code>int</code>或 <code>float</code>类型， 一切都只是<code>number</code></li>\n<li><code>boolean</code>只有两个值<code>true</code>和<code>false</code></li>\n</ul>\n<blockquote>\n<p>类型名称<code>String</code>, <code>Number</code>, 和<code>Boolean</code>（以大写字母开头）是合法的，但指的是一些很少出现在代码中的特殊内置类型。对于类型，<em>始终</em>使用<code>string</code>, <code>number</code>, 或<code>boolean</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str</span>: string = <span class=\"string\">&#x27;hello typescript&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">num</span>: number = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">bool</span>: boolean = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-数组\"><a href=\"#3-2-数组\" class=\"headerlink\" title=\"3.2 数组\"></a>3.2 数组</h2><p>数组是指定形如<code>[1, 2, 3]</code>数据，可以使用语法<code>number[]</code>来定义; 此语法适用于任何类型（例如<code>string[]</code>，字符串数组等）。</p>\n<p>你也可以写成<code>Array&lt;number&gt;</code>。<code>T&lt;U&gt;</code>当介绍<em>泛型</em>时，我们将了解更多有关这个语法的更多信息。</p>\n<p><strong>02-everyday-types&#x2F;src&#x2F;02-array.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">arr</span>: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">arr2</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-any\"><a href=\"#3-3-any\" class=\"headerlink\" title=\"3.3 any\"></a>3.3 any</h2><p>TypeScript 还有一个特殊类型 <code>any</code>，当你不希望某个特定值导致类型检查错误时，可以使用它。</p>\n<p>当一个值的类型是<code>any</code>时，可以访问它的任何属性，将它分配给任何类型的值，或者几乎任何其他语法上的东西都合法的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">obj</span>: <span class=\"built_in\">any</span> = &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 以下代码行都不会抛出编译器错误。</span></span><br><span class=\"line\"><span class=\"comment\">// 使用&#x27;any&#x27;将禁用所有进一步的类型检查</span></span><br><span class=\"line\">obj.<span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"title function_\">obj</span>();</span><br><span class=\"line\">obj.<span class=\"property\">bar</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\">obj = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">n</span>: <span class=\"built_in\">number</span> = obj;</span><br></pre></td></tr></table></figure>\n\n<p>但在运行环境下执行代码可能是错误的：</p>\n<img src=\"/img/TypeScript/03-02.png\" alt=\"image-20211113182543401\" style=\"zoom:50%;\" />\n\n<p>进入到 <code>dist</code>目录中，在 node 环境里运行代码，果然报错了。</p>\n<p>当你不想写出长类型只是为了让 TypeScript 相信特定的代码行没问题时，<code>any</code>类型很有用。</p>\n<ul>\n<li><strong>noImplicitAny</strong></li>\n</ul>\n<p>当不指定类型时，并且 TypeScript 无法从上下文推断它时，编译器通常会默认为<code>any</code>.</p>\n<p>但是，您通常希望避免这种情况，因为<code>any</code>没有进行类型检查。使用编译器标志<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"><code>noImplicitAny</code></a>将任何隐式标记<code>any</code>为错误。这个配置我们在前面讲到过。</p>\n<h2 id=\"3-4-变量上的类型注释\"><a href=\"#3-4-变量上的类型注释\" class=\"headerlink\" title=\"3.4 变量上的类型注释\"></a>3.4 变量上的类型注释</h2><p>当你使用<code>const</code>, <code>var</code>, 或声明变量时<code>let</code>，可以选择添加类型注释来显式指定变量的类型：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myName</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;Felixlu&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>TypeScript 不使用“左边的类型”风格的声明，比如<code>int x = 0;</code> 类型注解总是<em>在</em>被输入的东西<em>之后</em>。</p>\n</blockquote>\n<p>但是，在大多数情况下，这不是必需的。只要有可能，TypeScript 就会尝试自动<em>推断</em>代码中的类型。例如，变量的类型是根据其初始化器的类型推断出来的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不需要类型定义--“myName”推断为类型“string”</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">&quot;Felixlu&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>大多数情况下，不需要明确学习推理规则。如果你刚开始，请尝试使用比你想象的更少的类型注释 - 你可能会惊讶——TypeScript 完全了解正在发生的事情。</p>\n<h2 id=\"3-5-函数\"><a href=\"#3-5-函数\" class=\"headerlink\" title=\"3.5 函数\"></a>3.5 函数</h2><p>函数是在 JavaScript 中传递数据的主要方式。TypeScript 允许您指定函数的输入和输出值的类型。</p>\n<ul>\n<li>参数类型注释</li>\n</ul>\n<p>声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型。参数类型注释位于参数名称之后：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数类型定义</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + name.<span class=\"title function_\">toUpperCase</span>() + <span class=\"string\">&quot;!!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当参数具有类型注释时，将检查该函数的参数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果执行，将是一个运行时错误！</span></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"number\">42</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/SR9okXs1ez7ThC6.png\" alt=\"image-20211114072314780\" style=\"zoom: 50%;\" />\n\n<blockquote>\n<p>即使您的参数上没有类型注释，TypeScript 仍会检查您是否传递了正确数量的参数。</p>\n</blockquote>\n<ul>\n<li>返回类型注释</li>\n</ul>\n<p>你还可以添加返回类型注释。返回类型注释出现在参数列表之后：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFavoriteNumber</span>(<span class=\"params\"></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">26</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与变量类型注释非常相似，通常不需要返回类型注释，因为 TypeScript 会根据其<code>return</code>语句推断函数的返回类型。上面例子中的类型注释不会改变任何东西。某些代码库会出于文档目的明确指定返回类型，以防止意外更改或仅出于个人偏好。</p>\n<ul>\n<li>匿名函数</li>\n</ul>\n<p>匿名函数与函数声明有点不同。当一个函数出现在 TypeScript 可以确定它将如何被调用的地方时，该函数的参数会自动指定类型。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里没有类型注释，但是TypeScript可以发现错误</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Eve&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数上下文类型</span></span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"title function_\">toUppercase</span>());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上下文类型也适用于箭头函数</span></span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"title function_\">toUppercase</span>());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qMkb8YQzxUw2Xnc.png\" alt=\"image-20211114073444596\" style=\"zoom:50%;\" />\n\n<p>即使参数<code>s</code>没有类型注释，TypeScript 也会使用<code>forEach</code>函数的类型，以及数组的推断类型来确定<code>s</code>的类型。</p>\n<p>这个过程称为<em>上下文类型，</em>因为函数发生在其中的<em>上下文</em>通知它应该具有什么类型。</p>\n<p>与推理规则类似，你不需要明确了解这是如何发生的，但了解它的机制<em>确实</em>可以帮助你注意何时不需要类型注释。稍后，我们将看到更多关于<em>值出现的上下文</em>如何影响其类型的示例。</p>\n<h2 id=\"3-6-对象类型\"><a href=\"#3-6-对象类型\" class=\"headerlink\" title=\"3.6 对象类型\"></a>3.6 对象类型</h2><p>除了<code>string</code>，<code>number</code>，<code>boolean</code>类型（又称基元类型）外，你将遇到的最常见的类型是<em>对象类型</em>。这指的是任何带有属性的 JavaScript 值，几乎是所有属性！要定义对象类型，我们只需列出其属性及其类型。</p>\n<p>例如，这是一个接受点状对象的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数的类型注释是对象类型</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: &#123; x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标的x值为： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标的y值为： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">7</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们使用具有两个属性的类型注释参数 -<code>x</code>和<code>y</code>- 这两个属性都是 <code>number</code>类型。你可以以使用<code>,</code>或<code>;</code>来分隔属性，最后一个分隔符是可选的。</p>\n<p>每个属性的类型部分也是可选的。如果你不指定类型，则将假定为<code>any</code>。</p>\n<ul>\n<li>可选属性</li>\n</ul>\n<p>对象类型还可以指定其部分或全部属性是<em>可选的</em>。为此，请在属性名称后添加一个<code>?</code>：</p>\n<p><strong>02-everyday-types&#x2F;src&#x2F;05-object.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printName</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; first: <span class=\"built_in\">string</span>; last?: <span class=\"built_in\">string</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 两种传递参数都可以</span></span><br><span class=\"line\"><span class=\"title function_\">printName</span>(&#123; <span class=\"attr\">first</span>: <span class=\"string\">&quot;Felix&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">printName</span>(&#123; <span class=\"attr\">first</span>: <span class=\"string\">&quot;Felix&quot;</span>, <span class=\"attr\">last</span>: <span class=\"string\">&quot;Lu&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在 JavaScript 中，如果访问一个不存在的属性，将获得值<code>undefined</code>而不是运行时错误。因此，当你<em>读取</em>可选属性时，必须使用它之前用<code>undefined</code>进行检查。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printName</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; first: <span class=\"built_in\">string</span>; last?: <span class=\"built_in\">string</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 错误 - &#x27;obj.last&#x27; 可能不存在!</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.<span class=\"property\">last</span> !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这样可以</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 使用现代JavaScript语法的安全替代方案：</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>?.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7-联合类型\"><a href=\"#3-7-联合类型\" class=\"headerlink\" title=\"3.7 联合类型\"></a>3.7 联合类型</h2><p>TypeScript 的类型系统允许你使用多种运算符，从现有类型中构建新类型。现在我们知道如何编写几种类型，是时候开始以有趣的方式<em>组合</em>它们了。</p>\n<ul>\n<li>定义联合类型</li>\n</ul>\n<p>第一种组合类型的方法是<em>联合</em>类型。联合类型是由两个或多个其他类型组成的类型，表示可能是这些类型中的<em>任何一种</em>的值。我们将这些类型中的每一种称为<em>联合类型的成员</em>。</p>\n<p>让我们编写一个可以对字符串或数字进行操作的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Your ID is: &quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(<span class=\"number\">101</span>);</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(<span class=\"string\">&quot;202&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(&#123; <span class=\"attr\">myID</span>: <span class=\"number\">22342</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qkOvn9DrVdCRSBc.png\" alt=\"image-20211114081646215\" style=\"zoom:50%;\" />\n\n<ul>\n<li>使用联合类型</li>\n</ul>\n<p><em>提供</em>匹配联合类型的值很容易- 只需提供匹配任何联合成员的类型。如果你<em>有</em>一个联合类型的值，你如何使用它？</p>\n<p>如果联合的<em>每个</em>成员都有效，TypeScript 将只允许你使用联合做一些事情。例如，如果你有联合类型 <code>string | number</code>，则不能只使用一种类型的操作，比如<code>string</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/TnuapbGVlOE2BYw.png\" alt=\"image-20211114085508715\" style=\"zoom:50%;\" />\n\n<p>解决方案是用代码<em>缩小</em>联合，就像在没有类型注释的 JavaScript 中一样。 当 TypeScript 可以根据代码结构为值推断出更具体的类型时，就会发生<em>缩小</em>。</p>\n<p>例如，TypeScript 知道只有一个<code>string</code>值才会有一个<code>typeof</code>值<code>&quot;string&quot;</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> id === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在此分支中，id的类型为“string”</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此处，id的类型为“number”</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一个例子是使用如下函数<code>Array.isArray</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">welcomePeople</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(x)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此处: &#x27;x&#x27; 的类型是 &#x27;string[]&#x27;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + x.<span class=\"title function_\">join</span>(<span class=\"string\">&quot; and &quot;</span>));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此处: &#x27;x&#x27; 的类型是 &#x27;string&#x27;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Welcome lone traveler &quot;</span> + x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，在<code>else</code>分支中，我们不需要做任何特别的事情——如果<code>x</code>不是 <code>string[]</code>，那么它一定是 <code>string</code>。</p>\n<p>有时你会有一个 <code>union</code>，所有成员都有一些共同点。例如，数组和字符串都有一个<code>slice</code>方法。如果联合中的每个成员都有一个共同的属性，则可以使用该属性而不会缩小范围：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回类型推断为 number[] | string</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFirstThree</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-8-类型别名\"><a href=\"#3-8-类型别名\" class=\"headerlink\" title=\"3.8 类型别名\"></a>3.8 类型别名</h2><p>我们一直在通过直接在类型注释中编写对象类型和联合类型来使用它们。这很方便，但是想要多次使用同一个类型，并用一个名称来引用它是很常见的。</p>\n<p>一个<em>类型别名</em>正是一个<em>名称</em>为任何<em>类型</em>的定义。类型别名的语法是：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Point</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与前面的示例完全相同</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标x的值是： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标y的值是： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实际上，你可以使用类型别名为任何类型命名，而不仅仅是对象类型。例如，类型别名可以命名联合类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">ID</span> = <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，别名<em>只是</em>别名 - 你不能使用类型别名来创建相同类型的不同“版本”。当你使用别名时，就像你编写了别名类型一样。换句话说，这段代码可能<em>看起来不</em>合法，但根据 TypeScript 是可以的，因为这两种类型都是同一类型的别名：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UserInputSanitizedString</span> = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sanitizeInput</span>(<span class=\"params\"><span class=\"attr\">str</span>: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">UserInputSanitizedString</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建经过 sanitize 的输入</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userInput = <span class=\"title function_\">sanitizeInput</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但仍可以使用字符串重新分配值</span></span><br><span class=\"line\">userInput = <span class=\"string\">&quot;new input&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-9-接口\"><a href=\"#3-9-接口\" class=\"headerlink\" title=\"3.9 接口\"></a>3.9 接口</h2><p>一个<em>接口声明</em>是另一种方式来命名对象类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标x的值是： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标y的值是： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>就像我们在上面使用类型别名时一样，该示例就像我们使用了匿名对象类型一样工作。TypeScript 只关心我们传递给的值的<em>结构</em><code>printCoord</code>——它只关心它是否具有预期的属性。只关心类型的结构和功能，是我们将 TypeScript 称为<em>结构类型</em>类型系统的原因。</p>\n<ul>\n<li>类型别名和接口之间的差异</li>\n</ul>\n<p>类型别名和接口非常相似，在很多情况下你可以自由选择它们。几乎所有的功能都在<code>interface</code>中可用<code>type</code>，关键区别在于扩展新类型的方式不同：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 扩展接口</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bear</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">bear</span>: <span class=\"title class_\">Bear</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;winnie&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bear.<span class=\"property\">name</span>;</span><br><span class=\"line\">bear.<span class=\"property\">honey</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过交叉点扩展类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Animal</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bear</span> = <span class=\"title class_\">Animal</span> &amp; &#123;</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">bear</span>: <span class=\"title class_\">Bear</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;winnie&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bear.<span class=\"property\">name</span>;</span><br><span class=\"line\">bear.<span class=\"property\">honey</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向现有接口添加新字段</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyWindow</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyWindow</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">w</span>: <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;hello ts&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类型创建后不可更改</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/03-07.png\" alt=\"image-20211114094240585\" style=\"zoom:50%;\" />\n\n<blockquote>\n<ul>\n<li>在 TypeScript 4.2 版之前，类型别名<a href=\"https://www.typescriptlang.org/play#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA\"><em>可能</em>出现在错误消息中</a>，有时会代替等效的匿名类型（这可能是可取的，也可能是不可取的）。接口将始终在错误消息中命名。</li>\n<li>类型别名可能不参与<a href=\"https://www.typescriptlang.org/play#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA\">声明合并，但接口可以</a>。</li>\n<li>接口只能用于<a href=\"https://www.typescriptlang.org/play#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA\">声明对象的形状，不能重命名基元</a>。</li>\n<li>接口名称将<a href=\"https://www.typescriptlang.org/play#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA\"><em>始终</em>以其原始形式出现在</a>错误消息中，但<em>仅</em>当它们按名称使用时。</li>\n</ul>\n<p>大多数情况下，你可以根据个人喜好进行选择，TypeScript 会告诉你是否需要其他类型的声明。如果您想要启发式，请使用<code>interface</code>，然后在需要时使用<code>type</code>。</p>\n</blockquote>\n<h2 id=\"3-10-类型断言\"><a href=\"#3-10-类型断言\" class=\"headerlink\" title=\"3.10 类型断言\"></a>3.10 类型断言</h2><p>有时，你会获得有关 TypeScript 不知道的值类型的信息。</p>\n<p>例如，如果你正在使用<code>document.getElementById</code>，TypeScript 只知道这将返回<em>某种</em>类型的<code>HTMLElement</code>，但你可能知道你的页面将始终具有<code>HTMLCanvasElement</code>给定 ID 的值 。</p>\n<p>在这种情况下，你可以使用<em>类型断言</em>来指定更具体的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;main_canvas&quot;</span>) <span class=\"keyword\">as</span> <span class=\"title class_\">HTMLCanvasElement</span>;</span><br></pre></td></tr></table></figure>\n\n<p>与类型注释一样，类型断言由编译器删除，不会影响代码的运行时行为。</p>\n<p>还可以使用尖括号语法（除非代码在<code>.tsx</code>文件中），它是等效的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = &lt;<span class=\"title class_\">HTMLCanvasElement</span>&gt;<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;main_canvas&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>提醒：因为类型断言在编译时被移除，所以没有与类型断言相关联的运行时检查。<code>null</code>如果类型断言错误，则不会出现异常。</p>\n</blockquote>\n<p>TypeScript 只允许类型断言转换为<em>更具体</em>或<em>不太具体</em>的类型版本。此规则可防止“不可能”的强制，例如：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qNWktG6hBmzVZaC.png\" alt=\"image-20211114095324614\" style=\"zoom:50%;\" />\n\n<p>将类型<code>string</code>转换为类型<code>number</code>可能是错误的，因为两种类型都没有充分重叠。如果这是有意的，请先将表达式转换为 <code>any</code> 或 <code>unknown</code>（<code>unknown</code>，我们将在后面介绍），然后是所需的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">unknown</span> <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-11-文字类型\"><a href=\"#3-11-文字类型\" class=\"headerlink\" title=\"3.11 文字类型\"></a>3.11 文字类型</h2><p>除了一般类型<code>string</code>和<code>number</code>，我们可以在类型位置引用<em>特定的</em>字符串和数字。</p>\n<p>一种方法是考虑 JavaScript 如何以不同的方式声明变量。<code>var</code>而<code>let</code>两者都允许更改变量中保存的内容，<code>const</code>不允许，这反映在 TypeScript 如何为文字创建类型上。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> testString = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">testString = <span class=\"string\">&quot;Olá Mundo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//&#x27;testString&#x27;可以表示任何可能的字符串，那</span></span><br><span class=\"line\"><span class=\"comment\">//TypeScript是如何在类型系统中描述它的</span></span><br><span class=\"line\">testString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> constantString = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//因为&#x27;constantString&#x27;只能表示1个可能的字符串，所以</span></span><br><span class=\"line\"><span class=\"comment\">//具有文本类型表示</span></span><br><span class=\"line\">constantString;</span><br></pre></td></tr></table></figure>\n\n<p>就其本身而言，文字类型并不是很有价值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"string\">&quot;hello&quot;</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\">x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\">x = <span class=\"string\">&quot;howdy&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/kcOHJ74TKSvuq1h.png\" alt=\"image-20211114102648519\" style=\"zoom:50%;\" />\n\n<p>拥有一个只能有一个值的变量并没有多大用处！</p>\n<p>但是通过<em>将</em>文字<em>组合</em>成联合，你可以表达一个更有用的概念——例如，只接受一组特定已知值的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printText</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">alignment</span>: <span class=\"string\">&quot;left&quot;</span> | <span class=\"string\">&quot;right&quot;</span> | <span class=\"string\">&quot;center&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printText</span>(<span class=\"string\">&quot;Hello, world&quot;</span>, <span class=\"string\">&quot;left&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">printText</span>(<span class=\"string\">&quot;G&#x27;day, mate&quot;</span>, <span class=\"string\">&quot;centre&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/SrcPeBsQvOUkDfw.png\" alt=\"image-20211114103049870\" style=\"zoom:50%;\" />\n\n<p>数字文字类型的工作方式相同：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compare</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span></span>): -<span class=\"number\">1</span> | <span class=\"number\">0</span> | <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === b ? <span class=\"number\">0</span> : a &gt; b ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，你可以将这些与非文字类型结合使用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Options</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">width</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">configure</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Options</span> | <span class=\"string\">&quot;auto&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(&#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(<span class=\"string\">&quot;auto&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(<span class=\"string\">&quot;automatic&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/YZQwUvRlCtkzcTL.png\" alt=\"image-20211114103530209\" style=\"zoom:50%;\" />\n\n<p>还有一种文字类型：布尔文字。只有两种布尔文字类型，它们是类型<code>true</code>和<code>false</code>。类型<code>boolean</code>本身实际上只是联合类型 <code>union</code> 的别名<code>true | false</code>。</p>\n<ul>\n<li>文字推理</li>\n</ul>\n<p>当你使用对象初始化变量时，TypeScript 假定该对象的属性稍后可能会更改值。例如，如果你写了这样的代码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">counter</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (someCondition) &#123;</span><br><span class=\"line\">  obj.<span class=\"property\">counter</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript 不假定先前具有的字段值<code>0</code>，后又分配<code>1</code>是错误的。另一种说法是<code>obj.counter</code>必须有 <code>number</code>属性， 而非是 <code>0</code>，因为类型用于确定<em>读取</em>和<em>写入</em>行为。</p>\n<p>这同样适用于字符串：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleRequest</span>(<span class=\"params\"><span class=\"attr\">url</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> | <span class=\"string\">&quot;POST&quot;</span> | <span class=\"string\">&quot;GUESS&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/hmLQKWoi4kVtBFD.png\" alt=\"image-20211114105814002\" style=\"zoom:50%;\" />\n\n<p>在上面的例子<code>req.method</code>中推断是<code>string</code>，不是<code>&quot;GET&quot;</code>。因为代码可以在创建<code>req</code>和调用之间进行评估，TypeScript 认为这段代码有错误。</p>\n<p>有两种方法可以解决这个问题。</p>\n<p><strong>1. 可以通过在任一位置添加类型断言来更改推理：</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案 1:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> <span class=\"keyword\">as</span> <span class=\"string\">&quot;GET&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 方案 2</span></span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span> <span class=\"keyword\">as</span> <span class=\"string\">&quot;GET&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>方案 1 表示“我打算<code>req.method</code>始终拥有<em>文字类型</em> <code>&quot;GET&quot;</code>”，从而防止之后可能分配<code>&quot;GUESS&quot;</code>给该字段。</p>\n<p>方案 2 的意思是“我知道其他原因<code>req.method</code>具有<code>&quot;GET&quot;</code>值”。</p>\n<p><strong>2. 可以使用<code>as const</code>将整个对象转换为类型文字：</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> &#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span>);</span><br></pre></td></tr></table></figure>\n\n<p>该<code>as const</code>后缀就像<code>const</code>定义，确保所有属性分配的文本类型，而不是一个更一般的<code>string</code>或<code>number</code>。</p>\n<h2 id=\"3-12-null-和-undefined\"><a href=\"#3-12-null-和-undefined\" class=\"headerlink\" title=\"3.12 null 和 undefined\"></a>3.12 <code>null</code> 和 <code>undefined</code></h2><p>JavaScript 有两个原始值用于表示不存在或未初始化的值：<code>null</code>和<code>undefined</code>.</p>\n<p>TypeScript 有两个对应的同名<em>类型</em>。这些类型的行为取决于您是否设置<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a>选择。</p>\n<ul>\n<li><code>strictNullChecks</code> 关闭</li>\n</ul>\n<p>使用<em>false</em>，仍然可以正常访问的值，并且可以将值分配给任何类型的属性。这类似于没有空检查的语言（例如 C#、Java）的行为方式。缺乏对这些值的检查往往是错误的主要来源；如果在他们的代码库中这样做可行，我们总是建议大家打开。</p>\n<ul>\n<li><code>strictNullChecks</code> 打开</li>\n</ul>\n<p>使用<em>true</em>，你需要在对该值使用方法或属性之前测试这些值。就像在使用可选属性之前检查一样，我们可以使用<em>缩小</em>来检查可能的值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做一些事</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + x.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>非空断言运算符（<code>!</code>后缀）</li>\n</ul>\n<p>TypeScript 也有一种特殊的语法<code>null</code>，<code>undefined</code>，可以在不进行任何显式检查的情况下，从类型中移除和移除类型。<code>!</code>在任何表达式之后写入实际上是一种类型断言，即该值不是<code>null</code>or <code>undefined</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">liveDangerously</span>(<span class=\"params\"><span class=\"attr\">x</span>?: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正确</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x!.<span class=\"title function_\">toFixed</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就像其他类型断言一样，这不会更改代码的运行时行为，因此仅<code>!</code>当你知道该值<em>不能</em>是<code>null</code>或 <code>undefined</code>时使用才是重要的。</p>\n<h2 id=\"3-13-枚举\"><a href=\"#3-13-枚举\" class=\"headerlink\" title=\"3.13 枚举\"></a>3.13 枚举</h2><p>枚举是 TypeScript 添加到 JavaScript 的一项功能，它允许描述一个值，该值可能是一组可能的命名常量之一。与大多数 TypeScript 功能不同，这<em>不是</em>JavaScript 的类型级别的添加，而是添加到语言和运行时的内容。因此，你确定你确实需要枚举在做些事情，否则请不要使用。可以在<a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">Enum 参考页 中</a>阅读有关枚举的更多信息。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ts源码</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译后的js代码</span></span><br><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Direction</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"title class_\">Direction</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Up&quot;</span>] = <span class=\"number\">1</span>)] = <span class=\"string\">&quot;Up&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Down&quot;</span>] = <span class=\"number\">2</span>)] = <span class=\"string\">&quot;Down&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Left&quot;</span>] = <span class=\"number\">3</span>)] = <span class=\"string\">&quot;Left&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Right&quot;</span>] = <span class=\"number\">4</span>)] = <span class=\"string\">&quot;Right&quot;</span>;</span><br><span class=\"line\">&#125;)(<span class=\"title class_\">Direction</span> || (<span class=\"title class_\">Direction</span> = &#123;&#125;));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/dvthyFIPKAuBR1s.png\" alt=\"image-20211114112554381\" style=\"zoom:33%;\" />\n\n<h2 id=\"3-14-不太常见的原语\"><a href=\"#3-14-不太常见的原语\" class=\"headerlink\" title=\"3.14 不太常见的原语\"></a>3.14 不太常见的原语</h2><p>值得一提的是 JavaScript 中一些较新的原语，它们在 TypeScript 类型系统中也实现了。我们先简单的看两个例子：</p>\n<ul>\n<li><h4 id=\"bigint\"><a href=\"#bigint\" class=\"headerlink\" title=\"bigint\"></a><code>bigint</code></h4></li>\n</ul>\n<p>从 ES2020 开始，JavaScript 中有一个用于非常大的整数的原语<code>BigInt</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过bigint函数创建bigint</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">oneHundred</span>: <span class=\"built_in\">bigint</span> = <span class=\"title class_\">BigInt</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过文本语法创建BigInt</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">anotherHundred</span>: <span class=\"built_in\">bigint</span> = <span class=\"number\">100n</span>;</span><br></pre></td></tr></table></figure>\n\n<p>你可以在<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint\">TypeScript 3.2 发行说明 中</a>了解有关 BigInt 的更多信息。</p>\n<ul>\n<li><h4 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a><code>symbol</code></h4></li>\n</ul>\n<p>JavaScript 中有一个原语<code>Symbol()</code>，用于通过函数创建全局唯一引用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> firstName = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> secondName = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (firstName === secondName) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里的代码不可能执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/ORATaxUgEjrPL9V.png\" alt=\"image-20211114113536948\" style=\"zoom:40%;\" />\n\n<p>此条件将始终返回 <code>false</code>，因为类型 <code>typeof firstName</code>和<code>typeof secondName</code>没有重叠。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"三、常用类型\"><a href=\"#三、常用类型\" class=\"headerlink\" title=\"三、常用类型\"></a>三、常用类型</h1><p>在本章中，我们将介绍一些在 JavaScript 代码中最常见的值类型，并解释在 TypeScript 中描述这些类型的相应方法。这不是一个详尽的列表，未来的章节将描述命名和使用其他类型的更多方法。</p>\n<p>类型还可以出现在更多的<em>地方，</em>而不仅仅是类型注释。当我们了解类型本身时，我们还将了解可以引用这些类型以形成新结构的地方。</p>\n<p>我们将首先回顾你在编写 JavaScript 或 TypeScript 代码时，可能遇到的最基本和最常见的类型，它是形成更复杂类型的核心构建块。</p>\n<h2 id=\"3-0-TypeScript配置文件\"><a href=\"#3-0-TypeScript配置文件\" class=\"headerlink\" title=\"3.0 TypeScript配置文件\"></a>3.0 TypeScript配置文件</h2><p>为了方便学习，我们可以在一个单独的配置文件中保存命令行中的参数，应用 <code>tsc</code> 生成配置文件：</p>\n<img src=\"https://s2.loli.net/2022/02/22/1dAfz2imrs3CMbL.png\" alt=\"image-20211113170722654\" style=\"zoom: 50%;\"/>\n\n<p>在项目根目录下生成了一个配置文件 <code>tsconfig.json</code>。这里给出我们自己的配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/* Language and Environment */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Modules */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./src&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Emit */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">/* Type Checking */</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;strict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-1-基元类型string-number-和boolean\"><a href=\"#3-1-基元类型string-number-和boolean\" class=\"headerlink\" title=\"3.1 基元类型string,number, 和boolean\"></a>3.1 基元类型<code>string</code>,<code>number</code>, 和<code>boolean</code></h2><p>JavaScript有三个非常常用的<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">原语</a>：<code>string</code>，<code>number</code>，和<code>boolean</code>。每个在 TypeScript 中都有对应的类型。我们发现，这些名称与我们在 JavaScript 应用<code>typeof</code>返回的类型的名称相同：</p>\n<ul>\n<li><code>string</code> 表示字符串值，如 <code>&quot;Hello, world&quot;</code></li>\n<li><code>number</code>表示数字值，如 <code>42</code>。JavaScript 没有一个特殊的整数运行时值，所以没有等价于<code>int</code>或 <code>float</code>类型， 一切都只是<code>number</code></li>\n<li><code>boolean</code>只有两个值<code>true</code>和<code>false</code></li>\n</ul>\n<blockquote>\n<p>类型名称<code>String</code>, <code>Number</code>, 和<code>Boolean</code>（以大写字母开头）是合法的，但指的是一些很少出现在代码中的特殊内置类型。对于类型，<em>始终</em>使用<code>string</code>, <code>number</code>, 或<code>boolean</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str</span>: string = <span class=\"string\">&#x27;hello typescript&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">num</span>: number = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">bool</span>: boolean = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-数组\"><a href=\"#3-2-数组\" class=\"headerlink\" title=\"3.2 数组\"></a>3.2 数组</h2><p>数组是指定形如<code>[1, 2, 3]</code>数据，可以使用语法<code>number[]</code>来定义; 此语法适用于任何类型（例如<code>string[]</code>，字符串数组等）。</p>\n<p>你也可以写成<code>Array&lt;number&gt;</code>。<code>T&lt;U&gt;</code>当介绍<em>泛型</em>时，我们将了解更多有关这个语法的更多信息。</p>\n<p><strong>02-everyday-types&#x2F;src&#x2F;02-array.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">arr</span>: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">arr2</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-any\"><a href=\"#3-3-any\" class=\"headerlink\" title=\"3.3 any\"></a>3.3 any</h2><p>TypeScript 还有一个特殊类型 <code>any</code>，当你不希望某个特定值导致类型检查错误时，可以使用它。</p>\n<p>当一个值的类型是<code>any</code>时，可以访问它的任何属性，将它分配给任何类型的值，或者几乎任何其他语法上的东西都合法的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">obj</span>: <span class=\"built_in\">any</span> = &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 以下代码行都不会抛出编译器错误。</span></span><br><span class=\"line\"><span class=\"comment\">// 使用&#x27;any&#x27;将禁用所有进一步的类型检查</span></span><br><span class=\"line\">obj.<span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"title function_\">obj</span>();</span><br><span class=\"line\">obj.<span class=\"property\">bar</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\">obj = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">n</span>: <span class=\"built_in\">number</span> = obj;</span><br></pre></td></tr></table></figure>\n\n<p>但在运行环境下执行代码可能是错误的：</p>\n<img src=\"/img/TypeScript/03-02.png\" alt=\"image-20211113182543401\" style=\"zoom:50%;\" />\n\n<p>进入到 <code>dist</code>目录中，在 node 环境里运行代码，果然报错了。</p>\n<p>当你不想写出长类型只是为了让 TypeScript 相信特定的代码行没问题时，<code>any</code>类型很有用。</p>\n<ul>\n<li><strong>noImplicitAny</strong></li>\n</ul>\n<p>当不指定类型时，并且 TypeScript 无法从上下文推断它时，编译器通常会默认为<code>any</code>.</p>\n<p>但是，您通常希望避免这种情况，因为<code>any</code>没有进行类型检查。使用编译器标志<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"><code>noImplicitAny</code></a>将任何隐式标记<code>any</code>为错误。这个配置我们在前面讲到过。</p>\n<h2 id=\"3-4-变量上的类型注释\"><a href=\"#3-4-变量上的类型注释\" class=\"headerlink\" title=\"3.4 变量上的类型注释\"></a>3.4 变量上的类型注释</h2><p>当你使用<code>const</code>, <code>var</code>, 或声明变量时<code>let</code>，可以选择添加类型注释来显式指定变量的类型：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myName</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;Felixlu&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>TypeScript 不使用“左边的类型”风格的声明，比如<code>int x = 0;</code> 类型注解总是<em>在</em>被输入的东西<em>之后</em>。</p>\n</blockquote>\n<p>但是，在大多数情况下，这不是必需的。只要有可能，TypeScript 就会尝试自动<em>推断</em>代码中的类型。例如，变量的类型是根据其初始化器的类型推断出来的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不需要类型定义--“myName”推断为类型“string”</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">&quot;Felixlu&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>大多数情况下，不需要明确学习推理规则。如果你刚开始，请尝试使用比你想象的更少的类型注释 - 你可能会惊讶——TypeScript 完全了解正在发生的事情。</p>\n<h2 id=\"3-5-函数\"><a href=\"#3-5-函数\" class=\"headerlink\" title=\"3.5 函数\"></a>3.5 函数</h2><p>函数是在 JavaScript 中传递数据的主要方式。TypeScript 允许您指定函数的输入和输出值的类型。</p>\n<ul>\n<li>参数类型注释</li>\n</ul>\n<p>声明函数时，可以在每个参数后添加类型注解，以声明函数接受的参数类型。参数类型注释位于参数名称之后：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数类型定义</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + name.<span class=\"title function_\">toUpperCase</span>() + <span class=\"string\">&quot;!!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当参数具有类型注释时，将检查该函数的参数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果执行，将是一个运行时错误！</span></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"number\">42</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/SR9okXs1ez7ThC6.png\" alt=\"image-20211114072314780\" style=\"zoom: 50%;\" />\n\n<blockquote>\n<p>即使您的参数上没有类型注释，TypeScript 仍会检查您是否传递了正确数量的参数。</p>\n</blockquote>\n<ul>\n<li>返回类型注释</li>\n</ul>\n<p>你还可以添加返回类型注释。返回类型注释出现在参数列表之后：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFavoriteNumber</span>(<span class=\"params\"></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">26</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与变量类型注释非常相似，通常不需要返回类型注释，因为 TypeScript 会根据其<code>return</code>语句推断函数的返回类型。上面例子中的类型注释不会改变任何东西。某些代码库会出于文档目的明确指定返回类型，以防止意外更改或仅出于个人偏好。</p>\n<ul>\n<li>匿名函数</li>\n</ul>\n<p>匿名函数与函数声明有点不同。当一个函数出现在 TypeScript 可以确定它将如何被调用的地方时，该函数的参数会自动指定类型。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里没有类型注释，但是TypeScript可以发现错误</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Eve&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数上下文类型</span></span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"title function_\">toUppercase</span>());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上下文类型也适用于箭头函数</span></span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"title function_\">toUppercase</span>());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qMkb8YQzxUw2Xnc.png\" alt=\"image-20211114073444596\" style=\"zoom:50%;\" />\n\n<p>即使参数<code>s</code>没有类型注释，TypeScript 也会使用<code>forEach</code>函数的类型，以及数组的推断类型来确定<code>s</code>的类型。</p>\n<p>这个过程称为<em>上下文类型，</em>因为函数发生在其中的<em>上下文</em>通知它应该具有什么类型。</p>\n<p>与推理规则类似，你不需要明确了解这是如何发生的，但了解它的机制<em>确实</em>可以帮助你注意何时不需要类型注释。稍后，我们将看到更多关于<em>值出现的上下文</em>如何影响其类型的示例。</p>\n<h2 id=\"3-6-对象类型\"><a href=\"#3-6-对象类型\" class=\"headerlink\" title=\"3.6 对象类型\"></a>3.6 对象类型</h2><p>除了<code>string</code>，<code>number</code>，<code>boolean</code>类型（又称基元类型）外，你将遇到的最常见的类型是<em>对象类型</em>。这指的是任何带有属性的 JavaScript 值，几乎是所有属性！要定义对象类型，我们只需列出其属性及其类型。</p>\n<p>例如，这是一个接受点状对象的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数的类型注释是对象类型</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: &#123; x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标的x值为： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标的y值为： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">7</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们使用具有两个属性的类型注释参数 -<code>x</code>和<code>y</code>- 这两个属性都是 <code>number</code>类型。你可以以使用<code>,</code>或<code>;</code>来分隔属性，最后一个分隔符是可选的。</p>\n<p>每个属性的类型部分也是可选的。如果你不指定类型，则将假定为<code>any</code>。</p>\n<ul>\n<li>可选属性</li>\n</ul>\n<p>对象类型还可以指定其部分或全部属性是<em>可选的</em>。为此，请在属性名称后添加一个<code>?</code>：</p>\n<p><strong>02-everyday-types&#x2F;src&#x2F;05-object.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printName</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; first: <span class=\"built_in\">string</span>; last?: <span class=\"built_in\">string</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 两种传递参数都可以</span></span><br><span class=\"line\"><span class=\"title function_\">printName</span>(&#123; <span class=\"attr\">first</span>: <span class=\"string\">&quot;Felix&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">printName</span>(&#123; <span class=\"attr\">first</span>: <span class=\"string\">&quot;Felix&quot;</span>, <span class=\"attr\">last</span>: <span class=\"string\">&quot;Lu&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在 JavaScript 中，如果访问一个不存在的属性，将获得值<code>undefined</code>而不是运行时错误。因此，当你<em>读取</em>可选属性时，必须使用它之前用<code>undefined</code>进行检查。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printName</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; first: <span class=\"built_in\">string</span>; last?: <span class=\"built_in\">string</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 错误 - &#x27;obj.last&#x27; 可能不存在!</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.<span class=\"property\">last</span> !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这样可以</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 使用现代JavaScript语法的安全替代方案：</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">last</span>?.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7-联合类型\"><a href=\"#3-7-联合类型\" class=\"headerlink\" title=\"3.7 联合类型\"></a>3.7 联合类型</h2><p>TypeScript 的类型系统允许你使用多种运算符，从现有类型中构建新类型。现在我们知道如何编写几种类型，是时候开始以有趣的方式<em>组合</em>它们了。</p>\n<ul>\n<li>定义联合类型</li>\n</ul>\n<p>第一种组合类型的方法是<em>联合</em>类型。联合类型是由两个或多个其他类型组成的类型，表示可能是这些类型中的<em>任何一种</em>的值。我们将这些类型中的每一种称为<em>联合类型的成员</em>。</p>\n<p>让我们编写一个可以对字符串或数字进行操作的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Your ID is: &quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(<span class=\"number\">101</span>);</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(<span class=\"string\">&quot;202&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"title function_\">printId</span>(&#123; <span class=\"attr\">myID</span>: <span class=\"number\">22342</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qkOvn9DrVdCRSBc.png\" alt=\"image-20211114081646215\" style=\"zoom:50%;\" />\n\n<ul>\n<li>使用联合类型</li>\n</ul>\n<p><em>提供</em>匹配联合类型的值很容易- 只需提供匹配任何联合成员的类型。如果你<em>有</em>一个联合类型的值，你如何使用它？</p>\n<p>如果联合的<em>每个</em>成员都有效，TypeScript 将只允许你使用联合做一些事情。例如，如果你有联合类型 <code>string | number</code>，则不能只使用一种类型的操作，比如<code>string</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/TnuapbGVlOE2BYw.png\" alt=\"image-20211114085508715\" style=\"zoom:50%;\" />\n\n<p>解决方案是用代码<em>缩小</em>联合，就像在没有类型注释的 JavaScript 中一样。 当 TypeScript 可以根据代码结构为值推断出更具体的类型时，就会发生<em>缩小</em>。</p>\n<p>例如，TypeScript 知道只有一个<code>string</code>值才会有一个<code>typeof</code>值<code>&quot;string&quot;</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printId</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> id === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在此分支中，id的类型为“string”</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此处，id的类型为“number”</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(id);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一个例子是使用如下函数<code>Array.isArray</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">welcomePeople</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(x)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此处: &#x27;x&#x27; 的类型是 &#x27;string[]&#x27;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + x.<span class=\"title function_\">join</span>(<span class=\"string\">&quot; and &quot;</span>));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此处: &#x27;x&#x27; 的类型是 &#x27;string&#x27;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Welcome lone traveler &quot;</span> + x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，在<code>else</code>分支中，我们不需要做任何特别的事情——如果<code>x</code>不是 <code>string[]</code>，那么它一定是 <code>string</code>。</p>\n<p>有时你会有一个 <code>union</code>，所有成员都有一些共同点。例如，数组和字符串都有一个<code>slice</code>方法。如果联合中的每个成员都有一个共同的属性，则可以使用该属性而不会缩小范围：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回类型推断为 number[] | string</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFirstThree</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-8-类型别名\"><a href=\"#3-8-类型别名\" class=\"headerlink\" title=\"3.8 类型别名\"></a>3.8 类型别名</h2><p>我们一直在通过直接在类型注释中编写对象类型和联合类型来使用它们。这很方便，但是想要多次使用同一个类型，并用一个名称来引用它是很常见的。</p>\n<p>一个<em>类型别名</em>正是一个<em>名称</em>为任何<em>类型</em>的定义。类型别名的语法是：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Point</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与前面的示例完全相同</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标x的值是： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标y的值是： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>实际上，你可以使用类型别名为任何类型命名，而不仅仅是对象类型。例如，类型别名可以命名联合类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">ID</span> = <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，别名<em>只是</em>别名 - 你不能使用类型别名来创建相同类型的不同“版本”。当你使用别名时，就像你编写了别名类型一样。换句话说，这段代码可能<em>看起来不</em>合法，但根据 TypeScript 是可以的，因为这两种类型都是同一类型的别名：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UserInputSanitizedString</span> = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sanitizeInput</span>(<span class=\"params\"><span class=\"attr\">str</span>: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">UserInputSanitizedString</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建经过 sanitize 的输入</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userInput = <span class=\"title function_\">sanitizeInput</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但仍可以使用字符串重新分配值</span></span><br><span class=\"line\">userInput = <span class=\"string\">&quot;new input&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-9-接口\"><a href=\"#3-9-接口\" class=\"headerlink\" title=\"3.9 接口\"></a>3.9 接口</h2><p>一个<em>接口声明</em>是另一种方式来命名对象类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printCoord</span>(<span class=\"params\"><span class=\"attr\">pt</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标x的值是： &quot;</span> + pt.<span class=\"property\">x</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;坐标y的值是： &quot;</span> + pt.<span class=\"property\">y</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printCoord</span>(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>就像我们在上面使用类型别名时一样，该示例就像我们使用了匿名对象类型一样工作。TypeScript 只关心我们传递给的值的<em>结构</em><code>printCoord</code>——它只关心它是否具有预期的属性。只关心类型的结构和功能，是我们将 TypeScript 称为<em>结构类型</em>类型系统的原因。</p>\n<ul>\n<li>类型别名和接口之间的差异</li>\n</ul>\n<p>类型别名和接口非常相似，在很多情况下你可以自由选择它们。几乎所有的功能都在<code>interface</code>中可用<code>type</code>，关键区别在于扩展新类型的方式不同：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 扩展接口</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bear</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">bear</span>: <span class=\"title class_\">Bear</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;winnie&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bear.<span class=\"property\">name</span>;</span><br><span class=\"line\">bear.<span class=\"property\">honey</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过交叉点扩展类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Animal</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bear</span> = <span class=\"title class_\">Animal</span> &amp; &#123;</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">bear</span>: <span class=\"title class_\">Bear</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;winnie&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">honey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">bear.<span class=\"property\">name</span>;</span><br><span class=\"line\">bear.<span class=\"property\">honey</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向现有接口添加新字段</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyWindow</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyWindow</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">w</span>: <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;hello ts&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类型创建后不可更改</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyWindow</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">count</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/03-07.png\" alt=\"image-20211114094240585\" style=\"zoom:50%;\" />\n\n<blockquote>\n<ul>\n<li>在 TypeScript 4.2 版之前，类型别名<a href=\"https://www.typescriptlang.org/play#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA\"><em>可能</em>出现在错误消息中</a>，有时会代替等效的匿名类型（这可能是可取的，也可能是不可取的）。接口将始终在错误消息中命名。</li>\n<li>类型别名可能不参与<a href=\"https://www.typescriptlang.org/play#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA\">声明合并，但接口可以</a>。</li>\n<li>接口只能用于<a href=\"https://www.typescriptlang.org/play#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA\">声明对象的形状，不能重命名基元</a>。</li>\n<li>接口名称将<a href=\"https://www.typescriptlang.org/play#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA\"><em>始终</em>以其原始形式出现在</a>错误消息中，但<em>仅</em>当它们按名称使用时。</li>\n</ul>\n<p>大多数情况下，你可以根据个人喜好进行选择，TypeScript 会告诉你是否需要其他类型的声明。如果您想要启发式，请使用<code>interface</code>，然后在需要时使用<code>type</code>。</p>\n</blockquote>\n<h2 id=\"3-10-类型断言\"><a href=\"#3-10-类型断言\" class=\"headerlink\" title=\"3.10 类型断言\"></a>3.10 类型断言</h2><p>有时，你会获得有关 TypeScript 不知道的值类型的信息。</p>\n<p>例如，如果你正在使用<code>document.getElementById</code>，TypeScript 只知道这将返回<em>某种</em>类型的<code>HTMLElement</code>，但你可能知道你的页面将始终具有<code>HTMLCanvasElement</code>给定 ID 的值 。</p>\n<p>在这种情况下，你可以使用<em>类型断言</em>来指定更具体的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;main_canvas&quot;</span>) <span class=\"keyword\">as</span> <span class=\"title class_\">HTMLCanvasElement</span>;</span><br></pre></td></tr></table></figure>\n\n<p>与类型注释一样，类型断言由编译器删除，不会影响代码的运行时行为。</p>\n<p>还可以使用尖括号语法（除非代码在<code>.tsx</code>文件中），它是等效的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = &lt;<span class=\"title class_\">HTMLCanvasElement</span>&gt;<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;main_canvas&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>提醒：因为类型断言在编译时被移除，所以没有与类型断言相关联的运行时检查。<code>null</code>如果类型断言错误，则不会出现异常。</p>\n</blockquote>\n<p>TypeScript 只允许类型断言转换为<em>更具体</em>或<em>不太具体</em>的类型版本。此规则可防止“不可能”的强制，例如：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/qNWktG6hBmzVZaC.png\" alt=\"image-20211114095324614\" style=\"zoom:50%;\" />\n\n<p>将类型<code>string</code>转换为类型<code>number</code>可能是错误的，因为两种类型都没有充分重叠。如果这是有意的，请先将表达式转换为 <code>any</code> 或 <code>unknown</code>（<code>unknown</code>，我们将在后面介绍），然后是所需的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">unknown</span> <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-11-文字类型\"><a href=\"#3-11-文字类型\" class=\"headerlink\" title=\"3.11 文字类型\"></a>3.11 文字类型</h2><p>除了一般类型<code>string</code>和<code>number</code>，我们可以在类型位置引用<em>特定的</em>字符串和数字。</p>\n<p>一种方法是考虑 JavaScript 如何以不同的方式声明变量。<code>var</code>而<code>let</code>两者都允许更改变量中保存的内容，<code>const</code>不允许，这反映在 TypeScript 如何为文字创建类型上。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> testString = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">testString = <span class=\"string\">&quot;Olá Mundo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//&#x27;testString&#x27;可以表示任何可能的字符串，那</span></span><br><span class=\"line\"><span class=\"comment\">//TypeScript是如何在类型系统中描述它的</span></span><br><span class=\"line\">testString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> constantString = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//因为&#x27;constantString&#x27;只能表示1个可能的字符串，所以</span></span><br><span class=\"line\"><span class=\"comment\">//具有文本类型表示</span></span><br><span class=\"line\">constantString;</span><br></pre></td></tr></table></figure>\n\n<p>就其本身而言，文字类型并不是很有价值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"string\">&quot;hello&quot;</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\">x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\">x = <span class=\"string\">&quot;howdy&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/kcOHJ74TKSvuq1h.png\" alt=\"image-20211114102648519\" style=\"zoom:50%;\" />\n\n<p>拥有一个只能有一个值的变量并没有多大用处！</p>\n<p>但是通过<em>将</em>文字<em>组合</em>成联合，你可以表达一个更有用的概念——例如，只接受一组特定已知值的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printText</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">alignment</span>: <span class=\"string\">&quot;left&quot;</span> | <span class=\"string\">&quot;right&quot;</span> | <span class=\"string\">&quot;center&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printText</span>(<span class=\"string\">&quot;Hello, world&quot;</span>, <span class=\"string\">&quot;left&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">printText</span>(<span class=\"string\">&quot;G&#x27;day, mate&quot;</span>, <span class=\"string\">&quot;centre&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/SrcPeBsQvOUkDfw.png\" alt=\"image-20211114103049870\" style=\"zoom:50%;\" />\n\n<p>数字文字类型的工作方式相同：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">compare</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">string</span></span>): -<span class=\"number\">1</span> | <span class=\"number\">0</span> | <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === b ? <span class=\"number\">0</span> : a &gt; b ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，你可以将这些与非文字类型结合使用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Options</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">width</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">configure</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Options</span> | <span class=\"string\">&quot;auto&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(&#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(<span class=\"string\">&quot;auto&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">configure</span>(<span class=\"string\">&quot;automatic&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/YZQwUvRlCtkzcTL.png\" alt=\"image-20211114103530209\" style=\"zoom:50%;\" />\n\n<p>还有一种文字类型：布尔文字。只有两种布尔文字类型，它们是类型<code>true</code>和<code>false</code>。类型<code>boolean</code>本身实际上只是联合类型 <code>union</code> 的别名<code>true | false</code>。</p>\n<ul>\n<li>文字推理</li>\n</ul>\n<p>当你使用对象初始化变量时，TypeScript 假定该对象的属性稍后可能会更改值。例如，如果你写了这样的代码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">counter</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (someCondition) &#123;</span><br><span class=\"line\">  obj.<span class=\"property\">counter</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript 不假定先前具有的字段值<code>0</code>，后又分配<code>1</code>是错误的。另一种说法是<code>obj.counter</code>必须有 <code>number</code>属性， 而非是 <code>0</code>，因为类型用于确定<em>读取</em>和<em>写入</em>行为。</p>\n<p>这同样适用于字符串：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleRequest</span>(<span class=\"params\"><span class=\"attr\">url</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> | <span class=\"string\">&quot;POST&quot;</span> | <span class=\"string\">&quot;GUESS&quot;</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/hmLQKWoi4kVtBFD.png\" alt=\"image-20211114105814002\" style=\"zoom:50%;\" />\n\n<p>在上面的例子<code>req.method</code>中推断是<code>string</code>，不是<code>&quot;GET&quot;</code>。因为代码可以在创建<code>req</code>和调用之间进行评估，TypeScript 认为这段代码有错误。</p>\n<p>有两种方法可以解决这个问题。</p>\n<p><strong>1. 可以通过在任一位置添加类型断言来更改推理：</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案 1:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> <span class=\"keyword\">as</span> <span class=\"string\">&quot;GET&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 方案 2</span></span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span> <span class=\"keyword\">as</span> <span class=\"string\">&quot;GET&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>方案 1 表示“我打算<code>req.method</code>始终拥有<em>文字类型</em> <code>&quot;GET&quot;</code>”，从而防止之后可能分配<code>&quot;GUESS&quot;</code>给该字段。</p>\n<p>方案 2 的意思是“我知道其他原因<code>req.method</code>具有<code>&quot;GET&quot;</code>值”。</p>\n<p><strong>2. 可以使用<code>as const</code>将整个对象转换为类型文字：</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> req = &#123; <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://example.com&quot;</span>, <span class=\"attr\">method</span>: <span class=\"string\">&quot;GET&quot;</span> &#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"><span class=\"title function_\">handleRequest</span>(req.<span class=\"property\">url</span>, req.<span class=\"property\">method</span>);</span><br></pre></td></tr></table></figure>\n\n<p>该<code>as const</code>后缀就像<code>const</code>定义，确保所有属性分配的文本类型，而不是一个更一般的<code>string</code>或<code>number</code>。</p>\n<h2 id=\"3-12-null-和-undefined\"><a href=\"#3-12-null-和-undefined\" class=\"headerlink\" title=\"3.12 null 和 undefined\"></a>3.12 <code>null</code> 和 <code>undefined</code></h2><p>JavaScript 有两个原始值用于表示不存在或未初始化的值：<code>null</code>和<code>undefined</code>.</p>\n<p>TypeScript 有两个对应的同名<em>类型</em>。这些类型的行为取决于您是否设置<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a>选择。</p>\n<ul>\n<li><code>strictNullChecks</code> 关闭</li>\n</ul>\n<p>使用<em>false</em>，仍然可以正常访问的值，并且可以将值分配给任何类型的属性。这类似于没有空检查的语言（例如 C#、Java）的行为方式。缺乏对这些值的检查往往是错误的主要来源；如果在他们的代码库中这样做可行，我们总是建议大家打开。</p>\n<ul>\n<li><code>strictNullChecks</code> 打开</li>\n</ul>\n<p>使用<em>true</em>，你需要在对该值使用方法或属性之前测试这些值。就像在使用可选属性之前检查一样，我们可以使用<em>缩小</em>来检查可能的值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做一些事</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + x.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>非空断言运算符（<code>!</code>后缀）</li>\n</ul>\n<p>TypeScript 也有一种特殊的语法<code>null</code>，<code>undefined</code>，可以在不进行任何显式检查的情况下，从类型中移除和移除类型。<code>!</code>在任何表达式之后写入实际上是一种类型断言，即该值不是<code>null</code>or <code>undefined</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">liveDangerously</span>(<span class=\"params\"><span class=\"attr\">x</span>?: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正确</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x!.<span class=\"title function_\">toFixed</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就像其他类型断言一样，这不会更改代码的运行时行为，因此仅<code>!</code>当你知道该值<em>不能</em>是<code>null</code>或 <code>undefined</code>时使用才是重要的。</p>\n<h2 id=\"3-13-枚举\"><a href=\"#3-13-枚举\" class=\"headerlink\" title=\"3.13 枚举\"></a>3.13 枚举</h2><p>枚举是 TypeScript 添加到 JavaScript 的一项功能，它允许描述一个值，该值可能是一组可能的命名常量之一。与大多数 TypeScript 功能不同，这<em>不是</em>JavaScript 的类型级别的添加，而是添加到语言和运行时的内容。因此，你确定你确实需要枚举在做些事情，否则请不要使用。可以在<a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">Enum 参考页 中</a>阅读有关枚举的更多信息。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ts源码</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译后的js代码</span></span><br><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Direction</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"title class_\">Direction</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Up&quot;</span>] = <span class=\"number\">1</span>)] = <span class=\"string\">&quot;Up&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Down&quot;</span>] = <span class=\"number\">2</span>)] = <span class=\"string\">&quot;Down&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Left&quot;</span>] = <span class=\"number\">3</span>)] = <span class=\"string\">&quot;Left&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>[(<span class=\"title class_\">Direction</span>[<span class=\"string\">&quot;Right&quot;</span>] = <span class=\"number\">4</span>)] = <span class=\"string\">&quot;Right&quot;</span>;</span><br><span class=\"line\">&#125;)(<span class=\"title class_\">Direction</span> || (<span class=\"title class_\">Direction</span> = &#123;&#125;));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/dvthyFIPKAuBR1s.png\" alt=\"image-20211114112554381\" style=\"zoom:33%;\" />\n\n<h2 id=\"3-14-不太常见的原语\"><a href=\"#3-14-不太常见的原语\" class=\"headerlink\" title=\"3.14 不太常见的原语\"></a>3.14 不太常见的原语</h2><p>值得一提的是 JavaScript 中一些较新的原语，它们在 TypeScript 类型系统中也实现了。我们先简单的看两个例子：</p>\n<ul>\n<li><h4 id=\"bigint\"><a href=\"#bigint\" class=\"headerlink\" title=\"bigint\"></a><code>bigint</code></h4></li>\n</ul>\n<p>从 ES2020 开始，JavaScript 中有一个用于非常大的整数的原语<code>BigInt</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过bigint函数创建bigint</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">oneHundred</span>: <span class=\"built_in\">bigint</span> = <span class=\"title class_\">BigInt</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过文本语法创建BigInt</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">anotherHundred</span>: <span class=\"built_in\">bigint</span> = <span class=\"number\">100n</span>;</span><br></pre></td></tr></table></figure>\n\n<p>你可以在<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint\">TypeScript 3.2 发行说明 中</a>了解有关 BigInt 的更多信息。</p>\n<ul>\n<li><h4 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a><code>symbol</code></h4></li>\n</ul>\n<p>JavaScript 中有一个原语<code>Symbol()</code>，用于通过函数创建全局唯一引用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> firstName = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> secondName = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (firstName === secondName) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里的代码不可能执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/ORATaxUgEjrPL9V.png\" alt=\"image-20211114113536948\" style=\"zoom:40%;\" />\n\n<p>此条件将始终返回 <code>false</code>，因为类型 <code>typeof firstName</code>和<code>typeof secondName</code>没有重叠。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "1-4、基础篇：类型缩小",
        "toc": true,
        "swiper_index": 4,
        "swiper_cover": "/img/recommend/recommend_04.jpg",
        "swiper_desc": "1-4、基础篇：类型缩小",
        "abbrlink": 23966,
        "date": "2024-01-28T11:40:14.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 四、类型缩小\n\n假设我们有一个名为`padLeft`的函数：\n\n```tsx\nfunction padLeft(padding: number | string, input: string): string {\n  throw new Error(\"尚未实现!\");\n}\n```\n\n我们来扩充一下功能：如果`padding`是 `number`，它会将其视为我们想要添加到`input`的空格数；如果`padding`是 `string`，它只在`input`上做`padding` 。让我们尝试实现：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  return new Array(padding + 1).join(\" \") + input;\n}\n```\n\n![image-20211114161343249](/img/TypeScript/04-01.png)\n\n呃-哦，在`padding + 1`处我们遇到错误。TypeScript 警告我们，运算符 `+` 不能应用于类型 `string | number`和 `number`，这是对的。换句话说，我们没有明确检查 `padding`是否为 `number`，也没有处理它是 `string` 的情况，所以我们这样做：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return new Array(padding + 1).join(\" \") + input;\n  }\n  return padding + input;\n}\n```\n\n如果这大部分看起来像无趣的JavaScript代码，这也算是重点吧。除了我们设置的注解之外，这段TypeScript代码看起来就像JavaScript。我们的想法是，TypeScript的类型系统旨在使编写典型的JavaScript代码变得尽可能容易，而不需要弯腰去获得类型安全。\n\n虽然看起来不多，但实际上有很多东西在这里。就像TypeScript使用静态类型分析运行时的值一样，它在JavaScript的运行时控制流构造上叠加了类型分析，如if/else、条件三元组、循环、真实性检查等，这些都会影响到这些类型。\n\n在我们的if检查中，TypeScript看到 `typeof padding ===\"number\"`，并将其理解为一种特殊形式的代码，称为类型保护。TypeScript遵循我们的程序可能采取的执行路径，以分析一个值在特定位置的最具体的可能类型。它查看这些特殊的检查（称为类型防护）和赋值，将类型细化为比声明的更具体的类型的过程被称为缩小。在许多编辑器中，我们可以观察这些类型的变化，我们甚至会在我们的例子中这样做。\n\nTypeScript 可以理解几种不同的缩小结构。\n\n## 4.1 `typeof`类型守卫\n\n正如我们所见，JavaScript 支持一个`typeof`运算符，它可以提供有关我们在运行时拥有的值类型的非常基本的信息。TypeScript 期望它返回一组特定的字符串：\n\n- `\"string\"`\n- `\"number\"`\n- `\"bigint\"`\n- `\"boolean\"`\n- `\"symbol\"`\n- `\"undefined\"`\n- `\"object\"`\n- `\"function\"`\n\n就像我们在 `padLeft` 中看到的那样，这个运算符经常出现在许多 JavaScript 库中，TypeScript 可以理解为，它缩小在不同分支中的类型。\n\n在 TypeScript 中，检查`typeof`的返回值是一种类型保护。因为 TypeScript 对`typeof`操作进行编码，从而返回不同的值，所以它知道对 JavaScript 做了什么。例如，请注意在上面的列表中，`typeof`不返回 string `null`。查看以下示例：\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  } else {\n    // 做点事\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png\" alt=\"image-20211114164143361\" style=\"zoom:50%;\" />\n\n在`printAll`函数中，我们尝试检查`strs`是否为对象，来代替检查它是否为数组类型（现在可能是强调数组是 JavaScript 中的对象类型的好时机）。但事实证明，在 JavaScript 中，`typeof null`实际上也是`\"object\"`! 这是历史上的不幸事故之一。\n\n有足够经验的用户可能不会感到惊讶，但并不是每个人都在 JavaScript 中遇到过这种情况；幸运的是，typescript 让我们知道，`strs`只缩小到`string[] | null`，而不仅仅是`string[]`。\n\n这可能是我们所谓的“真实性”检查的一个很好的过渡。\n\n## 4.2 真值缩小\n\n真值检查是我们在 JavaScript 中经常做的一件事。在 JavaScript 中，我们可以在条件、`&&`、`||`、`if`语句、布尔否定 ( `!`) 等中使用任何表达式。例如，`if`语句不希望它们的条件总是具有类型`boolean`。\n\n```tsx\nfunction getUsersOnlineMessage(numUsersOnline: number) {\n  if (numUsersOnline) {\n    return `现在共有 ${numUsersOnline} 人在线!`;\n  }\n  return \"现在没有人在线. :(\";\n}\n```\n\n在 JavaScript 中，像这样的`if`条件语句，首先将它们的条件“强制”转化为`boolean` 以使其有意义，然后根据结果是`true`还是`false`来选择它们的分支。像这面这些值：\n\n- `0`\n- `NaN`\n- `\"\"` （空字符串）\n- `0n`（`bigint`零的版本）\n- `null`\n- `undefined`\n\n以上所有值强制都转换为`false`，其他值被强制转化为`true`。你始终可以在`Boolean`函数中运行值获得`boolean`，或使用较短的双布尔否定将值强制转换为`boolean`。（后者的优点是 TypeScript 推断出一个狭窄的文字布尔类型`true`，而将第一个推断为 `boolean`类型。）\n\n```tsx\n// 这两个结果都返回 true\nBoolean(\"hello\"); // type: boolean, value: true\n!!\"world\"; // type: true, value: true\n```\n\n利用这种行为是相当流行的，尤其是在防范诸如`null`或`undefined`之类的值时。例如，让我们尝试将它用于我们的`printAll`函数。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (strs && typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  }\n}\n```\n\n你会注意到我们已经通过检查`strs`是否为真，消除了上述错误。这至少可以防止我们在运行代码时出现可怕的错误，例如：\n\n```shell\nTypeError: null is not iterable\n```\n\n但请记住，对原语的真值检查通常容易出错。例如，考虑改写`printAll`:\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  // !!!!!!!!!!!!!!!!\n  //  别这样!\n  //  原因在下边\n  // !!!!!!!!!!!!!!!!\n  if (strs) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\n我们将整个函数体包装在一个真实的检查中，但这有一个小的缺点：我们可能不再正确处理空字符串的情况。\n\nTypeScript 在这里根本不会报错，但是如果你不太熟悉 JavaScript，这是值得注意的行为。TypeScript 通常可以帮助你及早发现错误，但是如果你选择对某个值不做*任何*处理，那么它可以做的就只有这么多，而不会考虑过多的逻辑方面的问题。如果需要，你可以确保使用 linter（程序规范性） 处理此类情况。\n\n关于通过真实性缩小范围的最后一点，是通过布尔否定`!`把逻辑从否定分支中过滤掉。\n\n```tsx\nfunction multiplyAll(\n  values: number[] | undefined,\n  factor: number,\n): number[] | undefined {\n  if (!values) {\n    return values;\n  } else {\n    return values.map((x) => x * factor);\n  }\n}\n```\n\n## 4.3 等值缩小\n\ntypescript 也使用分支语句做`===`，`!==`，`==`，和`!=`等值检查，来实现类型缩小。例如：\n\n```tsx\nfunction example(x: string | number, y: string | boolean) {\n  if (x === y) {\n    // 现在可以在x,y上调用字符串类型的方法了\n    x.toUpperCase();\n    y.toLowerCase();\n  } else {\n    console.log(x);\n    console.log(y);\n  }\n}\n```\n\n当我们在上面的示例中检查`x`和`y`是否相等时，TypeScript 知道它们的类型也必须相等。由于`string`是`x`和`y`都可以采用的唯一常见类型，因此TypeScript 知道`x`、`y`如果都是`string`，则程序走第一个分支中 。\n\n检查特定的字面量值（而不是变量）也有效。在我们关于真值缩小的部分中，我们编写了一个`printAll`容易出错的函数，因为它没有正确处理空字符串。相反，我们可以做一个特定的检查来阻止`null`，并且 TypeScript 仍然正确地从`strs`里移除`null`。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (strs !== null) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\nJavaScript 更宽松的相等性检查`==`和`!=`，也能被正确缩小。如果你不熟悉，如何检查某个变量是否`== null`，因为有时不仅要检查它是否是特定的值`null`，还要检查它是否可能是`undefined`。这同样适用于`== undefined`：它检查一个值是否为`null`或`undefined`。现在你只需要这个 `==`和`!=`就可以搞定了。\n\n```tsx\ninterface Container {\n  value: number | null | undefined;\n}\n\nfunction multiplyValue(container: Container, factor: number) {\n  // 从类型中排除了undefined 和 null\n  if (container.value != null) {\n    console.log(container.value);\n    // 现在我们可以安全地乘以“container.value”了\n    container.value *= factor;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png\" alt=\"image-20211115154532180\" style=\"zoom:50%;\" />\n\n前三个打印是通过的，第四个有问题了。\n\n## 4.4 `in`操作符缩小\n\nJavaScript 有一个运算符，用于确定对象是否具有某个名称的属性：`in`运算符。TypeScript 考虑到了这一点，以此来缩小潜在类型的范围。\n\n例如，使用代码：`\"value\" in x`。这里的 `\"value\"`是字符串文字，`x`是联合类型。值为“true”的分支缩小，需要`x`具有可选或必需属性的类型的值；值为 “false” 的分支缩小，需要具有可选或缺失属性的类型的值。\n\n```tsx\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n\nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    return animal.swim();\n  }\n\n  return animal.fly();\n}\n```\n\n另外，可选属性还将存在于缩小的两侧，例如，人类可以游泳和飞行（使用正确的设备），因此应该出现在`in`检查的两侧：\n\n```tsx\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ntype Human = { swim?: () => void; fly?: () => void };\n\nfunction move(animal: Fish | Bird | Human) {\n  if (\"swim\" in animal) {\n    // animal: Fish | Human\n    animal;\n  } else {\n    // animal: Bird | Human\n    animal;\n  }\n}\n```\n\n## 4.5 `instanceof`操作符缩小\n\nJavaScript 有一个运算符来 `instanceof` 检查一个值是否是另一个值的“实例”。更具体地，在JavaScript中`x instanceof Foo` 检查`x`的*原型链*是否含有`Foo.prototype`。虽然我们不会在这里深入探讨，当我们进入 `类(class)`学习时，你会看到更多这样的内容，它们大多数可以使用`new`关键字实例化。 正如你可能已经猜到的那样，`instanceof`也是一个类型保护，TypeScript 在由`instanceof`保护的分支中实现缩小。\n\n```tsx\nfunction logValue(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toUTCString());\n  } else {\n    console.log(x.toUpperCase());\n  }\n}\n\nlogValue(new Date()); // Mon, 15 Nov 2021 22:34:37 GMT\nlogValue(\"hello ts\"); // HELLO TS\n```\n\n## 4.6 分配缩小\n\n正如我们之前提到的，当我们为任何变量赋值时，TypeScript 会查看赋值的右侧并适当缩小左侧。\n\n```tsx\n// let x: string | number\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\n\nx = 1;\n// let x: number\nconsole.log(x);\n\nx = \"goodbye!\";\n// let x: string\nconsole.log(x);\n```\n\n请注意，这些分配中的每一个都是有效的。即使在我们第一次赋值后观察到的类型`x`更改为 `number`，我们仍然可以将`string`赋值给`x`。这是因为*声明类型*的`x`-该类型`x`开始是`string | number`。\n\n如果我们分配了一个`boolean`给 `x`，我们就会看到一个错误，因为它不是声明类型的一部分。\n\n```tsx\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\n\n// let x: string | number\nx = 1;\n\n// let x: number\nconsole.log(x);\n\n// 出错了！\nx = true;\n\n// let x: string | number\nconsole.log(x);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png\" alt=\"image-20211116065026159\" style=\"zoom: 50%;\" />\n\n## 4.7 控制流分析\n\n到目前为止，我们已经通过一些基本示例来说明 TypeScript 如何在特定分支中缩小范围。但是除了从每个变量中走出来，并在`if`、`while`、条件等中寻找类型保护之外，还有更多的事情要做。例如：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return new Array(padding + 1).join(\" \") + input;\n  }\n  return padding + input;\n}\n```\n\n`padLeft`从其第一个 `if`块中返回。TypeScript 能够分析这段代码，并看到在 padding 是数字的情况下，主体的其余部分（`return padding + input;`）是不可达的。因此，它能够将数字从 `padding` 的类型中移除（从字符串|数字缩小到字符串），用于该函数的其余部分。\n\n这种基于可达性的代码分析被称为控制流分析，TypeScript使用这种流分析来缩小类型，因为它遇到了类型守卫和赋值。当一个变量被分析时，控制流可以一次又一次地分裂和重新合并，该变量可以被观察到在每个点上有不同的类型。\n\n```tsx\nfunction example() {\n  let x: string | number | boolean;\n\n  x = Math.random() < 0.5;\n\n  // let x: boolean\n  console.log(x);\n\n  if (Math.random() < 0.5) {\n    x = \"hello\";\n    // let x: string\n    console.log(x);\n  } else {\n    x = 100;\n    // let x: number\n    console.log(x);\n  }\n\n  // let x: string | number\n  return x;\n}\n\nlet x = example();\nx = \"hello\";\nx = 100;\nx = true; // error\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png\" alt=\"image-20211117203742503\" style=\"zoom:50%;\" />\n\n## 4.8 使用类型谓词\n\n到目前为止，我们已经用现有的JavaScript结构来处理窄化问题，然而有时你想更直接地控制整个代码中的类型变化。\n\n为了定义一个用户定义的类型保护，我们只需要定义一个函数，其返回类型是一个类型谓词。\n\n```tsx\ntype Fish = {\n  name: string;\n  swim: () => void;\n};\n\ntype Bird = {\n  name: string;\n  fly: () => void;\n};\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\n在这个例子中，`pet is Fish` 是我们的类型谓词。谓词的形式是 `parameterName is Type`，其中 `parameterName` 必须是当前函数签名中的参数名称。\n\n任何时候 `isFish` 被调用时，如果原始类型是兼容的，TypeScript将把该变量缩小到该特定类型。\n\n```tsx\nfunction getSmallPet(): Fish | Bird {\n  let fish: Fish = {\n    name: \"gold fish\",\n    swim: () => {},\n  };\n\n  let bird: Bird = {\n    name: \"sparrow\",\n    fly: () => {},\n  };\n\n  return true ? bird : fish;\n}\n\n// 这里 pet 的 swim 和 fly 都可以访问了\nlet pet = getSmallPet();\nif (isFish(pet)) {\n  pet.swim();\n} else {\n  pet.fly();\n}\n```\n\n注意，TypeScript不仅知道 `pet` 在 `if` 分支中是一条鱼；它还知道在 `else` 分支中，你没有一条 `Fish`，所以你一定有一只 `Bird`。\n\n你可以使用类型守卫 `isFish` 来过滤 `Fish | Bird` 的数组，获得 `Fish` 的数组。\n\n```tsx\nconst zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];\nconst underWater1: Fish[] = zoo.filter(isFish);\n// 或者，等同于\nconst underWater2: Fish[] = zoo.filter(isFish) as Fish[];\n\n// 对于更复杂的例子，该谓词可能需要重复使用\nconst underWatch3: Fish[] = zoo.filter((pet): pet is Fish => {\n  if (pet.name === \"frog\") {\n    return false;\n  }\n  return isFish(pet);\n});\n```\n\n## 4.9 受歧视的 `unions`\n\n到目前为止，我们所看的大多数例子都是围绕着用简单的类型（如`string`、`boolean`和`number`）来缩小单个变量。虽然这很常见，但在JavaScript中，大多数时候我们要处理的是稍微复杂的结构。\n\n为了激发灵感，让我们想象一下，我们正试图对圆形和方形等形状进行编码。圆记录了它们的半径，方记录了它们的边长。我们将使用一个叫做 `kind` 的字段来告诉我们正在处理的是哪种形状。这里是定义 `Shape` 的第一个尝试。\n\n```tsx\ninterface Shape {\n  kind: \"circle\" | \"square\";\n  radius?: number;\n  sideLength?: number;\n}\n```\n\n注意，我们使用的是字符串字面类型的联合。`\"circle \"`和` \"square \"`分别告诉我们应该把这个形状当作一个圆形还是方形。通过使用 `\"circle\" | \"square \"` 而不是 `string`，我们可以避免拼写错误的问题。\n\n```tsx\nfunction handleShape(shape: Shape) {\n  // oops!\n  if (shape.kind === \"rect\") {\n    // ...\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png\" alt=\"image-20211118090404099\" style=\"zoom:50%;\" />\n\n我们可以编写一个 `getArea` 函数，根据它处理的是圆形还是方形来应用正确的逻辑。我们首先尝试处理圆形。\n\n```tsx\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png\" alt=\"image-20211118091637002\" style=\"zoom:50%;\" />\n\n在 `strictNullChecks` 下，这给了我们一个错误——这是很恰当的，因为 `radius` 可能没有被定义。但是如果我们对 `kind` 属性进行适当的检查呢？\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png\" alt=\"image-20211118093134890\" style=\"zoom:50%;\" />\n\n嗯，TypeScript 仍然不知道该怎么做。我们遇到了一个问题，即我们对我们的值比类型检查器知道的更多。我们可以尝试使用一个非空的断言 (`radius` 后面的那个叹号`!` ) 来说明 `radius` 肯定存在。\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius! ** 2;\n  }\n}\n```\n\n但这感觉并不理想。我们不得不用那些非空的断言对类型检查器声明一个叹号（`！`），以说服它相信`shape.radius` 是被定义的，但是如果我们开始移动代码，这些断言就容易出错。此外，在 `strictNullChecks` 之外，我们也可以意外地访问这些字段（因为在读取这些字段时，可选属性被认为总是存在的）。我们绝对可以做得更好。\n\n`Shape` 的这种编码的问题是，类型检查器没有办法根据种类属性知道 `radius` 或 `sideLength` 是否存在。我们需要把我们知道的东西传达给类型检查器。考虑到这一点，让我们再来定义一下Shape。\n\n```tsx\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\ninterface Square {\n  kind: \"square\";\n  sideLength: number;\n}\n\ntype Shape = Circle | Square;\n```\n\n在这里，我们正确地将 `Shape` 分成了两种类型，为 `kind` 属性设置了不同的值，但是 `radius` 和 `sideLength` 在它们各自的类型中被声明为必需的属性。\n\n让我们看看当我们试图访问 `Shape` 的半径时会发生什么。\n\n```tsx\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png\" alt=\"image-20211118180452972\" style=\"zoom:50%;\" />\n\n就像我们对 `Shape` 的第一个定义一样，这仍然是一个错误。当半径是可选的时候，我们得到了一个错误（仅在`strictNullChecks` 中），因为 TypeScript 无法判断该属性是否存在。现在 `Shape` 是一个联合体，TypeScript 告诉我们 `shape` 可能是一个 `Square` ，而Square并没有定义半径 `radius`。 这两种解释都是正确的，但只有我们对 `Shape` 的新编码仍然在 `strictNullChecks` 之外导致错误。\n\n但是，如果我们再次尝试检查kind属性呢？\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    // shape: Circle\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\n这就摆脱了错误! 当 `union` 中的每个类型都包含一个与字面类型相同的属性时，TypeScript 认为这是一个有区别的 `union` ，并且可以缩小 `union` 的成员。\n\n在这种情况下，`kind` 就是那个共同属性（这就是 `Shape` 的判别属性）。检查 `kind` 属性是否为 `\"circle\"`，就可以剔除 `Shape` 中所有没有` \"circle\"` 类型属性的类型。这就把 `Shape` 的范围缩小到了`Circle`这个类型。\n\n同样的检查方法也适用于 `switch` 语句。现在我们可以试着编写完整的 `getArea`，而不需要任何讨厌的叹号 `！`非空的断言。\n\n```tsx\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    // shape: Circle\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n\n    // shape: Square\n    case \"square\":\n      return shape.sideLength ** 2;\n  }\n}\n```\n\n这里最重要的是 `Shape` 的编码。向 TypeScript 传达正确的信息是至关重要的，这个信息就是 `Circle`和`Square`实际上是具有特定种类字段的两个独立类型。这样做让我们写出类型安全的TypeScript代码，看起来与我们本来要写的JavaScript没有区别。从那里，类型系统能够做 \"正确 \"的事情，并找出我们 `switch`语句的每个分支中的类型。\n\n> 作为一个旁观者，试着玩一玩上面的例子，去掉一些返回关键词。你会发现，类型检查可以帮助避免在switch语句中不小心落入不同子句的bug。\n\n辨证的联合体不仅仅适用于谈论圆形和方形。它们适合于在JavaScript中表示任何类型的消息传递方案，比如在网络上发送消息（`client/server`通信），或者在状态管理框架中编码突变。\n\n## 4.10 `never`类型与穷尽性检查\n\n在缩小范围时，你可以将一个联合体的选项减少到你已经删除了所有的可能性并且什么都不剩的程度。在这些情况下，TypeScript将使用一个`never`类型来代表一个不应该存在的状态。\n\n`never` 类型可以分配给每个类型；但是，没有任何类型可以分配给never（除了never本身）。这意味着你可以使用缩小并依靠`never`的出现在 `switch` 语句中做详尽的检查。\n\n例如，在我们的`getArea`函数中添加一个默认值，试图将形状分配给`never`，当每个可能的情况都没有被处理时，就会引发。\n\n```tsx\ntype Shape = Circle | Square;\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n在 `Shape` 联盟中添加一个新成员，将导致TypeScript错误。\n\n```tsx\ninterface Triangle {\n  kind: \"triangle\";\n  sideLength: number;\n}\n\ntype Shape = Circle | Square | Triangle;\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png\" alt=\"image-20211118183410201\" style=\"zoom:50%;\" />\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-4、基础篇：类型缩小.md",
        "raw": "---\ntitle: 1-4、基础篇：类型缩小\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nswiper_index: 4\nswiper_cover: /img/recommend/recommend_04.jpg\nswiper_desc: 1-4、基础篇：类型缩小\nabbrlink: 23966\ndate: 2024-01-28 19:40:14\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 四、类型缩小\n\n假设我们有一个名为`padLeft`的函数：\n\n```tsx\nfunction padLeft(padding: number | string, input: string): string {\n  throw new Error(\"尚未实现!\");\n}\n```\n\n我们来扩充一下功能：如果`padding`是 `number`，它会将其视为我们想要添加到`input`的空格数；如果`padding`是 `string`，它只在`input`上做`padding` 。让我们尝试实现：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  return new Array(padding + 1).join(\" \") + input;\n}\n```\n\n![image-20211114161343249](/img/TypeScript/04-01.png)\n\n呃-哦，在`padding + 1`处我们遇到错误。TypeScript 警告我们，运算符 `+` 不能应用于类型 `string | number`和 `number`，这是对的。换句话说，我们没有明确检查 `padding`是否为 `number`，也没有处理它是 `string` 的情况，所以我们这样做：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return new Array(padding + 1).join(\" \") + input;\n  }\n  return padding + input;\n}\n```\n\n如果这大部分看起来像无趣的JavaScript代码，这也算是重点吧。除了我们设置的注解之外，这段TypeScript代码看起来就像JavaScript。我们的想法是，TypeScript的类型系统旨在使编写典型的JavaScript代码变得尽可能容易，而不需要弯腰去获得类型安全。\n\n虽然看起来不多，但实际上有很多东西在这里。就像TypeScript使用静态类型分析运行时的值一样，它在JavaScript的运行时控制流构造上叠加了类型分析，如if/else、条件三元组、循环、真实性检查等，这些都会影响到这些类型。\n\n在我们的if检查中，TypeScript看到 `typeof padding ===\"number\"`，并将其理解为一种特殊形式的代码，称为类型保护。TypeScript遵循我们的程序可能采取的执行路径，以分析一个值在特定位置的最具体的可能类型。它查看这些特殊的检查（称为类型防护）和赋值，将类型细化为比声明的更具体的类型的过程被称为缩小。在许多编辑器中，我们可以观察这些类型的变化，我们甚至会在我们的例子中这样做。\n\nTypeScript 可以理解几种不同的缩小结构。\n\n## 4.1 `typeof`类型守卫\n\n正如我们所见，JavaScript 支持一个`typeof`运算符，它可以提供有关我们在运行时拥有的值类型的非常基本的信息。TypeScript 期望它返回一组特定的字符串：\n\n- `\"string\"`\n- `\"number\"`\n- `\"bigint\"`\n- `\"boolean\"`\n- `\"symbol\"`\n- `\"undefined\"`\n- `\"object\"`\n- `\"function\"`\n\n就像我们在 `padLeft` 中看到的那样，这个运算符经常出现在许多 JavaScript 库中，TypeScript 可以理解为，它缩小在不同分支中的类型。\n\n在 TypeScript 中，检查`typeof`的返回值是一种类型保护。因为 TypeScript 对`typeof`操作进行编码，从而返回不同的值，所以它知道对 JavaScript 做了什么。例如，请注意在上面的列表中，`typeof`不返回 string `null`。查看以下示例：\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  } else {\n    // 做点事\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png\" alt=\"image-20211114164143361\" style=\"zoom:50%;\" />\n\n在`printAll`函数中，我们尝试检查`strs`是否为对象，来代替检查它是否为数组类型（现在可能是强调数组是 JavaScript 中的对象类型的好时机）。但事实证明，在 JavaScript 中，`typeof null`实际上也是`\"object\"`! 这是历史上的不幸事故之一。\n\n有足够经验的用户可能不会感到惊讶，但并不是每个人都在 JavaScript 中遇到过这种情况；幸运的是，typescript 让我们知道，`strs`只缩小到`string[] | null`，而不仅仅是`string[]`。\n\n这可能是我们所谓的“真实性”检查的一个很好的过渡。\n\n## 4.2 真值缩小\n\n真值检查是我们在 JavaScript 中经常做的一件事。在 JavaScript 中，我们可以在条件、`&&`、`||`、`if`语句、布尔否定 ( `!`) 等中使用任何表达式。例如，`if`语句不希望它们的条件总是具有类型`boolean`。\n\n```tsx\nfunction getUsersOnlineMessage(numUsersOnline: number) {\n  if (numUsersOnline) {\n    return `现在共有 ${numUsersOnline} 人在线!`;\n  }\n  return \"现在没有人在线. :(\";\n}\n```\n\n在 JavaScript 中，像这样的`if`条件语句，首先将它们的条件“强制”转化为`boolean` 以使其有意义，然后根据结果是`true`还是`false`来选择它们的分支。像这面这些值：\n\n- `0`\n- `NaN`\n- `\"\"` （空字符串）\n- `0n`（`bigint`零的版本）\n- `null`\n- `undefined`\n\n以上所有值强制都转换为`false`，其他值被强制转化为`true`。你始终可以在`Boolean`函数中运行值获得`boolean`，或使用较短的双布尔否定将值强制转换为`boolean`。（后者的优点是 TypeScript 推断出一个狭窄的文字布尔类型`true`，而将第一个推断为 `boolean`类型。）\n\n```tsx\n// 这两个结果都返回 true\nBoolean(\"hello\"); // type: boolean, value: true\n!!\"world\"; // type: true, value: true\n```\n\n利用这种行为是相当流行的，尤其是在防范诸如`null`或`undefined`之类的值时。例如，让我们尝试将它用于我们的`printAll`函数。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (strs && typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  }\n}\n```\n\n你会注意到我们已经通过检查`strs`是否为真，消除了上述错误。这至少可以防止我们在运行代码时出现可怕的错误，例如：\n\n```shell\nTypeError: null is not iterable\n```\n\n但请记住，对原语的真值检查通常容易出错。例如，考虑改写`printAll`:\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  // !!!!!!!!!!!!!!!!\n  //  别这样!\n  //  原因在下边\n  // !!!!!!!!!!!!!!!!\n  if (strs) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\n我们将整个函数体包装在一个真实的检查中，但这有一个小的缺点：我们可能不再正确处理空字符串的情况。\n\nTypeScript 在这里根本不会报错，但是如果你不太熟悉 JavaScript，这是值得注意的行为。TypeScript 通常可以帮助你及早发现错误，但是如果你选择对某个值不做*任何*处理，那么它可以做的就只有这么多，而不会考虑过多的逻辑方面的问题。如果需要，你可以确保使用 linter（程序规范性） 处理此类情况。\n\n关于通过真实性缩小范围的最后一点，是通过布尔否定`!`把逻辑从否定分支中过滤掉。\n\n```tsx\nfunction multiplyAll(\n  values: number[] | undefined,\n  factor: number,\n): number[] | undefined {\n  if (!values) {\n    return values;\n  } else {\n    return values.map((x) => x * factor);\n  }\n}\n```\n\n## 4.3 等值缩小\n\ntypescript 也使用分支语句做`===`，`!==`，`==`，和`!=`等值检查，来实现类型缩小。例如：\n\n```tsx\nfunction example(x: string | number, y: string | boolean) {\n  if (x === y) {\n    // 现在可以在x,y上调用字符串类型的方法了\n    x.toUpperCase();\n    y.toLowerCase();\n  } else {\n    console.log(x);\n    console.log(y);\n  }\n}\n```\n\n当我们在上面的示例中检查`x`和`y`是否相等时，TypeScript 知道它们的类型也必须相等。由于`string`是`x`和`y`都可以采用的唯一常见类型，因此TypeScript 知道`x`、`y`如果都是`string`，则程序走第一个分支中 。\n\n检查特定的字面量值（而不是变量）也有效。在我们关于真值缩小的部分中，我们编写了一个`printAll`容易出错的函数，因为它没有正确处理空字符串。相反，我们可以做一个特定的检查来阻止`null`，并且 TypeScript 仍然正确地从`strs`里移除`null`。\n\n```tsx\nfunction printAll(strs: string | string[] | null) {\n  if (strs !== null) {\n    if (typeof strs === \"object\") {\n      for (const s of strs) {\n        console.log(s);\n      }\n    } else if (typeof strs === \"string\") {\n      console.log(strs);\n    }\n  }\n}\n```\n\nJavaScript 更宽松的相等性检查`==`和`!=`，也能被正确缩小。如果你不熟悉，如何检查某个变量是否`== null`，因为有时不仅要检查它是否是特定的值`null`，还要检查它是否可能是`undefined`。这同样适用于`== undefined`：它检查一个值是否为`null`或`undefined`。现在你只需要这个 `==`和`!=`就可以搞定了。\n\n```tsx\ninterface Container {\n  value: number | null | undefined;\n}\n\nfunction multiplyValue(container: Container, factor: number) {\n  // 从类型中排除了undefined 和 null\n  if (container.value != null) {\n    console.log(container.value);\n    // 现在我们可以安全地乘以“container.value”了\n    container.value *= factor;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png\" alt=\"image-20211115154532180\" style=\"zoom:50%;\" />\n\n前三个打印是通过的，第四个有问题了。\n\n## 4.4 `in`操作符缩小\n\nJavaScript 有一个运算符，用于确定对象是否具有某个名称的属性：`in`运算符。TypeScript 考虑到了这一点，以此来缩小潜在类型的范围。\n\n例如，使用代码：`\"value\" in x`。这里的 `\"value\"`是字符串文字，`x`是联合类型。值为“true”的分支缩小，需要`x`具有可选或必需属性的类型的值；值为 “false” 的分支缩小，需要具有可选或缺失属性的类型的值。\n\n```tsx\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n\nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    return animal.swim();\n  }\n\n  return animal.fly();\n}\n```\n\n另外，可选属性还将存在于缩小的两侧，例如，人类可以游泳和飞行（使用正确的设备），因此应该出现在`in`检查的两侧：\n\n```tsx\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ntype Human = { swim?: () => void; fly?: () => void };\n\nfunction move(animal: Fish | Bird | Human) {\n  if (\"swim\" in animal) {\n    // animal: Fish | Human\n    animal;\n  } else {\n    // animal: Bird | Human\n    animal;\n  }\n}\n```\n\n## 4.5 `instanceof`操作符缩小\n\nJavaScript 有一个运算符来 `instanceof` 检查一个值是否是另一个值的“实例”。更具体地，在JavaScript中`x instanceof Foo` 检查`x`的*原型链*是否含有`Foo.prototype`。虽然我们不会在这里深入探讨，当我们进入 `类(class)`学习时，你会看到更多这样的内容，它们大多数可以使用`new`关键字实例化。 正如你可能已经猜到的那样，`instanceof`也是一个类型保护，TypeScript 在由`instanceof`保护的分支中实现缩小。\n\n```tsx\nfunction logValue(x: Date | string) {\n  if (x instanceof Date) {\n    console.log(x.toUTCString());\n  } else {\n    console.log(x.toUpperCase());\n  }\n}\n\nlogValue(new Date()); // Mon, 15 Nov 2021 22:34:37 GMT\nlogValue(\"hello ts\"); // HELLO TS\n```\n\n## 4.6 分配缩小\n\n正如我们之前提到的，当我们为任何变量赋值时，TypeScript 会查看赋值的右侧并适当缩小左侧。\n\n```tsx\n// let x: string | number\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\n\nx = 1;\n// let x: number\nconsole.log(x);\n\nx = \"goodbye!\";\n// let x: string\nconsole.log(x);\n```\n\n请注意，这些分配中的每一个都是有效的。即使在我们第一次赋值后观察到的类型`x`更改为 `number`，我们仍然可以将`string`赋值给`x`。这是因为*声明类型*的`x`-该类型`x`开始是`string | number`。\n\n如果我们分配了一个`boolean`给 `x`，我们就会看到一个错误，因为它不是声明类型的一部分。\n\n```tsx\nlet x = Math.random() < 0.5 ? 10 : \"hello world!\";\n\n// let x: string | number\nx = 1;\n\n// let x: number\nconsole.log(x);\n\n// 出错了！\nx = true;\n\n// let x: string | number\nconsole.log(x);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png\" alt=\"image-20211116065026159\" style=\"zoom: 50%;\" />\n\n## 4.7 控制流分析\n\n到目前为止，我们已经通过一些基本示例来说明 TypeScript 如何在特定分支中缩小范围。但是除了从每个变量中走出来，并在`if`、`while`、条件等中寻找类型保护之外，还有更多的事情要做。例如：\n\n```tsx\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === \"number\") {\n    return new Array(padding + 1).join(\" \") + input;\n  }\n  return padding + input;\n}\n```\n\n`padLeft`从其第一个 `if`块中返回。TypeScript 能够分析这段代码，并看到在 padding 是数字的情况下，主体的其余部分（`return padding + input;`）是不可达的。因此，它能够将数字从 `padding` 的类型中移除（从字符串|数字缩小到字符串），用于该函数的其余部分。\n\n这种基于可达性的代码分析被称为控制流分析，TypeScript使用这种流分析来缩小类型，因为它遇到了类型守卫和赋值。当一个变量被分析时，控制流可以一次又一次地分裂和重新合并，该变量可以被观察到在每个点上有不同的类型。\n\n```tsx\nfunction example() {\n  let x: string | number | boolean;\n\n  x = Math.random() < 0.5;\n\n  // let x: boolean\n  console.log(x);\n\n  if (Math.random() < 0.5) {\n    x = \"hello\";\n    // let x: string\n    console.log(x);\n  } else {\n    x = 100;\n    // let x: number\n    console.log(x);\n  }\n\n  // let x: string | number\n  return x;\n}\n\nlet x = example();\nx = \"hello\";\nx = 100;\nx = true; // error\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png\" alt=\"image-20211117203742503\" style=\"zoom:50%;\" />\n\n## 4.8 使用类型谓词\n\n到目前为止，我们已经用现有的JavaScript结构来处理窄化问题，然而有时你想更直接地控制整个代码中的类型变化。\n\n为了定义一个用户定义的类型保护，我们只需要定义一个函数，其返回类型是一个类型谓词。\n\n```tsx\ntype Fish = {\n  name: string;\n  swim: () => void;\n};\n\ntype Bird = {\n  name: string;\n  fly: () => void;\n};\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n\n在这个例子中，`pet is Fish` 是我们的类型谓词。谓词的形式是 `parameterName is Type`，其中 `parameterName` 必须是当前函数签名中的参数名称。\n\n任何时候 `isFish` 被调用时，如果原始类型是兼容的，TypeScript将把该变量缩小到该特定类型。\n\n```tsx\nfunction getSmallPet(): Fish | Bird {\n  let fish: Fish = {\n    name: \"gold fish\",\n    swim: () => {},\n  };\n\n  let bird: Bird = {\n    name: \"sparrow\",\n    fly: () => {},\n  };\n\n  return true ? bird : fish;\n}\n\n// 这里 pet 的 swim 和 fly 都可以访问了\nlet pet = getSmallPet();\nif (isFish(pet)) {\n  pet.swim();\n} else {\n  pet.fly();\n}\n```\n\n注意，TypeScript不仅知道 `pet` 在 `if` 分支中是一条鱼；它还知道在 `else` 分支中，你没有一条 `Fish`，所以你一定有一只 `Bird`。\n\n你可以使用类型守卫 `isFish` 来过滤 `Fish | Bird` 的数组，获得 `Fish` 的数组。\n\n```tsx\nconst zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];\nconst underWater1: Fish[] = zoo.filter(isFish);\n// 或者，等同于\nconst underWater2: Fish[] = zoo.filter(isFish) as Fish[];\n\n// 对于更复杂的例子，该谓词可能需要重复使用\nconst underWatch3: Fish[] = zoo.filter((pet): pet is Fish => {\n  if (pet.name === \"frog\") {\n    return false;\n  }\n  return isFish(pet);\n});\n```\n\n## 4.9 受歧视的 `unions`\n\n到目前为止，我们所看的大多数例子都是围绕着用简单的类型（如`string`、`boolean`和`number`）来缩小单个变量。虽然这很常见，但在JavaScript中，大多数时候我们要处理的是稍微复杂的结构。\n\n为了激发灵感，让我们想象一下，我们正试图对圆形和方形等形状进行编码。圆记录了它们的半径，方记录了它们的边长。我们将使用一个叫做 `kind` 的字段来告诉我们正在处理的是哪种形状。这里是定义 `Shape` 的第一个尝试。\n\n```tsx\ninterface Shape {\n  kind: \"circle\" | \"square\";\n  radius?: number;\n  sideLength?: number;\n}\n```\n\n注意，我们使用的是字符串字面类型的联合。`\"circle \"`和` \"square \"`分别告诉我们应该把这个形状当作一个圆形还是方形。通过使用 `\"circle\" | \"square \"` 而不是 `string`，我们可以避免拼写错误的问题。\n\n```tsx\nfunction handleShape(shape: Shape) {\n  // oops!\n  if (shape.kind === \"rect\") {\n    // ...\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png\" alt=\"image-20211118090404099\" style=\"zoom:50%;\" />\n\n我们可以编写一个 `getArea` 函数，根据它处理的是圆形还是方形来应用正确的逻辑。我们首先尝试处理圆形。\n\n```tsx\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png\" alt=\"image-20211118091637002\" style=\"zoom:50%;\" />\n\n在 `strictNullChecks` 下，这给了我们一个错误——这是很恰当的，因为 `radius` 可能没有被定义。但是如果我们对 `kind` 属性进行适当的检查呢？\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png\" alt=\"image-20211118093134890\" style=\"zoom:50%;\" />\n\n嗯，TypeScript 仍然不知道该怎么做。我们遇到了一个问题，即我们对我们的值比类型检查器知道的更多。我们可以尝试使用一个非空的断言 (`radius` 后面的那个叹号`!` ) 来说明 `radius` 肯定存在。\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    return Math.PI * shape.radius! ** 2;\n  }\n}\n```\n\n但这感觉并不理想。我们不得不用那些非空的断言对类型检查器声明一个叹号（`！`），以说服它相信`shape.radius` 是被定义的，但是如果我们开始移动代码，这些断言就容易出错。此外，在 `strictNullChecks` 之外，我们也可以意外地访问这些字段（因为在读取这些字段时，可选属性被认为总是存在的）。我们绝对可以做得更好。\n\n`Shape` 的这种编码的问题是，类型检查器没有办法根据种类属性知道 `radius` 或 `sideLength` 是否存在。我们需要把我们知道的东西传达给类型检查器。考虑到这一点，让我们再来定义一下Shape。\n\n```tsx\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\ninterface Square {\n  kind: \"square\";\n  sideLength: number;\n}\n\ntype Shape = Circle | Square;\n```\n\n在这里，我们正确地将 `Shape` 分成了两种类型，为 `kind` 属性设置了不同的值，但是 `radius` 和 `sideLength` 在它们各自的类型中被声明为必需的属性。\n\n让我们看看当我们试图访问 `Shape` 的半径时会发生什么。\n\n```tsx\nfunction getArea(shape: Shape) {\n  return Math.PI * shape.radius ** 2;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png\" alt=\"image-20211118180452972\" style=\"zoom:50%;\" />\n\n就像我们对 `Shape` 的第一个定义一样，这仍然是一个错误。当半径是可选的时候，我们得到了一个错误（仅在`strictNullChecks` 中），因为 TypeScript 无法判断该属性是否存在。现在 `Shape` 是一个联合体，TypeScript 告诉我们 `shape` 可能是一个 `Square` ，而Square并没有定义半径 `radius`。 这两种解释都是正确的，但只有我们对 `Shape` 的新编码仍然在 `strictNullChecks` 之外导致错误。\n\n但是，如果我们再次尝试检查kind属性呢？\n\n```tsx\nfunction getArea(shape: Shape) {\n  if (shape.kind === \"circle\") {\n    // shape: Circle\n    return Math.PI * shape.radius ** 2;\n  }\n}\n```\n\n这就摆脱了错误! 当 `union` 中的每个类型都包含一个与字面类型相同的属性时，TypeScript 认为这是一个有区别的 `union` ，并且可以缩小 `union` 的成员。\n\n在这种情况下，`kind` 就是那个共同属性（这就是 `Shape` 的判别属性）。检查 `kind` 属性是否为 `\"circle\"`，就可以剔除 `Shape` 中所有没有` \"circle\"` 类型属性的类型。这就把 `Shape` 的范围缩小到了`Circle`这个类型。\n\n同样的检查方法也适用于 `switch` 语句。现在我们可以试着编写完整的 `getArea`，而不需要任何讨厌的叹号 `！`非空的断言。\n\n```tsx\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    // shape: Circle\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n\n    // shape: Square\n    case \"square\":\n      return shape.sideLength ** 2;\n  }\n}\n```\n\n这里最重要的是 `Shape` 的编码。向 TypeScript 传达正确的信息是至关重要的，这个信息就是 `Circle`和`Square`实际上是具有特定种类字段的两个独立类型。这样做让我们写出类型安全的TypeScript代码，看起来与我们本来要写的JavaScript没有区别。从那里，类型系统能够做 \"正确 \"的事情，并找出我们 `switch`语句的每个分支中的类型。\n\n> 作为一个旁观者，试着玩一玩上面的例子，去掉一些返回关键词。你会发现，类型检查可以帮助避免在switch语句中不小心落入不同子句的bug。\n\n辨证的联合体不仅仅适用于谈论圆形和方形。它们适合于在JavaScript中表示任何类型的消息传递方案，比如在网络上发送消息（`client/server`通信），或者在状态管理框架中编码突变。\n\n## 4.10 `never`类型与穷尽性检查\n\n在缩小范围时，你可以将一个联合体的选项减少到你已经删除了所有的可能性并且什么都不剩的程度。在这些情况下，TypeScript将使用一个`never`类型来代表一个不应该存在的状态。\n\n`never` 类型可以分配给每个类型；但是，没有任何类型可以分配给never（除了never本身）。这意味着你可以使用缩小并依靠`never`的出现在 `switch` 语句中做详尽的检查。\n\n例如，在我们的`getArea`函数中添加一个默认值，试图将形状分配给`never`，当每个可能的情况都没有被处理时，就会引发。\n\n```tsx\ntype Shape = Circle | Square;\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n在 `Shape` 联盟中添加一个新成员，将导致TypeScript错误。\n\n```tsx\ninterface Triangle {\n  kind: \"triangle\";\n  sideLength: number;\n}\n\ntype Shape = Circle | Square | Triangle;\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    default:\n      const _exhaustiveCheck: never = shape;\n      return _exhaustiveCheck;\n  }\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png\" alt=\"image-20211118183410201\" style=\"zoom:50%;\" />\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-4、基础篇：类型缩小",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao1000i94v37jpj8r7h",
        "content": "<h1 id=\"四、类型缩小\"><a href=\"#四、类型缩小\" class=\"headerlink\" title=\"四、类型缩小\"></a>四、类型缩小</h1><p>假设我们有一个名为<code>padLeft</code>的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;尚未实现!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来扩充一下功能：如果<code>padding</code>是 <code>number</code>，它会将其视为我们想要添加到<code>input</code>的空格数；如果<code>padding</code>是 <code>string</code>，它只在<code>input</code>上做<code>padding</code> 。让我们尝试实现：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/04-01.png\" alt=\"image-20211114161343249\"></p>\n<p>呃-哦，在<code>padding + 1</code>处我们遇到错误。TypeScript 警告我们，运算符 <code>+</code> 不能应用于类型 <code>string | number</code>和 <code>number</code>，这是对的。换句话说，我们没有明确检查 <code>padding</code>是否为 <code>number</code>，也没有处理它是 <code>string</code> 的情况，所以我们这样做：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> padding + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这大部分看起来像无趣的JavaScript代码，这也算是重点吧。除了我们设置的注解之外，这段TypeScript代码看起来就像JavaScript。我们的想法是，TypeScript的类型系统旨在使编写典型的JavaScript代码变得尽可能容易，而不需要弯腰去获得类型安全。</p>\n<p>虽然看起来不多，但实际上有很多东西在这里。就像TypeScript使用静态类型分析运行时的值一样，它在JavaScript的运行时控制流构造上叠加了类型分析，如if&#x2F;else、条件三元组、循环、真实性检查等，这些都会影响到这些类型。</p>\n<p>在我们的if检查中，TypeScript看到 <code>typeof padding ===&quot;number&quot;</code>，并将其理解为一种特殊形式的代码，称为类型保护。TypeScript遵循我们的程序可能采取的执行路径，以分析一个值在特定位置的最具体的可能类型。它查看这些特殊的检查（称为类型防护）和赋值，将类型细化为比声明的更具体的类型的过程被称为缩小。在许多编辑器中，我们可以观察这些类型的变化，我们甚至会在我们的例子中这样做。</p>\n<p>TypeScript 可以理解几种不同的缩小结构。</p>\n<h2 id=\"4-1-typeof类型守卫\"><a href=\"#4-1-typeof类型守卫\" class=\"headerlink\" title=\"4.1 typeof类型守卫\"></a>4.1 <code>typeof</code>类型守卫</h2><p>正如我们所见，JavaScript 支持一个<code>typeof</code>运算符，它可以提供有关我们在运行时拥有的值类型的非常基本的信息。TypeScript 期望它返回一组特定的字符串：</p>\n<ul>\n<li><code>&quot;string&quot;</code></li>\n<li><code>&quot;number&quot;</code></li>\n<li><code>&quot;bigint&quot;</code></li>\n<li><code>&quot;boolean&quot;</code></li>\n<li><code>&quot;symbol&quot;</code></li>\n<li><code>&quot;undefined&quot;</code></li>\n<li><code>&quot;object&quot;</code></li>\n<li><code>&quot;function&quot;</code></li>\n</ul>\n<p>就像我们在 <code>padLeft</code> 中看到的那样，这个运算符经常出现在许多 JavaScript 库中，TypeScript 可以理解为，它缩小在不同分支中的类型。</p>\n<p>在 TypeScript 中，检查<code>typeof</code>的返回值是一种类型保护。因为 TypeScript 对<code>typeof</code>操作进行编码，从而返回不同的值，所以它知道对 JavaScript 做了什么。例如，请注意在上面的列表中，<code>typeof</code>不返回 string <code>null</code>。查看以下示例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做点事</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png\" alt=\"image-20211114164143361\" style=\"zoom:50%;\" />\n\n<p>在<code>printAll</code>函数中，我们尝试检查<code>strs</code>是否为对象，来代替检查它是否为数组类型（现在可能是强调数组是 JavaScript 中的对象类型的好时机）。但事实证明，在 JavaScript 中，<code>typeof null</code>实际上也是<code>&quot;object&quot;</code>! 这是历史上的不幸事故之一。</p>\n<p>有足够经验的用户可能不会感到惊讶，但并不是每个人都在 JavaScript 中遇到过这种情况；幸运的是，typescript 让我们知道，<code>strs</code>只缩小到<code>string[] | null</code>，而不仅仅是<code>string[]</code>。</p>\n<p>这可能是我们所谓的“真实性”检查的一个很好的过渡。</p>\n<h2 id=\"4-2-真值缩小\"><a href=\"#4-2-真值缩小\" class=\"headerlink\" title=\"4.2 真值缩小\"></a>4.2 真值缩小</h2><p>真值检查是我们在 JavaScript 中经常做的一件事。在 JavaScript 中，我们可以在条件、<code>&amp;&amp;</code>、<code>||</code>、<code>if</code>语句、布尔否定 ( <code>!</code>) 等中使用任何表达式。例如，<code>if</code>语句不希望它们的条件总是具有类型<code>boolean</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getUsersOnlineMessage</span>(<span class=\"params\"><span class=\"attr\">numUsersOnline</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numUsersOnline) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`现在共有 <span class=\"subst\">$&#123;numUsersOnline&#125;</span> 人在线!`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;现在没有人在线. :(&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 JavaScript 中，像这样的<code>if</code>条件语句，首先将它们的条件“强制”转化为<code>boolean</code> 以使其有意义，然后根据结果是<code>true</code>还是<code>false</code>来选择它们的分支。像这面这些值：</p>\n<ul>\n<li><code>0</code></li>\n<li><code>NaN</code></li>\n<li><code>&quot;&quot;</code> （空字符串）</li>\n<li><code>0n</code>（<code>bigint</code>零的版本）</li>\n<li><code>null</code></li>\n<li><code>undefined</code></li>\n</ul>\n<p>以上所有值强制都转换为<code>false</code>，其他值被强制转化为<code>true</code>。你始终可以在<code>Boolean</code>函数中运行值获得<code>boolean</code>，或使用较短的双布尔否定将值强制转换为<code>boolean</code>。（后者的优点是 TypeScript 推断出一个狭窄的文字布尔类型<code>true</code>，而将第一个推断为 <code>boolean</code>类型。）</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两个结果都返回 true</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"string\">&quot;hello&quot;</span>); <span class=\"comment\">// type: boolean, value: true</span></span><br><span class=\"line\">!!<span class=\"string\">&quot;world&quot;</span>; <span class=\"comment\">// type: true, value: true</span></span><br></pre></td></tr></table></figure>\n\n<p>利用这种行为是相当流行的，尤其是在防范诸如<code>null</code>或<code>undefined</code>之类的值时。例如，让我们尝试将它用于我们的<code>printAll</code>函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs &amp;&amp; <span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你会注意到我们已经通过检查<code>strs</code>是否为真，消除了上述错误。这至少可以防止我们在运行代码时出现可怕的错误，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: null is not iterable</span><br></pre></td></tr></table></figure>\n\n<p>但请记住，对原语的真值检查通常容易出错。例如，考虑改写<code>printAll</code>:</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// !!!!!!!!!!!!!!!!</span></span><br><span class=\"line\">  <span class=\"comment\">//  别这样!</span></span><br><span class=\"line\">  <span class=\"comment\">//  原因在下边</span></span><br><span class=\"line\">  <span class=\"comment\">// !!!!!!!!!!!!!!!!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们将整个函数体包装在一个真实的检查中，但这有一个小的缺点：我们可能不再正确处理空字符串的情况。</p>\n<p>TypeScript 在这里根本不会报错，但是如果你不太熟悉 JavaScript，这是值得注意的行为。TypeScript 通常可以帮助你及早发现错误，但是如果你选择对某个值不做<em>任何</em>处理，那么它可以做的就只有这么多，而不会考虑过多的逻辑方面的问题。如果需要，你可以确保使用 linter（程序规范性） 处理此类情况。</p>\n<p>关于通过真实性缩小范围的最后一点，是通过布尔否定<code>!</code>把逻辑从否定分支中过滤掉。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiplyAll</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">values</span>: <span class=\"built_in\">number</span>[] | <span class=\"literal\">undefined</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">factor</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"built_in\">number</span>[] | <span class=\"literal\">undefined</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!values) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * factor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3-等值缩小\"><a href=\"#4-3-等值缩小\" class=\"headerlink\" title=\"4.3 等值缩小\"></a>4.3 等值缩小</h2><p>typescript 也使用分支语句做<code>===</code>，<code>!==</code>，<code>==</code>，和<code>!=</code>等值检查，来实现类型缩小。例如：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 现在可以在x,y上调用字符串类型的方法了</span></span><br><span class=\"line\">    x.<span class=\"title function_\">toUpperCase</span>();</span><br><span class=\"line\">    y.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们在上面的示例中检查<code>x</code>和<code>y</code>是否相等时，TypeScript 知道它们的类型也必须相等。由于<code>string</code>是<code>x</code>和<code>y</code>都可以采用的唯一常见类型，因此TypeScript 知道<code>x</code>、<code>y</code>如果都是<code>string</code>，则程序走第一个分支中 。</p>\n<p>检查特定的字面量值（而不是变量）也有效。在我们关于真值缩小的部分中，我们编写了一个<code>printAll</code>容易出错的函数，因为它没有正确处理空字符串。相反，我们可以做一个特定的检查来阻止<code>null</code>，并且 TypeScript 仍然正确地从<code>strs</code>里移除<code>null</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScript 更宽松的相等性检查<code>==</code>和<code>!=</code>，也能被正确缩小。如果你不熟悉，如何检查某个变量是否<code>== null</code>，因为有时不仅要检查它是否是特定的值<code>null</code>，还要检查它是否可能是<code>undefined</code>。这同样适用于<code>== undefined</code>：它检查一个值是否为<code>null</code>或<code>undefined</code>。现在你只需要这个 <code>==</code>和<code>!=</code>就可以搞定了。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Container</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiplyValue</span>(<span class=\"params\"><span class=\"attr\">container</span>: <span class=\"title class_\">Container</span>, <span class=\"attr\">factor</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从类型中排除了undefined 和 null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (container.<span class=\"property\">value</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(container.<span class=\"property\">value</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 现在我们可以安全地乘以“container.value”了</span></span><br><span class=\"line\">    container.<span class=\"property\">value</span> *= factor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png\" alt=\"image-20211115154532180\" style=\"zoom:50%;\" />\n\n<p>前三个打印是通过的，第四个有问题了。</p>\n<h2 id=\"4-4-in操作符缩小\"><a href=\"#4-4-in操作符缩小\" class=\"headerlink\" title=\"4.4 in操作符缩小\"></a>4.4 <code>in</code>操作符缩小</h2><p>JavaScript 有一个运算符，用于确定对象是否具有某个名称的属性：<code>in</code>运算符。TypeScript 考虑到了这一点，以此来缩小潜在类型的范围。</p>\n<p>例如，使用代码：<code>&quot;value&quot; in x</code>。这里的 <code>&quot;value&quot;</code>是字符串文字，<code>x</code>是联合类型。值为“true”的分支缩小，需要<code>x</code>具有可选或必需属性的类型的值；值为 “false” 的分支缩小，需要具有可选或缺失属性的类型的值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123; <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123; <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">move</span>(<span class=\"params\"><span class=\"attr\">animal</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&quot;swim&quot;</span> <span class=\"keyword\">in</span> animal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> animal.<span class=\"title function_\">swim</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> animal.<span class=\"title function_\">fly</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，可选属性还将存在于缩小的两侧，例如，人类可以游泳和飞行（使用正确的设备），因此应该出现在<code>in</code>检查的两侧：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123; <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123; <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Human</span> = &#123; <span class=\"attr\">swim</span>?: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>; <span class=\"attr\">fly</span>?: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">move</span>(<span class=\"params\"><span class=\"attr\">animal</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span> | <span class=\"title class_\">Human</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&quot;swim&quot;</span> <span class=\"keyword\">in</span> animal) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// animal: Fish | Human</span></span><br><span class=\"line\">    animal;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// animal: Bird | Human</span></span><br><span class=\"line\">    animal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-5-instanceof操作符缩小\"><a href=\"#4-5-instanceof操作符缩小\" class=\"headerlink\" title=\"4.5 instanceof操作符缩小\"></a>4.5 <code>instanceof</code>操作符缩小</h2><p>JavaScript 有一个运算符来 <code>instanceof</code> 检查一个值是否是另一个值的“实例”。更具体地，在JavaScript中<code>x instanceof Foo</code> 检查<code>x</code>的<em>原型链</em>是否含有<code>Foo.prototype</code>。虽然我们不会在这里深入探讨，当我们进入 <code>类(class)</code>学习时，你会看到更多这样的内容，它们大多数可以使用<code>new</code>关键字实例化。 正如你可能已经猜到的那样，<code>instanceof</code>也是一个类型保护，TypeScript 在由<code>instanceof</code>保护的分支中实现缩小。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logValue</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Date</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Date</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"title function_\">toUTCString</span>());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">logValue</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()); <span class=\"comment\">// Mon, 15 Nov 2021 22:34:37 GMT</span></span><br><span class=\"line\"><span class=\"title function_\">logValue</span>(<span class=\"string\">&quot;hello ts&quot;</span>); <span class=\"comment\">// HELLO TS</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-6-分配缩小\"><a href=\"#4-6-分配缩小\" class=\"headerlink\" title=\"4.6 分配缩小\"></a>4.6 分配缩小</h2><p>正如我们之前提到的，当我们为任何变量赋值时，TypeScript 会查看赋值的右侧并适当缩小左侧。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span> ? <span class=\"number\">10</span> : <span class=\"string\">&quot;hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&quot;goodbye!&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// let x: string</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这些分配中的每一个都是有效的。即使在我们第一次赋值后观察到的类型<code>x</code>更改为 <code>number</code>，我们仍然可以将<code>string</code>赋值给<code>x</code>。这是因为<em>声明类型</em>的<code>x</code>-该类型<code>x</code>开始是<code>string | number</code>。</p>\n<p>如果我们分配了一个<code>boolean</code>给 <code>x</code>，我们就会看到一个错误，因为它不是声明类型的一部分。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span> ? <span class=\"number\">10</span> : <span class=\"string\">&quot;hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出错了！</span></span><br><span class=\"line\">x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png\" alt=\"image-20211116065026159\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-7-控制流分析\"><a href=\"#4-7-控制流分析\" class=\"headerlink\" title=\"4.7 控制流分析\"></a>4.7 控制流分析</h2><p>到目前为止，我们已经通过一些基本示例来说明 TypeScript 如何在特定分支中缩小范围。但是除了从每个变量中走出来，并在<code>if</code>、<code>while</code>、条件等中寻找类型保护之外，还有更多的事情要做。例如：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> padding + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>padLeft</code>从其第一个 <code>if</code>块中返回。TypeScript 能够分析这段代码，并看到在 padding 是数字的情况下，主体的其余部分（<code>return padding + input;</code>）是不可达的。因此，它能够将数字从 <code>padding</code> 的类型中移除（从字符串|数字缩小到字符串），用于该函数的其余部分。</p>\n<p>这种基于可达性的代码分析被称为控制流分析，TypeScript使用这种流分析来缩小类型，因为它遇到了类型守卫和赋值。当一个变量被分析时，控制流可以一次又一次地分裂和重新合并，该变量可以被观察到在每个点上有不同的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// let x: boolean</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span>) &#123;</span><br><span class=\"line\">    x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// let x: string</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">// let x: number</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title function_\">example</span>();</span><br><span class=\"line\">x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">x = <span class=\"number\">100</span>;</span><br><span class=\"line\">x = <span class=\"literal\">true</span>; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png\" alt=\"image-20211117203742503\" style=\"zoom:50%;\" />\n\n<h2 id=\"4-8-使用类型谓词\"><a href=\"#4-8-使用类型谓词\" class=\"headerlink\" title=\"4.8 使用类型谓词\"></a>4.8 使用类型谓词</h2><p>到目前为止，我们已经用现有的JavaScript结构来处理窄化问题，然而有时你想更直接地控制整个代码中的类型变化。</p>\n<p>为了定义一个用户定义的类型保护，我们只需要定义一个函数，其返回类型是一个类型谓词。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isFish</span>(<span class=\"params\"><span class=\"attr\">pet</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span></span>): pet is <span class=\"title class_\">Fish</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> <span class=\"title class_\">Fish</span>).<span class=\"property\">swim</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>pet is Fish</code> 是我们的类型谓词。谓词的形式是 <code>parameterName is Type</code>，其中 <code>parameterName</code> 必须是当前函数签名中的参数名称。</p>\n<p>任何时候 <code>isFish</code> 被调用时，如果原始类型是兼容的，TypeScript将把该变量缩小到该特定类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">fish</span>: <span class=\"title class_\">Fish</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;gold fish&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">bird</span>: <span class=\"title class_\">Bird</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;sparrow&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span> ? bird : fish;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里 pet 的 swim 和 fly 都可以访问了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"title function_\">getSmallPet</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"title function_\">isFish</span>(pet)) &#123;</span><br><span class=\"line\">  pet.<span class=\"title function_\">swim</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.<span class=\"title function_\">fly</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，TypeScript不仅知道 <code>pet</code> 在 <code>if</code> 分支中是一条鱼；它还知道在 <code>else</code> 分支中，你没有一条 <code>Fish</code>，所以你一定有一只 <code>Bird</code>。</p>\n<p>你可以使用类型守卫 <code>isFish</code> 来过滤 <code>Fish | Bird</code> 的数组，获得 <code>Fish</code> 的数组。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">zoo</span>: (<span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span>)[] = [<span class=\"title function_\">getSmallPet</span>(), <span class=\"title function_\">getSmallPet</span>(), <span class=\"title function_\">getSmallPet</span>()];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWater1</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>(isFish);</span><br><span class=\"line\"><span class=\"comment\">// 或者，等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWater2</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>(isFish) <span class=\"keyword\">as</span> <span class=\"title class_\">Fish</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于更复杂的例子，该谓词可能需要重复使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWatch3</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>((pet): pet is <span class=\"title class_\">Fish</span> =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pet.<span class=\"property\">name</span> === <span class=\"string\">&quot;frog&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isFish</span>(pet);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-9-受歧视的-unions\"><a href=\"#4-9-受歧视的-unions\" class=\"headerlink\" title=\"4.9 受歧视的 unions\"></a>4.9 受歧视的 <code>unions</code></h2><p>到目前为止，我们所看的大多数例子都是围绕着用简单的类型（如<code>string</code>、<code>boolean</code>和<code>number</code>）来缩小单个变量。虽然这很常见，但在JavaScript中，大多数时候我们要处理的是稍微复杂的结构。</p>\n<p>为了激发灵感，让我们想象一下，我们正试图对圆形和方形等形状进行编码。圆记录了它们的半径，方记录了它们的边长。我们将使用一个叫做 <code>kind</code> 的字段来告诉我们正在处理的是哪种形状。这里是定义 <code>Shape</code> 的第一个尝试。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span> | <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们使用的是字符串字面类型的联合。<code>&quot;circle &quot;</code>和<code> &quot;square &quot;</code>分别告诉我们应该把这个形状当作一个圆形还是方形。通过使用 <code>&quot;circle&quot; | &quot;square &quot;</code> 而不是 <code>string</code>，我们可以避免拼写错误的问题。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleShape</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// oops!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;rect&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png\" alt=\"image-20211118090404099\" style=\"zoom:50%;\" />\n\n<p>我们可以编写一个 <code>getArea</code> 函数，根据它处理的是圆形还是方形来应用正确的逻辑。我们首先尝试处理圆形。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png\" alt=\"image-20211118091637002\" style=\"zoom:50%;\" />\n\n<p>在 <code>strictNullChecks</code> 下，这给了我们一个错误——这是很恰当的，因为 <code>radius</code> 可能没有被定义。但是如果我们对 <code>kind</code> 属性进行适当的检查呢？</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png\" alt=\"image-20211118093134890\" style=\"zoom:50%;\" />\n\n<p>嗯，TypeScript 仍然不知道该怎么做。我们遇到了一个问题，即我们对我们的值比类型检查器知道的更多。我们可以尝试使用一个非空的断言 (<code>radius</code> 后面的那个叹号<code>!</code> ) 来说明 <code>radius</code> 肯定存在。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span>! ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这感觉并不理想。我们不得不用那些非空的断言对类型检查器声明一个叹号（<code>！</code>），以说服它相信<code>shape.radius</code> 是被定义的，但是如果我们开始移动代码，这些断言就容易出错。此外，在 <code>strictNullChecks</code> 之外，我们也可以意外地访问这些字段（因为在读取这些字段时，可选属性被认为总是存在的）。我们绝对可以做得更好。</p>\n<p><code>Shape</code> 的这种编码的问题是，类型检查器没有办法根据种类属性知道 <code>radius</code> 或 <code>sideLength</code> 是否存在。我们需要把我们知道的东西传达给类型检查器。考虑到这一点，让我们再来定义一下Shape。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们正确地将 <code>Shape</code> 分成了两种类型，为 <code>kind</code> 属性设置了不同的值，但是 <code>radius</code> 和 <code>sideLength</code> 在它们各自的类型中被声明为必需的属性。</p>\n<p>让我们看看当我们试图访问 <code>Shape</code> 的半径时会发生什么。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png\" alt=\"image-20211118180452972\" style=\"zoom:50%;\" />\n\n<p>就像我们对 <code>Shape</code> 的第一个定义一样，这仍然是一个错误。当半径是可选的时候，我们得到了一个错误（仅在<code>strictNullChecks</code> 中），因为 TypeScript 无法判断该属性是否存在。现在 <code>Shape</code> 是一个联合体，TypeScript 告诉我们 <code>shape</code> 可能是一个 <code>Square</code> ，而Square并没有定义半径 <code>radius</code>。 这两种解释都是正确的，但只有我们对 <code>Shape</code> 的新编码仍然在 <code>strictNullChecks</code> 之外导致错误。</p>\n<p>但是，如果我们再次尝试检查kind属性呢？</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// shape: Circle</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就摆脱了错误! 当 <code>union</code> 中的每个类型都包含一个与字面类型相同的属性时，TypeScript 认为这是一个有区别的 <code>union</code> ，并且可以缩小 <code>union</code> 的成员。</p>\n<p>在这种情况下，<code>kind</code> 就是那个共同属性（这就是 <code>Shape</code> 的判别属性）。检查 <code>kind</code> 属性是否为 <code>&quot;circle&quot;</code>，就可以剔除 <code>Shape</code> 中所有没有<code> &quot;circle&quot;</code> 类型属性的类型。这就把 <code>Shape</code> 的范围缩小到了<code>Circle</code>这个类型。</p>\n<p>同样的检查方法也适用于 <code>switch</code> 语句。现在我们可以试着编写完整的 <code>getArea</code>，而不需要任何讨厌的叹号 <code>！</code>非空的断言。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// shape: Circle</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// shape: Square</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里最重要的是 <code>Shape</code> 的编码。向 TypeScript 传达正确的信息是至关重要的，这个信息就是 <code>Circle</code>和<code>Square</code>实际上是具有特定种类字段的两个独立类型。这样做让我们写出类型安全的TypeScript代码，看起来与我们本来要写的JavaScript没有区别。从那里，类型系统能够做 “正确 “的事情，并找出我们 <code>switch</code>语句的每个分支中的类型。</p>\n<blockquote>\n<p>作为一个旁观者，试着玩一玩上面的例子，去掉一些返回关键词。你会发现，类型检查可以帮助避免在switch语句中不小心落入不同子句的bug。</p>\n</blockquote>\n<p>辨证的联合体不仅仅适用于谈论圆形和方形。它们适合于在JavaScript中表示任何类型的消息传递方案，比如在网络上发送消息（<code>client/server</code>通信），或者在状态管理框架中编码突变。</p>\n<h2 id=\"4-10-never类型与穷尽性检查\"><a href=\"#4-10-never类型与穷尽性检查\" class=\"headerlink\" title=\"4.10 never类型与穷尽性检查\"></a>4.10 <code>never</code>类型与穷尽性检查</h2><p>在缩小范围时，你可以将一个联合体的选项减少到你已经删除了所有的可能性并且什么都不剩的程度。在这些情况下，TypeScript将使用一个<code>never</code>类型来代表一个不应该存在的状态。</p>\n<p><code>never</code> 类型可以分配给每个类型；但是，没有任何类型可以分配给never（除了never本身）。这意味着你可以使用缩小并依靠<code>never</code>的出现在 <code>switch</code> 语句中做详尽的检查。</p>\n<p>例如，在我们的<code>getArea</code>函数中添加一个默认值，试图将形状分配给<code>never</code>，当每个可能的情况都没有被处理时，就会引发。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">_exhaustiveCheck</span>: <span class=\"built_in\">never</span> = shape;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _exhaustiveCheck;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Shape</code> 联盟中添加一个新成员，将导致TypeScript错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;triangle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span> | <span class=\"title class_\">Triangle</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">_exhaustiveCheck</span>: <span class=\"built_in\">never</span> = shape;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _exhaustiveCheck;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png\" alt=\"image-20211118183410201\" style=\"zoom:50%;\" />\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"四、类型缩小\"><a href=\"#四、类型缩小\" class=\"headerlink\" title=\"四、类型缩小\"></a>四、类型缩小</h1><p>假设我们有一个名为<code>padLeft</code>的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;尚未实现!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来扩充一下功能：如果<code>padding</code>是 <code>number</code>，它会将其视为我们想要添加到<code>input</code>的空格数；如果<code>padding</code>是 <code>string</code>，它只在<code>input</code>上做<code>padding</code> 。让我们尝试实现：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/04-01.png\" alt=\"image-20211114161343249\"></p>\n<p>呃-哦，在<code>padding + 1</code>处我们遇到错误。TypeScript 警告我们，运算符 <code>+</code> 不能应用于类型 <code>string | number</code>和 <code>number</code>，这是对的。换句话说，我们没有明确检查 <code>padding</code>是否为 <code>number</code>，也没有处理它是 <code>string</code> 的情况，所以我们这样做：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> padding + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这大部分看起来像无趣的JavaScript代码，这也算是重点吧。除了我们设置的注解之外，这段TypeScript代码看起来就像JavaScript。我们的想法是，TypeScript的类型系统旨在使编写典型的JavaScript代码变得尽可能容易，而不需要弯腰去获得类型安全。</p>\n<p>虽然看起来不多，但实际上有很多东西在这里。就像TypeScript使用静态类型分析运行时的值一样，它在JavaScript的运行时控制流构造上叠加了类型分析，如if&#x2F;else、条件三元组、循环、真实性检查等，这些都会影响到这些类型。</p>\n<p>在我们的if检查中，TypeScript看到 <code>typeof padding ===&quot;number&quot;</code>，并将其理解为一种特殊形式的代码，称为类型保护。TypeScript遵循我们的程序可能采取的执行路径，以分析一个值在特定位置的最具体的可能类型。它查看这些特殊的检查（称为类型防护）和赋值，将类型细化为比声明的更具体的类型的过程被称为缩小。在许多编辑器中，我们可以观察这些类型的变化，我们甚至会在我们的例子中这样做。</p>\n<p>TypeScript 可以理解几种不同的缩小结构。</p>\n<h2 id=\"4-1-typeof类型守卫\"><a href=\"#4-1-typeof类型守卫\" class=\"headerlink\" title=\"4.1 typeof类型守卫\"></a>4.1 <code>typeof</code>类型守卫</h2><p>正如我们所见，JavaScript 支持一个<code>typeof</code>运算符，它可以提供有关我们在运行时拥有的值类型的非常基本的信息。TypeScript 期望它返回一组特定的字符串：</p>\n<ul>\n<li><code>&quot;string&quot;</code></li>\n<li><code>&quot;number&quot;</code></li>\n<li><code>&quot;bigint&quot;</code></li>\n<li><code>&quot;boolean&quot;</code></li>\n<li><code>&quot;symbol&quot;</code></li>\n<li><code>&quot;undefined&quot;</code></li>\n<li><code>&quot;object&quot;</code></li>\n<li><code>&quot;function&quot;</code></li>\n</ul>\n<p>就像我们在 <code>padLeft</code> 中看到的那样，这个运算符经常出现在许多 JavaScript 库中，TypeScript 可以理解为，它缩小在不同分支中的类型。</p>\n<p>在 TypeScript 中，检查<code>typeof</code>的返回值是一种类型保护。因为 TypeScript 对<code>typeof</code>操作进行编码，从而返回不同的值，所以它知道对 JavaScript 做了什么。例如，请注意在上面的列表中，<code>typeof</code>不返回 string <code>null</code>。查看以下示例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做点事</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/vqyDfKRPZkdzX7j.png\" alt=\"image-20211114164143361\" style=\"zoom:50%;\" />\n\n<p>在<code>printAll</code>函数中，我们尝试检查<code>strs</code>是否为对象，来代替检查它是否为数组类型（现在可能是强调数组是 JavaScript 中的对象类型的好时机）。但事实证明，在 JavaScript 中，<code>typeof null</code>实际上也是<code>&quot;object&quot;</code>! 这是历史上的不幸事故之一。</p>\n<p>有足够经验的用户可能不会感到惊讶，但并不是每个人都在 JavaScript 中遇到过这种情况；幸运的是，typescript 让我们知道，<code>strs</code>只缩小到<code>string[] | null</code>，而不仅仅是<code>string[]</code>。</p>\n<p>这可能是我们所谓的“真实性”检查的一个很好的过渡。</p>\n<h2 id=\"4-2-真值缩小\"><a href=\"#4-2-真值缩小\" class=\"headerlink\" title=\"4.2 真值缩小\"></a>4.2 真值缩小</h2><p>真值检查是我们在 JavaScript 中经常做的一件事。在 JavaScript 中，我们可以在条件、<code>&amp;&amp;</code>、<code>||</code>、<code>if</code>语句、布尔否定 ( <code>!</code>) 等中使用任何表达式。例如，<code>if</code>语句不希望它们的条件总是具有类型<code>boolean</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getUsersOnlineMessage</span>(<span class=\"params\"><span class=\"attr\">numUsersOnline</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numUsersOnline) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`现在共有 <span class=\"subst\">$&#123;numUsersOnline&#125;</span> 人在线!`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;现在没有人在线. :(&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 JavaScript 中，像这样的<code>if</code>条件语句，首先将它们的条件“强制”转化为<code>boolean</code> 以使其有意义，然后根据结果是<code>true</code>还是<code>false</code>来选择它们的分支。像这面这些值：</p>\n<ul>\n<li><code>0</code></li>\n<li><code>NaN</code></li>\n<li><code>&quot;&quot;</code> （空字符串）</li>\n<li><code>0n</code>（<code>bigint</code>零的版本）</li>\n<li><code>null</code></li>\n<li><code>undefined</code></li>\n</ul>\n<p>以上所有值强制都转换为<code>false</code>，其他值被强制转化为<code>true</code>。你始终可以在<code>Boolean</code>函数中运行值获得<code>boolean</code>，或使用较短的双布尔否定将值强制转换为<code>boolean</code>。（后者的优点是 TypeScript 推断出一个狭窄的文字布尔类型<code>true</code>，而将第一个推断为 <code>boolean</code>类型。）</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两个结果都返回 true</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"string\">&quot;hello&quot;</span>); <span class=\"comment\">// type: boolean, value: true</span></span><br><span class=\"line\">!!<span class=\"string\">&quot;world&quot;</span>; <span class=\"comment\">// type: true, value: true</span></span><br></pre></td></tr></table></figure>\n\n<p>利用这种行为是相当流行的，尤其是在防范诸如<code>null</code>或<code>undefined</code>之类的值时。例如，让我们尝试将它用于我们的<code>printAll</code>函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs &amp;&amp; <span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你会注意到我们已经通过检查<code>strs</code>是否为真，消除了上述错误。这至少可以防止我们在运行代码时出现可怕的错误，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: null is not iterable</span><br></pre></td></tr></table></figure>\n\n<p>但请记住，对原语的真值检查通常容易出错。例如，考虑改写<code>printAll</code>:</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// !!!!!!!!!!!!!!!!</span></span><br><span class=\"line\">  <span class=\"comment\">//  别这样!</span></span><br><span class=\"line\">  <span class=\"comment\">//  原因在下边</span></span><br><span class=\"line\">  <span class=\"comment\">// !!!!!!!!!!!!!!!!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们将整个函数体包装在一个真实的检查中，但这有一个小的缺点：我们可能不再正确处理空字符串的情况。</p>\n<p>TypeScript 在这里根本不会报错，但是如果你不太熟悉 JavaScript，这是值得注意的行为。TypeScript 通常可以帮助你及早发现错误，但是如果你选择对某个值不做<em>任何</em>处理，那么它可以做的就只有这么多，而不会考虑过多的逻辑方面的问题。如果需要，你可以确保使用 linter（程序规范性） 处理此类情况。</p>\n<p>关于通过真实性缩小范围的最后一点，是通过布尔否定<code>!</code>把逻辑从否定分支中过滤掉。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiplyAll</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">values</span>: <span class=\"built_in\">number</span>[] | <span class=\"literal\">undefined</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">factor</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"built_in\">number</span>[] | <span class=\"literal\">undefined</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!values) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * factor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3-等值缩小\"><a href=\"#4-3-等值缩小\" class=\"headerlink\" title=\"4.3 等值缩小\"></a>4.3 等值缩小</h2><p>typescript 也使用分支语句做<code>===</code>，<code>!==</code>，<code>==</code>，和<code>!=</code>等值检查，来实现类型缩小。例如：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x === y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 现在可以在x,y上调用字符串类型的方法了</span></span><br><span class=\"line\">    x.<span class=\"title function_\">toUpperCase</span>();</span><br><span class=\"line\">    y.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们在上面的示例中检查<code>x</code>和<code>y</code>是否相等时，TypeScript 知道它们的类型也必须相等。由于<code>string</code>是<code>x</code>和<code>y</code>都可以采用的唯一常见类型，因此TypeScript 知道<code>x</code>、<code>y</code>如果都是<code>string</code>，则程序走第一个分支中 。</p>\n<p>检查特定的字面量值（而不是变量）也有效。在我们关于真值缩小的部分中，我们编写了一个<code>printAll</code>容易出错的函数，因为它没有正确处理空字符串。相反，我们可以做一个特定的检查来阻止<code>null</code>，并且 TypeScript 仍然正确地从<code>strs</code>里移除<code>null</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printAll</span>(<span class=\"params\"><span class=\"attr\">strs</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (strs !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JavaScript 更宽松的相等性检查<code>==</code>和<code>!=</code>，也能被正确缩小。如果你不熟悉，如何检查某个变量是否<code>== null</code>，因为有时不仅要检查它是否是特定的值<code>null</code>，还要检查它是否可能是<code>undefined</code>。这同样适用于<code>== undefined</code>：它检查一个值是否为<code>null</code>或<code>undefined</code>。现在你只需要这个 <code>==</code>和<code>!=</code>就可以搞定了。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Container</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"built_in\">number</span> | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiplyValue</span>(<span class=\"params\"><span class=\"attr\">container</span>: <span class=\"title class_\">Container</span>, <span class=\"attr\">factor</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从类型中排除了undefined 和 null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (container.<span class=\"property\">value</span> != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(container.<span class=\"property\">value</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 现在我们可以安全地乘以“container.value”了</span></span><br><span class=\"line\">    container.<span class=\"property\">value</span> *= factor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/tkwKocVjWeRn3XN.png\" alt=\"image-20211115154532180\" style=\"zoom:50%;\" />\n\n<p>前三个打印是通过的，第四个有问题了。</p>\n<h2 id=\"4-4-in操作符缩小\"><a href=\"#4-4-in操作符缩小\" class=\"headerlink\" title=\"4.4 in操作符缩小\"></a>4.4 <code>in</code>操作符缩小</h2><p>JavaScript 有一个运算符，用于确定对象是否具有某个名称的属性：<code>in</code>运算符。TypeScript 考虑到了这一点，以此来缩小潜在类型的范围。</p>\n<p>例如，使用代码：<code>&quot;value&quot; in x</code>。这里的 <code>&quot;value&quot;</code>是字符串文字，<code>x</code>是联合类型。值为“true”的分支缩小，需要<code>x</code>具有可选或必需属性的类型的值；值为 “false” 的分支缩小，需要具有可选或缺失属性的类型的值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123; <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123; <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">move</span>(<span class=\"params\"><span class=\"attr\">animal</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&quot;swim&quot;</span> <span class=\"keyword\">in</span> animal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> animal.<span class=\"title function_\">swim</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> animal.<span class=\"title function_\">fly</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，可选属性还将存在于缩小的两侧，例如，人类可以游泳和飞行（使用正确的设备），因此应该出现在<code>in</code>检查的两侧：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123; <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123; <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Human</span> = &#123; <span class=\"attr\">swim</span>?: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>; <span class=\"attr\">fly</span>?: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">move</span>(<span class=\"params\"><span class=\"attr\">animal</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span> | <span class=\"title class_\">Human</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&quot;swim&quot;</span> <span class=\"keyword\">in</span> animal) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// animal: Fish | Human</span></span><br><span class=\"line\">    animal;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// animal: Bird | Human</span></span><br><span class=\"line\">    animal;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-5-instanceof操作符缩小\"><a href=\"#4-5-instanceof操作符缩小\" class=\"headerlink\" title=\"4.5 instanceof操作符缩小\"></a>4.5 <code>instanceof</code>操作符缩小</h2><p>JavaScript 有一个运算符来 <code>instanceof</code> 检查一个值是否是另一个值的“实例”。更具体地，在JavaScript中<code>x instanceof Foo</code> 检查<code>x</code>的<em>原型链</em>是否含有<code>Foo.prototype</code>。虽然我们不会在这里深入探讨，当我们进入 <code>类(class)</code>学习时，你会看到更多这样的内容，它们大多数可以使用<code>new</code>关键字实例化。 正如你可能已经猜到的那样，<code>instanceof</code>也是一个类型保护，TypeScript 在由<code>instanceof</code>保护的分支中实现缩小。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logValue</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Date</span> | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Date</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"title function_\">toUTCString</span>());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"title function_\">toUpperCase</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">logValue</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()); <span class=\"comment\">// Mon, 15 Nov 2021 22:34:37 GMT</span></span><br><span class=\"line\"><span class=\"title function_\">logValue</span>(<span class=\"string\">&quot;hello ts&quot;</span>); <span class=\"comment\">// HELLO TS</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-6-分配缩小\"><a href=\"#4-6-分配缩小\" class=\"headerlink\" title=\"4.6 分配缩小\"></a>4.6 分配缩小</h2><p>正如我们之前提到的，当我们为任何变量赋值时，TypeScript 会查看赋值的右侧并适当缩小左侧。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span> ? <span class=\"number\">10</span> : <span class=\"string\">&quot;hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"string\">&quot;goodbye!&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// let x: string</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这些分配中的每一个都是有效的。即使在我们第一次赋值后观察到的类型<code>x</code>更改为 <code>number</code>，我们仍然可以将<code>string</code>赋值给<code>x</code>。这是因为<em>声明类型</em>的<code>x</code>-该类型<code>x</code>开始是<code>string | number</code>。</p>\n<p>如果我们分配了一个<code>boolean</code>给 <code>x</code>，我们就会看到一个错误，因为它不是声明类型的一部分。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span> ? <span class=\"number\">10</span> : <span class=\"string\">&quot;hello world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出错了！</span></span><br><span class=\"line\">x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/iZFWjN4BkfKbdr2.png\" alt=\"image-20211116065026159\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-7-控制流分析\"><a href=\"#4-7-控制流分析\" class=\"headerlink\" title=\"4.7 控制流分析\"></a>4.7 控制流分析</h2><p>到目前为止，我们已经通过一些基本示例来说明 TypeScript 如何在特定分支中缩小范围。但是除了从每个变量中走出来，并在<code>if</code>、<code>while</code>、条件等中寻找类型保护之外，还有更多的事情要做。例如：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">padLeft</span>(<span class=\"params\"><span class=\"attr\">padding</span>: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(padding + <span class=\"number\">1</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot; &quot;</span>) + input;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> padding + input;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>padLeft</code>从其第一个 <code>if</code>块中返回。TypeScript 能够分析这段代码，并看到在 padding 是数字的情况下，主体的其余部分（<code>return padding + input;</code>）是不可达的。因此，它能够将数字从 <code>padding</code> 的类型中移除（从字符串|数字缩小到字符串），用于该函数的其余部分。</p>\n<p>这种基于可达性的代码分析被称为控制流分析，TypeScript使用这种流分析来缩小类型，因为它遇到了类型守卫和赋值。当一个变量被分析时，控制流可以一次又一次地分裂和重新合并，该变量可以被观察到在每个点上有不同的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  x = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// let x: boolean</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &lt; <span class=\"number\">0.5</span>) &#123;</span><br><span class=\"line\">    x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// let x: string</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">// let x: number</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// let x: string | number</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"title function_\">example</span>();</span><br><span class=\"line\">x = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">x = <span class=\"number\">100</span>;</span><br><span class=\"line\">x = <span class=\"literal\">true</span>; <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/hA2aRrP93TIBuOG.png\" alt=\"image-20211117203742503\" style=\"zoom:50%;\" />\n\n<h2 id=\"4-8-使用类型谓词\"><a href=\"#4-8-使用类型谓词\" class=\"headerlink\" title=\"4.8 使用类型谓词\"></a>4.8 使用类型谓词</h2><p>到目前为止，我们已经用现有的JavaScript结构来处理窄化问题，然而有时你想更直接地控制整个代码中的类型变化。</p>\n<p>为了定义一个用户定义的类型保护，我们只需要定义一个函数，其返回类型是一个类型谓词。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Fish</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bird</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isFish</span>(<span class=\"params\"><span class=\"attr\">pet</span>: <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span></span>): pet is <span class=\"title class_\">Fish</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> <span class=\"title class_\">Fish</span>).<span class=\"property\">swim</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>pet is Fish</code> 是我们的类型谓词。谓词的形式是 <code>parameterName is Type</code>，其中 <code>parameterName</code> 必须是当前函数签名中的参数名称。</p>\n<p>任何时候 <code>isFish</code> 被调用时，如果原始类型是兼容的，TypeScript将把该变量缩小到该特定类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">fish</span>: <span class=\"title class_\">Fish</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;gold fish&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">bird</span>: <span class=\"title class_\">Bird</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;sparrow&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">fly</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span> ? bird : fish;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里 pet 的 swim 和 fly 都可以访问了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = <span class=\"title function_\">getSmallPet</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"title function_\">isFish</span>(pet)) &#123;</span><br><span class=\"line\">  pet.<span class=\"title function_\">swim</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.<span class=\"title function_\">fly</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，TypeScript不仅知道 <code>pet</code> 在 <code>if</code> 分支中是一条鱼；它还知道在 <code>else</code> 分支中，你没有一条 <code>Fish</code>，所以你一定有一只 <code>Bird</code>。</p>\n<p>你可以使用类型守卫 <code>isFish</code> 来过滤 <code>Fish | Bird</code> 的数组，获得 <code>Fish</code> 的数组。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">zoo</span>: (<span class=\"title class_\">Fish</span> | <span class=\"title class_\">Bird</span>)[] = [<span class=\"title function_\">getSmallPet</span>(), <span class=\"title function_\">getSmallPet</span>(), <span class=\"title function_\">getSmallPet</span>()];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWater1</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>(isFish);</span><br><span class=\"line\"><span class=\"comment\">// 或者，等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWater2</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>(isFish) <span class=\"keyword\">as</span> <span class=\"title class_\">Fish</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于更复杂的例子，该谓词可能需要重复使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">underWatch3</span>: <span class=\"title class_\">Fish</span>[] = zoo.<span class=\"title function_\">filter</span>((pet): pet is <span class=\"title class_\">Fish</span> =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pet.<span class=\"property\">name</span> === <span class=\"string\">&quot;frog&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isFish</span>(pet);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-9-受歧视的-unions\"><a href=\"#4-9-受歧视的-unions\" class=\"headerlink\" title=\"4.9 受歧视的 unions\"></a>4.9 受歧视的 <code>unions</code></h2><p>到目前为止，我们所看的大多数例子都是围绕着用简单的类型（如<code>string</code>、<code>boolean</code>和<code>number</code>）来缩小单个变量。虽然这很常见，但在JavaScript中，大多数时候我们要处理的是稍微复杂的结构。</p>\n<p>为了激发灵感，让我们想象一下，我们正试图对圆形和方形等形状进行编码。圆记录了它们的半径，方记录了它们的边长。我们将使用一个叫做 <code>kind</code> 的字段来告诉我们正在处理的是哪种形状。这里是定义 <code>Shape</code> 的第一个尝试。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Shape</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span> | <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们使用的是字符串字面类型的联合。<code>&quot;circle &quot;</code>和<code> &quot;square &quot;</code>分别告诉我们应该把这个形状当作一个圆形还是方形。通过使用 <code>&quot;circle&quot; | &quot;square &quot;</code> 而不是 <code>string</code>，我们可以避免拼写错误的问题。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleShape</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// oops!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;rect&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/gN6Arztw5S2kFJm.png\" alt=\"image-20211118090404099\" style=\"zoom:50%;\" />\n\n<p>我们可以编写一个 <code>getArea</code> 函数，根据它处理的是圆形还是方形来应用正确的逻辑。我们首先尝试处理圆形。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/fNEWpy8i3GdxTLO.png\" alt=\"image-20211118091637002\" style=\"zoom:50%;\" />\n\n<p>在 <code>strictNullChecks</code> 下，这给了我们一个错误——这是很恰当的，因为 <code>radius</code> 可能没有被定义。但是如果我们对 <code>kind</code> 属性进行适当的检查呢？</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/T76rqcQbF2utN4U.png\" alt=\"image-20211118093134890\" style=\"zoom:50%;\" />\n\n<p>嗯，TypeScript 仍然不知道该怎么做。我们遇到了一个问题，即我们对我们的值比类型检查器知道的更多。我们可以尝试使用一个非空的断言 (<code>radius</code> 后面的那个叹号<code>!</code> ) 来说明 <code>radius</code> 肯定存在。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span>! ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这感觉并不理想。我们不得不用那些非空的断言对类型检查器声明一个叹号（<code>！</code>），以说服它相信<code>shape.radius</code> 是被定义的，但是如果我们开始移动代码，这些断言就容易出错。此外，在 <code>strictNullChecks</code> 之外，我们也可以意外地访问这些字段（因为在读取这些字段时，可选属性被认为总是存在的）。我们绝对可以做得更好。</p>\n<p><code>Shape</code> 的这种编码的问题是，类型检查器没有办法根据种类属性知道 <code>radius</code> 或 <code>sideLength</code> 是否存在。我们需要把我们知道的东西传达给类型检查器。考虑到这一点，让我们再来定义一下Shape。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们正确地将 <code>Shape</code> 分成了两种类型，为 <code>kind</code> 属性设置了不同的值，但是 <code>radius</code> 和 <code>sideLength</code> 在它们各自的类型中被声明为必需的属性。</p>\n<p>让我们看看当我们试图访问 <code>Shape</code> 的半径时会发生什么。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/ws1RYKDjvnQNxlC.png\" alt=\"image-20211118180452972\" style=\"zoom:50%;\" />\n\n<p>就像我们对 <code>Shape</code> 的第一个定义一样，这仍然是一个错误。当半径是可选的时候，我们得到了一个错误（仅在<code>strictNullChecks</code> 中），因为 TypeScript 无法判断该属性是否存在。现在 <code>Shape</code> 是一个联合体，TypeScript 告诉我们 <code>shape</code> 可能是一个 <code>Square</code> ，而Square并没有定义半径 <code>radius</code>。 这两种解释都是正确的，但只有我们对 <code>Shape</code> 的新编码仍然在 <code>strictNullChecks</code> 之外导致错误。</p>\n<p>但是，如果我们再次尝试检查kind属性呢？</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shape.<span class=\"property\">kind</span> === <span class=\"string\">&quot;circle&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// shape: Circle</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就摆脱了错误! 当 <code>union</code> 中的每个类型都包含一个与字面类型相同的属性时，TypeScript 认为这是一个有区别的 <code>union</code> ，并且可以缩小 <code>union</code> 的成员。</p>\n<p>在这种情况下，<code>kind</code> 就是那个共同属性（这就是 <code>Shape</code> 的判别属性）。检查 <code>kind</code> 属性是否为 <code>&quot;circle&quot;</code>，就可以剔除 <code>Shape</code> 中所有没有<code> &quot;circle&quot;</code> 类型属性的类型。这就把 <code>Shape</code> 的范围缩小到了<code>Circle</code>这个类型。</p>\n<p>同样的检查方法也适用于 <code>switch</code> 语句。现在我们可以试着编写完整的 <code>getArea</code>，而不需要任何讨厌的叹号 <code>！</code>非空的断言。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// shape: Circle</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// shape: Square</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里最重要的是 <code>Shape</code> 的编码。向 TypeScript 传达正确的信息是至关重要的，这个信息就是 <code>Circle</code>和<code>Square</code>实际上是具有特定种类字段的两个独立类型。这样做让我们写出类型安全的TypeScript代码，看起来与我们本来要写的JavaScript没有区别。从那里，类型系统能够做 “正确 “的事情，并找出我们 <code>switch</code>语句的每个分支中的类型。</p>\n<blockquote>\n<p>作为一个旁观者，试着玩一玩上面的例子，去掉一些返回关键词。你会发现，类型检查可以帮助避免在switch语句中不小心落入不同子句的bug。</p>\n</blockquote>\n<p>辨证的联合体不仅仅适用于谈论圆形和方形。它们适合于在JavaScript中表示任何类型的消息传递方案，比如在网络上发送消息（<code>client/server</code>通信），或者在状态管理框架中编码突变。</p>\n<h2 id=\"4-10-never类型与穷尽性检查\"><a href=\"#4-10-never类型与穷尽性检查\" class=\"headerlink\" title=\"4.10 never类型与穷尽性检查\"></a>4.10 <code>never</code>类型与穷尽性检查</h2><p>在缩小范围时，你可以将一个联合体的选项减少到你已经删除了所有的可能性并且什么都不剩的程度。在这些情况下，TypeScript将使用一个<code>never</code>类型来代表一个不应该存在的状态。</p>\n<p><code>never</code> 类型可以分配给每个类型；但是，没有任何类型可以分配给never（除了never本身）。这意味着你可以使用缩小并依靠<code>never</code>的出现在 <code>switch</code> 语句中做详尽的检查。</p>\n<p>例如，在我们的<code>getArea</code>函数中添加一个默认值，试图将形状分配给<code>never</code>，当每个可能的情况都没有被处理时，就会引发。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">_exhaustiveCheck</span>: <span class=\"built_in\">never</span> = shape;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _exhaustiveCheck;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Shape</code> 联盟中添加一个新成员，将导致TypeScript错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;triangle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = <span class=\"title class_\">Circle</span> | <span class=\"title class_\">Square</span> | <span class=\"title class_\">Triangle</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\"><span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape.<span class=\"property\">kind</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * shape.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> shape.<span class=\"property\">sideLength</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"attr\">_exhaustiveCheck</span>: <span class=\"built_in\">never</span> = shape;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _exhaustiveCheck;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/mPEYDNGbXZxzIy9.png\" alt=\"image-20211118183410201\" style=\"zoom:50%;\" />\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "1-2、基础篇：TypeScript入门",
        "toc": true,
        "swiper_index": 2,
        "swiper_cover": "/img/recommend/recommend_02.jpg",
        "swiper_desc": "1-2、基础篇：TypeScript入门",
        "abbrlink": 20247,
        "date": "2024-01-28T11:37:43.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_01.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 二、TypeScript入门\n\n## 2.1 发现问题\n\nJavaScript 中的每个值都有一组行为，您可以通过运行不同的操作来观察。这听起来很抽象，我们来举一个简单的例子，考虑我们可能对名为`message`的变量运行的一些操作：\n\n```js\n// 在 'message' 上访问属性 'toLowerCase'，并调用它\nmessage.toLowerCase();\n// 调用 'message'\nmessage();\n```\n\n如果我们分解它，第一行可运行的代码访问一个属性`toLowerCase`，然后调用它。第二个尝试 `message` 直接调用。\n\n但是假设我们不知道`message`。这很常见——我们无法可靠地说出尝试运行任何这些代码会得到什么结果。每个操作的行为完全取决于我们最初给`message`的赋值。\n\n- 可以调用`message`吗？\n- 它有`toLowerCase`这个属性吗？\n- 如果能，`toLowerCase`可以调用吗？\n- 如果这两个值都是可调用的，它们返回什么？\n\n这些问题的答案通常是我们在编写 JavaScript 时牢记在心的东西，我们必须希望所有细节都正确。\n\n假设`message`按以下方式定义：\n\n```js\nconst message = \"Hello World!\";\n```\n\n正如您可能猜到的，如果我们尝试运行`message.toLowerCase()`，我们只会得到相同的小写字符串。\n\n那第二行代码呢？如果您熟悉 JavaScript，您就会知道这会失败并出现异常：\n\n```shell\nTypeError: message is not a function\n```\n\n如果我们能避免这样的错误，那就太好了。\n\n当我们运行我们的代码时，我们的 JavaScript 运行时选择做什么的方式是通过确定值的*类型*——它具有什么样的行为和功能。这`TypeError`就是暗指的一部分- 它说字符串`\"Hello World!\"`不能作为函数调用。\n\n对于某些值，例如基本类型`string`和`number`，我们可以在运行时使用`typeof`运算符识别它们的类型。但是对于函数之类的其他东西，没有相应的运行时机制来识别它们的类型。例如，考虑这个函数：\n\n```js\nfunction fn(x) {\n  return x.flip();\n}\n```\n\n我们可以通过阅读代码*观察*到这个函数只有在给定一个具有可调用`flip`属性的对象时才能工作，但是 JavaScript 并没有以我们可以在代码运行时检查的方式来显示这些信息。在纯 JavaScript 中，告诉`fn`特定值做什么的**唯一方法**是调用它并查看会发生什么。这种行为使得在运行之前很难预测代码会做什么，这意味着在编写代码时更难知道代码会做什么。\n\n这样看来，*类型*是描述可以传递给`fn`哪些值会崩溃的概念。JavaScript 只真正提供*动态*类型——运行代码看看会发生什么。\n\n另一种方法是使用*静态*类型系统*在*运行*之前*预测预期的代码。\n\n## 2.2 **静态类型检查**\n\n回想一下`TypeError`我们之前尝试将 `string`作为函数调用的情况。 *大多数人*不喜欢在运行他们的代码时出现任何类型的错误 - 这些被认为是错误！当我们编写新代码时，我们会尽量避免引入新的错误。\n\n理想情况下，我们可以有一个工具来帮助我们*在*代码运行*之前*发现这些错误。这就是像 TypeScript 这样的静态类型检查器所做的。 *静态类型系统*描述了当我们运行程序时我们的值的形状和行为。像 TypeScript 这样的类型检查器，告诉我们什么时候事情可能会出轨。\n\n<img src=\"https://s2.loli.net/2022/02/22/5yhsbTCF7cqVGNQ.png\" alt=\"image-20211109134610557\" style=\"zoom:50%;\" align=\"left\" />\n\n在我们运行代码之前，使用 TypeScript 运行最后一个示例会给我们一条错误消息。\n\n## 2.3 **非异常故障**\n\n到目前为止，我们一直在讨论运行时错误——JavaScript 运行时告诉我们它认为某些东西是无意义的情况。出现这些情况是因为[ECMAScript 规范](https://tc39.github.io/ecma262/)明确说明了语言在遇到意外情况时应该如何表现。\n\n例如，规范说尝试调用不可调用的东西应该抛出错误。也许这听起来像是“明显的行为”，但您可以想象访问对象上不存在的属性也应该抛出错误。相反，JavaScript 给了我们不同的行为并返回值`undefined`：\n\n```js\nconst user = {\n  name: \"小千\",\n  age: 26,\n};\nuser.location; // 返回 undefined\n```\n\n最终，静态类型系统要求必须调用哪些代码，应该在其系统中标记，即使它是不会立即抛出错误的“有效”JavaScript。比如：在 TypeScript 中，以下代码会产生关于`location`未定义的错误：\n\n<img src=\"https://s2.loli.net/2022/02/22/Qqo8BZmtJnGC1D4.png\" alt=\"image-20211109141050215\" style=\"zoom:50%;\" />\n\nTypeScript 可以在我们的程序中捕获*很多*合法的错误。例如：\n\n- 错别字\n  ![](/img/TypeScript/01-04.png)\n- 未调用的函数\n\n<img src=\"https://s2.loli.net/2022/02/22/U1MmrPyjdbkueRC.png\" alt=\"image-20211109142053954\" style=\"zoom:50%;\" align=\"left\" />\n\n- 或基本逻辑错误\n\n![](/img/TypeScript/01-06.png)\n\n## 2.4 **使用工具**\n\n当我们在代码中出错时，TypeScript 可以捕获错误。这很好，但 TypeScript 也*可以首先*防止我们犯这些错误。\n\n类型检查器有能力帮助我们来检查，诸如是否正在访问变量和其他属性的正确属性。一旦有了这些信息，它还可以开始*建议*您可能想要使用的属性。\n\n这意味着当利用工具来编辑 TypeScript 代码，核心类型检查器可以在编辑器中键入代码时，提供错误消息和代码完成。这是我们在谈论 TypeScript 中的工具时经常提到的部分内容。\n\n<img src=\"https://s2.loli.net/2022/02/22/qolAfbMnVIcXvys.png\" alt=\"image-20211113085757666\" style=\"zoom: 25%;\" align=\"left\" />\n\nTypeScript 非常重视工具。支持 TypeScript 的编辑器可以提供“快速修复”以自动修复错误、重构以轻松重新组织代码的能力，以及用于跳转到变量定义或查找给定变量的所有引用的有用导航功能。所有这些都建立在类型检查器之上，并且是完全跨平台的，因此[您最喜欢的编辑器](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)可能[具有可用的 TypeScript 支持](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)。\n\n## 2.5 `tsc`编译器\n\n我们一直在谈论类型检查，但我们还没有使用我们的类型*检查器*。让我们认识一下我们的新朋友`tsc`TypeScript 编译器。首先，我们需要通过 npm 获取它。\n\n```she\nnpm install -g typescript\n```\n\n这将全局安装 TypeScript 编译器。\n\n现在让我们移动到一个空文件夹，并尝试编写我们的第一个 TypeScript 程序`hello.ts`：\n\n**01-ts-basics/hello.ts**\n\n```ts\n// 你好，世界\nconsole.log(\"Hello World\");\n```\n\n注意这里没有多余的装饰；这个“hello world”程序看起来与您在 JavaScript 中为“hello world”程序编写的程序相同。现在让我们通过运行`tsc`由`typescript`包为我们打包编译它：\n\n```shell\n[felix] 01-ts-basics $ tsc hello.ts\n```\n\n我们跑了`tsc`，什么也没发生！嗯，没有类型错误，所以我们没有在控制台中得到任何输出，因为没有什么可报告的。\n\n<img src=\"https://s2.loli.net/2022/02/22/APiNb5FzvuwGlZk.png\" alt=\"image-20211113093244339\" style=\"zoom: 50%;\" align=\"left\"/>\n\n但是再检查一下 - 我们得到了一些*文件*输出。如果我们查看当前目录，我们会发现有两个文件`hello.js`在`hello.ts`. 这是我们的`hello.ts`文件在`tsc` *编译*或*转换*为纯 JavaScript 文件后的输出。\n\n<img src=\"https://s2.loli.net/2022/02/22/ctI9MPpSY1y8uLr.png\" alt=\"image-20211113093559374\" style=\"zoom: 50%;\" align=\"left\" />\n\n如果我们检查`hello.js`，我们将看到 TypeScript 在处理`.ts`文件后吐出的内容：\n\n```js\n// 你好，世界\nconsole.log(\"Hello World\");\n```\n\n在这种情况下，TypeScript 几乎没有要转换的内容，因此它看起来与我们编写的内容相同。编译器会尝试编译出清晰可读的代码，看起来像一个人写的东西。注释也给我们保留下来。\n\n如果我们*确实*引入了类型检查错误呢？让我们重写`hello.ts`：\n\n```ts\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`);\n}\n\ngreet(\"小千\");\n```\n\n如果我们`tsc hello.ts`再次运行，我们在命令行上收到了错误！\n\n<img src=\"https://s2.loli.net/2022/02/22/QNL3DlBHYUbxu9Z.png\" alt=\"image-20211113095515775\" style=\"zoom:50%;\" align=\"left\"/>\n\nTypeScript 告诉我们忘记将参数传递给`greet`函数，这是理所当然的。到目前为止，我们只编写了标准的 JavaScript，但是类型检查仍然能够发现我们代码的其他问题。感谢TypeScript！\n\n## 2.6 发出错误\n\n从上一个示例中，你可能没有注意到的一件事，就是是我们的`hello.js`文件再次更改。如果我们打开该文件，那么我们会看到内容仍然与我们的输入文件基本相同。\n\n```js\n// 你好，世界\nconsole.log(\"Hello World\");\nfunction greet(person, date) {\n  console.log(\"Hello \" + person + \", today is \" + date + \"!\");\n}\ngreet(\"小千\");\n```\n\n鉴于`tsc`报告了有关我们代码的错误这一事实，这可能有点令人惊讶，但这是基于 TypeScript 的核心价值观之一：大多数情况下，*你*会比 TypeScript 更了解发生了什么。\n\n再回顾一下前面的内容，类型检查代码限制了我们可以运行的程序种类，因此需要权衡类型检查器认为可接受的类型。大多数情况下这没问题，但在某些情况下，这些检查会妨碍到我们。例如，想象自己将 JavaScript 代码迁移到 TypeScript 并引入类型检查错误。最终，你将开始为类型检查器进行代码清理，但原始 JavaScript 代码已经可以运行了！为什么非要将我们的JS代码转换为 TypeScript 代码，来去阻止运行它呢？\n\n所以 TypeScript 默认不会妨碍我们代码的运行，因为这些JS在宿主环境里运行时没有问题的。当然，随着时间的推移，我们可能希望对错误更加防御，并使 TypeScript 的行为更加严格。在这种情况下，我们可以使用[`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)编译器选项。尝试更改我们的`hello.ts`文件，并`tsc`使用该选项重新编译：\n\n```\ntsc --noEmitOnError hello.ts\n```\n\n![](/img/TypeScript/02-04.png)\n\n你会注意到`hello.js`永远不会更新。\n\n## 2.7 显式类型\n\n到现在为止，我们还没有告诉 typescript `person`或者`date`是什么类型。当我们编辑代码时会告诉 TypeScript `person`是一个`string`，那`date`应该是一个`Date`对象。\n\n有了这个，TypeScript 可以告诉我们其他`greet`可能被错误调用的情况。例如修改一下 `hello.ts`代码：\n\n```js\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n```\n\n![](/img/TypeScript/02-05.png)\n\n嗯？TypeScript 在我们的第二个参数上报告了一个错误，这是为什么呢？\n\n也许令人惊讶的是，`Date()`在 JavaScript 中调用会返回一个`string`。可以使用`new Date()`满足我们的期望,快速修复错误：\n\n```js\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n\ngreet(\"小锋\", new Date());\n```\n\n![](/img/TypeScript/02-06.png)\n\n成功的编译输出了 `hello.js`。\n\n请记住，我们并不总是必须给变量编写明确的类型注释。在许多情况下，TypeScript 可以为我们自动*推断*（或“找出”）类型，即使我们忽略定义这些类型。比如：\n\n<img src=\"https://s2.loli.net/2022/02/22/N2pXBbY6LRwoaC1.png\" alt=\"image-20211113111924590\" style=\"zoom:50%;\" align=\"left\" />\n\n这里没有给 msg 指定具体的类型，typescript 会根据函数的实参来自动推断类型。这是一个特性，当类型系统最终会推断出相同的类型时，最好不要添加类型注释。\n\n## 2.8 擦除类型\n\n让我们来仔细看看，当我们 `tsc`编译上面的代码会输出的什么样的JavaScript，观察 `hello.js`\n\n![](/img/TypeScript/02-08.png)\n\n这里要注意两点：\n\n1. 我们的`person`和`date`参数不再有类型注释。\n2. 我们的“模板字符串” - 使用反引号（`字符）的字符串 - 被转换为带有连接 ( + ) 的纯字符串。\n\n稍后会详细介绍第二点，现在让我们专注于第一点。类型注释不是 JavaScript 的一部分（或者说 ECMAScript 是落后的），因此实际上没有任何浏览器，或其他运行时可以不加修改地运行 TypeScript。这就是 TypeScript 首先需要编译器的原因——它需要某种方式来剥离或转换任何特定于 TypeScript 的代码，以便我们可以运行它。大多数 TypeScript 特定的代码都被删除了。\n\n> **请记住**：类型注释永远不会改变程序的运行时行为。\n\n## 2.9 降级编译\n\n与上面的另一个区别是我们的模板字符串是从：\n\n```js\n`Hello ${person}, today is ${date.toDateString()}!`;\n```\n\n到：\n\n```js\n\"Hello \" + person + \", today is \" + date.toDateString() + \"!\";\n```\n\n为什么会这样？\n\n模板字符串是 ECMAScript 版本的一个特性，称为 ECMAScript 2015（又名 ECMAScript 6、ES2015、ES6 等）。TypeScript 能够将代码从较新版本的 ECMAScript 重写为旧版本，例如 ECMAScript 3 或 ECMAScript 5（又名 ES3 和 ES5）。这种从更新或“更高”版本的 ECMAScript ，向下移动到旧版本或“更低”版本的过程有时称为*降级*。\n\n默认情况下，TypeScript 以 ES3 为目标，这是一个非常旧的 ECMAScript 版本。通过使用[`target`](https://www.typescriptlang.org/tsconfig#target)选项，我们可以选择更新一些的内容。运行`--target es2015`TypeScript 以针对 ECMAScript 2015进行更改，这意味着代码应该能够在支持 ECMAScript 2015 的任何地方运行。所以运行`tsc --target es2015 hello.ts`会给我们以下输出：\n\n<img src=\"https://s2.loli.net/2022/02/22/3BbKfisq9htp4nr.png\" alt=\"image-20211113113644658\" style=\"zoom:33%;\" />\n\n> 虽然默认目标是 ES3，但当前绝大多数浏览器都支持 ES2015。因此，大多数开发人员可以安全地将 ES2015 或更高版本指定为目标，除非考虑与某些旧浏览器的兼容性。\n\n## 2.10 严格模式\n\n不同的用户使用 TypeScript 在类型检查器中，希望检查的严格程度不同。有些人正在寻找更宽松的验证体验，它可以帮助仅验证其程序的某些部分，并且仍然拥有不错的工具。这是 TypeScript 的默认体验，其中类型是可选的，推理采用最宽松的类型，并且不检查潜在的`null`/`undefined`值，就像`tsc`面对错误时如何编译生成JS文件一样。如果你要迁移现有的 JavaScript，这可能是理想的第一步。\n\n相比之下，许多用户更喜欢让 TypeScript 尽可能多地立即验证，这就是该语言也提供严格性设置的原因。这些严格性设置将静态类型检查，从开关（无论您的代码是否被检查）转变为更接近于拨号的东西。你把这个拨盘调得越远，TypeScript 就会为你检查越多。这可能需要一些额外的工作，但总的来说，从长远来看，它是物有所值的，并且可以实现更彻底的检查和更准确的工具。如果可能，新的代码库应该始终打开这些严格性检查。\n\nTypeScript 有几个可以打开或关闭的类型检查严格标志，除非另有说明，否则我们所有的示例都将在启用所有这些标志的情况下编写。在命令行里设置[`strict`](https://www.typescriptlang.org/tsconfig#strict) ，或在[`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)中配置`\"strict\": true` 将它打开。\n\n![](/img/TypeScript/02-10.png)\n\n![](/img/TypeScript/02-11.png)\n\n以上两个案例错误是因为我们配置了 `--strict true`。\n\n同时我们可以单独选择配置它们。我们应该知道的最典型的两个是[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)和[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)。\n\n- **`noImplicitAny`**\n\n回想一下，在某些地方，TypeScript 不会尝试为我们推断类型，而是退回到最宽松的类型：`any`。这并不是可能发生的最糟糕的事情——毕竟，`any`无论如何，都能退回到普通的 JavaScript 体验。\n\n但是，使用`any`通常首先会破坏使用 TypeScript 的目的。你的程序类型越多，你获得的验证和工具就越多，这意味着你在编写代码时会遇到更少的错误。打开该[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)标志将对类型隐式推断为，当任何变量发出错误时都应用 `any` 类型。\n\n<img src=\"https://s2.loli.net/2022/02/22/Ir7T4vckJMsSnuK.png\" alt=\"image-20211113122642576\" style=\"zoom:40%;\" />\n\n- **`strictNullChecks`**\n\n默认情况下，值为`null`和`undefined`可分配给任何其他类型。这可以使编写一些代码更容易，但忘记处理`null`并且`undefined`是你代码无数错误的元凶 - 有些人认为这是一个[十亿美元的错误](https://www.youtube.com/watch?v=ybrQvs4x0Ps)！该[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)标志，使得操作`null`和`undefined`更加明确，它使我们不用担心是否*忘记*处理`null`和`undefined`。\n\n<img src=\"https://s2.loli.net/2022/02/22/wRlPY8gO9v1zkZa.png\" alt=\"image-20211113122914750\" style=\"zoom:50%;\" />\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-2、基础篇：TypeScript入门.md",
        "raw": "---\ntitle: 1-2、基础篇：TypeScript入门\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nswiper_index: 2\nswiper_cover: /img/recommend/recommend_02.jpg\nswiper_desc: 1-2、基础篇：TypeScript入门\nabbrlink: 20247\ndate: 2024-01-28 19:37:43\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 二、TypeScript入门\n\n## 2.1 发现问题\n\nJavaScript 中的每个值都有一组行为，您可以通过运行不同的操作来观察。这听起来很抽象，我们来举一个简单的例子，考虑我们可能对名为`message`的变量运行的一些操作：\n\n```js\n// 在 'message' 上访问属性 'toLowerCase'，并调用它\nmessage.toLowerCase();\n// 调用 'message'\nmessage();\n```\n\n如果我们分解它，第一行可运行的代码访问一个属性`toLowerCase`，然后调用它。第二个尝试 `message` 直接调用。\n\n但是假设我们不知道`message`。这很常见——我们无法可靠地说出尝试运行任何这些代码会得到什么结果。每个操作的行为完全取决于我们最初给`message`的赋值。\n\n- 可以调用`message`吗？\n- 它有`toLowerCase`这个属性吗？\n- 如果能，`toLowerCase`可以调用吗？\n- 如果这两个值都是可调用的，它们返回什么？\n\n这些问题的答案通常是我们在编写 JavaScript 时牢记在心的东西，我们必须希望所有细节都正确。\n\n假设`message`按以下方式定义：\n\n```js\nconst message = \"Hello World!\";\n```\n\n正如您可能猜到的，如果我们尝试运行`message.toLowerCase()`，我们只会得到相同的小写字符串。\n\n那第二行代码呢？如果您熟悉 JavaScript，您就会知道这会失败并出现异常：\n\n```shell\nTypeError: message is not a function\n```\n\n如果我们能避免这样的错误，那就太好了。\n\n当我们运行我们的代码时，我们的 JavaScript 运行时选择做什么的方式是通过确定值的*类型*——它具有什么样的行为和功能。这`TypeError`就是暗指的一部分- 它说字符串`\"Hello World!\"`不能作为函数调用。\n\n对于某些值，例如基本类型`string`和`number`，我们可以在运行时使用`typeof`运算符识别它们的类型。但是对于函数之类的其他东西，没有相应的运行时机制来识别它们的类型。例如，考虑这个函数：\n\n```js\nfunction fn(x) {\n  return x.flip();\n}\n```\n\n我们可以通过阅读代码*观察*到这个函数只有在给定一个具有可调用`flip`属性的对象时才能工作，但是 JavaScript 并没有以我们可以在代码运行时检查的方式来显示这些信息。在纯 JavaScript 中，告诉`fn`特定值做什么的**唯一方法**是调用它并查看会发生什么。这种行为使得在运行之前很难预测代码会做什么，这意味着在编写代码时更难知道代码会做什么。\n\n这样看来，*类型*是描述可以传递给`fn`哪些值会崩溃的概念。JavaScript 只真正提供*动态*类型——运行代码看看会发生什么。\n\n另一种方法是使用*静态*类型系统*在*运行*之前*预测预期的代码。\n\n## 2.2 **静态类型检查**\n\n回想一下`TypeError`我们之前尝试将 `string`作为函数调用的情况。 *大多数人*不喜欢在运行他们的代码时出现任何类型的错误 - 这些被认为是错误！当我们编写新代码时，我们会尽量避免引入新的错误。\n\n理想情况下，我们可以有一个工具来帮助我们*在*代码运行*之前*发现这些错误。这就是像 TypeScript 这样的静态类型检查器所做的。 *静态类型系统*描述了当我们运行程序时我们的值的形状和行为。像 TypeScript 这样的类型检查器，告诉我们什么时候事情可能会出轨。\n\n<img src=\"https://s2.loli.net/2022/02/22/5yhsbTCF7cqVGNQ.png\" alt=\"image-20211109134610557\" style=\"zoom:50%;\" align=\"left\" />\n\n在我们运行代码之前，使用 TypeScript 运行最后一个示例会给我们一条错误消息。\n\n## 2.3 **非异常故障**\n\n到目前为止，我们一直在讨论运行时错误——JavaScript 运行时告诉我们它认为某些东西是无意义的情况。出现这些情况是因为[ECMAScript 规范](https://tc39.github.io/ecma262/)明确说明了语言在遇到意外情况时应该如何表现。\n\n例如，规范说尝试调用不可调用的东西应该抛出错误。也许这听起来像是“明显的行为”，但您可以想象访问对象上不存在的属性也应该抛出错误。相反，JavaScript 给了我们不同的行为并返回值`undefined`：\n\n```js\nconst user = {\n  name: \"小千\",\n  age: 26,\n};\nuser.location; // 返回 undefined\n```\n\n最终，静态类型系统要求必须调用哪些代码，应该在其系统中标记，即使它是不会立即抛出错误的“有效”JavaScript。比如：在 TypeScript 中，以下代码会产生关于`location`未定义的错误：\n\n<img src=\"https://s2.loli.net/2022/02/22/Qqo8BZmtJnGC1D4.png\" alt=\"image-20211109141050215\" style=\"zoom:50%;\" />\n\nTypeScript 可以在我们的程序中捕获*很多*合法的错误。例如：\n\n- 错别字\n  ![](/img/TypeScript/01-04.png)\n- 未调用的函数\n\n<img src=\"https://s2.loli.net/2022/02/22/U1MmrPyjdbkueRC.png\" alt=\"image-20211109142053954\" style=\"zoom:50%;\" align=\"left\" />\n\n- 或基本逻辑错误\n\n![](/img/TypeScript/01-06.png)\n\n## 2.4 **使用工具**\n\n当我们在代码中出错时，TypeScript 可以捕获错误。这很好，但 TypeScript 也*可以首先*防止我们犯这些错误。\n\n类型检查器有能力帮助我们来检查，诸如是否正在访问变量和其他属性的正确属性。一旦有了这些信息，它还可以开始*建议*您可能想要使用的属性。\n\n这意味着当利用工具来编辑 TypeScript 代码，核心类型检查器可以在编辑器中键入代码时，提供错误消息和代码完成。这是我们在谈论 TypeScript 中的工具时经常提到的部分内容。\n\n<img src=\"https://s2.loli.net/2022/02/22/qolAfbMnVIcXvys.png\" alt=\"image-20211113085757666\" style=\"zoom: 25%;\" align=\"left\" />\n\nTypeScript 非常重视工具。支持 TypeScript 的编辑器可以提供“快速修复”以自动修复错误、重构以轻松重新组织代码的能力，以及用于跳转到变量定义或查找给定变量的所有引用的有用导航功能。所有这些都建立在类型检查器之上，并且是完全跨平台的，因此[您最喜欢的编辑器](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)可能[具有可用的 TypeScript 支持](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)。\n\n## 2.5 `tsc`编译器\n\n我们一直在谈论类型检查，但我们还没有使用我们的类型*检查器*。让我们认识一下我们的新朋友`tsc`TypeScript 编译器。首先，我们需要通过 npm 获取它。\n\n```she\nnpm install -g typescript\n```\n\n这将全局安装 TypeScript 编译器。\n\n现在让我们移动到一个空文件夹，并尝试编写我们的第一个 TypeScript 程序`hello.ts`：\n\n**01-ts-basics/hello.ts**\n\n```ts\n// 你好，世界\nconsole.log(\"Hello World\");\n```\n\n注意这里没有多余的装饰；这个“hello world”程序看起来与您在 JavaScript 中为“hello world”程序编写的程序相同。现在让我们通过运行`tsc`由`typescript`包为我们打包编译它：\n\n```shell\n[felix] 01-ts-basics $ tsc hello.ts\n```\n\n我们跑了`tsc`，什么也没发生！嗯，没有类型错误，所以我们没有在控制台中得到任何输出，因为没有什么可报告的。\n\n<img src=\"https://s2.loli.net/2022/02/22/APiNb5FzvuwGlZk.png\" alt=\"image-20211113093244339\" style=\"zoom: 50%;\" align=\"left\"/>\n\n但是再检查一下 - 我们得到了一些*文件*输出。如果我们查看当前目录，我们会发现有两个文件`hello.js`在`hello.ts`. 这是我们的`hello.ts`文件在`tsc` *编译*或*转换*为纯 JavaScript 文件后的输出。\n\n<img src=\"https://s2.loli.net/2022/02/22/ctI9MPpSY1y8uLr.png\" alt=\"image-20211113093559374\" style=\"zoom: 50%;\" align=\"left\" />\n\n如果我们检查`hello.js`，我们将看到 TypeScript 在处理`.ts`文件后吐出的内容：\n\n```js\n// 你好，世界\nconsole.log(\"Hello World\");\n```\n\n在这种情况下，TypeScript 几乎没有要转换的内容，因此它看起来与我们编写的内容相同。编译器会尝试编译出清晰可读的代码，看起来像一个人写的东西。注释也给我们保留下来。\n\n如果我们*确实*引入了类型检查错误呢？让我们重写`hello.ts`：\n\n```ts\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`);\n}\n\ngreet(\"小千\");\n```\n\n如果我们`tsc hello.ts`再次运行，我们在命令行上收到了错误！\n\n<img src=\"https://s2.loli.net/2022/02/22/QNL3DlBHYUbxu9Z.png\" alt=\"image-20211113095515775\" style=\"zoom:50%;\" align=\"left\"/>\n\nTypeScript 告诉我们忘记将参数传递给`greet`函数，这是理所当然的。到目前为止，我们只编写了标准的 JavaScript，但是类型检查仍然能够发现我们代码的其他问题。感谢TypeScript！\n\n## 2.6 发出错误\n\n从上一个示例中，你可能没有注意到的一件事，就是是我们的`hello.js`文件再次更改。如果我们打开该文件，那么我们会看到内容仍然与我们的输入文件基本相同。\n\n```js\n// 你好，世界\nconsole.log(\"Hello World\");\nfunction greet(person, date) {\n  console.log(\"Hello \" + person + \", today is \" + date + \"!\");\n}\ngreet(\"小千\");\n```\n\n鉴于`tsc`报告了有关我们代码的错误这一事实，这可能有点令人惊讶，但这是基于 TypeScript 的核心价值观之一：大多数情况下，*你*会比 TypeScript 更了解发生了什么。\n\n再回顾一下前面的内容，类型检查代码限制了我们可以运行的程序种类，因此需要权衡类型检查器认为可接受的类型。大多数情况下这没问题，但在某些情况下，这些检查会妨碍到我们。例如，想象自己将 JavaScript 代码迁移到 TypeScript 并引入类型检查错误。最终，你将开始为类型检查器进行代码清理，但原始 JavaScript 代码已经可以运行了！为什么非要将我们的JS代码转换为 TypeScript 代码，来去阻止运行它呢？\n\n所以 TypeScript 默认不会妨碍我们代码的运行，因为这些JS在宿主环境里运行时没有问题的。当然，随着时间的推移，我们可能希望对错误更加防御，并使 TypeScript 的行为更加严格。在这种情况下，我们可以使用[`noEmitOnError`](https://www.typescriptlang.org/tsconfig#noEmitOnError)编译器选项。尝试更改我们的`hello.ts`文件，并`tsc`使用该选项重新编译：\n\n```\ntsc --noEmitOnError hello.ts\n```\n\n![](/img/TypeScript/02-04.png)\n\n你会注意到`hello.js`永远不会更新。\n\n## 2.7 显式类型\n\n到现在为止，我们还没有告诉 typescript `person`或者`date`是什么类型。当我们编辑代码时会告诉 TypeScript `person`是一个`string`，那`date`应该是一个`Date`对象。\n\n有了这个，TypeScript 可以告诉我们其他`greet`可能被错误调用的情况。例如修改一下 `hello.ts`代码：\n\n```js\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n```\n\n![](/img/TypeScript/02-05.png)\n\n嗯？TypeScript 在我们的第二个参数上报告了一个错误，这是为什么呢？\n\n也许令人惊讶的是，`Date()`在 JavaScript 中调用会返回一个`string`。可以使用`new Date()`满足我们的期望,快速修复错误：\n\n```js\nfunction greet(person: string, date: Date) {\n  console.log(`Hello ${person}, today is ${date.toDateString()}!`);\n}\n\ngreet(\"小锋\", new Date());\n```\n\n![](/img/TypeScript/02-06.png)\n\n成功的编译输出了 `hello.js`。\n\n请记住，我们并不总是必须给变量编写明确的类型注释。在许多情况下，TypeScript 可以为我们自动*推断*（或“找出”）类型，即使我们忽略定义这些类型。比如：\n\n<img src=\"https://s2.loli.net/2022/02/22/N2pXBbY6LRwoaC1.png\" alt=\"image-20211113111924590\" style=\"zoom:50%;\" align=\"left\" />\n\n这里没有给 msg 指定具体的类型，typescript 会根据函数的实参来自动推断类型。这是一个特性，当类型系统最终会推断出相同的类型时，最好不要添加类型注释。\n\n## 2.8 擦除类型\n\n让我们来仔细看看，当我们 `tsc`编译上面的代码会输出的什么样的JavaScript，观察 `hello.js`\n\n![](/img/TypeScript/02-08.png)\n\n这里要注意两点：\n\n1. 我们的`person`和`date`参数不再有类型注释。\n2. 我们的“模板字符串” - 使用反引号（`字符）的字符串 - 被转换为带有连接 ( + ) 的纯字符串。\n\n稍后会详细介绍第二点，现在让我们专注于第一点。类型注释不是 JavaScript 的一部分（或者说 ECMAScript 是落后的），因此实际上没有任何浏览器，或其他运行时可以不加修改地运行 TypeScript。这就是 TypeScript 首先需要编译器的原因——它需要某种方式来剥离或转换任何特定于 TypeScript 的代码，以便我们可以运行它。大多数 TypeScript 特定的代码都被删除了。\n\n> **请记住**：类型注释永远不会改变程序的运行时行为。\n\n## 2.9 降级编译\n\n与上面的另一个区别是我们的模板字符串是从：\n\n```js\n`Hello ${person}, today is ${date.toDateString()}!`;\n```\n\n到：\n\n```js\n\"Hello \" + person + \", today is \" + date.toDateString() + \"!\";\n```\n\n为什么会这样？\n\n模板字符串是 ECMAScript 版本的一个特性，称为 ECMAScript 2015（又名 ECMAScript 6、ES2015、ES6 等）。TypeScript 能够将代码从较新版本的 ECMAScript 重写为旧版本，例如 ECMAScript 3 或 ECMAScript 5（又名 ES3 和 ES5）。这种从更新或“更高”版本的 ECMAScript ，向下移动到旧版本或“更低”版本的过程有时称为*降级*。\n\n默认情况下，TypeScript 以 ES3 为目标，这是一个非常旧的 ECMAScript 版本。通过使用[`target`](https://www.typescriptlang.org/tsconfig#target)选项，我们可以选择更新一些的内容。运行`--target es2015`TypeScript 以针对 ECMAScript 2015进行更改，这意味着代码应该能够在支持 ECMAScript 2015 的任何地方运行。所以运行`tsc --target es2015 hello.ts`会给我们以下输出：\n\n<img src=\"https://s2.loli.net/2022/02/22/3BbKfisq9htp4nr.png\" alt=\"image-20211113113644658\" style=\"zoom:33%;\" />\n\n> 虽然默认目标是 ES3，但当前绝大多数浏览器都支持 ES2015。因此，大多数开发人员可以安全地将 ES2015 或更高版本指定为目标，除非考虑与某些旧浏览器的兼容性。\n\n## 2.10 严格模式\n\n不同的用户使用 TypeScript 在类型检查器中，希望检查的严格程度不同。有些人正在寻找更宽松的验证体验，它可以帮助仅验证其程序的某些部分，并且仍然拥有不错的工具。这是 TypeScript 的默认体验，其中类型是可选的，推理采用最宽松的类型，并且不检查潜在的`null`/`undefined`值，就像`tsc`面对错误时如何编译生成JS文件一样。如果你要迁移现有的 JavaScript，这可能是理想的第一步。\n\n相比之下，许多用户更喜欢让 TypeScript 尽可能多地立即验证，这就是该语言也提供严格性设置的原因。这些严格性设置将静态类型检查，从开关（无论您的代码是否被检查）转变为更接近于拨号的东西。你把这个拨盘调得越远，TypeScript 就会为你检查越多。这可能需要一些额外的工作，但总的来说，从长远来看，它是物有所值的，并且可以实现更彻底的检查和更准确的工具。如果可能，新的代码库应该始终打开这些严格性检查。\n\nTypeScript 有几个可以打开或关闭的类型检查严格标志，除非另有说明，否则我们所有的示例都将在启用所有这些标志的情况下编写。在命令行里设置[`strict`](https://www.typescriptlang.org/tsconfig#strict) ，或在[`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)中配置`\"strict\": true` 将它打开。\n\n![](/img/TypeScript/02-10.png)\n\n![](/img/TypeScript/02-11.png)\n\n以上两个案例错误是因为我们配置了 `--strict true`。\n\n同时我们可以单独选择配置它们。我们应该知道的最典型的两个是[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)和[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)。\n\n- **`noImplicitAny`**\n\n回想一下，在某些地方，TypeScript 不会尝试为我们推断类型，而是退回到最宽松的类型：`any`。这并不是可能发生的最糟糕的事情——毕竟，`any`无论如何，都能退回到普通的 JavaScript 体验。\n\n但是，使用`any`通常首先会破坏使用 TypeScript 的目的。你的程序类型越多，你获得的验证和工具就越多，这意味着你在编写代码时会遇到更少的错误。打开该[`noImplicitAny`](https://www.typescriptlang.org/tsconfig#noImplicitAny)标志将对类型隐式推断为，当任何变量发出错误时都应用 `any` 类型。\n\n<img src=\"https://s2.loli.net/2022/02/22/Ir7T4vckJMsSnuK.png\" alt=\"image-20211113122642576\" style=\"zoom:40%;\" />\n\n- **`strictNullChecks`**\n\n默认情况下，值为`null`和`undefined`可分配给任何其他类型。这可以使编写一些代码更容易，但忘记处理`null`并且`undefined`是你代码无数错误的元凶 - 有些人认为这是一个[十亿美元的错误](https://www.youtube.com/watch?v=ybrQvs4x0Ps)！该[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)标志，使得操作`null`和`undefined`更加明确，它使我们不用担心是否*忘记*处理`null`和`undefined`。\n\n<img src=\"https://s2.loli.net/2022/02/22/wRlPY8gO9v1zkZa.png\" alt=\"image-20211113122914750\" style=\"zoom:50%;\" />\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-2、基础篇：TypeScript入门",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao2000m94v3120kdai9",
        "content": "<h1 id=\"二、TypeScript入门\"><a href=\"#二、TypeScript入门\" class=\"headerlink\" title=\"二、TypeScript入门\"></a>二、TypeScript入门</h1><h2 id=\"2-1-发现问题\"><a href=\"#2-1-发现问题\" class=\"headerlink\" title=\"2.1 发现问题\"></a>2.1 发现问题</h2><p>JavaScript 中的每个值都有一组行为，您可以通过运行不同的操作来观察。这听起来很抽象，我们来举一个简单的例子，考虑我们可能对名为<code>message</code>的变量运行的一些操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 &#x27;message&#x27; 上访问属性 &#x27;toLowerCase&#x27;，并调用它</span></span><br><span class=\"line\">message.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\"><span class=\"comment\">// 调用 &#x27;message&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">message</span>();</span><br></pre></td></tr></table></figure>\n\n<p>如果我们分解它，第一行可运行的代码访问一个属性<code>toLowerCase</code>，然后调用它。第二个尝试 <code>message</code> 直接调用。</p>\n<p>但是假设我们不知道<code>message</code>。这很常见——我们无法可靠地说出尝试运行任何这些代码会得到什么结果。每个操作的行为完全取决于我们最初给<code>message</code>的赋值。</p>\n<ul>\n<li>可以调用<code>message</code>吗？</li>\n<li>它有<code>toLowerCase</code>这个属性吗？</li>\n<li>如果能，<code>toLowerCase</code>可以调用吗？</li>\n<li>如果这两个值都是可调用的，它们返回什么？</li>\n</ul>\n<p>这些问题的答案通常是我们在编写 JavaScript 时牢记在心的东西，我们必须希望所有细节都正确。</p>\n<p>假设<code>message</code>按以下方式定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>正如您可能猜到的，如果我们尝试运行<code>message.toLowerCase()</code>，我们只会得到相同的小写字符串。</p>\n<p>那第二行代码呢？如果您熟悉 JavaScript，您就会知道这会失败并出现异常：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: message is not a function</span><br></pre></td></tr></table></figure>\n\n<p>如果我们能避免这样的错误，那就太好了。</p>\n<p>当我们运行我们的代码时，我们的 JavaScript 运行时选择做什么的方式是通过确定值的<em>类型</em>——它具有什么样的行为和功能。这<code>TypeError</code>就是暗指的一部分- 它说字符串<code>&quot;Hello World!&quot;</code>不能作为函数调用。</p>\n<p>对于某些值，例如基本类型<code>string</code>和<code>number</code>，我们可以在运行时使用<code>typeof</code>运算符识别它们的类型。但是对于函数之类的其他东西，没有相应的运行时机制来识别它们的类型。例如，考虑这个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"title function_\">flip</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过阅读代码<em>观察</em>到这个函数只有在给定一个具有可调用<code>flip</code>属性的对象时才能工作，但是 JavaScript 并没有以我们可以在代码运行时检查的方式来显示这些信息。在纯 JavaScript 中，告诉<code>fn</code>特定值做什么的<strong>唯一方法</strong>是调用它并查看会发生什么。这种行为使得在运行之前很难预测代码会做什么，这意味着在编写代码时更难知道代码会做什么。</p>\n<p>这样看来，<em>类型</em>是描述可以传递给<code>fn</code>哪些值会崩溃的概念。JavaScript 只真正提供<em>动态</em>类型——运行代码看看会发生什么。</p>\n<p>另一种方法是使用<em>静态</em>类型系统<em>在</em>运行<em>之前</em>预测预期的代码。</p>\n<h2 id=\"2-2-静态类型检查\"><a href=\"#2-2-静态类型检查\" class=\"headerlink\" title=\"2.2 静态类型检查\"></a>2.2 <strong>静态类型检查</strong></h2><p>回想一下<code>TypeError</code>我们之前尝试将 <code>string</code>作为函数调用的情况。 <em>大多数人</em>不喜欢在运行他们的代码时出现任何类型的错误 - 这些被认为是错误！当我们编写新代码时，我们会尽量避免引入新的错误。</p>\n<p>理想情况下，我们可以有一个工具来帮助我们<em>在</em>代码运行<em>之前</em>发现这些错误。这就是像 TypeScript 这样的静态类型检查器所做的。 <em>静态类型系统</em>描述了当我们运行程序时我们的值的形状和行为。像 TypeScript 这样的类型检查器，告诉我们什么时候事情可能会出轨。</p>\n<img src=\"https://s2.loli.net/2022/02/22/5yhsbTCF7cqVGNQ.png\" alt=\"image-20211109134610557\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>在我们运行代码之前，使用 TypeScript 运行最后一个示例会给我们一条错误消息。</p>\n<h2 id=\"2-3-非异常故障\"><a href=\"#2-3-非异常故障\" class=\"headerlink\" title=\"2.3 非异常故障\"></a>2.3 <strong>非异常故障</strong></h2><p>到目前为止，我们一直在讨论运行时错误——JavaScript 运行时告诉我们它认为某些东西是无意义的情况。出现这些情况是因为<a href=\"https://tc39.github.io/ecma262/\">ECMAScript 规范</a>明确说明了语言在遇到意外情况时应该如何表现。</p>\n<p>例如，规范说尝试调用不可调用的东西应该抛出错误。也许这听起来像是“明显的行为”，但您可以想象访问对象上不存在的属性也应该抛出错误。相反，JavaScript 给了我们不同的行为并返回值<code>undefined</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;小千&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">26</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">user.<span class=\"property\">location</span>; <span class=\"comment\">// 返回 undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>最终，静态类型系统要求必须调用哪些代码，应该在其系统中标记，即使它是不会立即抛出错误的“有效”JavaScript。比如：在 TypeScript 中，以下代码会产生关于<code>location</code>未定义的错误：</p>\n<img src=\"https://s2.loli.net/2022/02/22/Qqo8BZmtJnGC1D4.png\" alt=\"image-20211109141050215\" style=\"zoom:50%;\" />\n\n<p>TypeScript 可以在我们的程序中捕获<em>很多</em>合法的错误。例如：</p>\n<ul>\n<li>错别字<br><img src=\"/img/TypeScript/01-04.png\"></li>\n<li>未调用的函数</li>\n</ul>\n<img src=\"https://s2.loli.net/2022/02/22/U1MmrPyjdbkueRC.png\" alt=\"image-20211109142053954\" style=\"zoom:50%;\" align=\"left\" />\n\n<ul>\n<li>或基本逻辑错误</li>\n</ul>\n<p><img src=\"/img/TypeScript/01-06.png\"></p>\n<h2 id=\"2-4-使用工具\"><a href=\"#2-4-使用工具\" class=\"headerlink\" title=\"2.4 使用工具\"></a>2.4 <strong>使用工具</strong></h2><p>当我们在代码中出错时，TypeScript 可以捕获错误。这很好，但 TypeScript 也<em>可以首先</em>防止我们犯这些错误。</p>\n<p>类型检查器有能力帮助我们来检查，诸如是否正在访问变量和其他属性的正确属性。一旦有了这些信息，它还可以开始<em>建议</em>您可能想要使用的属性。</p>\n<p>这意味着当利用工具来编辑 TypeScript 代码，核心类型检查器可以在编辑器中键入代码时，提供错误消息和代码完成。这是我们在谈论 TypeScript 中的工具时经常提到的部分内容。</p>\n<img src=\"https://s2.loli.net/2022/02/22/qolAfbMnVIcXvys.png\" alt=\"image-20211113085757666\" style=\"zoom: 25%;\" align=\"left\" />\n\n<p>TypeScript 非常重视工具。支持 TypeScript 的编辑器可以提供“快速修复”以自动修复错误、重构以轻松重新组织代码的能力，以及用于跳转到变量定义或查找给定变量的所有引用的有用导航功能。所有这些都建立在类型检查器之上，并且是完全跨平台的，因此<a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">您最喜欢的编辑器</a>可能<a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">具有可用的 TypeScript 支持</a>。</p>\n<h2 id=\"2-5-tsc编译器\"><a href=\"#2-5-tsc编译器\" class=\"headerlink\" title=\"2.5 tsc编译器\"></a>2.5 <code>tsc</code>编译器</h2><p>我们一直在谈论类型检查，但我们还没有使用我们的类型<em>检查器</em>。让我们认识一下我们的新朋友<code>tsc</code>TypeScript 编译器。首先，我们需要通过 npm 获取它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n\n<p>这将全局安装 TypeScript 编译器。</p>\n<p>现在让我们移动到一个空文件夹，并尝试编写我们的第一个 TypeScript 程序<code>hello.ts</code>：</p>\n<p><strong>01-ts-basics&#x2F;hello.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意这里没有多余的装饰；这个“hello world”程序看起来与您在 JavaScript 中为“hello world”程序编写的程序相同。现在让我们通过运行<code>tsc</code>由<code>typescript</code>包为我们打包编译它：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[felix] 01-ts-basics $ tsc hello.ts</span><br></pre></td></tr></table></figure>\n\n<p>我们跑了<code>tsc</code>，什么也没发生！嗯，没有类型错误，所以我们没有在控制台中得到任何输出，因为没有什么可报告的。</p>\n<img src=\"https://s2.loli.net/2022/02/22/APiNb5FzvuwGlZk.png\" alt=\"image-20211113093244339\" style=\"zoom: 50%;\" align=\"left\"/>\n\n<p>但是再检查一下 - 我们得到了一些<em>文件</em>输出。如果我们查看当前目录，我们会发现有两个文件<code>hello.js</code>在<code>hello.ts</code>. 这是我们的<code>hello.ts</code>文件在<code>tsc</code> <em>编译</em>或<em>转换</em>为纯 JavaScript 文件后的输出。</p>\n<img src=\"https://s2.loli.net/2022/02/22/ctI9MPpSY1y8uLr.png\" alt=\"image-20211113093559374\" style=\"zoom: 50%;\" align=\"left\" />\n\n<p>如果我们检查<code>hello.js</code>，我们将看到 TypeScript 在处理<code>.ts</code>文件后吐出的内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，TypeScript 几乎没有要转换的内容，因此它看起来与我们编写的内容相同。编译器会尝试编译出清晰可读的代码，看起来像一个人写的东西。注释也给我们保留下来。</p>\n<p>如果我们<em>确实</em>引入了类型检查错误呢？让我们重写<code>hello.ts</code>：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person, date</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小千&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果我们<code>tsc hello.ts</code>再次运行，我们在命令行上收到了错误！</p>\n<img src=\"https://s2.loli.net/2022/02/22/QNL3DlBHYUbxu9Z.png\" alt=\"image-20211113095515775\" style=\"zoom:50%;\" align=\"left\"/>\n\n<p>TypeScript 告诉我们忘记将参数传递给<code>greet</code>函数，这是理所当然的。到目前为止，我们只编写了标准的 JavaScript，但是类型检查仍然能够发现我们代码的其他问题。感谢TypeScript！</p>\n<h2 id=\"2-6-发出错误\"><a href=\"#2-6-发出错误\" class=\"headerlink\" title=\"2.6 发出错误\"></a>2.6 发出错误</h2><p>从上一个示例中，你可能没有注意到的一件事，就是是我们的<code>hello.js</code>文件再次更改。如果我们打开该文件，那么我们会看到内容仍然与我们的输入文件基本相同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person, date</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello &quot;</span> + person + <span class=\"string\">&quot;, today is &quot;</span> + date + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小千&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>鉴于<code>tsc</code>报告了有关我们代码的错误这一事实，这可能有点令人惊讶，但这是基于 TypeScript 的核心价值观之一：大多数情况下，<em>你</em>会比 TypeScript 更了解发生了什么。</p>\n<p>再回顾一下前面的内容，类型检查代码限制了我们可以运行的程序种类，因此需要权衡类型检查器认为可接受的类型。大多数情况下这没问题，但在某些情况下，这些检查会妨碍到我们。例如，想象自己将 JavaScript 代码迁移到 TypeScript 并引入类型检查错误。最终，你将开始为类型检查器进行代码清理，但原始 JavaScript 代码已经可以运行了！为什么非要将我们的JS代码转换为 TypeScript 代码，来去阻止运行它呢？</p>\n<p>所以 TypeScript 默认不会妨碍我们代码的运行，因为这些JS在宿主环境里运行时没有问题的。当然，随着时间的推移，我们可能希望对错误更加防御，并使 TypeScript 的行为更加严格。在这种情况下，我们可以使用<a href=\"https://www.typescriptlang.org/tsconfig#noEmitOnError\"><code>noEmitOnError</code></a>编译器选项。尝试更改我们的<code>hello.ts</code>文件，并<code>tsc</code>使用该选项重新编译：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --noEmitOnError hello.ts</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-04.png\"></p>\n<p>你会注意到<code>hello.js</code>永远不会更新。</p>\n<h2 id=\"2-7-显式类型\"><a href=\"#2-7-显式类型\" class=\"headerlink\" title=\"2.7 显式类型\"></a>2.7 显式类型</h2><p>到现在为止，我们还没有告诉 typescript <code>person</code>或者<code>date</code>是什么类型。当我们编辑代码时会告诉 TypeScript <code>person</code>是一个<code>string</code>，那<code>date</code>应该是一个<code>Date</code>对象。</p>\n<p>有了这个，TypeScript 可以告诉我们其他<code>greet</code>可能被错误调用的情况。例如修改一下 <code>hello.ts</code>代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person: string, date: <span class=\"built_in\">Date</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-05.png\"></p>\n<p>嗯？TypeScript 在我们的第二个参数上报告了一个错误，这是为什么呢？</p>\n<p>也许令人惊讶的是，<code>Date()</code>在 JavaScript 中调用会返回一个<code>string</code>。可以使用<code>new Date()</code>满足我们的期望,快速修复错误：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person: string, date: <span class=\"built_in\">Date</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小锋&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-06.png\"></p>\n<p>成功的编译输出了 <code>hello.js</code>。</p>\n<p>请记住，我们并不总是必须给变量编写明确的类型注释。在许多情况下，TypeScript 可以为我们自动<em>推断</em>（或“找出”）类型，即使我们忽略定义这些类型。比如：</p>\n<img src=\"https://s2.loli.net/2022/02/22/N2pXBbY6LRwoaC1.png\" alt=\"image-20211113111924590\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>这里没有给 msg 指定具体的类型，typescript 会根据函数的实参来自动推断类型。这是一个特性，当类型系统最终会推断出相同的类型时，最好不要添加类型注释。</p>\n<h2 id=\"2-8-擦除类型\"><a href=\"#2-8-擦除类型\" class=\"headerlink\" title=\"2.8 擦除类型\"></a>2.8 擦除类型</h2><p>让我们来仔细看看，当我们 <code>tsc</code>编译上面的代码会输出的什么样的JavaScript，观察 <code>hello.js</code></p>\n<p><img src=\"/img/TypeScript/02-08.png\"></p>\n<p>这里要注意两点：</p>\n<ol>\n<li>我们的<code>person</code>和<code>date</code>参数不再有类型注释。</li>\n<li>我们的“模板字符串” - 使用反引号（&#96;字符）的字符串 - 被转换为带有连接 ( + ) 的纯字符串。</li>\n</ol>\n<p>稍后会详细介绍第二点，现在让我们专注于第一点。类型注释不是 JavaScript 的一部分（或者说 ECMAScript 是落后的），因此实际上没有任何浏览器，或其他运行时可以不加修改地运行 TypeScript。这就是 TypeScript 首先需要编译器的原因——它需要某种方式来剥离或转换任何特定于 TypeScript 的代码，以便我们可以运行它。大多数 TypeScript 特定的代码都被删除了。</p>\n<blockquote>\n<p><strong>请记住</strong>：类型注释永远不会改变程序的运行时行为。</p>\n</blockquote>\n<h2 id=\"2-9-降级编译\"><a href=\"#2-9-降级编译\" class=\"headerlink\" title=\"2.9 降级编译\"></a>2.9 降级编译</h2><p>与上面的另一个区别是我们的模板字符串是从：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>到：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello &quot;</span> + person + <span class=\"string\">&quot;, today is &quot;</span> + date.<span class=\"title function_\">toDateString</span>() + <span class=\"string\">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>为什么会这样？</p>\n<p>模板字符串是 ECMAScript 版本的一个特性，称为 ECMAScript 2015（又名 ECMAScript 6、ES2015、ES6 等）。TypeScript 能够将代码从较新版本的 ECMAScript 重写为旧版本，例如 ECMAScript 3 或 ECMAScript 5（又名 ES3 和 ES5）。这种从更新或“更高”版本的 ECMAScript ，向下移动到旧版本或“更低”版本的过程有时称为<em>降级</em>。</p>\n<p>默认情况下，TypeScript 以 ES3 为目标，这是一个非常旧的 ECMAScript 版本。通过使用<a href=\"https://www.typescriptlang.org/tsconfig#target\"><code>target</code></a>选项，我们可以选择更新一些的内容。运行<code>--target es2015</code>TypeScript 以针对 ECMAScript 2015进行更改，这意味着代码应该能够在支持 ECMAScript 2015 的任何地方运行。所以运行<code>tsc --target es2015 hello.ts</code>会给我们以下输出：</p>\n<img src=\"https://s2.loli.net/2022/02/22/3BbKfisq9htp4nr.png\" alt=\"image-20211113113644658\" style=\"zoom:33%;\" />\n\n<blockquote>\n<p>虽然默认目标是 ES3，但当前绝大多数浏览器都支持 ES2015。因此，大多数开发人员可以安全地将 ES2015 或更高版本指定为目标，除非考虑与某些旧浏览器的兼容性。</p>\n</blockquote>\n<h2 id=\"2-10-严格模式\"><a href=\"#2-10-严格模式\" class=\"headerlink\" title=\"2.10 严格模式\"></a>2.10 严格模式</h2><p>不同的用户使用 TypeScript 在类型检查器中，希望检查的严格程度不同。有些人正在寻找更宽松的验证体验，它可以帮助仅验证其程序的某些部分，并且仍然拥有不错的工具。这是 TypeScript 的默认体验，其中类型是可选的，推理采用最宽松的类型，并且不检查潜在的<code>null</code>&#x2F;<code>undefined</code>值，就像<code>tsc</code>面对错误时如何编译生成JS文件一样。如果你要迁移现有的 JavaScript，这可能是理想的第一步。</p>\n<p>相比之下，许多用户更喜欢让 TypeScript 尽可能多地立即验证，这就是该语言也提供严格性设置的原因。这些严格性设置将静态类型检查，从开关（无论您的代码是否被检查）转变为更接近于拨号的东西。你把这个拨盘调得越远，TypeScript 就会为你检查越多。这可能需要一些额外的工作，但总的来说，从长远来看，它是物有所值的，并且可以实现更彻底的检查和更准确的工具。如果可能，新的代码库应该始终打开这些严格性检查。</p>\n<p>TypeScript 有几个可以打开或关闭的类型检查严格标志，除非另有说明，否则我们所有的示例都将在启用所有这些标志的情况下编写。在命令行里设置<a href=\"https://www.typescriptlang.org/tsconfig#strict\"><code>strict</code></a> ，或在<a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\"><code>tsconfig.json</code></a>中配置<code>&quot;strict&quot;: true</code> 将它打开。</p>\n<p><img src=\"/img/TypeScript/02-10.png\"></p>\n<p><img src=\"/img/TypeScript/02-11.png\"></p>\n<p>以上两个案例错误是因为我们配置了 <code>--strict true</code>。</p>\n<p>同时我们可以单独选择配置它们。我们应该知道的最典型的两个是<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"><code>noImplicitAny</code></a>和<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a>。</p>\n<ul>\n<li><strong><code>noImplicitAny</code></strong></li>\n</ul>\n<p>回想一下，在某些地方，TypeScript 不会尝试为我们推断类型，而是退回到最宽松的类型：<code>any</code>。这并不是可能发生的最糟糕的事情——毕竟，<code>any</code>无论如何，都能退回到普通的 JavaScript 体验。</p>\n<p>但是，使用<code>any</code>通常首先会破坏使用 TypeScript 的目的。你的程序类型越多，你获得的验证和工具就越多，这意味着你在编写代码时会遇到更少的错误。打开该<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"><code>noImplicitAny</code></a>标志将对类型隐式推断为，当任何变量发出错误时都应用 <code>any</code> 类型。</p>\n<img src=\"https://s2.loli.net/2022/02/22/Ir7T4vckJMsSnuK.png\" alt=\"image-20211113122642576\" style=\"zoom:40%;\" />\n\n<ul>\n<li><strong><code>strictNullChecks</code></strong></li>\n</ul>\n<p>默认情况下，值为<code>null</code>和<code>undefined</code>可分配给任何其他类型。这可以使编写一些代码更容易，但忘记处理<code>null</code>并且<code>undefined</code>是你代码无数错误的元凶 - 有些人认为这是一个<a href=\"https://www.youtube.com/watch?v=ybrQvs4x0Ps\">十亿美元的错误</a>！该<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a>标志，使得操作<code>null</code>和<code>undefined</code>更加明确，它使我们不用担心是否<em>忘记</em>处理<code>null</code>和<code>undefined</code>。</p>\n<img src=\"https://s2.loli.net/2022/02/22/wRlPY8gO9v1zkZa.png\" alt=\"image-20211113122914750\" style=\"zoom:50%;\" />\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"二、TypeScript入门\"><a href=\"#二、TypeScript入门\" class=\"headerlink\" title=\"二、TypeScript入门\"></a>二、TypeScript入门</h1><h2 id=\"2-1-发现问题\"><a href=\"#2-1-发现问题\" class=\"headerlink\" title=\"2.1 发现问题\"></a>2.1 发现问题</h2><p>JavaScript 中的每个值都有一组行为，您可以通过运行不同的操作来观察。这听起来很抽象，我们来举一个简单的例子，考虑我们可能对名为<code>message</code>的变量运行的一些操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 &#x27;message&#x27; 上访问属性 &#x27;toLowerCase&#x27;，并调用它</span></span><br><span class=\"line\">message.<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\"><span class=\"comment\">// 调用 &#x27;message&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">message</span>();</span><br></pre></td></tr></table></figure>\n\n<p>如果我们分解它，第一行可运行的代码访问一个属性<code>toLowerCase</code>，然后调用它。第二个尝试 <code>message</code> 直接调用。</p>\n<p>但是假设我们不知道<code>message</code>。这很常见——我们无法可靠地说出尝试运行任何这些代码会得到什么结果。每个操作的行为完全取决于我们最初给<code>message</code>的赋值。</p>\n<ul>\n<li>可以调用<code>message</code>吗？</li>\n<li>它有<code>toLowerCase</code>这个属性吗？</li>\n<li>如果能，<code>toLowerCase</code>可以调用吗？</li>\n<li>如果这两个值都是可调用的，它们返回什么？</li>\n</ul>\n<p>这些问题的答案通常是我们在编写 JavaScript 时牢记在心的东西，我们必须希望所有细节都正确。</p>\n<p>假设<code>message</code>按以下方式定义：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>正如您可能猜到的，如果我们尝试运行<code>message.toLowerCase()</code>，我们只会得到相同的小写字符串。</p>\n<p>那第二行代码呢？如果您熟悉 JavaScript，您就会知道这会失败并出现异常：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">TypeError: message is not a function</span><br></pre></td></tr></table></figure>\n\n<p>如果我们能避免这样的错误，那就太好了。</p>\n<p>当我们运行我们的代码时，我们的 JavaScript 运行时选择做什么的方式是通过确定值的<em>类型</em>——它具有什么样的行为和功能。这<code>TypeError</code>就是暗指的一部分- 它说字符串<code>&quot;Hello World!&quot;</code>不能作为函数调用。</p>\n<p>对于某些值，例如基本类型<code>string</code>和<code>number</code>，我们可以在运行时使用<code>typeof</code>运算符识别它们的类型。但是对于函数之类的其他东西，没有相应的运行时机制来识别它们的类型。例如，考虑这个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"title function_\">flip</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过阅读代码<em>观察</em>到这个函数只有在给定一个具有可调用<code>flip</code>属性的对象时才能工作，但是 JavaScript 并没有以我们可以在代码运行时检查的方式来显示这些信息。在纯 JavaScript 中，告诉<code>fn</code>特定值做什么的<strong>唯一方法</strong>是调用它并查看会发生什么。这种行为使得在运行之前很难预测代码会做什么，这意味着在编写代码时更难知道代码会做什么。</p>\n<p>这样看来，<em>类型</em>是描述可以传递给<code>fn</code>哪些值会崩溃的概念。JavaScript 只真正提供<em>动态</em>类型——运行代码看看会发生什么。</p>\n<p>另一种方法是使用<em>静态</em>类型系统<em>在</em>运行<em>之前</em>预测预期的代码。</p>\n<h2 id=\"2-2-静态类型检查\"><a href=\"#2-2-静态类型检查\" class=\"headerlink\" title=\"2.2 静态类型检查\"></a>2.2 <strong>静态类型检查</strong></h2><p>回想一下<code>TypeError</code>我们之前尝试将 <code>string</code>作为函数调用的情况。 <em>大多数人</em>不喜欢在运行他们的代码时出现任何类型的错误 - 这些被认为是错误！当我们编写新代码时，我们会尽量避免引入新的错误。</p>\n<p>理想情况下，我们可以有一个工具来帮助我们<em>在</em>代码运行<em>之前</em>发现这些错误。这就是像 TypeScript 这样的静态类型检查器所做的。 <em>静态类型系统</em>描述了当我们运行程序时我们的值的形状和行为。像 TypeScript 这样的类型检查器，告诉我们什么时候事情可能会出轨。</p>\n<img src=\"https://s2.loli.net/2022/02/22/5yhsbTCF7cqVGNQ.png\" alt=\"image-20211109134610557\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>在我们运行代码之前，使用 TypeScript 运行最后一个示例会给我们一条错误消息。</p>\n<h2 id=\"2-3-非异常故障\"><a href=\"#2-3-非异常故障\" class=\"headerlink\" title=\"2.3 非异常故障\"></a>2.3 <strong>非异常故障</strong></h2><p>到目前为止，我们一直在讨论运行时错误——JavaScript 运行时告诉我们它认为某些东西是无意义的情况。出现这些情况是因为<a href=\"https://tc39.github.io/ecma262/\">ECMAScript 规范</a>明确说明了语言在遇到意外情况时应该如何表现。</p>\n<p>例如，规范说尝试调用不可调用的东西应该抛出错误。也许这听起来像是“明显的行为”，但您可以想象访问对象上不存在的属性也应该抛出错误。相反，JavaScript 给了我们不同的行为并返回值<code>undefined</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;小千&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">26</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">user.<span class=\"property\">location</span>; <span class=\"comment\">// 返回 undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>最终，静态类型系统要求必须调用哪些代码，应该在其系统中标记，即使它是不会立即抛出错误的“有效”JavaScript。比如：在 TypeScript 中，以下代码会产生关于<code>location</code>未定义的错误：</p>\n<img src=\"https://s2.loli.net/2022/02/22/Qqo8BZmtJnGC1D4.png\" alt=\"image-20211109141050215\" style=\"zoom:50%;\" />\n\n<p>TypeScript 可以在我们的程序中捕获<em>很多</em>合法的错误。例如：</p>\n<ul>\n<li>错别字<br><img src=\"/img/TypeScript/01-04.png\"></li>\n<li>未调用的函数</li>\n</ul>\n<img src=\"https://s2.loli.net/2022/02/22/U1MmrPyjdbkueRC.png\" alt=\"image-20211109142053954\" style=\"zoom:50%;\" align=\"left\" />\n\n<ul>\n<li>或基本逻辑错误</li>\n</ul>\n<p><img src=\"/img/TypeScript/01-06.png\"></p>\n<h2 id=\"2-4-使用工具\"><a href=\"#2-4-使用工具\" class=\"headerlink\" title=\"2.4 使用工具\"></a>2.4 <strong>使用工具</strong></h2><p>当我们在代码中出错时，TypeScript 可以捕获错误。这很好，但 TypeScript 也<em>可以首先</em>防止我们犯这些错误。</p>\n<p>类型检查器有能力帮助我们来检查，诸如是否正在访问变量和其他属性的正确属性。一旦有了这些信息，它还可以开始<em>建议</em>您可能想要使用的属性。</p>\n<p>这意味着当利用工具来编辑 TypeScript 代码，核心类型检查器可以在编辑器中键入代码时，提供错误消息和代码完成。这是我们在谈论 TypeScript 中的工具时经常提到的部分内容。</p>\n<img src=\"https://s2.loli.net/2022/02/22/qolAfbMnVIcXvys.png\" alt=\"image-20211113085757666\" style=\"zoom: 25%;\" align=\"left\" />\n\n<p>TypeScript 非常重视工具。支持 TypeScript 的编辑器可以提供“快速修复”以自动修复错误、重构以轻松重新组织代码的能力，以及用于跳转到变量定义或查找给定变量的所有引用的有用导航功能。所有这些都建立在类型检查器之上，并且是完全跨平台的，因此<a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">您最喜欢的编辑器</a>可能<a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">具有可用的 TypeScript 支持</a>。</p>\n<h2 id=\"2-5-tsc编译器\"><a href=\"#2-5-tsc编译器\" class=\"headerlink\" title=\"2.5 tsc编译器\"></a>2.5 <code>tsc</code>编译器</h2><p>我们一直在谈论类型检查，但我们还没有使用我们的类型<em>检查器</em>。让我们认识一下我们的新朋友<code>tsc</code>TypeScript 编译器。首先，我们需要通过 npm 获取它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n\n<p>这将全局安装 TypeScript 编译器。</p>\n<p>现在让我们移动到一个空文件夹，并尝试编写我们的第一个 TypeScript 程序<code>hello.ts</code>：</p>\n<p><strong>01-ts-basics&#x2F;hello.ts</strong></p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意这里没有多余的装饰；这个“hello world”程序看起来与您在 JavaScript 中为“hello world”程序编写的程序相同。现在让我们通过运行<code>tsc</code>由<code>typescript</code>包为我们打包编译它：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[felix] 01-ts-basics $ tsc hello.ts</span><br></pre></td></tr></table></figure>\n\n<p>我们跑了<code>tsc</code>，什么也没发生！嗯，没有类型错误，所以我们没有在控制台中得到任何输出，因为没有什么可报告的。</p>\n<img src=\"https://s2.loli.net/2022/02/22/APiNb5FzvuwGlZk.png\" alt=\"image-20211113093244339\" style=\"zoom: 50%;\" align=\"left\"/>\n\n<p>但是再检查一下 - 我们得到了一些<em>文件</em>输出。如果我们查看当前目录，我们会发现有两个文件<code>hello.js</code>在<code>hello.ts</code>. 这是我们的<code>hello.ts</code>文件在<code>tsc</code> <em>编译</em>或<em>转换</em>为纯 JavaScript 文件后的输出。</p>\n<img src=\"https://s2.loli.net/2022/02/22/ctI9MPpSY1y8uLr.png\" alt=\"image-20211113093559374\" style=\"zoom: 50%;\" align=\"left\" />\n\n<p>如果我们检查<code>hello.js</code>，我们将看到 TypeScript 在处理<code>.ts</code>文件后吐出的内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，TypeScript 几乎没有要转换的内容，因此它看起来与我们编写的内容相同。编译器会尝试编译出清晰可读的代码，看起来像一个人写的东西。注释也给我们保留下来。</p>\n<p>如果我们<em>确实</em>引入了类型检查错误呢？让我们重写<code>hello.ts</code>：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person, date</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小千&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果我们<code>tsc hello.ts</code>再次运行，我们在命令行上收到了错误！</p>\n<img src=\"https://s2.loli.net/2022/02/22/QNL3DlBHYUbxu9Z.png\" alt=\"image-20211113095515775\" style=\"zoom:50%;\" align=\"left\"/>\n\n<p>TypeScript 告诉我们忘记将参数传递给<code>greet</code>函数，这是理所当然的。到目前为止，我们只编写了标准的 JavaScript，但是类型检查仍然能够发现我们代码的其他问题。感谢TypeScript！</p>\n<h2 id=\"2-6-发出错误\"><a href=\"#2-6-发出错误\" class=\"headerlink\" title=\"2.6 发出错误\"></a>2.6 发出错误</h2><p>从上一个示例中，你可能没有注意到的一件事，就是是我们的<code>hello.js</code>文件再次更改。如果我们打开该文件，那么我们会看到内容仍然与我们的输入文件基本相同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你好，世界</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person, date</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello &quot;</span> + person + <span class=\"string\">&quot;, today is &quot;</span> + date + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小千&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>鉴于<code>tsc</code>报告了有关我们代码的错误这一事实，这可能有点令人惊讶，但这是基于 TypeScript 的核心价值观之一：大多数情况下，<em>你</em>会比 TypeScript 更了解发生了什么。</p>\n<p>再回顾一下前面的内容，类型检查代码限制了我们可以运行的程序种类，因此需要权衡类型检查器认为可接受的类型。大多数情况下这没问题，但在某些情况下，这些检查会妨碍到我们。例如，想象自己将 JavaScript 代码迁移到 TypeScript 并引入类型检查错误。最终，你将开始为类型检查器进行代码清理，但原始 JavaScript 代码已经可以运行了！为什么非要将我们的JS代码转换为 TypeScript 代码，来去阻止运行它呢？</p>\n<p>所以 TypeScript 默认不会妨碍我们代码的运行，因为这些JS在宿主环境里运行时没有问题的。当然，随着时间的推移，我们可能希望对错误更加防御，并使 TypeScript 的行为更加严格。在这种情况下，我们可以使用<a href=\"https://www.typescriptlang.org/tsconfig#noEmitOnError\"><code>noEmitOnError</code></a>编译器选项。尝试更改我们的<code>hello.ts</code>文件，并<code>tsc</code>使用该选项重新编译：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --noEmitOnError hello.ts</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-04.png\"></p>\n<p>你会注意到<code>hello.js</code>永远不会更新。</p>\n<h2 id=\"2-7-显式类型\"><a href=\"#2-7-显式类型\" class=\"headerlink\" title=\"2.7 显式类型\"></a>2.7 显式类型</h2><p>到现在为止，我们还没有告诉 typescript <code>person</code>或者<code>date</code>是什么类型。当我们编辑代码时会告诉 TypeScript <code>person</code>是一个<code>string</code>，那<code>date</code>应该是一个<code>Date</code>对象。</p>\n<p>有了这个，TypeScript 可以告诉我们其他<code>greet</code>可能被错误调用的情况。例如修改一下 <code>hello.ts</code>代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person: string, date: <span class=\"built_in\">Date</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-05.png\"></p>\n<p>嗯？TypeScript 在我们的第二个参数上报告了一个错误，这是为什么呢？</p>\n<p>也许令人惊讶的是，<code>Date()</code>在 JavaScript 中调用会返回一个<code>string</code>。可以使用<code>new Date()</code>满足我们的期望,快速修复错误：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person: string, date: <span class=\"built_in\">Date</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;小锋&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/TypeScript/02-06.png\"></p>\n<p>成功的编译输出了 <code>hello.js</code>。</p>\n<p>请记住，我们并不总是必须给变量编写明确的类型注释。在许多情况下，TypeScript 可以为我们自动<em>推断</em>（或“找出”）类型，即使我们忽略定义这些类型。比如：</p>\n<img src=\"https://s2.loli.net/2022/02/22/N2pXBbY6LRwoaC1.png\" alt=\"image-20211113111924590\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>这里没有给 msg 指定具体的类型，typescript 会根据函数的实参来自动推断类型。这是一个特性，当类型系统最终会推断出相同的类型时，最好不要添加类型注释。</p>\n<h2 id=\"2-8-擦除类型\"><a href=\"#2-8-擦除类型\" class=\"headerlink\" title=\"2.8 擦除类型\"></a>2.8 擦除类型</h2><p>让我们来仔细看看，当我们 <code>tsc</code>编译上面的代码会输出的什么样的JavaScript，观察 <code>hello.js</code></p>\n<p><img src=\"/img/TypeScript/02-08.png\"></p>\n<p>这里要注意两点：</p>\n<ol>\n<li>我们的<code>person</code>和<code>date</code>参数不再有类型注释。</li>\n<li>我们的“模板字符串” - 使用反引号（&#96;字符）的字符串 - 被转换为带有连接 ( + ) 的纯字符串。</li>\n</ol>\n<p>稍后会详细介绍第二点，现在让我们专注于第一点。类型注释不是 JavaScript 的一部分（或者说 ECMAScript 是落后的），因此实际上没有任何浏览器，或其他运行时可以不加修改地运行 TypeScript。这就是 TypeScript 首先需要编译器的原因——它需要某种方式来剥离或转换任何特定于 TypeScript 的代码，以便我们可以运行它。大多数 TypeScript 特定的代码都被删除了。</p>\n<blockquote>\n<p><strong>请记住</strong>：类型注释永远不会改变程序的运行时行为。</p>\n</blockquote>\n<h2 id=\"2-9-降级编译\"><a href=\"#2-9-降级编译\" class=\"headerlink\" title=\"2.9 降级编译\"></a>2.9 降级编译</h2><p>与上面的另一个区别是我们的模板字符串是从：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;person&#125;</span>, today is <span class=\"subst\">$&#123;date.toDateString()&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>到：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello &quot;</span> + person + <span class=\"string\">&quot;, today is &quot;</span> + date.<span class=\"title function_\">toDateString</span>() + <span class=\"string\">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>为什么会这样？</p>\n<p>模板字符串是 ECMAScript 版本的一个特性，称为 ECMAScript 2015（又名 ECMAScript 6、ES2015、ES6 等）。TypeScript 能够将代码从较新版本的 ECMAScript 重写为旧版本，例如 ECMAScript 3 或 ECMAScript 5（又名 ES3 和 ES5）。这种从更新或“更高”版本的 ECMAScript ，向下移动到旧版本或“更低”版本的过程有时称为<em>降级</em>。</p>\n<p>默认情况下，TypeScript 以 ES3 为目标，这是一个非常旧的 ECMAScript 版本。通过使用<a href=\"https://www.typescriptlang.org/tsconfig#target\"><code>target</code></a>选项，我们可以选择更新一些的内容。运行<code>--target es2015</code>TypeScript 以针对 ECMAScript 2015进行更改，这意味着代码应该能够在支持 ECMAScript 2015 的任何地方运行。所以运行<code>tsc --target es2015 hello.ts</code>会给我们以下输出：</p>\n<img src=\"https://s2.loli.net/2022/02/22/3BbKfisq9htp4nr.png\" alt=\"image-20211113113644658\" style=\"zoom:33%;\" />\n\n<blockquote>\n<p>虽然默认目标是 ES3，但当前绝大多数浏览器都支持 ES2015。因此，大多数开发人员可以安全地将 ES2015 或更高版本指定为目标，除非考虑与某些旧浏览器的兼容性。</p>\n</blockquote>\n<h2 id=\"2-10-严格模式\"><a href=\"#2-10-严格模式\" class=\"headerlink\" title=\"2.10 严格模式\"></a>2.10 严格模式</h2><p>不同的用户使用 TypeScript 在类型检查器中，希望检查的严格程度不同。有些人正在寻找更宽松的验证体验，它可以帮助仅验证其程序的某些部分，并且仍然拥有不错的工具。这是 TypeScript 的默认体验，其中类型是可选的，推理采用最宽松的类型，并且不检查潜在的<code>null</code>&#x2F;<code>undefined</code>值，就像<code>tsc</code>面对错误时如何编译生成JS文件一样。如果你要迁移现有的 JavaScript，这可能是理想的第一步。</p>\n<p>相比之下，许多用户更喜欢让 TypeScript 尽可能多地立即验证，这就是该语言也提供严格性设置的原因。这些严格性设置将静态类型检查，从开关（无论您的代码是否被检查）转变为更接近于拨号的东西。你把这个拨盘调得越远，TypeScript 就会为你检查越多。这可能需要一些额外的工作，但总的来说，从长远来看，它是物有所值的，并且可以实现更彻底的检查和更准确的工具。如果可能，新的代码库应该始终打开这些严格性检查。</p>\n<p>TypeScript 有几个可以打开或关闭的类型检查严格标志，除非另有说明，否则我们所有的示例都将在启用所有这些标志的情况下编写。在命令行里设置<a href=\"https://www.typescriptlang.org/tsconfig#strict\"><code>strict</code></a> ，或在<a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\"><code>tsconfig.json</code></a>中配置<code>&quot;strict&quot;: true</code> 将它打开。</p>\n<p><img src=\"/img/TypeScript/02-10.png\"></p>\n<p><img src=\"/img/TypeScript/02-11.png\"></p>\n<p>以上两个案例错误是因为我们配置了 <code>--strict true</code>。</p>\n<p>同时我们可以单独选择配置它们。我们应该知道的最典型的两个是<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"><code>noImplicitAny</code></a>和<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a>。</p>\n<ul>\n<li><strong><code>noImplicitAny</code></strong></li>\n</ul>\n<p>回想一下，在某些地方，TypeScript 不会尝试为我们推断类型，而是退回到最宽松的类型：<code>any</code>。这并不是可能发生的最糟糕的事情——毕竟，<code>any</code>无论如何，都能退回到普通的 JavaScript 体验。</p>\n<p>但是，使用<code>any</code>通常首先会破坏使用 TypeScript 的目的。你的程序类型越多，你获得的验证和工具就越多，这意味着你在编写代码时会遇到更少的错误。打开该<a href=\"https://www.typescriptlang.org/tsconfig#noImplicitAny\"><code>noImplicitAny</code></a>标志将对类型隐式推断为，当任何变量发出错误时都应用 <code>any</code> 类型。</p>\n<img src=\"https://s2.loli.net/2022/02/22/Ir7T4vckJMsSnuK.png\" alt=\"image-20211113122642576\" style=\"zoom:40%;\" />\n\n<ul>\n<li><strong><code>strictNullChecks</code></strong></li>\n</ul>\n<p>默认情况下，值为<code>null</code>和<code>undefined</code>可分配给任何其他类型。这可以使编写一些代码更容易，但忘记处理<code>null</code>并且<code>undefined</code>是你代码无数错误的元凶 - 有些人认为这是一个<a href=\"https://www.youtube.com/watch?v=ybrQvs4x0Ps\">十亿美元的错误</a>！该<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a>标志，使得操作<code>null</code>和<code>undefined</code>更加明确，它使我们不用担心是否<em>忘记</em>处理<code>null</code>和<code>undefined</code>。</p>\n<img src=\"https://s2.loli.net/2022/02/22/wRlPY8gO9v1zkZa.png\" alt=\"image-20211113122914750\" style=\"zoom:50%;\" />\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "1-7、基础篇：类型操纵",
        "toc": true,
        "abbrlink": 2401,
        "date": "2024-01-28T11:41:58.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_02.jpeg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 七、类型操纵\n\n## 7.0 从类型中创建类型\n\nTypeScript的类型系统非常强大，因为它允许用其他类型的术语来表达类型。\n\n这个想法的最简单的形式是泛型，我们实际上有各种各样的类型操作符可以使用。也可以用我们已经有的值来表达类型。\n\n通过结合各种类型操作符，我们可以用一种简洁、可维护的方式来表达复杂的操作和值。在本节中，我们将介绍用现有的类型或值来表达一个新类型的方法。\n\n- 泛型型 - 带参数的类型\n\n- Keyof 类型操作符- `keyof` 操作符创建新类型\n- Typeof 类型操作符 - 使用 `typeof` 操作符来创建新的类型`\n- 索引访问类型 - 使用 `Type['a']` 语法来访问一个类型的子集\n- 条件类型 - 在类型系统中像if语句一样行事的类型\n- 映射类型 - 通过映射现有类型中的每个属性来创建类型\n- 模板字面量类型 - 通过模板字面字符串改变属性的映射类型\n\n## 7.1 泛型\n\n软件工程的一个主要部分是建立组件，这些组件不仅有定义明确和一致的API，而且还可以重复使用。能够处理今天的数据和明天的数据的组件将为你建立大型软件系统提供最灵活的能力。\n\n在像C#和Java这样的语言中，创建可重用组件的工具箱中的主要工具之一是泛型，也就是说，能够创建一个在各种类型上工作的组件，而不是单一的类型。这使得用户可以消费这些组件并使用他们自己的类型。\n\n### 7.1.1 Hello World\n\n首先，让我们做一下泛型的 \" hello world\"：身份函数。身份函数是一个函数，它将返回传入的任何内容。你可以用类似于echo命令的方式来考虑它。\n\n如果没有泛型，我们将不得不给身份函数一个特定的类型。\n\n```tsx\nfunction identity(arg: number): number {\n  return arg;\n}\n```\n\n或者，我们可以用任意类型来描述身份函数。\n\n```tsx\nfunction identity(arg: any): any {\n  return arg;\n}\n```\n\n使用 `any` 当然是通用的，因为它将使函数接受 `arg`类型的任何和所有的类型，但实际上我们在函数返回时失去了关于该类型的信息。如果我们传入一个数字，我们唯一的信息就是任何类型都可以被返回。\n\n相反，我们需要一种方法来捕获参数的类型，以便我们也可以用它来表示返回的内容。在这里，我们将使用一个类型变量，这是一种特殊的变量，对类型而不是数值起作用。\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n```\n\n我们现在已经在身份函数中添加了一个类型变量 `Type`。这个 `Type` 允许我们捕获用户提供的类型（例如数字），这样我们就可以在以后使用这些信息。这里，我们再次使用Type作为返回类型。经过检查，我们现在可以看到参数和返回类型使用的是相同的类型。这使得我们可以将类型信息从函数的一侧输入，然后从另一侧输出。\n\n我们说这个版本的身份函数是通用的，因为它在一系列的类型上工作。与使用任何类型不同的是，它也和第一个使用数字作为参数和返回类型的身份函数一样精确（即，它不会丢失任何信息）。\n\n一旦我们写好了通用身份函数，我们就可以用两种方式之一来调用它。第一种方式是将所有的参数，包括类型参数，都传递给函数：\n\n```tsx\nlet output = identity<string>(\"myString\");\n```\n\n这里我们明确地将 `Type` 设置为`string`，作为函数调用的参数之一，用参数周围的 `<>` 而不是 `()` 来表示。\n\n第二种方式可能也是最常见的。这里我们使用类型参数推理——也就是说，我们希望编译器根据我们传入的参数的类型，自动为我们设置 `Type` 的值。\n\n```tsx\nlet output = identity(\"myString\");\n```\n\n注意，我们不必在角括号（<>）中明确地传递类型；编译器只是查看了 \"myString \"这个值，并将Type设置为其类型。虽然类型参数推断是一个有用的工具，可以使代码更短、更易读，但当编译器不能推断出类型时，你可能需要像我们在前面的例子中那样明确地传入类型参数，这在更复杂的例子中可能发生。\n\n### 7.1.2 使用通用类型变量\n\n当你开始使用泛型时，你会注意到，当你创建像`identity`这样的泛型函数时，编译器会强制要求你在函数主体中正确使用任何泛型参数。也就是说，你实际上是把这些参数当作是任何和所有的类型。\n\n让我们来看看我们前面的 `identity` 函数。\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n```\n\n如果我们想在每次调用时将参数 `arg` 的长度记录到控制台，该怎么办？我们可能很想这样写：\n\n```tsx\nfunction loggingIdentity<Type>(arg: Type): Type {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/dqsOFKoSHTPJBMv.png\" alt=\"image-20211127215153933\" style=\"zoom:50%;\" />\n\n当我们这样做时，编译器会给我们一个错误，说我们在使用 `arg` 的 `.length` 成员，但我们没有说 `arg` 有这个成员。记住，我们在前面说过，这些类型的变量可以代表任何和所有的类型，所以使用这个函数的人可以传入一个`number` ，而这个数字没有一个 `.length` 成员。\n\n比方说，我们实际上是想让这个函数在 `Type` 的数组上工作，而不是直接在 `Type`上工作。既然我们在处理数组，那么`.length`成员应该是可用的。我们可以像创建其他类型的数组那样来描述它。\n\n```tsx\nfunction loggingIdentity<Type>(arg: Type[]): Type[] {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n你可以把 `loggingIdentity` 的类型理解为 \"通用函数 `loggingIdentity` 接收一个类型参数 `Type` 和一个参数 `arg`，`arg`是一个`Type`数组，并返回一个`Type`数组。\" 如果我们传入一个数字数组，我们会得到一个数字数组，因为Type会绑定到数字。这允许我们使用我们的通用类型变量 `Type` 作为我们正在处理的类型的一部分，而不是整个类型，给我们更大的灵活性。\n\n我们也可以这样来写这个例子：\n\n```tsx\nfunction loggingIdentity<Type>(arg: Array<Type>): Array<Type> {\n  console.log(arg.length); // 数组有一个.length，所以不会再出错了\n  return arg;\n}\n```\n\n你可能已经从其他语言中熟悉了这种类型的风格。在下一节中，我们将介绍如何创建你自己的通用类型，如`Array<Type>`。\n\n### 7.1.3 泛型类型\n\n在前几节中，我们创建了在一系列类型上工作的通用身份函数。在这一节中，我们将探讨函数本身的类型以及如何创建通用接口。\n\n泛型函数的类型与非泛型函数的类型一样，类型参数列在前面，与函数声明类似：\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: <Type>(arg: Type) => Type = identity;\n```\n\n我们也可以为类型中的通用类型参数使用一个不同的名字，只要类型变量的数量和类型变量的使用方式一致。\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: <Input>(arg: Input) => Input = identity;\n```\n\n我们也可以把泛型写成一个对象字面类型的调用签名。\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: { <Type>(arg: Type): Type } = identity;\n```\n\n这让我们开始编写我们的第一个泛型接口。让我们把前面例子中的对象字面意思移到一个接口中。\n\n```tsx\ninterface GenericIdentityFn {\n  <Type>(arg: Type): Type;\n}\n\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: GenericIdentityFn = identity;\n```\n\n在一个类似的例子中，我们可能想把通用参数移到整个接口的参数上。这可以让我们看到我们的泛型是什么类型（例如，`Dictionary<string>`而不是仅仅`Dictionary`）。这使得类型参数对接口的所有其他成员可见。\n\n```tsx\ninterface GenericIdentityFn<Type> {\n  (arg: Type): Type;\n}\n\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity;\n```\n\n请注意，我们的例子已经改变了，变成了稍微不同的东西。我们现在没有描述一个泛型函数，而是有一个非泛型的函数签名，它是泛型类型的一部分。当我们使用 `GenericIdentityFn` 时，我们现在还需要指定相应的类型参数（这里是：数字），有效地锁定了底层调用签名将使用什么。了解什么时候把类型参数直接放在调用签名上，什么时候把它放在接口本身，将有助于描述一个类型的哪些方面是通用的。\n\n除了泛型接口之外，我们还可以创建泛型类。注意，不可能创建泛型枚举和命名空间。\n\n### 7.1.4 泛型类\n\n一个泛型类的形状与泛型接口相似。泛型类在类的名字后面有一个角括号（<>）中的泛型参数列表。\n\n```tsx\nclass GenericNumber<NumType> {\n  zeroValue: NumType;\n  add: (x: NumType, y: NumType) => NumType;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n```\n\n这是对`GenericNumber`类相当直白的使用，但你可能已经注意到，没有任何东西限制它只能使用数字类型。我们本可以使用字符串或更复杂的对象。\n\n```tsx\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \"\";\nstringNumeric.add = function (x, y) {\n  return x + y;\n};\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\n```\n\n就像接口一样，把类型参数放在类本身，可以让我们确保类的所有属性都与相同的类型一起工作。\n\n正如我们在关于类的章节中提到的，一个类的类型有两个方面：静态方面和实例方面。通用类只在其实例侧而非静态侧具有通用性，所以在使用类时，静态成员不能使用类的类型参数。\n\n### 7.1.5 泛型约束\n\n如果你还记得前面的例子，你有时可能想写一个通用函数，在一组类型上工作，而你对这组类型会有什么能力有一定的了解。在我们的 `loggingIdentity` 例子中，我们希望能够访问 `arg.length` 属性，但是编译器无法证明每个类型都有一个 `.length` 属性，所以它警告我们不能做这个假设。\n\n```tsx\nfunction loggingIdentity<Type>(arg: Type): Type {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/gS8VUxOYPyER62K.png\" alt=\"image-20211128095950588\" style=\"zoom:50%;\" />\n\n我们希望限制这个函数与 `any` 和所有类型一起工作，而不是与 `any` 和所有同时具有 `.length` 属性的类型一起工作。只要这个类型有这个成员，我们就允许它，但它必须至少有这个成员。要做到这一点，我们必须把我们的要求作为一个约束条件列在 `Type` 可以是什么。\n\n为了做到这一点，我们将创建一个接口来描述我们的约束。在这里，我们将创建一个接口，它有一个单一的 `.length` 属性，然后我们将使用这个接和 `extends` 关键字来表示我们的约束条件。\n\n```tsx\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<Type extends Lengthwise>(arg: Type): Type {\n  console.log(arg.length); // 现在我们知道它有一个 .length 属性，所以不再有错误了\n  return arg;\n}\n```\n\n因为泛型函数现在被限制了，它将不再对 `any` 和 所有的类型起作用。\n\n```\nloggingIdentity(3);\n```\n\n<img src=\"/img/TypeScript/07-03.png\" alt=\"image-20211128102358263\" style=\"zoom:50%;\" />\n\n相反，我们需要传入其类型具有所有所需属性的值。\n\n```tsx\nloggingIdentity({ length: 10, value: 3 });\n```\n\n### 7.1.6 在泛型约束中使用类型参数\n\n你可以声明一个受另一个类型参数约束的类型参数。例如，在这里我们想从一个给定名称的对象中获取一个属性。我们想确保我们不会意外地获取一个不存在于 `obj` 上的属性，所以我们要在这两种类型之间放置一个约束条件。\n\n```tsx\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, \"a\");\ngetProperty(x, \"m\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/MrLOcvzYgSbophf.png\" alt=\"image-20211128103719103\" style=\"zoom:50%;\" />\n\n### 7.1.7 在泛型中使用类类型\n\n在TypeScript中使用泛型创建工厂时，有必要通过其构造函数来引用类的类型。比如说：\n\n```tsx\nfunction create<Type>(c: { new (): Type }): Type {\n  return new c();\n}\n```\n\n一个更高级的例子，使用原型属性来推断和约束类类型的构造函数和实例方之间的关系。\n\n```tsx\nclass BeeKeeper {\n  hasMask: boolean = true;\n}\n\nclass ZooKeeper {\n  nametag: string = \"Mikle\";\n}\n\nclass Animal {\n  numLegs: number = 4;\n}\n\nclass Bee extends Animal {\n  keeper: BeeKeeper = new BeeKeeper();\n}\n\nclass Lion extends Animal {\n  keeper: ZooKeeper = new ZooKeeper();\n}\n\nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n\ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\n```\n\n## 7.2 `Keyof`类型操作符\n\n`keyof`运算符接收一个对象类型，并产生其键的字符串或数字字面联合。下面的类型P与 \"x\"|\"y \"是同一类型。\n\n```tsx\ntype Point = { x: number; y: number };\ntype P = keyof Point;\nconst p1: P = \"x\";\nconst p2: P = \"y\";\n```\n\n如果该类型有一个字符串或数字索引签名，`keyof` 将返回这些类型。\n\n```tsx\ntype Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish;\nconst a: A = 0;\n\ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish;\nconst m: M = \"a\";\nconst m2: M = 10;\n```\n\n注意，在这个例子中，`M`是 `string|number`——这是因为JavaScript对象的键总是被强制为字符串，所以 `obj[0]`总是与`obj[\"0\"]`相同。\n\n`keyof`类型在与映射类型结合时变得特别有用，我们将在后面进一步了解。\n\n## 7.3 `Typeof` 类型操作符\n\nJavaScript已经有一个 `typeof` 操作符，你可以在表达式上下文中使用。\n\n```tsx\n// 输出 \"string\"\nconsole.log(typeof \"Hello world\");\n```\n\nTypeScript添加了一个`typeof`操作符，你可以在类型上下文中使用它来引用一个变量或属性的类型。\n\n```tsx\nlet s = \"hello\";\nlet n: typeof s;\nn = \"world\";\nn = 100;\n```\n\n<img src=\"/img/TypeScript/07-05.png\" alt=\"image-20211128110305093\" style=\"zoom:50%;\" />\n\n这对基本类型来说不是很有用，但结合其他类型操作符，你可以使用typeof来方便地表达许多模式。举一个例子，让我们先看看预定义的类型`ReturnType<T>`。它接收一个函数类型并产生其返回类型：\n\n```tsx\ntype Predicate = (x: unknown) => boolean;\ntype K = ReturnType<Predicate>;\n```\n\n如果我们试图在一个函数名上使用 `ReturnType`，我们会看到一个指示性的错误。\n\n```tsx\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<f>;\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/foM6iTw7GecalgD.png\" alt=\"image-20211128111022283\" style=\"zoom:50%;\" />\n\n请记住，值和类型并不是一回事。为了指代值f的类型，我们使用 `typeof`。\n\n```tsx\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<typeof f>;\n```\n\nTypeScript 故意限制了你可以使用 typeof 的表达式种类。\n\n具体来说，只有在标识符（即变量名）或其属性上使用typeof是合法的。这有助于避免混乱的陷阱，即编写你认为是在执行的代码，但其实不是。\n\n```tsx\n// 我们认为使用 = ReturnType<typeof msgbox>\nlet shouldContinue: typeof msgbox(\"Are you sure you want to continue?\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/AUnW94tZuiI2fLw.png\" alt=\"image-20211128111627727\" style=\"zoom:50%;\" />\n\n## 7.4 索引访问类型\n\n我们可以使用一个索引访问类型来查询另一个类型上的特定属性：\n\n```tsx\ntype Person = { age: number; name: string; alive: boolean };\ntype Age = Person[\"age\"];\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/vdRnGwYBI6r4Elx.png\" alt=\"image-20211128114411725\" style=\"zoom:50%;\" />\n\n索引类型本身就是一个类型，所以我们可以完全使用 unions、`keyof` 或者其他类型。\n\n```tsx\ninterface Person {\n  name: string;\n  age: number;\n  alive: boolean;\n}\n\n// type I1 = string | number\ntype I1 = Person[\"age\" | \"name\"];\nconst i11: I1 = 100;\nconst i12: I1 = \"\";\n\n// type I2 = string | number | boolean\ntype I2 = Person[keyof Person];\nconst i21: I2 = \"\";\nconst i22: I2 = 100;\nconst i23: I2 = false;\n\n// type I3 = Person[AliveOrName];\ntype AliveOrName = \"alive\" | \"name\";\nconst aon1: AliveOrName = \"alive\";\nconst aon2: AliveOrName = \"name\";\n```\n\n如果你试图索引一个不存在的属性，你甚至会看到一个错误：\n\n```tsx\ntype I1 = Person[\"alve\"];\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/aKBPU27y5pJLQz3.png\" alt=\"image-20211128115726772\" style=\"zoom:50%;\" />\n\n另一个使用任意类型进行索引的例子是使用`number`来获取一个数组元素的类型。我们可以把它和 `typeof`结合起来，方便地获取一个数组字面的元素类型。\n\n```tsx\nconst MyArray = [\n  { name: \"Alice\", age: 15 },\n  { name: \"Bob\", age: 23 },\n  { name: \"Eve\", age: 38 },\n];\n\n/* type Person = {\n    name: string;\n    age: number;\n} */\ntype Person = (typeof MyArray)[number];\nconst p: Person = {\n  name: \"xiaoqian\",\n  age: 11,\n};\n\n// type Age = number\ntype Age = (typeof MyArray)[number][\"age\"];\nconst age: Age = 11;\n\n// 或者\n// type Age2 = number\ntype Age2 = Person[\"age\"];\nconst age2: Age2 = 11;\n```\n\n你只能在索引时使用类型，这意味着你不能使用`const`来做一个变量引用：\n\n```tsx\nconst key = \"age\";\ntype Age = Person[key];\n```\n\n<img src=\"/img/TypeScript/08-03.png\" alt=\"image-20211128122324127\" style=\"zoom:60%;\" />\n\n然而，你可以使用类型别名来实现类似的重构风格：\n\n```tsx\ntype key = \"age\";\ntype Age = Person[key];\n```\n\n## 7.5 条件类型\n\n在大多数有用的程序的核心，我们必须根据输入来做决定。JavaScript程序也不例外，但鉴于数值可以很容易地被内省，这些决定也是基于输入的类型。条件类型有助于描述输入和输出的类型之间的关系。\n\n```tsx\ninterface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n\n// type Example1 = number\ntype Example1 = Dog extends Animal ? number : string;\n\n// type Example2 = string\ntype Example2 = RegExp extends Animal ? number : string;\n```\n\n条件类型的形式看起来有点像JavaScript中的条件表达式（`condition ? trueExpression : falseExpression`）。\n\n```tsx\n SomeType extends OtherType ? TrueType : FalseType;\n```\n\n当 `extends` 左边的类型可以赋值给右边的类型时，那么你将得到第一个分支中的类型（\"真 \"分支）；否则你将得到后一个分支中的类型（\"假 \"分支）。\n\n从上面的例子来看，条件类型可能并不立即显得有用——我们可以告诉自己是否 `Dog extends Animal`，并选择 `number`或`string`！但条件类型的威力来自于它所带来的好处。条件类型的力量来自于将它们与泛型一起使用。\n\n例如，让我们来看看下面这个 `createLabel` 函数：\n\n```tsx\ninterface IdLabel {\n  id: number /* 一些字段 */;\n}\ninterface NameLabel {\n  name: string /* 另一些字段 */;\n}\n\nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel {\n  throw \"unimplemented\";\n}\n```\n\n`createLabel`的这些重载描述了一个单一的JavaScript函数，该函数根据其输入的类型做出选择。注意一些事情：\n\n- 如果一个库必须在其API中反复做出同样的选择，这就会变得很麻烦。\n- 我们必须创建三个重载：一个用于确定类型的情况（一个用于 `string`，一个用于 `number`），一个用于最一般的情况（取一个 `string`| `number`）。对于 `createLabel`所能处理的每一种新类型，重载的数量都会呈指数级增长。\n\n相反，我们可以在一个条件类型中对该逻辑进行编码：\n\n```tsx\ntype NameOrId<T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n```\n\n然后我们可以使用该条件类型，将我们的重载简化为一个没有重载的单一函数。\n\n```tsx\ninterface IdLabel {\n  id: number /* some fields */;\n}\ninterface NameLabel {\n  name: string /* other fields */;\n}\n\ntype NameOrId<T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n\nfunction createLabel<T extends number | string>(idOrName: T): NameOrId<T> {\n  throw \"unimplemented\";\n}\n\n// let a: NameLabel\nlet a = createLabel(\"typescript\");\n\n// let b: IdLabel\nlet b = createLabel(2.8);\n\n// let c: NameLabel | IdLabel\nlet c = createLabel(Math.random() ? \"hello\" : 42);\n```\n\n### 7.5.1 条件类型约束\n\n通常，条件类型中的检查会给我们提供一些新的信息。就像用类型守卫缩小范围可以给我们一个更具体的类型一样，条件类型的真正分支将通过我们检查的类型进一步约束泛型。\n\n例如，让我们来看看下面的例子：\n\n```tsx\ntype MessageOf<T> = T[\"message\"];\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/GEXfr1zpLO2ghPw.png\" alt=\"image-20211129092739341\" style=\"zoom:50%;\" />\n\n在这个例子中，TypeScript出错是因为 `T` 不知道有一个叫做 `message` 的属性。我们可以对 `T` 进行约束，TypeScript就不会再抱怨。\n\n```tsx\ntype MessageOf<T extends { message: unknown }> = T[\"message\"];\n\ninterface Email {\n  message: string;\n}\n\ntype EmailMessageContents = MessageOf<Email>;\n```\n\n然而，如果我们想让 `MessageOf` 接受任何类型，并在消息属性不可用的情况下，默认为 `never`类型呢？我们可以通过将约束条件移出，并引入一个条件类型来做到这一点。\n\n```tsx\ntype MessageOf<T> = T extends { message: unknown } ? T[\"message\"] : never;\n\ninterface Email {\n  message: string;\n}\n\ninterface Dog {\n  bark(): void;\n}\n\n// type EmailMessageContents = string\ntype EmailMessageContents = MessageOf<Email>;\nconst emc: EmailMessageContents = \"balabala...\";\n\n// type DogMessageContents = never\ntype DogMessageContents = MessageOf<Dog>;\nconst dmc: DogMessageContents = \"error\" as never;\n```\n\n在真正的分支中，TypeScript知道 `T`会有一个消息属性。\n\n作为另一个例子，我们也可以写一个叫做 `Flatten` 的类型，将数组类型平铺到它们的元素类型上，但在其他方面则不做处理。\n\n```tsx\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\n// 提取出元素类型。\n// type Str = string\ntype Str = Flatten<string[]>;\n\n// 单独一个类型。\n// type Num = number\ntype Num = Flatten<number>;\n```\n\n当 `Flatten` 被赋予一个数组类型时，它使用一个带有数字的索引访问来获取 `string[]` 的元素类型。否则，它只是返回它被赋予的类型。\n\n### 7.5.2 在条件类型内进行推理\n\n我们只是发现自己使用条件类型来应用约束条件，然后提取出类型。这最终成为一种常见的操作，而条件类型使它变得更容易。\n\n条件类型为我们提供了一种方法来推断我们在真实分支中使用 `infer` 关键字进行对比的类型。例如，我们可以在`Flatten` 中推断出元素类型，而不是用索引访问类型 \"手动 \"提取出来。\n\n```tsx\ntype Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\n```\n\n在这里，我们使用 `infer` 关键字来声明性地引入一个名为 `Item` 的新的通用类型变量，而不是指定如何在真实分支中检索 `T` 的元素类型。这使我们不必考虑如何挖掘和探测我们感兴趣的类型的结构。\n\n我们可以使用 `infer` 关键字编写一些有用的辅助类型别名。例如，对于简单的情况，我们可以从函数类型中提取出返回类型。\n\n```tsx\ntype GetReturnType<Type> = Type extends (...args: never[]) => infer Return\n  ? Return\n  : never;\n\n// type Num = number\ntype Num = GetReturnType<() => number>;\n\n// type Str = string\ntype Str = GetReturnType<(x: string) => string>;\n\n// type Bools = boolean[]\ntype Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;\n\n// 给泛型传入 string 类型，条件类型会返回 never\ntype Never = GetReturnType<string>;\nconst nev: Never = \"error\" as never;\n```\n\n当从一个具有多个调用签名的类型（如重载函数的类型）进行推断时，从最后一个签名进行推断（据推测，这是最容许的万能情况）。不可能根据参数类型的列表来执行重载解析。\n\n```tsx\ndeclare function stringOrNum(x: string): number;\ndeclare function stringOrNum(x: number): string;\ndeclare function stringOrNum(x: string | number): string | number;\n\n// type T1 = string | number\ntype T1 = ReturnType<typeof stringOrNum>;\n```\n\n### 7.5.3 分布式条件类型\n\n当条件类型作用于一个通用类型时，当给定一个联合类型时，它们就变成了分布式的。例如，以下面的例子为例：\n\n```tsx\ntype ToArray<Type> = Type extends any ? Type[] : never;\n```\n\n如果我们将一个联合类型插入ToArray，那么条件类型将被应用于该联合的每个成员。\n\n```tsx\ntype ToArray<Type> = Type extends any ? Type[] : never;\n\n// type StrArrOrNumArr = string[] | number[]\ntype StrArrOrNumArr = ToArray<string | number>;\n```\n\n这里发生的情况是，StrArrOrNumArr分布在：\n\n```tsx\nstring | number;\n```\n\n并对联合的每个成员类型进行映射，以达到有效的目的：\n\n```tsx\nToArray<string> | ToArray<number>;\n```\n\n这给我们留下了：\n\n```tsx\nstring[] | number[];\n```\n\n通常情况下，分布性是需要的行为。为了避免这种行为，你可以用方括号包围 `extends`关键字的每一边。\n\n```tsx\ntype ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n\n// 'StrArrOrNumArr'不再是一个联合类型\n// type StrArrOrNumArr = (string | number)[]\ntype StrArrOrNumArr = ToArrayNonDist<string | number>;\n```\n\n## 7.6 映射类型\n\n当你不想重复定义类型，一个类型可以以另一个类型为基础创建新类型。\n\n映射类型建立在索引签名的语法上，索引签名用于声明没有被提前声明的属性类型。\n\n```tsx\ntype OnlyBoolsAndHorses = {\n  [key: string]: boolean | Horse;\n};\n\nconst conforms: OnlyBoolsAndHorses = {\n  del: true,\n  rodney: false,\n};\n```\n\n映射类型是一种通用类型，它使用 `PropertyKeys`的联合（经常通过`keyof`创建）迭代键来创建一个类型。\n\n```tsx\ntype OptionsFlags<Type> = {\n  [Property in keyof Type]: boolean;\n};\n```\n\n在这个例子中，`OptionsFlags`将从`Type`类型中获取所有属性，并将它们的值改为布尔值。\n\n```tsx\ntype FeatureFlags = {\n  darkMode: () => void;\n  newUserProfile: () => void;\n};\n\n/*\ntype FeatureOptions = {\n    darkMode: boolean;\n    newUserProfile: boolean;\n}\n*/\ntype FeatureOptions = OptionsFlags<FeatureFlags>;\n```\n\n### 7.6.1 映射修改器\n\n在映射过程中，有两个额外的修饰符可以应用：`readonly`和`?` ，它们分别影响可变性和可选性。\n\n你可以通过用`-`或`+`作为前缀来删除或添加这些修饰语。如果你不加前缀，那么就假定是`+`。\n\n```tsx\ntype CreateMutable<Type> = {\n  // 从一个类型的属性中删除 \"readonly\"属性\n  -readonly [Property in keyof Type]: Type[Property];\n};\n\ntype LockedAccount = {\n  readonly id: string;\n  readonly name: string;\n};\n\n/*\ntype UnlockedAccount = {\n    id: string;\n    name: string;\n}\n*/\ntype UnlockedAccount = CreateMutable<LockedAccount>;\n```\n\n```tsx\n// 从一个类型的属性中删除 \"可选\" 属性\ntype Concrete<Type> = {\n  [Property in keyof Type]-?: Type[Property];\n};\n\ntype MaybeUser = {\n  id: string;\n  name?: string;\n  age?: number;\n};\n\n/*\ntype User = {\n    id: string;\n    name: string;\n    age: number;\n}\n*/\ntype User = Concrete<MaybeUser>;\n```\n\n### 7.6.2 通过 `as` 做 `key` 重映射\n\n在TypeScript 4.1及以后的版本中，你可以通过映射类型中的as子句重新映射映射类型中的键。\n\n```tsx\ntype MappedTypeWithNewProperties<Type> = {\n  [Properties in keyof Type as NewKeyType]: Type[Properties];\n};\n```\n\n你可以利用[模板字面类型](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)等功能，从先前的属性名称中创建新的属性名称。\n\n```tsx\ntype Getters<Type> = {\n  [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property];\n};\n\ninterface Person {\n  name: string;\n  age: number;\n  location: string;\n}\n\n/*\ntype LazyPerson = {\n  getName: () => string;\n  getAge: () => number;\n  getLocation: () => string;\n}\n*/\ntype LazyPerson = Getters<Person>;\n```\n\n你可以通过条件类型产生`never`滤掉的键。\n\n```tsx\n// 删除 \"kind\"属性\ntype RemoveKindField<Type> = {\n  [Property in keyof Type as Exclude<Property, \"kind\">]: Type[Property];\n};\n\n/*\ntype KindlessCircle = {\n    radius: number;\n}\n*/\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\ntype KindlessCircle = RemoveKindField<Circle>;\n```\n\n你可以映射任意的联合体，不仅仅是`string | number | symbol`的联合体，还有任何类型的联合体。\n\n```tsx\ntype EventConfig<Events extends { kind: string }> = {\n  [E in Events as E[\"kind\"]]: (event: E) => void;\n};\n\ntype SquareEvent = { kind: \"square\"; x: number; y: number };\ntype CircleEvent = { kind: \"circle\"; radius: number };\n\n/*\ntype Config = {\n    square: (event: SquareEvent) => void;\n    circle: (event: CircleEvent) => void;\n}\n*/\ntype Config = EventConfig<SquareEvent | CircleEvent>;\n```\n\n### 7.6.3 进一步探索\n\n映射类型与本类型操作部分的其他功能配合得很好，例如，这里有一个[使用条件类型的映射类型](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) ，它根据一个对象的属性`pii`是否被设置为字面意义上的 `true`，返回`true`或`false`。\n\n```tsx\ntype ExtractPII<Type> = {\n  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;\n};\n\n/*\ntype ObjectsNeedingGDPRDeletion = {\n  id: false;\n  name: true;\n}\n*/\ntype DBFields = {\n  id: { format: \"incrementing\" };\n  name: { type: string; pii: true };\n};\n\ntype ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-7、基础篇：类型操纵.md",
        "raw": "---\ntitle: 1-7、基础篇：类型操纵\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 2401\ndate: 2024-01-28 19:41:58\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 七、类型操纵\n\n## 7.0 从类型中创建类型\n\nTypeScript的类型系统非常强大，因为它允许用其他类型的术语来表达类型。\n\n这个想法的最简单的形式是泛型，我们实际上有各种各样的类型操作符可以使用。也可以用我们已经有的值来表达类型。\n\n通过结合各种类型操作符，我们可以用一种简洁、可维护的方式来表达复杂的操作和值。在本节中，我们将介绍用现有的类型或值来表达一个新类型的方法。\n\n- 泛型型 - 带参数的类型\n\n- Keyof 类型操作符- `keyof` 操作符创建新类型\n- Typeof 类型操作符 - 使用 `typeof` 操作符来创建新的类型`\n- 索引访问类型 - 使用 `Type['a']` 语法来访问一个类型的子集\n- 条件类型 - 在类型系统中像if语句一样行事的类型\n- 映射类型 - 通过映射现有类型中的每个属性来创建类型\n- 模板字面量类型 - 通过模板字面字符串改变属性的映射类型\n\n## 7.1 泛型\n\n软件工程的一个主要部分是建立组件，这些组件不仅有定义明确和一致的API，而且还可以重复使用。能够处理今天的数据和明天的数据的组件将为你建立大型软件系统提供最灵活的能力。\n\n在像C#和Java这样的语言中，创建可重用组件的工具箱中的主要工具之一是泛型，也就是说，能够创建一个在各种类型上工作的组件，而不是单一的类型。这使得用户可以消费这些组件并使用他们自己的类型。\n\n### 7.1.1 Hello World\n\n首先，让我们做一下泛型的 \" hello world\"：身份函数。身份函数是一个函数，它将返回传入的任何内容。你可以用类似于echo命令的方式来考虑它。\n\n如果没有泛型，我们将不得不给身份函数一个特定的类型。\n\n```tsx\nfunction identity(arg: number): number {\n  return arg;\n}\n```\n\n或者，我们可以用任意类型来描述身份函数。\n\n```tsx\nfunction identity(arg: any): any {\n  return arg;\n}\n```\n\n使用 `any` 当然是通用的，因为它将使函数接受 `arg`类型的任何和所有的类型，但实际上我们在函数返回时失去了关于该类型的信息。如果我们传入一个数字，我们唯一的信息就是任何类型都可以被返回。\n\n相反，我们需要一种方法来捕获参数的类型，以便我们也可以用它来表示返回的内容。在这里，我们将使用一个类型变量，这是一种特殊的变量，对类型而不是数值起作用。\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n```\n\n我们现在已经在身份函数中添加了一个类型变量 `Type`。这个 `Type` 允许我们捕获用户提供的类型（例如数字），这样我们就可以在以后使用这些信息。这里，我们再次使用Type作为返回类型。经过检查，我们现在可以看到参数和返回类型使用的是相同的类型。这使得我们可以将类型信息从函数的一侧输入，然后从另一侧输出。\n\n我们说这个版本的身份函数是通用的，因为它在一系列的类型上工作。与使用任何类型不同的是，它也和第一个使用数字作为参数和返回类型的身份函数一样精确（即，它不会丢失任何信息）。\n\n一旦我们写好了通用身份函数，我们就可以用两种方式之一来调用它。第一种方式是将所有的参数，包括类型参数，都传递给函数：\n\n```tsx\nlet output = identity<string>(\"myString\");\n```\n\n这里我们明确地将 `Type` 设置为`string`，作为函数调用的参数之一，用参数周围的 `<>` 而不是 `()` 来表示。\n\n第二种方式可能也是最常见的。这里我们使用类型参数推理——也就是说，我们希望编译器根据我们传入的参数的类型，自动为我们设置 `Type` 的值。\n\n```tsx\nlet output = identity(\"myString\");\n```\n\n注意，我们不必在角括号（<>）中明确地传递类型；编译器只是查看了 \"myString \"这个值，并将Type设置为其类型。虽然类型参数推断是一个有用的工具，可以使代码更短、更易读，但当编译器不能推断出类型时，你可能需要像我们在前面的例子中那样明确地传入类型参数，这在更复杂的例子中可能发生。\n\n### 7.1.2 使用通用类型变量\n\n当你开始使用泛型时，你会注意到，当你创建像`identity`这样的泛型函数时，编译器会强制要求你在函数主体中正确使用任何泛型参数。也就是说，你实际上是把这些参数当作是任何和所有的类型。\n\n让我们来看看我们前面的 `identity` 函数。\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n```\n\n如果我们想在每次调用时将参数 `arg` 的长度记录到控制台，该怎么办？我们可能很想这样写：\n\n```tsx\nfunction loggingIdentity<Type>(arg: Type): Type {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/dqsOFKoSHTPJBMv.png\" alt=\"image-20211127215153933\" style=\"zoom:50%;\" />\n\n当我们这样做时，编译器会给我们一个错误，说我们在使用 `arg` 的 `.length` 成员，但我们没有说 `arg` 有这个成员。记住，我们在前面说过，这些类型的变量可以代表任何和所有的类型，所以使用这个函数的人可以传入一个`number` ，而这个数字没有一个 `.length` 成员。\n\n比方说，我们实际上是想让这个函数在 `Type` 的数组上工作，而不是直接在 `Type`上工作。既然我们在处理数组，那么`.length`成员应该是可用的。我们可以像创建其他类型的数组那样来描述它。\n\n```tsx\nfunction loggingIdentity<Type>(arg: Type[]): Type[] {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n你可以把 `loggingIdentity` 的类型理解为 \"通用函数 `loggingIdentity` 接收一个类型参数 `Type` 和一个参数 `arg`，`arg`是一个`Type`数组，并返回一个`Type`数组。\" 如果我们传入一个数字数组，我们会得到一个数字数组，因为Type会绑定到数字。这允许我们使用我们的通用类型变量 `Type` 作为我们正在处理的类型的一部分，而不是整个类型，给我们更大的灵活性。\n\n我们也可以这样来写这个例子：\n\n```tsx\nfunction loggingIdentity<Type>(arg: Array<Type>): Array<Type> {\n  console.log(arg.length); // 数组有一个.length，所以不会再出错了\n  return arg;\n}\n```\n\n你可能已经从其他语言中熟悉了这种类型的风格。在下一节中，我们将介绍如何创建你自己的通用类型，如`Array<Type>`。\n\n### 7.1.3 泛型类型\n\n在前几节中，我们创建了在一系列类型上工作的通用身份函数。在这一节中，我们将探讨函数本身的类型以及如何创建通用接口。\n\n泛型函数的类型与非泛型函数的类型一样，类型参数列在前面，与函数声明类似：\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: <Type>(arg: Type) => Type = identity;\n```\n\n我们也可以为类型中的通用类型参数使用一个不同的名字，只要类型变量的数量和类型变量的使用方式一致。\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: <Input>(arg: Input) => Input = identity;\n```\n\n我们也可以把泛型写成一个对象字面类型的调用签名。\n\n```tsx\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: { <Type>(arg: Type): Type } = identity;\n```\n\n这让我们开始编写我们的第一个泛型接口。让我们把前面例子中的对象字面意思移到一个接口中。\n\n```tsx\ninterface GenericIdentityFn {\n  <Type>(arg: Type): Type;\n}\n\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: GenericIdentityFn = identity;\n```\n\n在一个类似的例子中，我们可能想把通用参数移到整个接口的参数上。这可以让我们看到我们的泛型是什么类型（例如，`Dictionary<string>`而不是仅仅`Dictionary`）。这使得类型参数对接口的所有其他成员可见。\n\n```tsx\ninterface GenericIdentityFn<Type> {\n  (arg: Type): Type;\n}\n\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity;\n```\n\n请注意，我们的例子已经改变了，变成了稍微不同的东西。我们现在没有描述一个泛型函数，而是有一个非泛型的函数签名，它是泛型类型的一部分。当我们使用 `GenericIdentityFn` 时，我们现在还需要指定相应的类型参数（这里是：数字），有效地锁定了底层调用签名将使用什么。了解什么时候把类型参数直接放在调用签名上，什么时候把它放在接口本身，将有助于描述一个类型的哪些方面是通用的。\n\n除了泛型接口之外，我们还可以创建泛型类。注意，不可能创建泛型枚举和命名空间。\n\n### 7.1.4 泛型类\n\n一个泛型类的形状与泛型接口相似。泛型类在类的名字后面有一个角括号（<>）中的泛型参数列表。\n\n```tsx\nclass GenericNumber<NumType> {\n  zeroValue: NumType;\n  add: (x: NumType, y: NumType) => NumType;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n```\n\n这是对`GenericNumber`类相当直白的使用，但你可能已经注意到，没有任何东西限制它只能使用数字类型。我们本可以使用字符串或更复杂的对象。\n\n```tsx\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \"\";\nstringNumeric.add = function (x, y) {\n  return x + y;\n};\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\n```\n\n就像接口一样，把类型参数放在类本身，可以让我们确保类的所有属性都与相同的类型一起工作。\n\n正如我们在关于类的章节中提到的，一个类的类型有两个方面：静态方面和实例方面。通用类只在其实例侧而非静态侧具有通用性，所以在使用类时，静态成员不能使用类的类型参数。\n\n### 7.1.5 泛型约束\n\n如果你还记得前面的例子，你有时可能想写一个通用函数，在一组类型上工作，而你对这组类型会有什么能力有一定的了解。在我们的 `loggingIdentity` 例子中，我们希望能够访问 `arg.length` 属性，但是编译器无法证明每个类型都有一个 `.length` 属性，所以它警告我们不能做这个假设。\n\n```tsx\nfunction loggingIdentity<Type>(arg: Type): Type {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/gS8VUxOYPyER62K.png\" alt=\"image-20211128095950588\" style=\"zoom:50%;\" />\n\n我们希望限制这个函数与 `any` 和所有类型一起工作，而不是与 `any` 和所有同时具有 `.length` 属性的类型一起工作。只要这个类型有这个成员，我们就允许它，但它必须至少有这个成员。要做到这一点，我们必须把我们的要求作为一个约束条件列在 `Type` 可以是什么。\n\n为了做到这一点，我们将创建一个接口来描述我们的约束。在这里，我们将创建一个接口，它有一个单一的 `.length` 属性，然后我们将使用这个接和 `extends` 关键字来表示我们的约束条件。\n\n```tsx\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<Type extends Lengthwise>(arg: Type): Type {\n  console.log(arg.length); // 现在我们知道它有一个 .length 属性，所以不再有错误了\n  return arg;\n}\n```\n\n因为泛型函数现在被限制了，它将不再对 `any` 和 所有的类型起作用。\n\n```\nloggingIdentity(3);\n```\n\n<img src=\"/img/TypeScript/07-03.png\" alt=\"image-20211128102358263\" style=\"zoom:50%;\" />\n\n相反，我们需要传入其类型具有所有所需属性的值。\n\n```tsx\nloggingIdentity({ length: 10, value: 3 });\n```\n\n### 7.1.6 在泛型约束中使用类型参数\n\n你可以声明一个受另一个类型参数约束的类型参数。例如，在这里我们想从一个给定名称的对象中获取一个属性。我们想确保我们不会意外地获取一个不存在于 `obj` 上的属性，所以我们要在这两种类型之间放置一个约束条件。\n\n```tsx\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, \"a\");\ngetProperty(x, \"m\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/MrLOcvzYgSbophf.png\" alt=\"image-20211128103719103\" style=\"zoom:50%;\" />\n\n### 7.1.7 在泛型中使用类类型\n\n在TypeScript中使用泛型创建工厂时，有必要通过其构造函数来引用类的类型。比如说：\n\n```tsx\nfunction create<Type>(c: { new (): Type }): Type {\n  return new c();\n}\n```\n\n一个更高级的例子，使用原型属性来推断和约束类类型的构造函数和实例方之间的关系。\n\n```tsx\nclass BeeKeeper {\n  hasMask: boolean = true;\n}\n\nclass ZooKeeper {\n  nametag: string = \"Mikle\";\n}\n\nclass Animal {\n  numLegs: number = 4;\n}\n\nclass Bee extends Animal {\n  keeper: BeeKeeper = new BeeKeeper();\n}\n\nclass Lion extends Animal {\n  keeper: ZooKeeper = new ZooKeeper();\n}\n\nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n\ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\n```\n\n## 7.2 `Keyof`类型操作符\n\n`keyof`运算符接收一个对象类型，并产生其键的字符串或数字字面联合。下面的类型P与 \"x\"|\"y \"是同一类型。\n\n```tsx\ntype Point = { x: number; y: number };\ntype P = keyof Point;\nconst p1: P = \"x\";\nconst p2: P = \"y\";\n```\n\n如果该类型有一个字符串或数字索引签名，`keyof` 将返回这些类型。\n\n```tsx\ntype Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish;\nconst a: A = 0;\n\ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish;\nconst m: M = \"a\";\nconst m2: M = 10;\n```\n\n注意，在这个例子中，`M`是 `string|number`——这是因为JavaScript对象的键总是被强制为字符串，所以 `obj[0]`总是与`obj[\"0\"]`相同。\n\n`keyof`类型在与映射类型结合时变得特别有用，我们将在后面进一步了解。\n\n## 7.3 `Typeof` 类型操作符\n\nJavaScript已经有一个 `typeof` 操作符，你可以在表达式上下文中使用。\n\n```tsx\n// 输出 \"string\"\nconsole.log(typeof \"Hello world\");\n```\n\nTypeScript添加了一个`typeof`操作符，你可以在类型上下文中使用它来引用一个变量或属性的类型。\n\n```tsx\nlet s = \"hello\";\nlet n: typeof s;\nn = \"world\";\nn = 100;\n```\n\n<img src=\"/img/TypeScript/07-05.png\" alt=\"image-20211128110305093\" style=\"zoom:50%;\" />\n\n这对基本类型来说不是很有用，但结合其他类型操作符，你可以使用typeof来方便地表达许多模式。举一个例子，让我们先看看预定义的类型`ReturnType<T>`。它接收一个函数类型并产生其返回类型：\n\n```tsx\ntype Predicate = (x: unknown) => boolean;\ntype K = ReturnType<Predicate>;\n```\n\n如果我们试图在一个函数名上使用 `ReturnType`，我们会看到一个指示性的错误。\n\n```tsx\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<f>;\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/foM6iTw7GecalgD.png\" alt=\"image-20211128111022283\" style=\"zoom:50%;\" />\n\n请记住，值和类型并不是一回事。为了指代值f的类型，我们使用 `typeof`。\n\n```tsx\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<typeof f>;\n```\n\nTypeScript 故意限制了你可以使用 typeof 的表达式种类。\n\n具体来说，只有在标识符（即变量名）或其属性上使用typeof是合法的。这有助于避免混乱的陷阱，即编写你认为是在执行的代码，但其实不是。\n\n```tsx\n// 我们认为使用 = ReturnType<typeof msgbox>\nlet shouldContinue: typeof msgbox(\"Are you sure you want to continue?\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/AUnW94tZuiI2fLw.png\" alt=\"image-20211128111627727\" style=\"zoom:50%;\" />\n\n## 7.4 索引访问类型\n\n我们可以使用一个索引访问类型来查询另一个类型上的特定属性：\n\n```tsx\ntype Person = { age: number; name: string; alive: boolean };\ntype Age = Person[\"age\"];\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/vdRnGwYBI6r4Elx.png\" alt=\"image-20211128114411725\" style=\"zoom:50%;\" />\n\n索引类型本身就是一个类型，所以我们可以完全使用 unions、`keyof` 或者其他类型。\n\n```tsx\ninterface Person {\n  name: string;\n  age: number;\n  alive: boolean;\n}\n\n// type I1 = string | number\ntype I1 = Person[\"age\" | \"name\"];\nconst i11: I1 = 100;\nconst i12: I1 = \"\";\n\n// type I2 = string | number | boolean\ntype I2 = Person[keyof Person];\nconst i21: I2 = \"\";\nconst i22: I2 = 100;\nconst i23: I2 = false;\n\n// type I3 = Person[AliveOrName];\ntype AliveOrName = \"alive\" | \"name\";\nconst aon1: AliveOrName = \"alive\";\nconst aon2: AliveOrName = \"name\";\n```\n\n如果你试图索引一个不存在的属性，你甚至会看到一个错误：\n\n```tsx\ntype I1 = Person[\"alve\"];\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/aKBPU27y5pJLQz3.png\" alt=\"image-20211128115726772\" style=\"zoom:50%;\" />\n\n另一个使用任意类型进行索引的例子是使用`number`来获取一个数组元素的类型。我们可以把它和 `typeof`结合起来，方便地获取一个数组字面的元素类型。\n\n```tsx\nconst MyArray = [\n  { name: \"Alice\", age: 15 },\n  { name: \"Bob\", age: 23 },\n  { name: \"Eve\", age: 38 },\n];\n\n/* type Person = {\n    name: string;\n    age: number;\n} */\ntype Person = (typeof MyArray)[number];\nconst p: Person = {\n  name: \"xiaoqian\",\n  age: 11,\n};\n\n// type Age = number\ntype Age = (typeof MyArray)[number][\"age\"];\nconst age: Age = 11;\n\n// 或者\n// type Age2 = number\ntype Age2 = Person[\"age\"];\nconst age2: Age2 = 11;\n```\n\n你只能在索引时使用类型，这意味着你不能使用`const`来做一个变量引用：\n\n```tsx\nconst key = \"age\";\ntype Age = Person[key];\n```\n\n<img src=\"/img/TypeScript/08-03.png\" alt=\"image-20211128122324127\" style=\"zoom:60%;\" />\n\n然而，你可以使用类型别名来实现类似的重构风格：\n\n```tsx\ntype key = \"age\";\ntype Age = Person[key];\n```\n\n## 7.5 条件类型\n\n在大多数有用的程序的核心，我们必须根据输入来做决定。JavaScript程序也不例外，但鉴于数值可以很容易地被内省，这些决定也是基于输入的类型。条件类型有助于描述输入和输出的类型之间的关系。\n\n```tsx\ninterface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n\n// type Example1 = number\ntype Example1 = Dog extends Animal ? number : string;\n\n// type Example2 = string\ntype Example2 = RegExp extends Animal ? number : string;\n```\n\n条件类型的形式看起来有点像JavaScript中的条件表达式（`condition ? trueExpression : falseExpression`）。\n\n```tsx\n SomeType extends OtherType ? TrueType : FalseType;\n```\n\n当 `extends` 左边的类型可以赋值给右边的类型时，那么你将得到第一个分支中的类型（\"真 \"分支）；否则你将得到后一个分支中的类型（\"假 \"分支）。\n\n从上面的例子来看，条件类型可能并不立即显得有用——我们可以告诉自己是否 `Dog extends Animal`，并选择 `number`或`string`！但条件类型的威力来自于它所带来的好处。条件类型的力量来自于将它们与泛型一起使用。\n\n例如，让我们来看看下面这个 `createLabel` 函数：\n\n```tsx\ninterface IdLabel {\n  id: number /* 一些字段 */;\n}\ninterface NameLabel {\n  name: string /* 另一些字段 */;\n}\n\nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel {\n  throw \"unimplemented\";\n}\n```\n\n`createLabel`的这些重载描述了一个单一的JavaScript函数，该函数根据其输入的类型做出选择。注意一些事情：\n\n- 如果一个库必须在其API中反复做出同样的选择，这就会变得很麻烦。\n- 我们必须创建三个重载：一个用于确定类型的情况（一个用于 `string`，一个用于 `number`），一个用于最一般的情况（取一个 `string`| `number`）。对于 `createLabel`所能处理的每一种新类型，重载的数量都会呈指数级增长。\n\n相反，我们可以在一个条件类型中对该逻辑进行编码：\n\n```tsx\ntype NameOrId<T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n```\n\n然后我们可以使用该条件类型，将我们的重载简化为一个没有重载的单一函数。\n\n```tsx\ninterface IdLabel {\n  id: number /* some fields */;\n}\ninterface NameLabel {\n  name: string /* other fields */;\n}\n\ntype NameOrId<T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n\nfunction createLabel<T extends number | string>(idOrName: T): NameOrId<T> {\n  throw \"unimplemented\";\n}\n\n// let a: NameLabel\nlet a = createLabel(\"typescript\");\n\n// let b: IdLabel\nlet b = createLabel(2.8);\n\n// let c: NameLabel | IdLabel\nlet c = createLabel(Math.random() ? \"hello\" : 42);\n```\n\n### 7.5.1 条件类型约束\n\n通常，条件类型中的检查会给我们提供一些新的信息。就像用类型守卫缩小范围可以给我们一个更具体的类型一样，条件类型的真正分支将通过我们检查的类型进一步约束泛型。\n\n例如，让我们来看看下面的例子：\n\n```tsx\ntype MessageOf<T> = T[\"message\"];\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/GEXfr1zpLO2ghPw.png\" alt=\"image-20211129092739341\" style=\"zoom:50%;\" />\n\n在这个例子中，TypeScript出错是因为 `T` 不知道有一个叫做 `message` 的属性。我们可以对 `T` 进行约束，TypeScript就不会再抱怨。\n\n```tsx\ntype MessageOf<T extends { message: unknown }> = T[\"message\"];\n\ninterface Email {\n  message: string;\n}\n\ntype EmailMessageContents = MessageOf<Email>;\n```\n\n然而，如果我们想让 `MessageOf` 接受任何类型，并在消息属性不可用的情况下，默认为 `never`类型呢？我们可以通过将约束条件移出，并引入一个条件类型来做到这一点。\n\n```tsx\ntype MessageOf<T> = T extends { message: unknown } ? T[\"message\"] : never;\n\ninterface Email {\n  message: string;\n}\n\ninterface Dog {\n  bark(): void;\n}\n\n// type EmailMessageContents = string\ntype EmailMessageContents = MessageOf<Email>;\nconst emc: EmailMessageContents = \"balabala...\";\n\n// type DogMessageContents = never\ntype DogMessageContents = MessageOf<Dog>;\nconst dmc: DogMessageContents = \"error\" as never;\n```\n\n在真正的分支中，TypeScript知道 `T`会有一个消息属性。\n\n作为另一个例子，我们也可以写一个叫做 `Flatten` 的类型，将数组类型平铺到它们的元素类型上，但在其他方面则不做处理。\n\n```tsx\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\n// 提取出元素类型。\n// type Str = string\ntype Str = Flatten<string[]>;\n\n// 单独一个类型。\n// type Num = number\ntype Num = Flatten<number>;\n```\n\n当 `Flatten` 被赋予一个数组类型时，它使用一个带有数字的索引访问来获取 `string[]` 的元素类型。否则，它只是返回它被赋予的类型。\n\n### 7.5.2 在条件类型内进行推理\n\n我们只是发现自己使用条件类型来应用约束条件，然后提取出类型。这最终成为一种常见的操作，而条件类型使它变得更容易。\n\n条件类型为我们提供了一种方法来推断我们在真实分支中使用 `infer` 关键字进行对比的类型。例如，我们可以在`Flatten` 中推断出元素类型，而不是用索引访问类型 \"手动 \"提取出来。\n\n```tsx\ntype Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\n```\n\n在这里，我们使用 `infer` 关键字来声明性地引入一个名为 `Item` 的新的通用类型变量，而不是指定如何在真实分支中检索 `T` 的元素类型。这使我们不必考虑如何挖掘和探测我们感兴趣的类型的结构。\n\n我们可以使用 `infer` 关键字编写一些有用的辅助类型别名。例如，对于简单的情况，我们可以从函数类型中提取出返回类型。\n\n```tsx\ntype GetReturnType<Type> = Type extends (...args: never[]) => infer Return\n  ? Return\n  : never;\n\n// type Num = number\ntype Num = GetReturnType<() => number>;\n\n// type Str = string\ntype Str = GetReturnType<(x: string) => string>;\n\n// type Bools = boolean[]\ntype Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]>;\n\n// 给泛型传入 string 类型，条件类型会返回 never\ntype Never = GetReturnType<string>;\nconst nev: Never = \"error\" as never;\n```\n\n当从一个具有多个调用签名的类型（如重载函数的类型）进行推断时，从最后一个签名进行推断（据推测，这是最容许的万能情况）。不可能根据参数类型的列表来执行重载解析。\n\n```tsx\ndeclare function stringOrNum(x: string): number;\ndeclare function stringOrNum(x: number): string;\ndeclare function stringOrNum(x: string | number): string | number;\n\n// type T1 = string | number\ntype T1 = ReturnType<typeof stringOrNum>;\n```\n\n### 7.5.3 分布式条件类型\n\n当条件类型作用于一个通用类型时，当给定一个联合类型时，它们就变成了分布式的。例如，以下面的例子为例：\n\n```tsx\ntype ToArray<Type> = Type extends any ? Type[] : never;\n```\n\n如果我们将一个联合类型插入ToArray，那么条件类型将被应用于该联合的每个成员。\n\n```tsx\ntype ToArray<Type> = Type extends any ? Type[] : never;\n\n// type StrArrOrNumArr = string[] | number[]\ntype StrArrOrNumArr = ToArray<string | number>;\n```\n\n这里发生的情况是，StrArrOrNumArr分布在：\n\n```tsx\nstring | number;\n```\n\n并对联合的每个成员类型进行映射，以达到有效的目的：\n\n```tsx\nToArray<string> | ToArray<number>;\n```\n\n这给我们留下了：\n\n```tsx\nstring[] | number[];\n```\n\n通常情况下，分布性是需要的行为。为了避免这种行为，你可以用方括号包围 `extends`关键字的每一边。\n\n```tsx\ntype ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n\n// 'StrArrOrNumArr'不再是一个联合类型\n// type StrArrOrNumArr = (string | number)[]\ntype StrArrOrNumArr = ToArrayNonDist<string | number>;\n```\n\n## 7.6 映射类型\n\n当你不想重复定义类型，一个类型可以以另一个类型为基础创建新类型。\n\n映射类型建立在索引签名的语法上，索引签名用于声明没有被提前声明的属性类型。\n\n```tsx\ntype OnlyBoolsAndHorses = {\n  [key: string]: boolean | Horse;\n};\n\nconst conforms: OnlyBoolsAndHorses = {\n  del: true,\n  rodney: false,\n};\n```\n\n映射类型是一种通用类型，它使用 `PropertyKeys`的联合（经常通过`keyof`创建）迭代键来创建一个类型。\n\n```tsx\ntype OptionsFlags<Type> = {\n  [Property in keyof Type]: boolean;\n};\n```\n\n在这个例子中，`OptionsFlags`将从`Type`类型中获取所有属性，并将它们的值改为布尔值。\n\n```tsx\ntype FeatureFlags = {\n  darkMode: () => void;\n  newUserProfile: () => void;\n};\n\n/*\ntype FeatureOptions = {\n    darkMode: boolean;\n    newUserProfile: boolean;\n}\n*/\ntype FeatureOptions = OptionsFlags<FeatureFlags>;\n```\n\n### 7.6.1 映射修改器\n\n在映射过程中，有两个额外的修饰符可以应用：`readonly`和`?` ，它们分别影响可变性和可选性。\n\n你可以通过用`-`或`+`作为前缀来删除或添加这些修饰语。如果你不加前缀，那么就假定是`+`。\n\n```tsx\ntype CreateMutable<Type> = {\n  // 从一个类型的属性中删除 \"readonly\"属性\n  -readonly [Property in keyof Type]: Type[Property];\n};\n\ntype LockedAccount = {\n  readonly id: string;\n  readonly name: string;\n};\n\n/*\ntype UnlockedAccount = {\n    id: string;\n    name: string;\n}\n*/\ntype UnlockedAccount = CreateMutable<LockedAccount>;\n```\n\n```tsx\n// 从一个类型的属性中删除 \"可选\" 属性\ntype Concrete<Type> = {\n  [Property in keyof Type]-?: Type[Property];\n};\n\ntype MaybeUser = {\n  id: string;\n  name?: string;\n  age?: number;\n};\n\n/*\ntype User = {\n    id: string;\n    name: string;\n    age: number;\n}\n*/\ntype User = Concrete<MaybeUser>;\n```\n\n### 7.6.2 通过 `as` 做 `key` 重映射\n\n在TypeScript 4.1及以后的版本中，你可以通过映射类型中的as子句重新映射映射类型中的键。\n\n```tsx\ntype MappedTypeWithNewProperties<Type> = {\n  [Properties in keyof Type as NewKeyType]: Type[Properties];\n};\n```\n\n你可以利用[模板字面类型](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)等功能，从先前的属性名称中创建新的属性名称。\n\n```tsx\ntype Getters<Type> = {\n  [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property];\n};\n\ninterface Person {\n  name: string;\n  age: number;\n  location: string;\n}\n\n/*\ntype LazyPerson = {\n  getName: () => string;\n  getAge: () => number;\n  getLocation: () => string;\n}\n*/\ntype LazyPerson = Getters<Person>;\n```\n\n你可以通过条件类型产生`never`滤掉的键。\n\n```tsx\n// 删除 \"kind\"属性\ntype RemoveKindField<Type> = {\n  [Property in keyof Type as Exclude<Property, \"kind\">]: Type[Property];\n};\n\n/*\ntype KindlessCircle = {\n    radius: number;\n}\n*/\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\ntype KindlessCircle = RemoveKindField<Circle>;\n```\n\n你可以映射任意的联合体，不仅仅是`string | number | symbol`的联合体，还有任何类型的联合体。\n\n```tsx\ntype EventConfig<Events extends { kind: string }> = {\n  [E in Events as E[\"kind\"]]: (event: E) => void;\n};\n\ntype SquareEvent = { kind: \"square\"; x: number; y: number };\ntype CircleEvent = { kind: \"circle\"; radius: number };\n\n/*\ntype Config = {\n    square: (event: SquareEvent) => void;\n    circle: (event: CircleEvent) => void;\n}\n*/\ntype Config = EventConfig<SquareEvent | CircleEvent>;\n```\n\n### 7.6.3 进一步探索\n\n映射类型与本类型操作部分的其他功能配合得很好，例如，这里有一个[使用条件类型的映射类型](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) ，它根据一个对象的属性`pii`是否被设置为字面意义上的 `true`，返回`true`或`false`。\n\n```tsx\ntype ExtractPII<Type> = {\n  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;\n};\n\n/*\ntype ObjectsNeedingGDPRDeletion = {\n  id: false;\n  name: true;\n}\n*/\ntype DBFields = {\n  id: { format: \"incrementing\" };\n  name: { type: string; pii: true };\n};\n\ntype ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-7、基础篇：类型操纵",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao3000n94v3hfofdvv1",
        "content": "<h1 id=\"七、类型操纵\"><a href=\"#七、类型操纵\" class=\"headerlink\" title=\"七、类型操纵\"></a>七、类型操纵</h1><h2 id=\"7-0-从类型中创建类型\"><a href=\"#7-0-从类型中创建类型\" class=\"headerlink\" title=\"7.0 从类型中创建类型\"></a>7.0 从类型中创建类型</h2><p>TypeScript的类型系统非常强大，因为它允许用其他类型的术语来表达类型。</p>\n<p>这个想法的最简单的形式是泛型，我们实际上有各种各样的类型操作符可以使用。也可以用我们已经有的值来表达类型。</p>\n<p>通过结合各种类型操作符，我们可以用一种简洁、可维护的方式来表达复杂的操作和值。在本节中，我们将介绍用现有的类型或值来表达一个新类型的方法。</p>\n<ul>\n<li><p>泛型型 - 带参数的类型</p>\n</li>\n<li><p>Keyof 类型操作符- <code>keyof</code> 操作符创建新类型</p>\n</li>\n<li><p>Typeof 类型操作符 - 使用 <code>typeof</code> 操作符来创建新的类型&#96;</p>\n</li>\n<li><p>索引访问类型 - 使用 <code>Type[&#39;a&#39;]</code> 语法来访问一个类型的子集</p>\n</li>\n<li><p>条件类型 - 在类型系统中像if语句一样行事的类型</p>\n</li>\n<li><p>映射类型 - 通过映射现有类型中的每个属性来创建类型</p>\n</li>\n<li><p>模板字面量类型 - 通过模板字面字符串改变属性的映射类型</p>\n</li>\n</ul>\n<h2 id=\"7-1-泛型\"><a href=\"#7-1-泛型\" class=\"headerlink\" title=\"7.1 泛型\"></a>7.1 泛型</h2><p>软件工程的一个主要部分是建立组件，这些组件不仅有定义明确和一致的API，而且还可以重复使用。能够处理今天的数据和明天的数据的组件将为你建立大型软件系统提供最灵活的能力。</p>\n<p>在像C#和Java这样的语言中，创建可重用组件的工具箱中的主要工具之一是泛型，也就是说，能够创建一个在各种类型上工作的组件，而不是单一的类型。这使得用户可以消费这些组件并使用他们自己的类型。</p>\n<h3 id=\"7-1-1-Hello-World\"><a href=\"#7-1-1-Hello-World\" class=\"headerlink\" title=\"7.1.1 Hello World\"></a>7.1.1 Hello World</h3><p>首先，让我们做一下泛型的 “ hello world”：身份函数。身份函数是一个函数，它将返回传入的任何内容。你可以用类似于echo命令的方式来考虑它。</p>\n<p>如果没有泛型，我们将不得不给身份函数一个特定的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">identity</span>(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者，我们可以用任意类型来描述身份函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">identity</span>(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"built_in\">any</span></span>): <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>any</code> 当然是通用的，因为它将使函数接受 <code>arg</code>类型的任何和所有的类型，但实际上我们在函数返回时失去了关于该类型的信息。如果我们传入一个数字，我们唯一的信息就是任何类型都可以被返回。</p>\n<p>相反，我们需要一种方法来捕获参数的类型，以便我们也可以用它来表示返回的内容。在这里，我们将使用一个类型变量，这是一种特殊的变量，对类型而不是数值起作用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们现在已经在身份函数中添加了一个类型变量 <code>Type</code>。这个 <code>Type</code> 允许我们捕获用户提供的类型（例如数字），这样我们就可以在以后使用这些信息。这里，我们再次使用Type作为返回类型。经过检查，我们现在可以看到参数和返回类型使用的是相同的类型。这使得我们可以将类型信息从函数的一侧输入，然后从另一侧输出。</p>\n<p>我们说这个版本的身份函数是通用的，因为它在一系列的类型上工作。与使用任何类型不同的是，它也和第一个使用数字作为参数和返回类型的身份函数一样精确（即，它不会丢失任何信息）。</p>\n<p>一旦我们写好了通用身份函数，我们就可以用两种方式之一来调用它。第一种方式是将所有的参数，包括类型参数，都传递给函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们明确地将 <code>Type</code> 设置为<code>string</code>，作为函数调用的参数之一，用参数周围的 <code>&lt;&gt;</code> 而不是 <code>()</code> 来表示。</p>\n<p>第二种方式可能也是最常见的。这里我们使用类型参数推理——也就是说，我们希望编译器根据我们传入的参数的类型，自动为我们设置 <code>Type</code> 的值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = <span class=\"title function_\">identity</span>(<span class=\"string\">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们不必在角括号（&lt;&gt;）中明确地传递类型；编译器只是查看了 “myString “这个值，并将Type设置为其类型。虽然类型参数推断是一个有用的工具，可以使代码更短、更易读，但当编译器不能推断出类型时，你可能需要像我们在前面的例子中那样明确地传入类型参数，这在更复杂的例子中可能发生。</p>\n<h3 id=\"7-1-2-使用通用类型变量\"><a href=\"#7-1-2-使用通用类型变量\" class=\"headerlink\" title=\"7.1.2 使用通用类型变量\"></a>7.1.2 使用通用类型变量</h3><p>当你开始使用泛型时，你会注意到，当你创建像<code>identity</code>这样的泛型函数时，编译器会强制要求你在函数主体中正确使用任何泛型参数。也就是说，你实际上是把这些参数当作是任何和所有的类型。</p>\n<p>让我们来看看我们前面的 <code>identity</code> 函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们想在每次调用时将参数 <code>arg</code> 的长度记录到控制台，该怎么办？我们可能很想这样写：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/dqsOFKoSHTPJBMv.png\" alt=\"image-20211127215153933\" style=\"zoom:50%;\" />\n\n<p>当我们这样做时，编译器会给我们一个错误，说我们在使用 <code>arg</code> 的 <code>.length</code> 成员，但我们没有说 <code>arg</code> 有这个成员。记住，我们在前面说过，这些类型的变量可以代表任何和所有的类型，所以使用这个函数的人可以传入一个<code>number</code> ，而这个数字没有一个 <code>.length</code> 成员。</p>\n<p>比方说，我们实际上是想让这个函数在 <code>Type</code> 的数组上工作，而不是直接在 <code>Type</code>上工作。既然我们在处理数组，那么<code>.length</code>成员应该是可用的。我们可以像创建其他类型的数组那样来描述它。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>[]): <span class=\"title class_\">Type</span>[] &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以把 <code>loggingIdentity</code> 的类型理解为 “通用函数 <code>loggingIdentity</code> 接收一个类型参数 <code>Type</code> 和一个参数 <code>arg</code>，<code>arg</code>是一个<code>Type</code>数组，并返回一个<code>Type</code>数组。” 如果我们传入一个数字数组，我们会得到一个数字数组，因为Type会绑定到数字。这允许我们使用我们的通用类型变量 <code>Type</code> 作为我们正在处理的类型的一部分，而不是整个类型，给我们更大的灵活性。</p>\n<p>我们也可以这样来写这个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">Type</span>&gt;): <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>); <span class=\"comment\">// 数组有一个.length，所以不会再出错了</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可能已经从其他语言中熟悉了这种类型的风格。在下一节中，我们将介绍如何创建你自己的通用类型，如<code>Array&lt;Type&gt;</code>。</p>\n<h3 id=\"7-1-3-泛型类型\"><a href=\"#7-1-3-泛型类型\" class=\"headerlink\" title=\"7.1.3 泛型类型\"></a>7.1.3 泛型类型</h3><p>在前几节中，我们创建了在一系列类型上工作的通用身份函数。在这一节中，我们将探讨函数本身的类型以及如何创建通用接口。</p>\n<p>泛型函数的类型与非泛型函数的类型一样，类型参数列在前面，与函数声明类似：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: &lt;<span class=\"title class_\">Type</span>&gt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span></span>) =&gt;</span> <span class=\"title class_\">Type</span> = identity;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以为类型中的通用类型参数使用一个不同的名字，只要类型变量的数量和类型变量的使用方式一致。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: &lt;<span class=\"title class_\">Input</span>&gt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"title class_\">Input</span></span>) =&gt;</span> <span class=\"title class_\">Input</span> = identity;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以把泛型写成一个对象字面类型的调用签名。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: &#123; &lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#125; = identity;</span><br></pre></td></tr></table></figure>\n\n<p>这让我们开始编写我们的第一个泛型接口。让我们把前面例子中的对象字面意思移到一个接口中。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">GenericIdentityFn</span> &#123;</span><br><span class=\"line\">  &lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: <span class=\"title class_\">GenericIdentityFn</span> = identity;</span><br></pre></td></tr></table></figure>\n\n<p>在一个类似的例子中，我们可能想把通用参数移到整个接口的参数上。这可以让我们看到我们的泛型是什么类型（例如，<code>Dictionary&lt;string&gt;</code>而不是仅仅<code>Dictionary</code>）。这使得类型参数对接口的所有其他成员可见。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">GenericIdentityFn</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  (<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: <span class=\"title class_\">GenericIdentityFn</span>&lt;<span class=\"built_in\">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，我们的例子已经改变了，变成了稍微不同的东西。我们现在没有描述一个泛型函数，而是有一个非泛型的函数签名，它是泛型类型的一部分。当我们使用 <code>GenericIdentityFn</code> 时，我们现在还需要指定相应的类型参数（这里是：数字），有效地锁定了底层调用签名将使用什么。了解什么时候把类型参数直接放在调用签名上，什么时候把它放在接口本身，将有助于描述一个类型的哪些方面是通用的。</p>\n<p>除了泛型接口之外，我们还可以创建泛型类。注意，不可能创建泛型枚举和命名空间。</p>\n<h3 id=\"7-1-4-泛型类\"><a href=\"#7-1-4-泛型类\" class=\"headerlink\" title=\"7.1.4 泛型类\"></a>7.1.4 泛型类</h3><p>一个泛型类的形状与泛型接口相似。泛型类在类的名字后面有一个角括号（&lt;&gt;）中的泛型参数列表。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GenericNumber</span>&lt;<span class=\"title class_\">NumType</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">zeroValue</span>: <span class=\"title class_\">NumType</span>;</span><br><span class=\"line\">  <span class=\"attr\">add</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">NumType</span>, <span class=\"attr\">y</span>: <span class=\"title class_\">NumType</span></span>) =&gt;</span> <span class=\"title class_\">NumType</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> <span class=\"title class_\">GenericNumber</span>&lt;<span class=\"built_in\">number</span>&gt;();</span><br><span class=\"line\">myGenericNumber.<span class=\"property\">zeroValue</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">myGenericNumber.<span class=\"property\">add</span> = <span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是对<code>GenericNumber</code>类相当直白的使用，但你可能已经注意到，没有任何东西限制它只能使用数字类型。我们本可以使用字符串或更复杂的对象。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringNumeric = <span class=\"keyword\">new</span> <span class=\"title class_\">GenericNumber</span>&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">stringNumeric.<span class=\"property\">zeroValue</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">stringNumeric.<span class=\"property\">add</span> = <span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(stringNumeric.<span class=\"title function_\">add</span>(stringNumeric.<span class=\"property\">zeroValue</span>, <span class=\"string\">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>就像接口一样，把类型参数放在类本身，可以让我们确保类的所有属性都与相同的类型一起工作。</p>\n<p>正如我们在关于类的章节中提到的，一个类的类型有两个方面：静态方面和实例方面。通用类只在其实例侧而非静态侧具有通用性，所以在使用类时，静态成员不能使用类的类型参数。</p>\n<h3 id=\"7-1-5-泛型约束\"><a href=\"#7-1-5-泛型约束\" class=\"headerlink\" title=\"7.1.5 泛型约束\"></a>7.1.5 泛型约束</h3><p>如果你还记得前面的例子，你有时可能想写一个通用函数，在一组类型上工作，而你对这组类型会有什么能力有一定的了解。在我们的 <code>loggingIdentity</code> 例子中，我们希望能够访问 <code>arg.length</code> 属性，但是编译器无法证明每个类型都有一个 <code>.length</code> 属性，所以它警告我们不能做这个假设。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/gS8VUxOYPyER62K.png\" alt=\"image-20211128095950588\" style=\"zoom:50%;\" />\n\n<p>我们希望限制这个函数与 <code>any</code> 和所有类型一起工作，而不是与 <code>any</code> 和所有同时具有 <code>.length</code> 属性的类型一起工作。只要这个类型有这个成员，我们就允许它，但它必须至少有这个成员。要做到这一点，我们必须把我们的要求作为一个约束条件列在 <code>Type</code> 可以是什么。</p>\n<p>为了做到这一点，我们将创建一个接口来描述我们的约束。在这里，我们将创建一个接口，它有一个单一的 <code>.length</code> 属性，然后我们将使用这个接和 <code>extends</code> 关键字来表示我们的约束条件。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Lengthwise</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Lengthwise</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>); <span class=\"comment\">// 现在我们知道它有一个 .length 属性，所以不再有错误了</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为泛型函数现在被限制了，它将不再对 <code>any</code> 和 所有的类型起作用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">loggingIdentity(3);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/07-03.png\" alt=\"image-20211128102358263\" style=\"zoom:50%;\" />\n\n<p>相反，我们需要传入其类型具有所有所需属性的值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">loggingIdentity</span>(&#123; <span class=\"attr\">length</span>: <span class=\"number\">10</span>, <span class=\"attr\">value</span>: <span class=\"number\">3</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-6-在泛型约束中使用类型参数\"><a href=\"#7-1-6-在泛型约束中使用类型参数\" class=\"headerlink\" title=\"7.1.6 在泛型约束中使用类型参数\"></a>7.1.6 在泛型约束中使用类型参数</h3><p>你可以声明一个受另一个类型参数约束的类型参数。例如，在这里我们想从一个给定名称的对象中获取一个属性。我们想确保我们不会意外地获取一个不存在于 <code>obj</code> 上的属性，所以我们要在这两种类型之间放置一个约束条件。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> getProperty&lt;<span class=\"title class_\">Type</span>, <span class=\"title class_\">Key</span> <span class=\"keyword\">extends</span> keyof <span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">obj</span>: <span class=\"title class_\">Type</span>, <span class=\"attr\">key</span>: <span class=\"title class_\">Key</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">3</span>, <span class=\"attr\">d</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getProperty</span>(x, <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">getProperty</span>(x, <span class=\"string\">&quot;m&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/MrLOcvzYgSbophf.png\" alt=\"image-20211128103719103\" style=\"zoom:50%;\" />\n\n<h3 id=\"7-1-7-在泛型中使用类类型\"><a href=\"#7-1-7-在泛型中使用类类型\" class=\"headerlink\" title=\"7.1.7 在泛型中使用类类型\"></a>7.1.7 在泛型中使用类类型</h3><p>在TypeScript中使用泛型创建工厂时，有必要通过其构造函数来引用类的类型。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> create&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">c</span>: &#123; <span class=\"title function_\">new</span> (): <span class=\"title class_\">Type</span> &#125;): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">c</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个更高级的例子，使用原型属性来推断和约束类类型的构造函数和实例方之间的关系。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BeeKeeper</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">hasMask</span>: <span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeper</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">nametag</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;Mikle&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">numLegs</span>: <span class=\"built_in\">number</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bee</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">keeper</span>: <span class=\"title class_\">BeeKeeper</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">BeeKeeper</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">keeper</span>: <span class=\"title class_\">ZooKeeper</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ZooKeeper</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> createInstance&lt;A <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span>&gt;(<span class=\"attr\">c</span>: <span class=\"title function_\">new</span> () =&gt; A): A &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">c</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">createInstance</span>(<span class=\"title class_\">Lion</span>).<span class=\"property\">keeper</span>.<span class=\"property\">nametag</span>;</span><br><span class=\"line\"><span class=\"title function_\">createInstance</span>(<span class=\"title class_\">Bee</span>).<span class=\"property\">keeper</span>.<span class=\"property\">hasMask</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-2-Keyof类型操作符\"><a href=\"#7-2-Keyof类型操作符\" class=\"headerlink\" title=\"7.2 Keyof类型操作符\"></a>7.2 <code>Keyof</code>类型操作符</h2><p><code>keyof</code>运算符接收一个对象类型，并产生其键的字符串或数字字面联合。下面的类型P与 “x”|”y “是同一类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Point</span> = &#123; <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">y</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> P = keyof <span class=\"title class_\">Point</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p1</span>: P = <span class=\"string\">&quot;x&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p2</span>: P = <span class=\"string\">&quot;y&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果该类型有一个字符串或数字索引签名，<code>keyof</code> 将返回这些类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Arrayish</span> = &#123; [<span class=\"attr\">n</span>: <span class=\"built_in\">number</span>]: <span class=\"built_in\">unknown</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> A = keyof <span class=\"title class_\">Arrayish</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: A = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Mapish</span> = &#123; [<span class=\"attr\">k</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">boolean</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> M = keyof <span class=\"title class_\">Mapish</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">m</span>: M = <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">m2</span>: M = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意，在这个例子中，<code>M</code>是 <code>string|number</code>——这是因为JavaScript对象的键总是被强制为字符串，所以 <code>obj[0]</code>总是与<code>obj[&quot;0&quot;]</code>相同。</p>\n<p><code>keyof</code>类型在与映射类型结合时变得特别有用，我们将在后面进一步了解。</p>\n<h2 id=\"7-3-Typeof-类型操作符\"><a href=\"#7-3-Typeof-类型操作符\" class=\"headerlink\" title=\"7.3 Typeof 类型操作符\"></a>7.3 <code>Typeof</code> 类型操作符</h2><p>JavaScript已经有一个 <code>typeof</code> 操作符，你可以在表达式上下文中使用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"string\">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript添加了一个<code>typeof</code>操作符，你可以在类型上下文中使用它来引用一个变量或属性的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">n</span>: <span class=\"keyword\">typeof</span> s;</span><br><span class=\"line\">n = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">n = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/07-05.png\" alt=\"image-20211128110305093\" style=\"zoom:50%;\" />\n\n<p>这对基本类型来说不是很有用，但结合其他类型操作符，你可以使用typeof来方便地表达许多模式。举一个例子，让我们先看看预定义的类型<code>ReturnType&lt;T&gt;</code>。它接收一个函数类型并产生其返回类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Predicate</span> = <span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">unknown</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> K = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"title class_\">Predicate</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们试图在一个函数名上使用 <code>ReturnType</code>，我们会看到一个指示性的错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> P = <span class=\"title class_\">ReturnType</span>&lt;f&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/foM6iTw7GecalgD.png\" alt=\"image-20211128111022283\" style=\"zoom:50%;\" />\n\n<p>请记住，值和类型并不是一回事。为了指代值f的类型，我们使用 <code>typeof</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> P = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"keyword\">typeof</span> f&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript 故意限制了你可以使用 typeof 的表达式种类。</p>\n<p>具体来说，只有在标识符（即变量名）或其属性上使用typeof是合法的。这有助于避免混乱的陷阱，即编写你认为是在执行的代码，但其实不是。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们认为使用 = ReturnType&lt;typeof msgbox&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">shouldContinue</span>: <span class=\"keyword\">typeof</span> <span class=\"title function_\">msgbox</span>(<span class=\"string\">&quot;Are you sure you want to continue?&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/AUnW94tZuiI2fLw.png\" alt=\"image-20211128111627727\" style=\"zoom:50%;\" />\n\n<h2 id=\"7-4-索引访问类型\"><a href=\"#7-4-索引访问类型\" class=\"headerlink\" title=\"7.4 索引访问类型\"></a>7.4 索引访问类型</h2><p>我们可以使用一个索引访问类型来查询另一个类型上的特定属性：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Person</span> = &#123; <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">alive</span>: <span class=\"built_in\">boolean</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age</span> = <span class=\"title class_\">Person</span>[<span class=\"string\">&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/vdRnGwYBI6r4Elx.png\" alt=\"image-20211128114411725\" style=\"zoom:50%;\" />\n\n<p>索引类型本身就是一个类型，所以我们可以完全使用 unions、<code>keyof</code> 或者其他类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">alive</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type I1 = string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">I1</span> = <span class=\"title class_\">Person</span>[<span class=\"string\">&quot;age&quot;</span> | <span class=\"string\">&quot;name&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i11</span>: <span class=\"variable constant_\">I1</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i12</span>: <span class=\"variable constant_\">I1</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type I2 = string | number | boolean</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">I2</span> = <span class=\"title class_\">Person</span>[keyof <span class=\"title class_\">Person</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i21</span>: <span class=\"variable constant_\">I2</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i22</span>: <span class=\"variable constant_\">I2</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i23</span>: <span class=\"variable constant_\">I2</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type I3 = Person[AliveOrName];</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">AliveOrName</span> = <span class=\"string\">&quot;alive&quot;</span> | <span class=\"string\">&quot;name&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">aon1</span>: <span class=\"title class_\">AliveOrName</span> = <span class=\"string\">&quot;alive&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">aon2</span>: <span class=\"title class_\">AliveOrName</span> = <span class=\"string\">&quot;name&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果你试图索引一个不存在的属性，你甚至会看到一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">I1</span> = <span class=\"title class_\">Person</span>[<span class=\"string\">&quot;alve&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/aKBPU27y5pJLQz3.png\" alt=\"image-20211128115726772\" style=\"zoom:50%;\" />\n\n<p>另一个使用任意类型进行索引的例子是使用<code>number</code>来获取一个数组元素的类型。我们可以把它和 <code>typeof</code>结合起来，方便地获取一个数组字面的元素类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MyArray</span> = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">15</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Eve&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">38</span> &#125;,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* type Person = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    name: string;</span></span><br><span class=\"line\"><span class=\"comment\">    age: number;</span></span><br><span class=\"line\"><span class=\"comment\">&#125; */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Person</span> = (<span class=\"keyword\">typeof</span> <span class=\"title class_\">MyArray</span>)[<span class=\"built_in\">number</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p</span>: <span class=\"title class_\">Person</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;xiaoqian&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Age = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age</span> = (<span class=\"keyword\">typeof</span> <span class=\"title class_\">MyArray</span>)[<span class=\"built_in\">number</span>][<span class=\"string\">&quot;age&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">age</span>: <span class=\"title class_\">Age</span> = <span class=\"number\">11</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"comment\">// type Age2 = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age2</span> = <span class=\"title class_\">Person</span>[<span class=\"string\">&quot;age&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">age2</span>: <span class=\"title class_\">Age2</span> = <span class=\"number\">11</span>;</span><br></pre></td></tr></table></figure>\n\n<p>你只能在索引时使用类型，这意味着你不能使用<code>const</code>来做一个变量引用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">&quot;age&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age</span> = <span class=\"title class_\">Person</span>[key];</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/08-03.png\" alt=\"image-20211128122324127\" style=\"zoom:60%;\" />\n\n<p>然而，你可以使用类型别名来实现类似的重构风格：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> key = <span class=\"string\">&quot;age&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age</span> = <span class=\"title class_\">Person</span>[key];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-5-条件类型\"><a href=\"#7-5-条件类型\" class=\"headerlink\" title=\"7.5 条件类型\"></a>7.5 条件类型</h2><p>在大多数有用的程序的核心，我们必须根据输入来做决定。JavaScript程序也不例外，但鉴于数值可以很容易地被内省，这些决定也是基于输入的类型。条件类型有助于描述输入和输出的类型之间的关系。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">live</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">woof</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Example1 = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Example1</span> = <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> ? <span class=\"built_in\">number</span> : <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Example2 = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Example2</span> = <span class=\"title class_\">RegExp</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> ? <span class=\"built_in\">number</span> : <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n\n<p>条件类型的形式看起来有点像JavaScript中的条件表达式（<code>condition ? trueExpression : falseExpression</code>）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">SomeType</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OtherType</span> ? <span class=\"title class_\">TrueType</span> : <span class=\"title class_\">FalseType</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当 <code>extends</code> 左边的类型可以赋值给右边的类型时，那么你将得到第一个分支中的类型（”真 “分支）；否则你将得到后一个分支中的类型（”假 “分支）。</p>\n<p>从上面的例子来看，条件类型可能并不立即显得有用——我们可以告诉自己是否 <code>Dog extends Animal</code>，并选择 <code>number</code>或<code>string</code>！但条件类型的威力来自于它所带来的好处。条件类型的力量来自于将它们与泛型一起使用。</p>\n<p>例如，让我们来看看下面这个 <code>createLabel</code> 函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IdLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"built_in\">number</span> <span class=\"comment\">/* 一些字段 */</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NameLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> <span class=\"comment\">/* 另一些字段 */</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLabel</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">IdLabel</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLabel</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">NameLabel</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLabel</span>(<span class=\"params\"><span class=\"attr\">nameOrId</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>): <span class=\"title class_\">IdLabel</span> | <span class=\"title class_\">NameLabel</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLabel</span>(<span class=\"params\"><span class=\"attr\">nameOrId</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>): <span class=\"title class_\">IdLabel</span> | <span class=\"title class_\">NameLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">&quot;unimplemented&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>createLabel</code>的这些重载描述了一个单一的JavaScript函数，该函数根据其输入的类型做出选择。注意一些事情：</p>\n<ul>\n<li>如果一个库必须在其API中反复做出同样的选择，这就会变得很麻烦。</li>\n<li>我们必须创建三个重载：一个用于确定类型的情况（一个用于 <code>string</code>，一个用于 <code>number</code>），一个用于最一般的情况（取一个 <code>string</code>| <code>number</code>）。对于 <code>createLabel</code>所能处理的每一种新类型，重载的数量都会呈指数级增长。</li>\n</ul>\n<p>相反，我们可以在一个条件类型中对该逻辑进行编码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NameOrId</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span></span><br><span class=\"line\">  ? <span class=\"title class_\">IdLabel</span></span><br><span class=\"line\">  : <span class=\"title class_\">NameLabel</span>;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们可以使用该条件类型，将我们的重载简化为一个没有重载的单一函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IdLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"built_in\">number</span> <span class=\"comment\">/* some fields */</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NameLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> <span class=\"comment\">/* other fields */</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NameOrId</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span></span><br><span class=\"line\">  ? <span class=\"title class_\">IdLabel</span></span><br><span class=\"line\">  : <span class=\"title class_\">NameLabel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> createLabel&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>&gt;(<span class=\"attr\">idOrName</span>: T): <span class=\"title class_\">NameOrId</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">&quot;unimplemented&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let a: NameLabel</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"title function_\">createLabel</span>(<span class=\"string\">&quot;typescript&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let b: IdLabel</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"title function_\">createLabel</span>(<span class=\"number\">2.8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let c: NameLabel | IdLabel</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"title function_\">createLabel</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() ? <span class=\"string\">&quot;hello&quot;</span> : <span class=\"number\">42</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-5-1-条件类型约束\"><a href=\"#7-5-1-条件类型约束\" class=\"headerlink\" title=\"7.5.1 条件类型约束\"></a>7.5.1 条件类型约束</h3><p>通常，条件类型中的检查会给我们提供一些新的信息。就像用类型守卫缩小范围可以给我们一个更具体的类型一样，条件类型的真正分支将通过我们检查的类型进一步约束泛型。</p>\n<p>例如，让我们来看看下面的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MessageOf</span>&lt;T&gt; = T[<span class=\"string\">&quot;message&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/GEXfr1zpLO2ghPw.png\" alt=\"image-20211129092739341\" style=\"zoom:50%;\" />\n\n<p>在这个例子中，TypeScript出错是因为 <code>T</code> 不知道有一个叫做 <code>message</code> 的属性。我们可以对 <code>T</code> 进行约束，TypeScript就不会再抱怨。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MessageOf</span>&lt;T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">message</span>: <span class=\"built_in\">unknown</span> &#125;&gt; = T[<span class=\"string\">&quot;message&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Email</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">message</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">EmailMessageContents</span> = <span class=\"title class_\">MessageOf</span>&lt;<span class=\"title class_\">Email</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>然而，如果我们想让 <code>MessageOf</code> 接受任何类型，并在消息属性不可用的情况下，默认为 <code>never</code>类型呢？我们可以通过将约束条件移出，并引入一个条件类型来做到这一点。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MessageOf</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">message</span>: <span class=\"built_in\">unknown</span> &#125; ? T[<span class=\"string\">&quot;message&quot;</span>] : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Email</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">message</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">bark</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type EmailMessageContents = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">EmailMessageContents</span> = <span class=\"title class_\">MessageOf</span>&lt;<span class=\"title class_\">Email</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">emc</span>: <span class=\"title class_\">EmailMessageContents</span> = <span class=\"string\">&quot;balabala...&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type DogMessageContents = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DogMessageContents</span> = <span class=\"title class_\">MessageOf</span>&lt;<span class=\"title class_\">Dog</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">dmc</span>: <span class=\"title class_\">DogMessageContents</span> = <span class=\"string\">&quot;error&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在真正的分支中，TypeScript知道 <code>T</code>会有一个消息属性。</p>\n<p>作为另一个例子，我们也可以写一个叫做 <code>Flatten</code> 的类型，将数组类型平铺到它们的元素类型上，但在其他方面则不做处理。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Flatten</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[] ? T[<span class=\"built_in\">number</span>] : T;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提取出元素类型。</span></span><br><span class=\"line\"><span class=\"comment\">// type Str = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Str</span> = <span class=\"title class_\">Flatten</span>&lt;<span class=\"built_in\">string</span>[]&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单独一个类型。</span></span><br><span class=\"line\"><span class=\"comment\">// type Num = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Num</span> = <span class=\"title class_\">Flatten</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>当 <code>Flatten</code> 被赋予一个数组类型时，它使用一个带有数字的索引访问来获取 <code>string[]</code> 的元素类型。否则，它只是返回它被赋予的类型。</p>\n<h3 id=\"7-5-2-在条件类型内进行推理\"><a href=\"#7-5-2-在条件类型内进行推理\" class=\"headerlink\" title=\"7.5.2 在条件类型内进行推理\"></a>7.5.2 在条件类型内进行推理</h3><p>我们只是发现自己使用条件类型来应用约束条件，然后提取出类型。这最终成为一种常见的操作，而条件类型使它变得更容易。</p>\n<p>条件类型为我们提供了一种方法来推断我们在真实分支中使用 <code>infer</code> 关键字进行对比的类型。例如，我们可以在<code>Flatten</code> 中推断出元素类型，而不是用索引访问类型 “手动 “提取出来。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Flatten</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Array</span>&lt;infer <span class=\"title class_\">Item</span>&gt; ? <span class=\"title class_\">Item</span> : <span class=\"title class_\">Type</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们使用 <code>infer</code> 关键字来声明性地引入一个名为 <code>Item</code> 的新的通用类型变量，而不是指定如何在真实分支中检索 <code>T</code> 的元素类型。这使我们不必考虑如何挖掘和探测我们感兴趣的类型的结构。</p>\n<p>我们可以使用 <code>infer</code> 关键字编写一些有用的辅助类型别名。例如，对于简单的情况，我们可以从函数类型中提取出返回类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> <span class=\"title function_\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">never</span>[]) =&gt; infer <span class=\"title class_\">Return</span></span><br><span class=\"line\">  ? <span class=\"title class_\">Return</span></span><br><span class=\"line\">  : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Num = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Num</span> = <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Str = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Str</span> = <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Bools = boolean[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bools</span> = <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">boolean</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">boolean</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>[]&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给泛型传入 string 类型，条件类型会返回 never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Never</span> = <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">nev</span>: <span class=\"title class_\">Never</span> = <span class=\"string\">&quot;error&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当从一个具有多个调用签名的类型（如重载函数的类型）进行推断时，从最后一个签名进行推断（据推测，这是最容许的万能情况）。不可能根据参数类型的列表来执行重载解析。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">stringOrNum</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">stringOrNum</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">stringOrNum</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>): <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"keyword\">typeof</span> stringOrNum&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-5-3-分布式条件类型\"><a href=\"#7-5-3-分布式条件类型\" class=\"headerlink\" title=\"7.5.3 分布式条件类型\"></a>7.5.3 分布式条件类型</h3><p>当条件类型作用于一个通用类型时，当给定一个联合类型时，它们就变成了分布式的。例如，以下面的例子为例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ToArray</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span> ? <span class=\"title class_\">Type</span>[] : <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们将一个联合类型插入ToArray，那么条件类型将被应用于该联合的每个成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ToArray</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span> ? <span class=\"title class_\">Type</span>[] : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type StrArrOrNumArr = string[] | number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StrArrOrNumArr</span> = <span class=\"title class_\">ToArray</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>这里发生的情况是，StrArrOrNumArr分布在：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<p>并对联合的每个成员类型进行映射，以达到有效的目的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">ToArray</span>&lt;<span class=\"built_in\">string</span>&gt; | <span class=\"title class_\">ToArray</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>这给我们留下了：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>[] | <span class=\"built_in\">number</span>[];</span><br></pre></td></tr></table></figure>\n\n<p>通常情况下，分布性是需要的行为。为了避免这种行为，你可以用方括号包围 <code>extends</code>关键字的每一边。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ToArrayNonDist</span>&lt;<span class=\"title class_\">Type</span>&gt; = [<span class=\"title class_\">Type</span>] <span class=\"keyword\">extends</span> [<span class=\"built_in\">any</span>] ? <span class=\"title class_\">Type</span>[] : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &#x27;StrArrOrNumArr&#x27;不再是一个联合类型</span></span><br><span class=\"line\"><span class=\"comment\">// type StrArrOrNumArr = (string | number)[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StrArrOrNumArr</span> = <span class=\"title class_\">ToArrayNonDist</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-6-映射类型\"><a href=\"#7-6-映射类型\" class=\"headerlink\" title=\"7.6 映射类型\"></a>7.6 映射类型</h2><p>当你不想重复定义类型，一个类型可以以另一个类型为基础创建新类型。</p>\n<p>映射类型建立在索引签名的语法上，索引签名用于声明没有被提前声明的属性类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OnlyBoolsAndHorses</span> = &#123;</span><br><span class=\"line\">  [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">boolean</span> | <span class=\"title class_\">Horse</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">conforms</span>: <span class=\"title class_\">OnlyBoolsAndHorses</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">del</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">rodney</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>映射类型是一种通用类型，它使用 <code>PropertyKeys</code>的联合（经常通过<code>keyof</code>创建）迭代键来创建一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OptionsFlags</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span>]: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>OptionsFlags</code>将从<code>Type</code>类型中获取所有属性，并将它们的值改为布尔值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FeatureFlags</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">darkMode</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  <span class=\"attr\">newUserProfile</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type FeatureOptions = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    darkMode: boolean;</span></span><br><span class=\"line\"><span class=\"comment\">    newUserProfile: boolean;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FeatureOptions</span> = <span class=\"title class_\">OptionsFlags</span>&lt;<span class=\"title class_\">FeatureFlags</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-1-映射修改器\"><a href=\"#7-6-1-映射修改器\" class=\"headerlink\" title=\"7.6.1 映射修改器\"></a>7.6.1 映射修改器</h3><p>在映射过程中，有两个额外的修饰符可以应用：<code>readonly</code>和<code>?</code> ，它们分别影响可变性和可选性。</p>\n<p>你可以通过用<code>-</code>或<code>+</code>作为前缀来删除或添加这些修饰语。如果你不加前缀，那么就假定是<code>+</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CreateMutable</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从一个类型的属性中删除 &quot;readonly&quot;属性</span></span><br><span class=\"line\">  -<span class=\"keyword\">readonly</span> [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span>]: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">LockedAccount</span> = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type UnlockedAccount = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    id: string;</span></span><br><span class=\"line\"><span class=\"comment\">    name: string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UnlockedAccount</span> = <span class=\"title class_\">CreateMutable</span>&lt;<span class=\"title class_\">LockedAccount</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从一个类型的属性中删除 &quot;可选&quot; 属性</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Concrete</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span>]-?: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MaybeUser</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">name</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type User = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    id: string;</span></span><br><span class=\"line\"><span class=\"comment\">    name: string;</span></span><br><span class=\"line\"><span class=\"comment\">    age: number;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = <span class=\"title class_\">Concrete</span>&lt;<span class=\"title class_\">MaybeUser</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-2-通过-as-做-key-重映射\"><a href=\"#7-6-2-通过-as-做-key-重映射\" class=\"headerlink\" title=\"7.6.2 通过 as 做 key 重映射\"></a>7.6.2 通过 <code>as</code> 做 <code>key</code> 重映射</h3><p>在TypeScript 4.1及以后的版本中，你可以通过映射类型中的as子句重新映射映射类型中的键。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MappedTypeWithNewProperties</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Properties</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span> <span class=\"keyword\">as</span> <span class=\"title class_\">NewKeyType</span>]: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Properties</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>你可以利用<a href=\"https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html\">模板字面类型</a>等功能，从先前的属性名称中创建新的属性名称。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Getters</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span> <span class=\"keyword\">as</span> <span class=\"string\">`get<span class=\"subst\">$&#123;Capitalize&lt;<span class=\"built_in\">string</span> &amp; Property&gt;&#125;</span>`</span>]: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">location</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type LazyPerson = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  getName: () =&gt; string;</span></span><br><span class=\"line\"><span class=\"comment\">  getAge: () =&gt; number;</span></span><br><span class=\"line\"><span class=\"comment\">  getLocation: () =&gt; string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">LazyPerson</span> = <span class=\"title class_\">Getters</span>&lt;<span class=\"title class_\">Person</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>你可以通过条件类型产生<code>never</code>滤掉的键。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除 &quot;kind&quot;属性</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">RemoveKindField</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span> <span class=\"keyword\">as</span> <span class=\"title class_\">Exclude</span>&lt;<span class=\"title class_\">Property</span>, <span class=\"string\">&quot;kind&quot;</span>&gt;]: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type KindlessCircle = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    radius: number;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">KindlessCircle</span> = <span class=\"title class_\">RemoveKindField</span>&lt;<span class=\"title class_\">Circle</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>你可以映射任意的联合体，不仅仅是<code>string | number | symbol</code>的联合体，还有任何类型的联合体。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">EventConfig</span>&lt;<span class=\"title class_\">Events</span> <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">kind</span>: <span class=\"built_in\">string</span> &#125;&gt; = &#123;</span><br><span class=\"line\">  [E <span class=\"keyword\">in</span> <span class=\"title class_\">Events</span> <span class=\"keyword\">as</span> E[<span class=\"string\">&quot;kind&quot;</span>]]: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">event</span>: E</span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">SquareEvent</span> = &#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;square&quot;</span>; <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">y</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CircleEvent</span> = &#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>; <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type Config = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    square: (event: SquareEvent) =&gt; void;</span></span><br><span class=\"line\"><span class=\"comment\">    circle: (event: CircleEvent) =&gt; void;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Config</span> = <span class=\"title class_\">EventConfig</span>&lt;<span class=\"title class_\">SquareEvent</span> | <span class=\"title class_\">CircleEvent</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-3-进一步探索\"><a href=\"#7-6-3-进一步探索\" class=\"headerlink\" title=\"7.6.3 进一步探索\"></a>7.6.3 进一步探索</h3><p>映射类型与本类型操作部分的其他功能配合得很好，例如，这里有一个<a href=\"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html\">使用条件类型的映射类型</a> ，它根据一个对象的属性<code>pii</code>是否被设置为字面意义上的 <code>true</code>，返回<code>true</code>或<code>false</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ExtractPII</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span>]: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>] <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">pii</span>: <span class=\"literal\">true</span> &#125; ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type ObjectsNeedingGDPRDeletion = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  id: false;</span></span><br><span class=\"line\"><span class=\"comment\">  name: true;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DBFields</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: &#123; <span class=\"attr\">format</span>: <span class=\"string\">&quot;incrementing&quot;</span> &#125;;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">pii</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ObjectsNeedingGDPRDeletion</span> = <span class=\"title class_\">ExtractPII</span>&lt;<span class=\"title class_\">DBFields</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"七、类型操纵\"><a href=\"#七、类型操纵\" class=\"headerlink\" title=\"七、类型操纵\"></a>七、类型操纵</h1><h2 id=\"7-0-从类型中创建类型\"><a href=\"#7-0-从类型中创建类型\" class=\"headerlink\" title=\"7.0 从类型中创建类型\"></a>7.0 从类型中创建类型</h2><p>TypeScript的类型系统非常强大，因为它允许用其他类型的术语来表达类型。</p>\n<p>这个想法的最简单的形式是泛型，我们实际上有各种各样的类型操作符可以使用。也可以用我们已经有的值来表达类型。</p>\n<p>通过结合各种类型操作符，我们可以用一种简洁、可维护的方式来表达复杂的操作和值。在本节中，我们将介绍用现有的类型或值来表达一个新类型的方法。</p>\n<ul>\n<li><p>泛型型 - 带参数的类型</p>\n</li>\n<li><p>Keyof 类型操作符- <code>keyof</code> 操作符创建新类型</p>\n</li>\n<li><p>Typeof 类型操作符 - 使用 <code>typeof</code> 操作符来创建新的类型&#96;</p>\n</li>\n<li><p>索引访问类型 - 使用 <code>Type[&#39;a&#39;]</code> 语法来访问一个类型的子集</p>\n</li>\n<li><p>条件类型 - 在类型系统中像if语句一样行事的类型</p>\n</li>\n<li><p>映射类型 - 通过映射现有类型中的每个属性来创建类型</p>\n</li>\n<li><p>模板字面量类型 - 通过模板字面字符串改变属性的映射类型</p>\n</li>\n</ul>\n<h2 id=\"7-1-泛型\"><a href=\"#7-1-泛型\" class=\"headerlink\" title=\"7.1 泛型\"></a>7.1 泛型</h2><p>软件工程的一个主要部分是建立组件，这些组件不仅有定义明确和一致的API，而且还可以重复使用。能够处理今天的数据和明天的数据的组件将为你建立大型软件系统提供最灵活的能力。</p>\n<p>在像C#和Java这样的语言中，创建可重用组件的工具箱中的主要工具之一是泛型，也就是说，能够创建一个在各种类型上工作的组件，而不是单一的类型。这使得用户可以消费这些组件并使用他们自己的类型。</p>\n<h3 id=\"7-1-1-Hello-World\"><a href=\"#7-1-1-Hello-World\" class=\"headerlink\" title=\"7.1.1 Hello World\"></a>7.1.1 Hello World</h3><p>首先，让我们做一下泛型的 “ hello world”：身份函数。身份函数是一个函数，它将返回传入的任何内容。你可以用类似于echo命令的方式来考虑它。</p>\n<p>如果没有泛型，我们将不得不给身份函数一个特定的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">identity</span>(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者，我们可以用任意类型来描述身份函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">identity</span>(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"built_in\">any</span></span>): <span class=\"built_in\">any</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>any</code> 当然是通用的，因为它将使函数接受 <code>arg</code>类型的任何和所有的类型，但实际上我们在函数返回时失去了关于该类型的信息。如果我们传入一个数字，我们唯一的信息就是任何类型都可以被返回。</p>\n<p>相反，我们需要一种方法来捕获参数的类型，以便我们也可以用它来表示返回的内容。在这里，我们将使用一个类型变量，这是一种特殊的变量，对类型而不是数值起作用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们现在已经在身份函数中添加了一个类型变量 <code>Type</code>。这个 <code>Type</code> 允许我们捕获用户提供的类型（例如数字），这样我们就可以在以后使用这些信息。这里，我们再次使用Type作为返回类型。经过检查，我们现在可以看到参数和返回类型使用的是相同的类型。这使得我们可以将类型信息从函数的一侧输入，然后从另一侧输出。</p>\n<p>我们说这个版本的身份函数是通用的，因为它在一系列的类型上工作。与使用任何类型不同的是，它也和第一个使用数字作为参数和返回类型的身份函数一样精确（即，它不会丢失任何信息）。</p>\n<p>一旦我们写好了通用身份函数，我们就可以用两种方式之一来调用它。第一种方式是将所有的参数，包括类型参数，都传递给函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们明确地将 <code>Type</code> 设置为<code>string</code>，作为函数调用的参数之一，用参数周围的 <code>&lt;&gt;</code> 而不是 <code>()</code> 来表示。</p>\n<p>第二种方式可能也是最常见的。这里我们使用类型参数推理——也就是说，我们希望编译器根据我们传入的参数的类型，自动为我们设置 <code>Type</code> 的值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = <span class=\"title function_\">identity</span>(<span class=\"string\">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们不必在角括号（&lt;&gt;）中明确地传递类型；编译器只是查看了 “myString “这个值，并将Type设置为其类型。虽然类型参数推断是一个有用的工具，可以使代码更短、更易读，但当编译器不能推断出类型时，你可能需要像我们在前面的例子中那样明确地传入类型参数，这在更复杂的例子中可能发生。</p>\n<h3 id=\"7-1-2-使用通用类型变量\"><a href=\"#7-1-2-使用通用类型变量\" class=\"headerlink\" title=\"7.1.2 使用通用类型变量\"></a>7.1.2 使用通用类型变量</h3><p>当你开始使用泛型时，你会注意到，当你创建像<code>identity</code>这样的泛型函数时，编译器会强制要求你在函数主体中正确使用任何泛型参数。也就是说，你实际上是把这些参数当作是任何和所有的类型。</p>\n<p>让我们来看看我们前面的 <code>identity</code> 函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们想在每次调用时将参数 <code>arg</code> 的长度记录到控制台，该怎么办？我们可能很想这样写：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/dqsOFKoSHTPJBMv.png\" alt=\"image-20211127215153933\" style=\"zoom:50%;\" />\n\n<p>当我们这样做时，编译器会给我们一个错误，说我们在使用 <code>arg</code> 的 <code>.length</code> 成员，但我们没有说 <code>arg</code> 有这个成员。记住，我们在前面说过，这些类型的变量可以代表任何和所有的类型，所以使用这个函数的人可以传入一个<code>number</code> ，而这个数字没有一个 <code>.length</code> 成员。</p>\n<p>比方说，我们实际上是想让这个函数在 <code>Type</code> 的数组上工作，而不是直接在 <code>Type</code>上工作。既然我们在处理数组，那么<code>.length</code>成员应该是可用的。我们可以像创建其他类型的数组那样来描述它。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>[]): <span class=\"title class_\">Type</span>[] &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以把 <code>loggingIdentity</code> 的类型理解为 “通用函数 <code>loggingIdentity</code> 接收一个类型参数 <code>Type</code> 和一个参数 <code>arg</code>，<code>arg</code>是一个<code>Type</code>数组，并返回一个<code>Type</code>数组。” 如果我们传入一个数字数组，我们会得到一个数字数组，因为Type会绑定到数字。这允许我们使用我们的通用类型变量 <code>Type</code> 作为我们正在处理的类型的一部分，而不是整个类型，给我们更大的灵活性。</p>\n<p>我们也可以这样来写这个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">Type</span>&gt;): <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>); <span class=\"comment\">// 数组有一个.length，所以不会再出错了</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可能已经从其他语言中熟悉了这种类型的风格。在下一节中，我们将介绍如何创建你自己的通用类型，如<code>Array&lt;Type&gt;</code>。</p>\n<h3 id=\"7-1-3-泛型类型\"><a href=\"#7-1-3-泛型类型\" class=\"headerlink\" title=\"7.1.3 泛型类型\"></a>7.1.3 泛型类型</h3><p>在前几节中，我们创建了在一系列类型上工作的通用身份函数。在这一节中，我们将探讨函数本身的类型以及如何创建通用接口。</p>\n<p>泛型函数的类型与非泛型函数的类型一样，类型参数列在前面，与函数声明类似：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: &lt;<span class=\"title class_\">Type</span>&gt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span></span>) =&gt;</span> <span class=\"title class_\">Type</span> = identity;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以为类型中的通用类型参数使用一个不同的名字，只要类型变量的数量和类型变量的使用方式一致。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: &lt;<span class=\"title class_\">Input</span>&gt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"title class_\">Input</span></span>) =&gt;</span> <span class=\"title class_\">Input</span> = identity;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以把泛型写成一个对象字面类型的调用签名。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: &#123; &lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#125; = identity;</span><br></pre></td></tr></table></figure>\n\n<p>这让我们开始编写我们的第一个泛型接口。让我们把前面例子中的对象字面意思移到一个接口中。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">GenericIdentityFn</span> &#123;</span><br><span class=\"line\">  &lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: <span class=\"title class_\">GenericIdentityFn</span> = identity;</span><br></pre></td></tr></table></figure>\n\n<p>在一个类似的例子中，我们可能想把通用参数移到整个接口的参数上。这可以让我们看到我们的泛型是什么类型（例如，<code>Dictionary&lt;string&gt;</code>而不是仅仅<code>Dictionary</code>）。这使得类型参数对接口的所有其他成员可见。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">GenericIdentityFn</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  (<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> identity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myIdentity</span>: <span class=\"title class_\">GenericIdentityFn</span>&lt;<span class=\"built_in\">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，我们的例子已经改变了，变成了稍微不同的东西。我们现在没有描述一个泛型函数，而是有一个非泛型的函数签名，它是泛型类型的一部分。当我们使用 <code>GenericIdentityFn</code> 时，我们现在还需要指定相应的类型参数（这里是：数字），有效地锁定了底层调用签名将使用什么。了解什么时候把类型参数直接放在调用签名上，什么时候把它放在接口本身，将有助于描述一个类型的哪些方面是通用的。</p>\n<p>除了泛型接口之外，我们还可以创建泛型类。注意，不可能创建泛型枚举和命名空间。</p>\n<h3 id=\"7-1-4-泛型类\"><a href=\"#7-1-4-泛型类\" class=\"headerlink\" title=\"7.1.4 泛型类\"></a>7.1.4 泛型类</h3><p>一个泛型类的形状与泛型接口相似。泛型类在类的名字后面有一个角括号（&lt;&gt;）中的泛型参数列表。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GenericNumber</span>&lt;<span class=\"title class_\">NumType</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">zeroValue</span>: <span class=\"title class_\">NumType</span>;</span><br><span class=\"line\">  <span class=\"attr\">add</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">NumType</span>, <span class=\"attr\">y</span>: <span class=\"title class_\">NumType</span></span>) =&gt;</span> <span class=\"title class_\">NumType</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> <span class=\"title class_\">GenericNumber</span>&lt;<span class=\"built_in\">number</span>&gt;();</span><br><span class=\"line\">myGenericNumber.<span class=\"property\">zeroValue</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">myGenericNumber.<span class=\"property\">add</span> = <span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是对<code>GenericNumber</code>类相当直白的使用，但你可能已经注意到，没有任何东西限制它只能使用数字类型。我们本可以使用字符串或更复杂的对象。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringNumeric = <span class=\"keyword\">new</span> <span class=\"title class_\">GenericNumber</span>&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">stringNumeric.<span class=\"property\">zeroValue</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">stringNumeric.<span class=\"property\">add</span> = <span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(stringNumeric.<span class=\"title function_\">add</span>(stringNumeric.<span class=\"property\">zeroValue</span>, <span class=\"string\">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>就像接口一样，把类型参数放在类本身，可以让我们确保类的所有属性都与相同的类型一起工作。</p>\n<p>正如我们在关于类的章节中提到的，一个类的类型有两个方面：静态方面和实例方面。通用类只在其实例侧而非静态侧具有通用性，所以在使用类时，静态成员不能使用类的类型参数。</p>\n<h3 id=\"7-1-5-泛型约束\"><a href=\"#7-1-5-泛型约束\" class=\"headerlink\" title=\"7.1.5 泛型约束\"></a>7.1.5 泛型约束</h3><p>如果你还记得前面的例子，你有时可能想写一个通用函数，在一组类型上工作，而你对这组类型会有什么能力有一定的了解。在我们的 <code>loggingIdentity</code> 例子中，我们希望能够访问 <code>arg.length</code> 属性，但是编译器无法证明每个类型都有一个 <code>.length</code> 属性，所以它警告我们不能做这个假设。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/gS8VUxOYPyER62K.png\" alt=\"image-20211128095950588\" style=\"zoom:50%;\" />\n\n<p>我们希望限制这个函数与 <code>any</code> 和所有类型一起工作，而不是与 <code>any</code> 和所有同时具有 <code>.length</code> 属性的类型一起工作。只要这个类型有这个成员，我们就允许它，但它必须至少有这个成员。要做到这一点，我们必须把我们的要求作为一个约束条件列在 <code>Type</code> 可以是什么。</p>\n<p>为了做到这一点，我们将创建一个接口来描述我们的约束。在这里，我们将创建一个接口，它有一个单一的 <code>.length</code> 属性，然后我们将使用这个接和 <code>extends</code> 关键字来表示我们的约束条件。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Lengthwise</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> loggingIdentity&lt;<span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Lengthwise</span>&gt;(<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arg.<span class=\"property\">length</span>); <span class=\"comment\">// 现在我们知道它有一个 .length 属性，所以不再有错误了</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为泛型函数现在被限制了，它将不再对 <code>any</code> 和 所有的类型起作用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">loggingIdentity(3);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/07-03.png\" alt=\"image-20211128102358263\" style=\"zoom:50%;\" />\n\n<p>相反，我们需要传入其类型具有所有所需属性的值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">loggingIdentity</span>(&#123; <span class=\"attr\">length</span>: <span class=\"number\">10</span>, <span class=\"attr\">value</span>: <span class=\"number\">3</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-6-在泛型约束中使用类型参数\"><a href=\"#7-1-6-在泛型约束中使用类型参数\" class=\"headerlink\" title=\"7.1.6 在泛型约束中使用类型参数\"></a>7.1.6 在泛型约束中使用类型参数</h3><p>你可以声明一个受另一个类型参数约束的类型参数。例如，在这里我们想从一个给定名称的对象中获取一个属性。我们想确保我们不会意外地获取一个不存在于 <code>obj</code> 上的属性，所以我们要在这两种类型之间放置一个约束条件。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> getProperty&lt;<span class=\"title class_\">Type</span>, <span class=\"title class_\">Key</span> <span class=\"keyword\">extends</span> keyof <span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">obj</span>: <span class=\"title class_\">Type</span>, <span class=\"attr\">key</span>: <span class=\"title class_\">Key</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">3</span>, <span class=\"attr\">d</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getProperty</span>(x, <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">getProperty</span>(x, <span class=\"string\">&quot;m&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/MrLOcvzYgSbophf.png\" alt=\"image-20211128103719103\" style=\"zoom:50%;\" />\n\n<h3 id=\"7-1-7-在泛型中使用类类型\"><a href=\"#7-1-7-在泛型中使用类类型\" class=\"headerlink\" title=\"7.1.7 在泛型中使用类类型\"></a>7.1.7 在泛型中使用类类型</h3><p>在TypeScript中使用泛型创建工厂时，有必要通过其构造函数来引用类的类型。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> create&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">c</span>: &#123; <span class=\"title function_\">new</span> (): <span class=\"title class_\">Type</span> &#125;): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">c</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个更高级的例子，使用原型属性来推断和约束类类型的构造函数和实例方之间的关系。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BeeKeeper</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">hasMask</span>: <span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZooKeeper</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">nametag</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;Mikle&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">numLegs</span>: <span class=\"built_in\">number</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bee</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">keeper</span>: <span class=\"title class_\">BeeKeeper</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">BeeKeeper</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">keeper</span>: <span class=\"title class_\">ZooKeeper</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ZooKeeper</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> createInstance&lt;A <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span>&gt;(<span class=\"attr\">c</span>: <span class=\"title function_\">new</span> () =&gt; A): A &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">c</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">createInstance</span>(<span class=\"title class_\">Lion</span>).<span class=\"property\">keeper</span>.<span class=\"property\">nametag</span>;</span><br><span class=\"line\"><span class=\"title function_\">createInstance</span>(<span class=\"title class_\">Bee</span>).<span class=\"property\">keeper</span>.<span class=\"property\">hasMask</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-2-Keyof类型操作符\"><a href=\"#7-2-Keyof类型操作符\" class=\"headerlink\" title=\"7.2 Keyof类型操作符\"></a>7.2 <code>Keyof</code>类型操作符</h2><p><code>keyof</code>运算符接收一个对象类型，并产生其键的字符串或数字字面联合。下面的类型P与 “x”|”y “是同一类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Point</span> = &#123; <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">y</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> P = keyof <span class=\"title class_\">Point</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p1</span>: P = <span class=\"string\">&quot;x&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p2</span>: P = <span class=\"string\">&quot;y&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果该类型有一个字符串或数字索引签名，<code>keyof</code> 将返回这些类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Arrayish</span> = &#123; [<span class=\"attr\">n</span>: <span class=\"built_in\">number</span>]: <span class=\"built_in\">unknown</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> A = keyof <span class=\"title class_\">Arrayish</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: A = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Mapish</span> = &#123; [<span class=\"attr\">k</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">boolean</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> M = keyof <span class=\"title class_\">Mapish</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">m</span>: M = <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">m2</span>: M = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意，在这个例子中，<code>M</code>是 <code>string|number</code>——这是因为JavaScript对象的键总是被强制为字符串，所以 <code>obj[0]</code>总是与<code>obj[&quot;0&quot;]</code>相同。</p>\n<p><code>keyof</code>类型在与映射类型结合时变得特别有用，我们将在后面进一步了解。</p>\n<h2 id=\"7-3-Typeof-类型操作符\"><a href=\"#7-3-Typeof-类型操作符\" class=\"headerlink\" title=\"7.3 Typeof 类型操作符\"></a>7.3 <code>Typeof</code> 类型操作符</h2><p>JavaScript已经有一个 <code>typeof</code> 操作符，你可以在表达式上下文中使用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"string\">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript添加了一个<code>typeof</code>操作符，你可以在类型上下文中使用它来引用一个变量或属性的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">n</span>: <span class=\"keyword\">typeof</span> s;</span><br><span class=\"line\">n = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">n = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/07-05.png\" alt=\"image-20211128110305093\" style=\"zoom:50%;\" />\n\n<p>这对基本类型来说不是很有用，但结合其他类型操作符，你可以使用typeof来方便地表达许多模式。举一个例子，让我们先看看预定义的类型<code>ReturnType&lt;T&gt;</code>。它接收一个函数类型并产生其返回类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Predicate</span> = <span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">unknown</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> K = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"title class_\">Predicate</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们试图在一个函数名上使用 <code>ReturnType</code>，我们会看到一个指示性的错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> P = <span class=\"title class_\">ReturnType</span>&lt;f&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/foM6iTw7GecalgD.png\" alt=\"image-20211128111022283\" style=\"zoom:50%;\" />\n\n<p>请记住，值和类型并不是一回事。为了指代值f的类型，我们使用 <code>typeof</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> P = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"keyword\">typeof</span> f&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript 故意限制了你可以使用 typeof 的表达式种类。</p>\n<p>具体来说，只有在标识符（即变量名）或其属性上使用typeof是合法的。这有助于避免混乱的陷阱，即编写你认为是在执行的代码，但其实不是。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们认为使用 = ReturnType&lt;typeof msgbox&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">shouldContinue</span>: <span class=\"keyword\">typeof</span> <span class=\"title function_\">msgbox</span>(<span class=\"string\">&quot;Are you sure you want to continue?&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/AUnW94tZuiI2fLw.png\" alt=\"image-20211128111627727\" style=\"zoom:50%;\" />\n\n<h2 id=\"7-4-索引访问类型\"><a href=\"#7-4-索引访问类型\" class=\"headerlink\" title=\"7.4 索引访问类型\"></a>7.4 索引访问类型</h2><p>我们可以使用一个索引访问类型来查询另一个类型上的特定属性：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Person</span> = &#123; <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">alive</span>: <span class=\"built_in\">boolean</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age</span> = <span class=\"title class_\">Person</span>[<span class=\"string\">&quot;age&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/vdRnGwYBI6r4Elx.png\" alt=\"image-20211128114411725\" style=\"zoom:50%;\" />\n\n<p>索引类型本身就是一个类型，所以我们可以完全使用 unions、<code>keyof</code> 或者其他类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">alive</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type I1 = string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">I1</span> = <span class=\"title class_\">Person</span>[<span class=\"string\">&quot;age&quot;</span> | <span class=\"string\">&quot;name&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i11</span>: <span class=\"variable constant_\">I1</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i12</span>: <span class=\"variable constant_\">I1</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type I2 = string | number | boolean</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">I2</span> = <span class=\"title class_\">Person</span>[keyof <span class=\"title class_\">Person</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i21</span>: <span class=\"variable constant_\">I2</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i22</span>: <span class=\"variable constant_\">I2</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">i23</span>: <span class=\"variable constant_\">I2</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type I3 = Person[AliveOrName];</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">AliveOrName</span> = <span class=\"string\">&quot;alive&quot;</span> | <span class=\"string\">&quot;name&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">aon1</span>: <span class=\"title class_\">AliveOrName</span> = <span class=\"string\">&quot;alive&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">aon2</span>: <span class=\"title class_\">AliveOrName</span> = <span class=\"string\">&quot;name&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果你试图索引一个不存在的属性，你甚至会看到一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">I1</span> = <span class=\"title class_\">Person</span>[<span class=\"string\">&quot;alve&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/aKBPU27y5pJLQz3.png\" alt=\"image-20211128115726772\" style=\"zoom:50%;\" />\n\n<p>另一个使用任意类型进行索引的例子是使用<code>number</code>来获取一个数组元素的类型。我们可以把它和 <code>typeof</code>结合起来，方便地获取一个数组字面的元素类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MyArray</span> = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">15</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Eve&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">38</span> &#125;,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* type Person = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    name: string;</span></span><br><span class=\"line\"><span class=\"comment\">    age: number;</span></span><br><span class=\"line\"><span class=\"comment\">&#125; */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Person</span> = (<span class=\"keyword\">typeof</span> <span class=\"title class_\">MyArray</span>)[<span class=\"built_in\">number</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p</span>: <span class=\"title class_\">Person</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;xiaoqian&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">11</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Age = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age</span> = (<span class=\"keyword\">typeof</span> <span class=\"title class_\">MyArray</span>)[<span class=\"built_in\">number</span>][<span class=\"string\">&quot;age&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">age</span>: <span class=\"title class_\">Age</span> = <span class=\"number\">11</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"comment\">// type Age2 = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age2</span> = <span class=\"title class_\">Person</span>[<span class=\"string\">&quot;age&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">age2</span>: <span class=\"title class_\">Age2</span> = <span class=\"number\">11</span>;</span><br></pre></td></tr></table></figure>\n\n<p>你只能在索引时使用类型，这意味着你不能使用<code>const</code>来做一个变量引用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> key = <span class=\"string\">&quot;age&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age</span> = <span class=\"title class_\">Person</span>[key];</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/08-03.png\" alt=\"image-20211128122324127\" style=\"zoom:60%;\" />\n\n<p>然而，你可以使用类型别名来实现类似的重构风格：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> key = <span class=\"string\">&quot;age&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Age</span> = <span class=\"title class_\">Person</span>[key];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-5-条件类型\"><a href=\"#7-5-条件类型\" class=\"headerlink\" title=\"7.5 条件类型\"></a>7.5 条件类型</h2><p>在大多数有用的程序的核心，我们必须根据输入来做决定。JavaScript程序也不例外，但鉴于数值可以很容易地被内省，这些决定也是基于输入的类型。条件类型有助于描述输入和输出的类型之间的关系。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">live</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">woof</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Example1 = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Example1</span> = <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> ? <span class=\"built_in\">number</span> : <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Example2 = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Example2</span> = <span class=\"title class_\">RegExp</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> ? <span class=\"built_in\">number</span> : <span class=\"built_in\">string</span>;</span><br></pre></td></tr></table></figure>\n\n<p>条件类型的形式看起来有点像JavaScript中的条件表达式（<code>condition ? trueExpression : falseExpression</code>）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">SomeType</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">OtherType</span> ? <span class=\"title class_\">TrueType</span> : <span class=\"title class_\">FalseType</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当 <code>extends</code> 左边的类型可以赋值给右边的类型时，那么你将得到第一个分支中的类型（”真 “分支）；否则你将得到后一个分支中的类型（”假 “分支）。</p>\n<p>从上面的例子来看，条件类型可能并不立即显得有用——我们可以告诉自己是否 <code>Dog extends Animal</code>，并选择 <code>number</code>或<code>string</code>！但条件类型的威力来自于它所带来的好处。条件类型的力量来自于将它们与泛型一起使用。</p>\n<p>例如，让我们来看看下面这个 <code>createLabel</code> 函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IdLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"built_in\">number</span> <span class=\"comment\">/* 一些字段 */</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NameLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> <span class=\"comment\">/* 另一些字段 */</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLabel</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">IdLabel</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLabel</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">NameLabel</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLabel</span>(<span class=\"params\"><span class=\"attr\">nameOrId</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>): <span class=\"title class_\">IdLabel</span> | <span class=\"title class_\">NameLabel</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLabel</span>(<span class=\"params\"><span class=\"attr\">nameOrId</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>): <span class=\"title class_\">IdLabel</span> | <span class=\"title class_\">NameLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">&quot;unimplemented&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>createLabel</code>的这些重载描述了一个单一的JavaScript函数，该函数根据其输入的类型做出选择。注意一些事情：</p>\n<ul>\n<li>如果一个库必须在其API中反复做出同样的选择，这就会变得很麻烦。</li>\n<li>我们必须创建三个重载：一个用于确定类型的情况（一个用于 <code>string</code>，一个用于 <code>number</code>），一个用于最一般的情况（取一个 <code>string</code>| <code>number</code>）。对于 <code>createLabel</code>所能处理的每一种新类型，重载的数量都会呈指数级增长。</li>\n</ul>\n<p>相反，我们可以在一个条件类型中对该逻辑进行编码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NameOrId</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span></span><br><span class=\"line\">  ? <span class=\"title class_\">IdLabel</span></span><br><span class=\"line\">  : <span class=\"title class_\">NameLabel</span>;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们可以使用该条件类型，将我们的重载简化为一个没有重载的单一函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IdLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"built_in\">number</span> <span class=\"comment\">/* some fields */</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NameLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> <span class=\"comment\">/* other fields */</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NameOrId</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span></span><br><span class=\"line\">  ? <span class=\"title class_\">IdLabel</span></span><br><span class=\"line\">  : <span class=\"title class_\">NameLabel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> createLabel&lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>&gt;(<span class=\"attr\">idOrName</span>: T): <span class=\"title class_\">NameOrId</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">&quot;unimplemented&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let a: NameLabel</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"title function_\">createLabel</span>(<span class=\"string\">&quot;typescript&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let b: IdLabel</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"title function_\">createLabel</span>(<span class=\"number\">2.8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let c: NameLabel | IdLabel</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"title function_\">createLabel</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() ? <span class=\"string\">&quot;hello&quot;</span> : <span class=\"number\">42</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-5-1-条件类型约束\"><a href=\"#7-5-1-条件类型约束\" class=\"headerlink\" title=\"7.5.1 条件类型约束\"></a>7.5.1 条件类型约束</h3><p>通常，条件类型中的检查会给我们提供一些新的信息。就像用类型守卫缩小范围可以给我们一个更具体的类型一样，条件类型的真正分支将通过我们检查的类型进一步约束泛型。</p>\n<p>例如，让我们来看看下面的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MessageOf</span>&lt;T&gt; = T[<span class=\"string\">&quot;message&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/GEXfr1zpLO2ghPw.png\" alt=\"image-20211129092739341\" style=\"zoom:50%;\" />\n\n<p>在这个例子中，TypeScript出错是因为 <code>T</code> 不知道有一个叫做 <code>message</code> 的属性。我们可以对 <code>T</code> 进行约束，TypeScript就不会再抱怨。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MessageOf</span>&lt;T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">message</span>: <span class=\"built_in\">unknown</span> &#125;&gt; = T[<span class=\"string\">&quot;message&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Email</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">message</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">EmailMessageContents</span> = <span class=\"title class_\">MessageOf</span>&lt;<span class=\"title class_\">Email</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>然而，如果我们想让 <code>MessageOf</code> 接受任何类型，并在消息属性不可用的情况下，默认为 <code>never</code>类型呢？我们可以通过将约束条件移出，并引入一个条件类型来做到这一点。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MessageOf</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">message</span>: <span class=\"built_in\">unknown</span> &#125; ? T[<span class=\"string\">&quot;message&quot;</span>] : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Email</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">message</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">bark</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type EmailMessageContents = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">EmailMessageContents</span> = <span class=\"title class_\">MessageOf</span>&lt;<span class=\"title class_\">Email</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">emc</span>: <span class=\"title class_\">EmailMessageContents</span> = <span class=\"string\">&quot;balabala...&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type DogMessageContents = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DogMessageContents</span> = <span class=\"title class_\">MessageOf</span>&lt;<span class=\"title class_\">Dog</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">dmc</span>: <span class=\"title class_\">DogMessageContents</span> = <span class=\"string\">&quot;error&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在真正的分支中，TypeScript知道 <code>T</code>会有一个消息属性。</p>\n<p>作为另一个例子，我们也可以写一个叫做 <code>Flatten</code> 的类型，将数组类型平铺到它们的元素类型上，但在其他方面则不做处理。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Flatten</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[] ? T[<span class=\"built_in\">number</span>] : T;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提取出元素类型。</span></span><br><span class=\"line\"><span class=\"comment\">// type Str = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Str</span> = <span class=\"title class_\">Flatten</span>&lt;<span class=\"built_in\">string</span>[]&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单独一个类型。</span></span><br><span class=\"line\"><span class=\"comment\">// type Num = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Num</span> = <span class=\"title class_\">Flatten</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>当 <code>Flatten</code> 被赋予一个数组类型时，它使用一个带有数字的索引访问来获取 <code>string[]</code> 的元素类型。否则，它只是返回它被赋予的类型。</p>\n<h3 id=\"7-5-2-在条件类型内进行推理\"><a href=\"#7-5-2-在条件类型内进行推理\" class=\"headerlink\" title=\"7.5.2 在条件类型内进行推理\"></a>7.5.2 在条件类型内进行推理</h3><p>我们只是发现自己使用条件类型来应用约束条件，然后提取出类型。这最终成为一种常见的操作，而条件类型使它变得更容易。</p>\n<p>条件类型为我们提供了一种方法来推断我们在真实分支中使用 <code>infer</code> 关键字进行对比的类型。例如，我们可以在<code>Flatten</code> 中推断出元素类型，而不是用索引访问类型 “手动 “提取出来。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Flatten</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Array</span>&lt;infer <span class=\"title class_\">Item</span>&gt; ? <span class=\"title class_\">Item</span> : <span class=\"title class_\">Type</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们使用 <code>infer</code> 关键字来声明性地引入一个名为 <code>Item</code> 的新的通用类型变量，而不是指定如何在真实分支中检索 <code>T</code> 的元素类型。这使我们不必考虑如何挖掘和探测我们感兴趣的类型的结构。</p>\n<p>我们可以使用 <code>infer</code> 关键字编写一些有用的辅助类型别名。例如，对于简单的情况，我们可以从函数类型中提取出返回类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> <span class=\"title function_\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">never</span>[]) =&gt; infer <span class=\"title class_\">Return</span></span><br><span class=\"line\">  ? <span class=\"title class_\">Return</span></span><br><span class=\"line\">  : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Num = number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Num</span> = <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Str = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Str</span> = <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type Bools = boolean[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Bools</span> = <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">boolean</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">boolean</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>[]&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给泛型传入 string 类型，条件类型会返回 never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Never</span> = <span class=\"title class_\">GetReturnType</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">nev</span>: <span class=\"title class_\">Never</span> = <span class=\"string\">&quot;error&quot;</span> <span class=\"keyword\">as</span> <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当从一个具有多个调用签名的类型（如重载函数的类型）进行推断时，从最后一个签名进行推断（据推测，这是最容许的万能情况）。不可能根据参数类型的列表来执行重载解析。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">stringOrNum</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">stringOrNum</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">stringOrNum</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>): <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"keyword\">typeof</span> stringOrNum&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-5-3-分布式条件类型\"><a href=\"#7-5-3-分布式条件类型\" class=\"headerlink\" title=\"7.5.3 分布式条件类型\"></a>7.5.3 分布式条件类型</h3><p>当条件类型作用于一个通用类型时，当给定一个联合类型时，它们就变成了分布式的。例如，以下面的例子为例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ToArray</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span> ? <span class=\"title class_\">Type</span>[] : <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们将一个联合类型插入ToArray，那么条件类型将被应用于该联合的每个成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ToArray</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span> ? <span class=\"title class_\">Type</span>[] : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type StrArrOrNumArr = string[] | number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StrArrOrNumArr</span> = <span class=\"title class_\">ToArray</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>这里发生的情况是，StrArrOrNumArr分布在：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure>\n\n<p>并对联合的每个成员类型进行映射，以达到有效的目的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">ToArray</span>&lt;<span class=\"built_in\">string</span>&gt; | <span class=\"title class_\">ToArray</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>这给我们留下了：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>[] | <span class=\"built_in\">number</span>[];</span><br></pre></td></tr></table></figure>\n\n<p>通常情况下，分布性是需要的行为。为了避免这种行为，你可以用方括号包围 <code>extends</code>关键字的每一边。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ToArrayNonDist</span>&lt;<span class=\"title class_\">Type</span>&gt; = [<span class=\"title class_\">Type</span>] <span class=\"keyword\">extends</span> [<span class=\"built_in\">any</span>] ? <span class=\"title class_\">Type</span>[] : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &#x27;StrArrOrNumArr&#x27;不再是一个联合类型</span></span><br><span class=\"line\"><span class=\"comment\">// type StrArrOrNumArr = (string | number)[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StrArrOrNumArr</span> = <span class=\"title class_\">ToArrayNonDist</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-6-映射类型\"><a href=\"#7-6-映射类型\" class=\"headerlink\" title=\"7.6 映射类型\"></a>7.6 映射类型</h2><p>当你不想重复定义类型，一个类型可以以另一个类型为基础创建新类型。</p>\n<p>映射类型建立在索引签名的语法上，索引签名用于声明没有被提前声明的属性类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OnlyBoolsAndHorses</span> = &#123;</span><br><span class=\"line\">  [<span class=\"attr\">key</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">boolean</span> | <span class=\"title class_\">Horse</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">conforms</span>: <span class=\"title class_\">OnlyBoolsAndHorses</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">del</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">rodney</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>映射类型是一种通用类型，它使用 <code>PropertyKeys</code>的联合（经常通过<code>keyof</code>创建）迭代键来创建一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OptionsFlags</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span>]: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>OptionsFlags</code>将从<code>Type</code>类型中获取所有属性，并将它们的值改为布尔值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FeatureFlags</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">darkMode</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  <span class=\"attr\">newUserProfile</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type FeatureOptions = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    darkMode: boolean;</span></span><br><span class=\"line\"><span class=\"comment\">    newUserProfile: boolean;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FeatureOptions</span> = <span class=\"title class_\">OptionsFlags</span>&lt;<span class=\"title class_\">FeatureFlags</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-1-映射修改器\"><a href=\"#7-6-1-映射修改器\" class=\"headerlink\" title=\"7.6.1 映射修改器\"></a>7.6.1 映射修改器</h3><p>在映射过程中，有两个额外的修饰符可以应用：<code>readonly</code>和<code>?</code> ，它们分别影响可变性和可选性。</p>\n<p>你可以通过用<code>-</code>或<code>+</code>作为前缀来删除或添加这些修饰语。如果你不加前缀，那么就假定是<code>+</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CreateMutable</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从一个类型的属性中删除 &quot;readonly&quot;属性</span></span><br><span class=\"line\">  -<span class=\"keyword\">readonly</span> [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span>]: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">LockedAccount</span> = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type UnlockedAccount = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    id: string;</span></span><br><span class=\"line\"><span class=\"comment\">    name: string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UnlockedAccount</span> = <span class=\"title class_\">CreateMutable</span>&lt;<span class=\"title class_\">LockedAccount</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从一个类型的属性中删除 &quot;可选&quot; 属性</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Concrete</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span>]-?: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MaybeUser</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">name</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type User = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    id: string;</span></span><br><span class=\"line\"><span class=\"comment\">    name: string;</span></span><br><span class=\"line\"><span class=\"comment\">    age: number;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = <span class=\"title class_\">Concrete</span>&lt;<span class=\"title class_\">MaybeUser</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-2-通过-as-做-key-重映射\"><a href=\"#7-6-2-通过-as-做-key-重映射\" class=\"headerlink\" title=\"7.6.2 通过 as 做 key 重映射\"></a>7.6.2 通过 <code>as</code> 做 <code>key</code> 重映射</h3><p>在TypeScript 4.1及以后的版本中，你可以通过映射类型中的as子句重新映射映射类型中的键。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MappedTypeWithNewProperties</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Properties</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span> <span class=\"keyword\">as</span> <span class=\"title class_\">NewKeyType</span>]: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Properties</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>你可以利用<a href=\"https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html\">模板字面类型</a>等功能，从先前的属性名称中创建新的属性名称。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Getters</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span> <span class=\"keyword\">as</span> <span class=\"string\">`get<span class=\"subst\">$&#123;Capitalize&lt;<span class=\"built_in\">string</span> &amp; Property&gt;&#125;</span>`</span>]: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">location</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type LazyPerson = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  getName: () =&gt; string;</span></span><br><span class=\"line\"><span class=\"comment\">  getAge: () =&gt; number;</span></span><br><span class=\"line\"><span class=\"comment\">  getLocation: () =&gt; string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">LazyPerson</span> = <span class=\"title class_\">Getters</span>&lt;<span class=\"title class_\">Person</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>你可以通过条件类型产生<code>never</code>滤掉的键。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除 &quot;kind&quot;属性</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">RemoveKindField</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span> <span class=\"keyword\">as</span> <span class=\"title class_\">Exclude</span>&lt;<span class=\"title class_\">Property</span>, <span class=\"string\">&quot;kind&quot;</span>&gt;]: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type KindlessCircle = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    radius: number;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">KindlessCircle</span> = <span class=\"title class_\">RemoveKindField</span>&lt;<span class=\"title class_\">Circle</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>你可以映射任意的联合体，不仅仅是<code>string | number | symbol</code>的联合体，还有任何类型的联合体。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">EventConfig</span>&lt;<span class=\"title class_\">Events</span> <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">kind</span>: <span class=\"built_in\">string</span> &#125;&gt; = &#123;</span><br><span class=\"line\">  [E <span class=\"keyword\">in</span> <span class=\"title class_\">Events</span> <span class=\"keyword\">as</span> E[<span class=\"string\">&quot;kind&quot;</span>]]: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">event</span>: E</span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">SquareEvent</span> = &#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;square&quot;</span>; <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">y</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CircleEvent</span> = &#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>; <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type Config = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    square: (event: SquareEvent) =&gt; void;</span></span><br><span class=\"line\"><span class=\"comment\">    circle: (event: CircleEvent) =&gt; void;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Config</span> = <span class=\"title class_\">EventConfig</span>&lt;<span class=\"title class_\">SquareEvent</span> | <span class=\"title class_\">CircleEvent</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-3-进一步探索\"><a href=\"#7-6-3-进一步探索\" class=\"headerlink\" title=\"7.6.3 进一步探索\"></a>7.6.3 进一步探索</h3><p>映射类型与本类型操作部分的其他功能配合得很好，例如，这里有一个<a href=\"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html\">使用条件类型的映射类型</a> ，它根据一个对象的属性<code>pii</code>是否被设置为字面意义上的 <code>true</code>，返回<code>true</code>或<code>false</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ExtractPII</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Property</span> <span class=\"keyword\">in</span> keyof <span class=\"title class_\">Type</span>]: <span class=\"title class_\">Type</span>[<span class=\"title class_\">Property</span>] <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">pii</span>: <span class=\"literal\">true</span> &#125; ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type ObjectsNeedingGDPRDeletion = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  id: false;</span></span><br><span class=\"line\"><span class=\"comment\">  name: true;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DBFields</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: &#123; <span class=\"attr\">format</span>: <span class=\"string\">&quot;incrementing&quot;</span> &#125;;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">pii</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ObjectsNeedingGDPRDeletion</span> = <span class=\"title class_\">ExtractPII</span>&lt;<span class=\"title class_\">DBFields</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "1-5、基础篇：函数更多",
        "toc": true,
        "swiper_index": 5,
        "swiper_cover": "/img/recommend/recommend_05.jpg",
        "swiper_desc": "1-5、基础篇：函数更多",
        "abbrlink": 30791,
        "date": "2024-01-28T11:40:50.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_02.jpeg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 五、函数更多\n\n函数是任何应用程序的基本构件，无论它们是本地函数，从另一个模块导入，还是一个类上的方法。它们也是值，就像其他值一样，TypeScript有很多方法来描述如何调用函数。让我们来学习一下如何编写描述函数的类型。\n\n## 5.1 函数类型表达式\n\n描述一个函数的最简单方法是用一个函数类型表达式。这些类型在语法上类似于箭头函数。\n\n```tsx\nfunction greeter(fn: (a: string) => void) {\n  fn(\"Hello, World\");\n}\n\nfunction printToConsole(s: string) {\n  console.log(s);\n}\n\ngreeter(printToConsole);\n```\n\n语法`(a: string) => void`意味着 \"有一个参数的函数，名为 `a`，类型为字符串，没有返回值\"。就像函数声明一样，如果没有指定参数类型，它就隐含为 `any` 类型。\n\n当然，我们可以用一个类型别名来命名一个函数类型。\n\n```tsx\ntype GreetFunction = (a: string) => void;\nfunction greeter(fn: GreetFunction) {\n  // ...\n}\n```\n\n## 5.2 调用签名\n\n在JavaScript中，除了可调用之外，函数还可以有属性。然而，函数类型表达式的语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以在一个对象类型中写一个*调用签名*。\n\n```tsx\ntype DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\n\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + \" returned \" + fn(6));\n}\n\nfunction fn1() {\n  return true;\n}\nfn1.description = \"balabala...\";\n\ndoSomething(fn1);\n```\n\n注意，与函数类型表达式相比，语法略有不同：在参数列表和返回类型之间使用`:`而不是`=>`。\n\n## 5.3 构造签名\n\nJavaScript函数也可以用 `new` 操作符来调用。TypeScript将这些称为构造函数，因为它们通常会创建一个新的对象。你可以通过在调用签名前面添加 `new` 关键字来写一个构造签名。\n\n```tsx\nclass Ctor {\n  s: string;\n  constructor(s: string) {\n    this.s = s;\n  }\n}\n\ntype SomeConstructor = {\n  new (s: string): Ctor;\n};\nfunction fn(ctor: SomeConstructor) {\n  return new ctor(\"hello\");\n}\n\nconst f = fn(Ctor);\nconsole.log(f.s);\n```\n\n有些对象，如 JavaScript 的 `Date` 对象，可以在有 `new` 或没有 `new` 的情况下被调用。你可以在同一类型中任意地结合调用和构造签名。\n\n```tsx\ninterface CallOrConstruct {\n  new (s: string): Date;\n  (n?: number): number;\n}\n\nfunction fn(date: CallOrConstruct) {\n  let d = new date(\"2021-11-20\");\n  let n = date(100);\n}\n```\n\n再举一个例子：\n\n```tsx\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n\ninterface ClockInterface {\n  tick(): void;\n}\n\nfunction createClock(\n  ctor: ClockConstructor,\n  hour: number,\n  minute: number,\n): ClockInterface {\n  return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"beep beep\");\n  }\n}\n\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"tick tock\");\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n```\n\n## 5.4 泛型函数\n\n在写一个函数时，输入的类型与输出的类型有关，或者两个输入的类型以某种方式相关，这是常见的。让我们考虑一下一个返回数组中第一个元素的函数。\n\n```tsx\nfunction firstElement(arr: any[]) {\n  return arr[0];\n}\n```\n\n这个函数完成了它的工作，但不幸的是它的返回类型是 `any`。如果该函数返回数组元素的类型会更好。\n\n在TypeScript中，当我们想描述两个值之间的对应关系时，会使用泛型。我们通过在函数签名中声明一个类型参数来做到这一点：\n\n```tsx\nfunction firstElement<Type>(arr: Type[]): Type | undefined {\n  return arr[0];\n}\n```\n\n通过给这个函数添加一个类型参数 `Type`，并在两个地方使用它，我们已经在函数的输入（数组）和输出（返回值）之间建立了一个联系。现在当我们调用它时，一个更具体的类型就出来了：\n\n```tsx\n// s 是 'string' 类型\nconst s = firstElement([\"a\", \"b\", \"c\"]);\n// n 是 'number' 类型\nconst n = firstElement([1, 2, 3]);\n// u 是 undefined 类型\nconst u = firstElement([]);\n```\n\n### 5.4.1 类型推断\n\n请注意，在这个例子中，我们没有必要指定类型。类型是由TypeScript推断出来的--自动选择。\n\n我们也可以使用多个类型参数。例如，一个独立版本的map看起来是这样的。\n\n```tsx\nfunction map<Input, Output>(\n  arr: Input[],\n  func: (arg: Input) => Output,\n): Output[] {\n  return arr.map(func);\n}\n\n// 参数'n'是'字符串'类型。\n// 'parsed'是'number[]'类型。\nconst parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));\n```\n\n请注意，在这个例子中，TypeScript可以推断出输入类型参数的类型（从给定的字符串数组），以及基于函数表达式的返回值（数字）的输出类型参数。\n\n### 5.4.2 限制条件\n\n我们已经写了一些通用函数，可以对任何类型的值进行操作。有时我们想把两个值联系起来，但只能对某个值的子集进行操作。在这种情况下，我们可以使用一个约束条件来限制一个类型参数可以接受的类型。\n\n让我们写一个函数，返回两个值中较长的值。要做到这一点，我们需要一个长度属性，是一个数字。我们通过写一个扩展子句将类型参数限制在这个类型上。\n\n```tsx\nfunction longest<Type extends { length: number }>(a: Type, b: Type) {\n  if (a.length >= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n// longerArray 的类型是 'number[]'\nconst longerArray = longest([1, 2], [1, 2, 3]);\n// longerString 是 'alice'|'bob' 的类型。\nconst longerString = longest(\"alice\", \"bob\");\n// 错误! 数字没有'长度'属性\nconst notOK = longest(10, 100);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/WjBVzACtyJ87q1H.png\" alt=\"image-20211121103833933\" style=\"zoom:50%;\" />\n\n在这个例子中，有一些有趣的事情需要注意。我们允许TypeScript推断 `longest` 的返回类型。返回类型推断也适用于通用函数。\n\n因为我们将 Type 约束为` { length: number }`，所以我们被允许访问 `a` 和 `b` 参数的 `.length` 属性。如果没有类型约束，我们就不能访问这些属性，因为这些值可能是一些没有长度属性的其他类型。\n\n`longerArray` 和 `longerString` 的类型是根据参数推断出来的。记住，泛型就是把两个或多个具有相同类型的值联系起来。\n\n最后，正如我们所希望的，对 `longest(10, 100)` 的调用被拒绝了，因为数字类型没有一个`.length`属性。\n\n### 5.4.3 使用受限值\n\n这里有一个使用通用约束条件时的常见错误。\n\n```tsx\nfunction minimumLength<Type extends { length: number }>(\n  obj: Type,\n  minimum: number,\n): Type {\n  if (obj.length >= minimum) {\n    return obj;\n  } else {\n    return { length: minimum };\n  }\n}\n```\n\n<img src=\"/img/TypeScript/04-12.png\" alt=\"image-20211121104538424\" style=\"zoom:40%;\" />\n\n看起来这个函数没有问题--Type被限制为{ length: number }，而且这个函数要么返回Type，要么返回一个与该限制相匹配的值。问题是，该函数承诺返回与传入的对象相同的类型，而不仅仅是与约束条件相匹配的一些对象。如果这段代码是合法的，你可以写出肯定无法工作的代码。\n\n```tsx\n// 'arr' 获得值： { length: 6 }\nconst arr = minimumLength([1, 2, 3], 6);\n//在此崩溃，因为数组有一个'切片'方法，但没有返回对象!\nconsole.log(arr.slice(0));\n```\n\n![image-20211121105340359](Users/felix/Library/Application Support/typora-user-images/image-20211121105340359.png)\n\n### 5.4.4 指定类型参数\n\nTypeScript 通常可以推断出通用调用中的预期类型参数，但并非总是如此。例如，假设你写了一个函数来合并两个数组：\n\n```tsx\nfunction combine<Type>(arr1: Type[], arr2: Type[]): Type[] {\n  return arr1.concat(arr2);\n}\n```\n\n通常情况下，用不匹配的数组调用这个函数是一个错误：\n\n```tsx\nconst arr = combine([1, 2, 3], [\"hello\"]);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/a7IfnzN9h3mAHKk.png\" alt=\"image-20211121110056686\" style=\"zoom:40%;\" />\n\n然而，如果你打算这样做，你可以手动指定类型：\n\n```tsx\nconst arr = combine<string | number>([1, 2, 3], [\"hello\"]);\n```\n\n### 5.4.5 编写优秀通用函数的准则\n\n编写泛型函数很有趣，而且很容易被类型参数所迷惑。有太多的类型参数或在不需要的地方使用约束，会使推理不那么成功，使你的函数的调用者感到沮丧。\n\n- **类型参数下推**\n\n下面是两种看似相似的函数写法。\n\n```tsx\nfunction firstElement1<Type>(arr: Type[]) {\n  return arr[0];\n}\n\nfunction firstElement2<Type extends any[]>(arr: Type) {\n  return arr[0];\n}\n\n// a: number (推荐)\nconst a = firstElement1([1, 2, 3]);\n// b: any (不推荐)\nconst b = firstElement2([1, 2, 3]);\n```\n\n乍一看，这些可能是相同的，但 `firstElement1` 是写这个函数的一个更好的方法。它的推断返回类型是Type，但 `firstElement2` 的推断返回类型是 `any`，因为TypeScript必须使用约束类型来解析`arr[0]`表达式，而不是在调用期间 \"等待 \"解析该元素。\n\n> **规则：**在可能的情况下，使用类型参数本身，而不是对其进行约束\n\n- **使用更少的类型参数**\n\n下面是另一对类似的函数。\n\n```tsx\nfunction filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {\n  return arr.filter(func);\n}\n\nfunction filter2<Type, Func extends (arg: Type) => boolean>(\n  arr: Type[],\n  func: Func,\n): Type[] {\n  return arr.filter(func);\n}\n```\n\n我们已经创建了一个类型参数 `Func`，它并不涉及两个值。这总是一个值得标记的坏习惯，因为它意味着想要指定类型参数的调用者必须无缘无故地手动指定一个额外的类型参数。`Func`除了使函数更难阅读和推理外，什么也没做。\n\n> **规则：**总是尽可能少地使用类型参数\n\n- **类型参数应出现两次**\n\n有时我们会忘记，一个函数可能不需要是通用的：\n\n```tsx\nfunction greet<Str extends string>(s: Str) {\n  console.log(\"Hello, \" + s);\n}\n\ngreet(\"world\");\n```\n\n我们完全可以写一个更简单的版本：\n\n```tsx\nfunction greet(s: string) {\n  console.log(\"Hello, \" + s);\n}\n```\n\n记住，类型参数是用来关联多个值的类型的。如果一个类型参数在函数签名中只使用一次，那么它就没有任何关系。\n\n> **规则：**如果一个类型的参数只出现在一个地方，请重新考虑你是否真的需要它\n\n## 5.5 可选参数\n\nJavaScript中的函数经常需要一个可变数量的参数。例如，`number` 的 `toFixed`方法需要一个可选的数字计数。\n\n```tsx\nfunction f(n: number) {\n  console.log(n.toFixed()); // 0 个参数\n  console.log(n.toFixed(3)); // 1 个参数\n}\n```\n\n我们可以在TypeScript中通过将参数用 `?`标记：\n\n```tsx\nfunction f(x?: number) {\n  // ...\n}\nf(); // 正确\nf(10); // 正确\n```\n\n虽然参数被指定为 `number` 类型，但 `x` 参数实际上将具有 `number | undefined` 类型，因为在JavaScript中未指定的参数会得到 `undefined` 的值。\n\n你也可以提供一个参数默认值。\n\n```tsx\nfunction f(x = 10) {\n  // ...\n}\n```\n\n现在在 `f` 的主体中，`x` 将具有 `number` 类型，因为任何 `undefined` 的参数将被替换为 `10`。请注意，当一个参数是可选的，调用者总是可以传递未定义的参数，因为这只是模拟一个 \"丢失 \"的参数：\n\n```tsx\ndeclare function f(x?: number): void;\n\n// 以下调用都是正确的\nf();\nf(10);\nf(undefined);\n```\n\n### 5.5.1 回调中的可选参数\n\n一旦你了解了可选参数和函数类型表达式，在编写调用回调的函数时就很容易犯以下错误：\n\n```tsx\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    callback(arr[i], i);\n  }\n}\n```\n\n我们在写 `index?` 作为一个可选参数时，通常是想让这些调用都是合法的：\n\n```tsx\nmyForEach([1, 2, 3], (a) => console.log(a));\nmyForEach([1, 2, 3], (a, i) => console.log(a, i));\n```\n\n这实际上意味着回调可能会被调用，只有一个参数。换句话说，该函数定义说，实现可能是这样的：\n\n```tsx\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    // 我现在不想提供索引\n    callback(arr[i]);\n  }\n}\n```\n\n反过来，TypeScript会强制执行这个意思，并发出实际上不可能的错误：\n\n```tsx\nmyForEach([1, 2, 3], (a, i) => {\n  console.log(i.toFixed());\n});\n```\n\n<img src=\"/img/TypeScript/04-14.png\" alt=\"image-20211121151911039\" style=\"zoom:40%;\" />\n\n在JavaScript中，如果你调用一个形参多于实参的函数，额外的参数会被简单地忽略。TypeScript的行为也是如此。参数较少的函数（相同的类型）总是可以取代参数较多的函数的位置。\n\n> 当为回调写一个函数类型时，永远不要写一个可选参数，除非你打算在不传递该参数的情况下调用函数。\n\n## 5.6 函数重载\n\n一些 JavaScript 函数可以在不同的参数数量和类型中被调用。例如，你可能会写一个函数来产生一个Date，它需要一个时间戳（一个参数）或一个月/日/年规格（三个参数）。\n\n在TypeScript中，我们可以通过编写重载签名来指定一个可以以不同方式调用的函数。要做到这一点，要写一些数量的函数签名（通常是两个或更多），然后是函数的主体：\n\n```tsx\nfunction makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\nconst d1 = makeDate(12345678);\nconst d2 = makeDate(5, 5, 5);\nconst d3 = makeDate(1, 3);\n```\n\n<img src=\"/img/TypeScript/04-15.png\" alt=\"image-20211121153802236\" style=\"zoom:42%;\" />\n\n在这个例子中，我们写了两个重载：一个接受一个参数，另一个接受三个参数。这前两个签名被称为重载签名。\n\n然后，我们写了一个具有兼容签名的函数实现。函数有一个实现签名，但这个签名不能被直接调用。即使我们写了一个在所需参数之后有两个可选参数的函数，它也不能以两个参数被调用！\n\n### 5.6.1 重载签名和实现签名\n\n这是一个常见的混乱来源。通常我们会写这样的代码，却不明白为什么会出现错误：\n\n```tsx\nfunction fn(x: string): void;\nfunction fn() {\n  // ...\n}\n// 期望能够以零参数调用\nfn();\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/2PbtdUgEz5Ts3Dr.png\" alt=\"image-20211121154720160\" style=\"zoom:50%;\" />\n\n同样，用于编写函数体的签名不能从外面 \"看到\"。\n\n> 实现的签名从外面是看不到的。在编写重载函数时，你应该总是在函数的实现上面有两个或多个签名。\n\n实现签名也必须与重载签名兼容。例如，这些函数有错误，因为实现签名没有以正确的方式匹配重载：\n\n```tsx\nfunction fn(x: boolean): void;\n// 参数类型不正确\nfunction fn(x: string): void;\nfunction fn(x: boolean) {}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/saCfOyHuShpilg3.png\" alt=\"image-20211121160302934\" style=\"zoom:50%;\" />\n\n```tsx\nfunction fn(x: string): string;\n// 返回类型不正确\nfunction fn(x: number): boolean;\nfunction fn(x: string | number) {\n  return \"oops\";\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/4OAqJInZEdRftuv.png\" alt=\"image-20211121160413329\" style=\"zoom: 50%;\" />\n\n### 5.6.2 编写好的重载\n\n和泛型一样，在使用函数重载时，有一些准则是你应该遵循的。遵循这些原则将使你的函数更容易调用，更容易理解，更容易实现。\n\n让我们考虑一个返回字符串或数组长度的函数：\n\n```tsx\nfunction len(s: string): number;\nfunction len(arr: any[]): number;\nfunction len(x: any) {\n  return x.length;\n}\n```\n\n这个函数是好的；我们可以用字符串或数组来调用它。然而，我们不能用一个可能是字符串或数组的值来调用它，因为TypeScript只能将一个函数调用解析为一个重载：\n\n```tsx\nlen(\"\"); // OK\nlen([0]); // OK\nlen(Math.random() > 0.5 ? \"hello\" : [0]);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/6NRbiq5Dp3ulKhg.png\" alt=\"image-20211121161500523\" style=\"zoom:50%;\" />\n\n因为两个重载都有相同的参数数量和相同的返回类型，我们可以改写一个非重载版本的函数：\n\n```tsx\nfunction len(x: any[] | string) {\n  return x.length;\n}\n\nlen(\"\"); // OK\nlen([0]); // OK\nlen(Math.random() > 0.5 ? \"hello\" : [0]); // OK\n```\n\n这就好得多了! 调用者可以用任何一种值来调用它，而且作为额外的奖励，我们不需要找出一个正确的实现签名。\n\n> 在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数\n\n### 5.6.3 函数内`This`的声明\n\nTypeScript会通过代码流分析来推断函数中的 `this` 应该是什么，比如下面的例子：\n\n```tsx\nconst user = {\n  id: 123,\n\n  admin: false,\n  becomeAdmin: function () {\n    this.admin = true;\n  },\n};\n```\n\nTypeScript理解函数 `user.becomeAdmin` 有一个对应的 `this`，它是外部对象 `user`。这个对于很多情况来说已经足够了，但是有很多情况下你需要更多的控制 `this` 代表什么对象。JavaScript规范规定，你不能有一个叫 `this`的参数，所以TypeScript使用这个语法空间，让你在函数体中声明`this`的类型。\n\n```tsx\ninterface User {\n  admin: boolean;\n}\n\ninterface DB {\n  filterUsers(filter: (this: User) => boolean): User[];\n}\n\nconst db: DB = {\n  filterUsers: (filter: (this: User) => boolean) => {\n    let user1 = {\n      admin: true,\n    };\n    let user2 = {\n      admin: false,\n    };\n    return [user1, user2];\n  },\n};\n\nconst admins = db.filterUsers(function (this: User) {\n  return this.admin;\n});\n```\n\n这种模式在回调式API中很常见，另一个对象通常控制你的函数何时被调用。注意，你需要使用函数而不是箭头函数来获得这种行为。\n\n```tsx\ninterface User {\n  admin: boolean;\n}\n\ninterface DB {\n  filterUsers(filter: (this: User) => boolean): User[];\n}\n\nconst db: DB = {\n  filterUsers: (filter: (this: User) => boolean) => {\n    let user1 = {\n      admin: true,\n    };\n    let user2 = {\n      admin: false,\n    };\n    return [user1, user2];\n  },\n};\n// 不能为箭头函数\nconst admins = db.filterUsers(() => this.admin);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/vYImhS8FQOHgJfT.png\" alt=\"image-20211121164923229\" style=\"zoom:40%;\" />\n\n## 5.7 需要了解的其他类型\n\n有一些额外的类型你会想要认识，它们在处理函数类型时经常出现。像所有的类型一样，你可以在任何地方使用它们，但这些类型在函数的上下文中特别相关。\n\n### 5.7.1 `void`\n\n`void`表示没有返回值的函数的返回值。当一个函数没有任何返回语句，或者没有从这些返回语句中返回任何明确的值时，它都是推断出来的类型。\n\n```tsx\n// 推断出的返回类型是void\nfunction noop() {\n  return;\n}\n```\n\n在JavaScript中，一个不返回任何值的函数将隐含地返回`undefinded`的值。然而，在TypeScript中，`void`和`undefined`是不一样的。在本章末尾有进一步的细节。\n\n> `void`与`undefined`不一样。\n\n### 5.7.2 `object`\n\n特殊类型 `object` 指的是任何不是基元的值（`string`、`number`、`bigint`、`boolean`、`symbol`、`null `或 `undefined`）。这与空对象类型`{ }`不同，也与全局类型 `Object` 不同。你很可能永远不会使用 `Object`。\n\n> `object`不是`Object`。始终使用`object`!\n\n请注意，在JavaScript中，函数值是对象。它们有属性，在它们的原型链中有`Object.prototype`，是 `Object`的实例，你可以对它们调用 `Object.key`，等等。由于这个原因，函数类型在TypeScript中被认为是`object`。\n\n### 5.7.3 `unknown`\n\n`unknown`类型代表任何值。这与 `any` 类型类似，但更安全，因为对未知 `unknown` 值做任何事情都是不合法的。\n\n```tsx\nfunction f1(a: any) {\n  a.b(); // 正确\n}\nfunction f2(a: unknown) {\n  a.b();\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/pl7s6ZDr8QKAJgh.png\" alt=\"image-20211121172520948\" style=\"zoom:50%;\" />\n\n这在描述函数类型时很有用，因为你可以描述接受任何值的函数，而不需要在函数体中有 `any` 值。\n\n反之，你可以描述一个返回未知类型的值的函数：\n\n```tsx\nfunction safeParse(s: string): unknown {\n  return JSON.parse(s);\n}\n\n// 需要小心对待'obj'!\nconst obj = safeParse(someRandomString);\n```\n\n### 5.7.4 `never`\n\n有些函数永远不会返回一个值：\n\n```tsx\nfunction fail(msg: string): never {\n  throw new Error(msg);\n}\n```\n\n`never`类型表示永远不会被观察到的值。在一个返回类型中，这意味着函数抛出一个异常或终止程序的执行。\n\n`never`也出现在TypeScript确定一个 `union` 中没有任何东西的时候。\n\n```tsx\nfunction fn(x: string | number) {\n  if (typeof x === \"string\") {\n    // 做一些事\n  } else if (typeof x === \"number\") {\n    // 再做一些事\n  } else {\n    x; // 'never'!\n  }\n}\n```\n\n### 5.7.5 `Function`\n\n全局性的 `Function` 类型描述了诸如 `bind`、`call`、`apply`和其他存在于JavaScript中所有函数值的属性。它还有一个特殊的属性，即 `Function` 类型的值总是可以被调用；这些调用返回 `any`。\n\n```tsx\nfunction doSomething(f: Function) {\n  return f(1, 2, 3);\n}\n```\n\n这是一个无类型的函数调用，一般来说最好避免，因为 `any` 返回类型都不安全。\n\n如果你需要接受一个任意的函数，但不打算调用它，一般来说，`() => void`的类型比较安全。\n\n## 5.8 参数展开运算符\n\n### 5.8.1 形参展开(Rest Parameters)\n\n除了使用可选参数或重载来制作可以接受各种固定参数数量的函数之外，我们还可以使用休止参数来定义接受无限制数量的参数的函数。\n\n`rest`参数出现在所有其他参数之后，并使用`...`的语法：\n\n```tsx\nfunction multiply(n: number, ...m: number[]) {\n  return m.map((x) => n * x);\n}\n// 'a' 获得的值 [10, 20, 30, 40]\nconst a = multiply(10, 1, 2, 3, 4);\n```\n\n在TypeScript中，这些参数的类型注解是隐含的 `any[]`，而不是`any`，任何给出的类型注解必须是`Array<T>`或`T[]`的形式，或一个元组类型（我们将在后面学习）。\n\n### 5.8.2 实参展开(Rest Arguments)\n\n反之，我们可以使用 `spread` 语法从数组中提供可变数量的参数。例如，数组的 `push` 方法需要任意数量的参数。\n\n```tsx\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\narr1.push(...arr2);\n```\n\n请注意，一般来说，TypeScript并不假定数组是不可变的。这可能会导致一些令人惊讶的行为。\n\n```tsx\n// 推断的类型是 number[] -- \"一个有零或多个数字的数组\"。\n// 不专指两个数字\nconst args = [8, 5];\nconst angle = Math.atan2(...args);\n```\n\n<img src=\"/img/TypeScript/05-06.png\" alt=\"image-20211122191044837\" style=\"zoom: 50%;\" />\n\n这种情况的最佳解决方案取决于你的代码，但一般来说，`const context` 是最直接的解决方案。\n\n```tsx\n// 推断为2个长度的元组\nconst args = [8, 5] as const;\n// 正确\nconst angle = Math.atan2(...args);\n```\n\n## 5.9 参数解构\n\n你可以使用参数重构来方便地将作为参数提供的对象，解压到函数主体的一个或多个局部变量中。在JavaScript中，它看起来像这样：\n\n```tsx\nfunction sum({ a, b, c }) {\n  console.log(a + b + c);\n}\nsum({ a: 10, b: 3, c: 9 });\n```\n\n对象的类型注解在解构的语法之后：\n\n```tsx\nfunction sum({ a, b, c }: { a: number; b: number; c: number }) {\n  console.log(a + b + c);\n}\n```\n\n这看起来有点啰嗦，但你也可以在这里使用一个命名的类型：\n\n```tsx\n// 与之前的例子相同\ntype ABC = { a: number; b: number; c: number };\nfunction sum({ a, b, c }: ABC) {\n  console.log(a + b + c);\n}\n```\n\n## 5.10 函数的可分配性\n\n### 5.10.1 返回 `void` 类型\n\n函数的 `void` 返回类型可以产生一些不寻常的，但却是预期的行为。\n\n返回类型为 `void` 的上下文类型并不强迫函数不返回东西。另一种说法是，一个具有 `void`返回类型的上下文函数类型（`type vf = () => void`），在实现时，可以返回任何其他的值，但它会被忽略。\n\n因此，以下`（）=> void`类型的实现是有效的：\n\n```tsx\ntype voidFunc = () => void;\n\nconst f1: voidFunc = () => {\n  return true;\n};\n\nconst f2: voidFunc = () => true;\n\nconst f3: voidFunc = function () {\n  return true;\n};\n```\n\n而当这些函数之一的返回值被分配给另一个变量时，它将保留 `void` 的类型：\n\n```tsx\nconst v1 = f1();\nconst v2 = f2();\nconst v3 = f3();\n```\n\n这种行为的存在使得下面的代码是有效的，即使 `Array.prototype.push`返回一个数字，而`Array.prototype.forEach`方法期望一个返回类型为`void`的函数：\n\n```tsx\nconst src = [1, 2, 3];\nconst dst = [0];\n\nsrc.forEach((el) => dst.push(el));\n```\n\n还有一个需要注意的特殊情况，当一个字面的函数定义有一个 `void` 的返回类型时，该函数必须不返回任何东西。\n\n```tsx\nfunction f2(): void {\n  return true;\n}\n\nconst f3 = function (): void {\n  return true;\n};\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/t7q4nWcpJxZz12D.png\" alt=\"image-20211122220703542\" style=\"zoom:50%;\" />\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-5、基础篇：函数更多.md",
        "raw": "---\ntitle: 1-5、基础篇：函数更多\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nswiper_index: 5\nswiper_cover: /img/recommend/recommend_05.jpg\nswiper_desc: 1-5、基础篇：函数更多\nabbrlink: 30791\ndate: 2024-01-28 19:40:50\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 五、函数更多\n\n函数是任何应用程序的基本构件，无论它们是本地函数，从另一个模块导入，还是一个类上的方法。它们也是值，就像其他值一样，TypeScript有很多方法来描述如何调用函数。让我们来学习一下如何编写描述函数的类型。\n\n## 5.1 函数类型表达式\n\n描述一个函数的最简单方法是用一个函数类型表达式。这些类型在语法上类似于箭头函数。\n\n```tsx\nfunction greeter(fn: (a: string) => void) {\n  fn(\"Hello, World\");\n}\n\nfunction printToConsole(s: string) {\n  console.log(s);\n}\n\ngreeter(printToConsole);\n```\n\n语法`(a: string) => void`意味着 \"有一个参数的函数，名为 `a`，类型为字符串，没有返回值\"。就像函数声明一样，如果没有指定参数类型，它就隐含为 `any` 类型。\n\n当然，我们可以用一个类型别名来命名一个函数类型。\n\n```tsx\ntype GreetFunction = (a: string) => void;\nfunction greeter(fn: GreetFunction) {\n  // ...\n}\n```\n\n## 5.2 调用签名\n\n在JavaScript中，除了可调用之外，函数还可以有属性。然而，函数类型表达式的语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以在一个对象类型中写一个*调用签名*。\n\n```tsx\ntype DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\n\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + \" returned \" + fn(6));\n}\n\nfunction fn1() {\n  return true;\n}\nfn1.description = \"balabala...\";\n\ndoSomething(fn1);\n```\n\n注意，与函数类型表达式相比，语法略有不同：在参数列表和返回类型之间使用`:`而不是`=>`。\n\n## 5.3 构造签名\n\nJavaScript函数也可以用 `new` 操作符来调用。TypeScript将这些称为构造函数，因为它们通常会创建一个新的对象。你可以通过在调用签名前面添加 `new` 关键字来写一个构造签名。\n\n```tsx\nclass Ctor {\n  s: string;\n  constructor(s: string) {\n    this.s = s;\n  }\n}\n\ntype SomeConstructor = {\n  new (s: string): Ctor;\n};\nfunction fn(ctor: SomeConstructor) {\n  return new ctor(\"hello\");\n}\n\nconst f = fn(Ctor);\nconsole.log(f.s);\n```\n\n有些对象，如 JavaScript 的 `Date` 对象，可以在有 `new` 或没有 `new` 的情况下被调用。你可以在同一类型中任意地结合调用和构造签名。\n\n```tsx\ninterface CallOrConstruct {\n  new (s: string): Date;\n  (n?: number): number;\n}\n\nfunction fn(date: CallOrConstruct) {\n  let d = new date(\"2021-11-20\");\n  let n = date(100);\n}\n```\n\n再举一个例子：\n\n```tsx\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n\ninterface ClockInterface {\n  tick(): void;\n}\n\nfunction createClock(\n  ctor: ClockConstructor,\n  hour: number,\n  minute: number,\n): ClockInterface {\n  return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"beep beep\");\n  }\n}\n\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"tick tock\");\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n```\n\n## 5.4 泛型函数\n\n在写一个函数时，输入的类型与输出的类型有关，或者两个输入的类型以某种方式相关，这是常见的。让我们考虑一下一个返回数组中第一个元素的函数。\n\n```tsx\nfunction firstElement(arr: any[]) {\n  return arr[0];\n}\n```\n\n这个函数完成了它的工作，但不幸的是它的返回类型是 `any`。如果该函数返回数组元素的类型会更好。\n\n在TypeScript中，当我们想描述两个值之间的对应关系时，会使用泛型。我们通过在函数签名中声明一个类型参数来做到这一点：\n\n```tsx\nfunction firstElement<Type>(arr: Type[]): Type | undefined {\n  return arr[0];\n}\n```\n\n通过给这个函数添加一个类型参数 `Type`，并在两个地方使用它，我们已经在函数的输入（数组）和输出（返回值）之间建立了一个联系。现在当我们调用它时，一个更具体的类型就出来了：\n\n```tsx\n// s 是 'string' 类型\nconst s = firstElement([\"a\", \"b\", \"c\"]);\n// n 是 'number' 类型\nconst n = firstElement([1, 2, 3]);\n// u 是 undefined 类型\nconst u = firstElement([]);\n```\n\n### 5.4.1 类型推断\n\n请注意，在这个例子中，我们没有必要指定类型。类型是由TypeScript推断出来的--自动选择。\n\n我们也可以使用多个类型参数。例如，一个独立版本的map看起来是这样的。\n\n```tsx\nfunction map<Input, Output>(\n  arr: Input[],\n  func: (arg: Input) => Output,\n): Output[] {\n  return arr.map(func);\n}\n\n// 参数'n'是'字符串'类型。\n// 'parsed'是'number[]'类型。\nconst parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));\n```\n\n请注意，在这个例子中，TypeScript可以推断出输入类型参数的类型（从给定的字符串数组），以及基于函数表达式的返回值（数字）的输出类型参数。\n\n### 5.4.2 限制条件\n\n我们已经写了一些通用函数，可以对任何类型的值进行操作。有时我们想把两个值联系起来，但只能对某个值的子集进行操作。在这种情况下，我们可以使用一个约束条件来限制一个类型参数可以接受的类型。\n\n让我们写一个函数，返回两个值中较长的值。要做到这一点，我们需要一个长度属性，是一个数字。我们通过写一个扩展子句将类型参数限制在这个类型上。\n\n```tsx\nfunction longest<Type extends { length: number }>(a: Type, b: Type) {\n  if (a.length >= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n// longerArray 的类型是 'number[]'\nconst longerArray = longest([1, 2], [1, 2, 3]);\n// longerString 是 'alice'|'bob' 的类型。\nconst longerString = longest(\"alice\", \"bob\");\n// 错误! 数字没有'长度'属性\nconst notOK = longest(10, 100);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/WjBVzACtyJ87q1H.png\" alt=\"image-20211121103833933\" style=\"zoom:50%;\" />\n\n在这个例子中，有一些有趣的事情需要注意。我们允许TypeScript推断 `longest` 的返回类型。返回类型推断也适用于通用函数。\n\n因为我们将 Type 约束为` { length: number }`，所以我们被允许访问 `a` 和 `b` 参数的 `.length` 属性。如果没有类型约束，我们就不能访问这些属性，因为这些值可能是一些没有长度属性的其他类型。\n\n`longerArray` 和 `longerString` 的类型是根据参数推断出来的。记住，泛型就是把两个或多个具有相同类型的值联系起来。\n\n最后，正如我们所希望的，对 `longest(10, 100)` 的调用被拒绝了，因为数字类型没有一个`.length`属性。\n\n### 5.4.3 使用受限值\n\n这里有一个使用通用约束条件时的常见错误。\n\n```tsx\nfunction minimumLength<Type extends { length: number }>(\n  obj: Type,\n  minimum: number,\n): Type {\n  if (obj.length >= minimum) {\n    return obj;\n  } else {\n    return { length: minimum };\n  }\n}\n```\n\n<img src=\"/img/TypeScript/04-12.png\" alt=\"image-20211121104538424\" style=\"zoom:40%;\" />\n\n看起来这个函数没有问题--Type被限制为{ length: number }，而且这个函数要么返回Type，要么返回一个与该限制相匹配的值。问题是，该函数承诺返回与传入的对象相同的类型，而不仅仅是与约束条件相匹配的一些对象。如果这段代码是合法的，你可以写出肯定无法工作的代码。\n\n```tsx\n// 'arr' 获得值： { length: 6 }\nconst arr = minimumLength([1, 2, 3], 6);\n//在此崩溃，因为数组有一个'切片'方法，但没有返回对象!\nconsole.log(arr.slice(0));\n```\n\n![image-20211121105340359](Users/felix/Library/Application Support/typora-user-images/image-20211121105340359.png)\n\n### 5.4.4 指定类型参数\n\nTypeScript 通常可以推断出通用调用中的预期类型参数，但并非总是如此。例如，假设你写了一个函数来合并两个数组：\n\n```tsx\nfunction combine<Type>(arr1: Type[], arr2: Type[]): Type[] {\n  return arr1.concat(arr2);\n}\n```\n\n通常情况下，用不匹配的数组调用这个函数是一个错误：\n\n```tsx\nconst arr = combine([1, 2, 3], [\"hello\"]);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/a7IfnzN9h3mAHKk.png\" alt=\"image-20211121110056686\" style=\"zoom:40%;\" />\n\n然而，如果你打算这样做，你可以手动指定类型：\n\n```tsx\nconst arr = combine<string | number>([1, 2, 3], [\"hello\"]);\n```\n\n### 5.4.5 编写优秀通用函数的准则\n\n编写泛型函数很有趣，而且很容易被类型参数所迷惑。有太多的类型参数或在不需要的地方使用约束，会使推理不那么成功，使你的函数的调用者感到沮丧。\n\n- **类型参数下推**\n\n下面是两种看似相似的函数写法。\n\n```tsx\nfunction firstElement1<Type>(arr: Type[]) {\n  return arr[0];\n}\n\nfunction firstElement2<Type extends any[]>(arr: Type) {\n  return arr[0];\n}\n\n// a: number (推荐)\nconst a = firstElement1([1, 2, 3]);\n// b: any (不推荐)\nconst b = firstElement2([1, 2, 3]);\n```\n\n乍一看，这些可能是相同的，但 `firstElement1` 是写这个函数的一个更好的方法。它的推断返回类型是Type，但 `firstElement2` 的推断返回类型是 `any`，因为TypeScript必须使用约束类型来解析`arr[0]`表达式，而不是在调用期间 \"等待 \"解析该元素。\n\n> **规则：**在可能的情况下，使用类型参数本身，而不是对其进行约束\n\n- **使用更少的类型参数**\n\n下面是另一对类似的函数。\n\n```tsx\nfunction filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {\n  return arr.filter(func);\n}\n\nfunction filter2<Type, Func extends (arg: Type) => boolean>(\n  arr: Type[],\n  func: Func,\n): Type[] {\n  return arr.filter(func);\n}\n```\n\n我们已经创建了一个类型参数 `Func`，它并不涉及两个值。这总是一个值得标记的坏习惯，因为它意味着想要指定类型参数的调用者必须无缘无故地手动指定一个额外的类型参数。`Func`除了使函数更难阅读和推理外，什么也没做。\n\n> **规则：**总是尽可能少地使用类型参数\n\n- **类型参数应出现两次**\n\n有时我们会忘记，一个函数可能不需要是通用的：\n\n```tsx\nfunction greet<Str extends string>(s: Str) {\n  console.log(\"Hello, \" + s);\n}\n\ngreet(\"world\");\n```\n\n我们完全可以写一个更简单的版本：\n\n```tsx\nfunction greet(s: string) {\n  console.log(\"Hello, \" + s);\n}\n```\n\n记住，类型参数是用来关联多个值的类型的。如果一个类型参数在函数签名中只使用一次，那么它就没有任何关系。\n\n> **规则：**如果一个类型的参数只出现在一个地方，请重新考虑你是否真的需要它\n\n## 5.5 可选参数\n\nJavaScript中的函数经常需要一个可变数量的参数。例如，`number` 的 `toFixed`方法需要一个可选的数字计数。\n\n```tsx\nfunction f(n: number) {\n  console.log(n.toFixed()); // 0 个参数\n  console.log(n.toFixed(3)); // 1 个参数\n}\n```\n\n我们可以在TypeScript中通过将参数用 `?`标记：\n\n```tsx\nfunction f(x?: number) {\n  // ...\n}\nf(); // 正确\nf(10); // 正确\n```\n\n虽然参数被指定为 `number` 类型，但 `x` 参数实际上将具有 `number | undefined` 类型，因为在JavaScript中未指定的参数会得到 `undefined` 的值。\n\n你也可以提供一个参数默认值。\n\n```tsx\nfunction f(x = 10) {\n  // ...\n}\n```\n\n现在在 `f` 的主体中，`x` 将具有 `number` 类型，因为任何 `undefined` 的参数将被替换为 `10`。请注意，当一个参数是可选的，调用者总是可以传递未定义的参数，因为这只是模拟一个 \"丢失 \"的参数：\n\n```tsx\ndeclare function f(x?: number): void;\n\n// 以下调用都是正确的\nf();\nf(10);\nf(undefined);\n```\n\n### 5.5.1 回调中的可选参数\n\n一旦你了解了可选参数和函数类型表达式，在编写调用回调的函数时就很容易犯以下错误：\n\n```tsx\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    callback(arr[i], i);\n  }\n}\n```\n\n我们在写 `index?` 作为一个可选参数时，通常是想让这些调用都是合法的：\n\n```tsx\nmyForEach([1, 2, 3], (a) => console.log(a));\nmyForEach([1, 2, 3], (a, i) => console.log(a, i));\n```\n\n这实际上意味着回调可能会被调用，只有一个参数。换句话说，该函数定义说，实现可能是这样的：\n\n```tsx\nfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {\n  for (let i = 0; i < arr.length; i++) {\n    // 我现在不想提供索引\n    callback(arr[i]);\n  }\n}\n```\n\n反过来，TypeScript会强制执行这个意思，并发出实际上不可能的错误：\n\n```tsx\nmyForEach([1, 2, 3], (a, i) => {\n  console.log(i.toFixed());\n});\n```\n\n<img src=\"/img/TypeScript/04-14.png\" alt=\"image-20211121151911039\" style=\"zoom:40%;\" />\n\n在JavaScript中，如果你调用一个形参多于实参的函数，额外的参数会被简单地忽略。TypeScript的行为也是如此。参数较少的函数（相同的类型）总是可以取代参数较多的函数的位置。\n\n> 当为回调写一个函数类型时，永远不要写一个可选参数，除非你打算在不传递该参数的情况下调用函数。\n\n## 5.6 函数重载\n\n一些 JavaScript 函数可以在不同的参数数量和类型中被调用。例如，你可能会写一个函数来产生一个Date，它需要一个时间戳（一个参数）或一个月/日/年规格（三个参数）。\n\n在TypeScript中，我们可以通过编写重载签名来指定一个可以以不同方式调用的函数。要做到这一点，要写一些数量的函数签名（通常是两个或更多），然后是函数的主体：\n\n```tsx\nfunction makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\nconst d1 = makeDate(12345678);\nconst d2 = makeDate(5, 5, 5);\nconst d3 = makeDate(1, 3);\n```\n\n<img src=\"/img/TypeScript/04-15.png\" alt=\"image-20211121153802236\" style=\"zoom:42%;\" />\n\n在这个例子中，我们写了两个重载：一个接受一个参数，另一个接受三个参数。这前两个签名被称为重载签名。\n\n然后，我们写了一个具有兼容签名的函数实现。函数有一个实现签名，但这个签名不能被直接调用。即使我们写了一个在所需参数之后有两个可选参数的函数，它也不能以两个参数被调用！\n\n### 5.6.1 重载签名和实现签名\n\n这是一个常见的混乱来源。通常我们会写这样的代码，却不明白为什么会出现错误：\n\n```tsx\nfunction fn(x: string): void;\nfunction fn() {\n  // ...\n}\n// 期望能够以零参数调用\nfn();\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/2PbtdUgEz5Ts3Dr.png\" alt=\"image-20211121154720160\" style=\"zoom:50%;\" />\n\n同样，用于编写函数体的签名不能从外面 \"看到\"。\n\n> 实现的签名从外面是看不到的。在编写重载函数时，你应该总是在函数的实现上面有两个或多个签名。\n\n实现签名也必须与重载签名兼容。例如，这些函数有错误，因为实现签名没有以正确的方式匹配重载：\n\n```tsx\nfunction fn(x: boolean): void;\n// 参数类型不正确\nfunction fn(x: string): void;\nfunction fn(x: boolean) {}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/saCfOyHuShpilg3.png\" alt=\"image-20211121160302934\" style=\"zoom:50%;\" />\n\n```tsx\nfunction fn(x: string): string;\n// 返回类型不正确\nfunction fn(x: number): boolean;\nfunction fn(x: string | number) {\n  return \"oops\";\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/4OAqJInZEdRftuv.png\" alt=\"image-20211121160413329\" style=\"zoom: 50%;\" />\n\n### 5.6.2 编写好的重载\n\n和泛型一样，在使用函数重载时，有一些准则是你应该遵循的。遵循这些原则将使你的函数更容易调用，更容易理解，更容易实现。\n\n让我们考虑一个返回字符串或数组长度的函数：\n\n```tsx\nfunction len(s: string): number;\nfunction len(arr: any[]): number;\nfunction len(x: any) {\n  return x.length;\n}\n```\n\n这个函数是好的；我们可以用字符串或数组来调用它。然而，我们不能用一个可能是字符串或数组的值来调用它，因为TypeScript只能将一个函数调用解析为一个重载：\n\n```tsx\nlen(\"\"); // OK\nlen([0]); // OK\nlen(Math.random() > 0.5 ? \"hello\" : [0]);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/6NRbiq5Dp3ulKhg.png\" alt=\"image-20211121161500523\" style=\"zoom:50%;\" />\n\n因为两个重载都有相同的参数数量和相同的返回类型，我们可以改写一个非重载版本的函数：\n\n```tsx\nfunction len(x: any[] | string) {\n  return x.length;\n}\n\nlen(\"\"); // OK\nlen([0]); // OK\nlen(Math.random() > 0.5 ? \"hello\" : [0]); // OK\n```\n\n这就好得多了! 调用者可以用任何一种值来调用它，而且作为额外的奖励，我们不需要找出一个正确的实现签名。\n\n> 在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数\n\n### 5.6.3 函数内`This`的声明\n\nTypeScript会通过代码流分析来推断函数中的 `this` 应该是什么，比如下面的例子：\n\n```tsx\nconst user = {\n  id: 123,\n\n  admin: false,\n  becomeAdmin: function () {\n    this.admin = true;\n  },\n};\n```\n\nTypeScript理解函数 `user.becomeAdmin` 有一个对应的 `this`，它是外部对象 `user`。这个对于很多情况来说已经足够了，但是有很多情况下你需要更多的控制 `this` 代表什么对象。JavaScript规范规定，你不能有一个叫 `this`的参数，所以TypeScript使用这个语法空间，让你在函数体中声明`this`的类型。\n\n```tsx\ninterface User {\n  admin: boolean;\n}\n\ninterface DB {\n  filterUsers(filter: (this: User) => boolean): User[];\n}\n\nconst db: DB = {\n  filterUsers: (filter: (this: User) => boolean) => {\n    let user1 = {\n      admin: true,\n    };\n    let user2 = {\n      admin: false,\n    };\n    return [user1, user2];\n  },\n};\n\nconst admins = db.filterUsers(function (this: User) {\n  return this.admin;\n});\n```\n\n这种模式在回调式API中很常见，另一个对象通常控制你的函数何时被调用。注意，你需要使用函数而不是箭头函数来获得这种行为。\n\n```tsx\ninterface User {\n  admin: boolean;\n}\n\ninterface DB {\n  filterUsers(filter: (this: User) => boolean): User[];\n}\n\nconst db: DB = {\n  filterUsers: (filter: (this: User) => boolean) => {\n    let user1 = {\n      admin: true,\n    };\n    let user2 = {\n      admin: false,\n    };\n    return [user1, user2];\n  },\n};\n// 不能为箭头函数\nconst admins = db.filterUsers(() => this.admin);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/vYImhS8FQOHgJfT.png\" alt=\"image-20211121164923229\" style=\"zoom:40%;\" />\n\n## 5.7 需要了解的其他类型\n\n有一些额外的类型你会想要认识，它们在处理函数类型时经常出现。像所有的类型一样，你可以在任何地方使用它们，但这些类型在函数的上下文中特别相关。\n\n### 5.7.1 `void`\n\n`void`表示没有返回值的函数的返回值。当一个函数没有任何返回语句，或者没有从这些返回语句中返回任何明确的值时，它都是推断出来的类型。\n\n```tsx\n// 推断出的返回类型是void\nfunction noop() {\n  return;\n}\n```\n\n在JavaScript中，一个不返回任何值的函数将隐含地返回`undefinded`的值。然而，在TypeScript中，`void`和`undefined`是不一样的。在本章末尾有进一步的细节。\n\n> `void`与`undefined`不一样。\n\n### 5.7.2 `object`\n\n特殊类型 `object` 指的是任何不是基元的值（`string`、`number`、`bigint`、`boolean`、`symbol`、`null `或 `undefined`）。这与空对象类型`{ }`不同，也与全局类型 `Object` 不同。你很可能永远不会使用 `Object`。\n\n> `object`不是`Object`。始终使用`object`!\n\n请注意，在JavaScript中，函数值是对象。它们有属性，在它们的原型链中有`Object.prototype`，是 `Object`的实例，你可以对它们调用 `Object.key`，等等。由于这个原因，函数类型在TypeScript中被认为是`object`。\n\n### 5.7.3 `unknown`\n\n`unknown`类型代表任何值。这与 `any` 类型类似，但更安全，因为对未知 `unknown` 值做任何事情都是不合法的。\n\n```tsx\nfunction f1(a: any) {\n  a.b(); // 正确\n}\nfunction f2(a: unknown) {\n  a.b();\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/pl7s6ZDr8QKAJgh.png\" alt=\"image-20211121172520948\" style=\"zoom:50%;\" />\n\n这在描述函数类型时很有用，因为你可以描述接受任何值的函数，而不需要在函数体中有 `any` 值。\n\n反之，你可以描述一个返回未知类型的值的函数：\n\n```tsx\nfunction safeParse(s: string): unknown {\n  return JSON.parse(s);\n}\n\n// 需要小心对待'obj'!\nconst obj = safeParse(someRandomString);\n```\n\n### 5.7.4 `never`\n\n有些函数永远不会返回一个值：\n\n```tsx\nfunction fail(msg: string): never {\n  throw new Error(msg);\n}\n```\n\n`never`类型表示永远不会被观察到的值。在一个返回类型中，这意味着函数抛出一个异常或终止程序的执行。\n\n`never`也出现在TypeScript确定一个 `union` 中没有任何东西的时候。\n\n```tsx\nfunction fn(x: string | number) {\n  if (typeof x === \"string\") {\n    // 做一些事\n  } else if (typeof x === \"number\") {\n    // 再做一些事\n  } else {\n    x; // 'never'!\n  }\n}\n```\n\n### 5.7.5 `Function`\n\n全局性的 `Function` 类型描述了诸如 `bind`、`call`、`apply`和其他存在于JavaScript中所有函数值的属性。它还有一个特殊的属性，即 `Function` 类型的值总是可以被调用；这些调用返回 `any`。\n\n```tsx\nfunction doSomething(f: Function) {\n  return f(1, 2, 3);\n}\n```\n\n这是一个无类型的函数调用，一般来说最好避免，因为 `any` 返回类型都不安全。\n\n如果你需要接受一个任意的函数，但不打算调用它，一般来说，`() => void`的类型比较安全。\n\n## 5.8 参数展开运算符\n\n### 5.8.1 形参展开(Rest Parameters)\n\n除了使用可选参数或重载来制作可以接受各种固定参数数量的函数之外，我们还可以使用休止参数来定义接受无限制数量的参数的函数。\n\n`rest`参数出现在所有其他参数之后，并使用`...`的语法：\n\n```tsx\nfunction multiply(n: number, ...m: number[]) {\n  return m.map((x) => n * x);\n}\n// 'a' 获得的值 [10, 20, 30, 40]\nconst a = multiply(10, 1, 2, 3, 4);\n```\n\n在TypeScript中，这些参数的类型注解是隐含的 `any[]`，而不是`any`，任何给出的类型注解必须是`Array<T>`或`T[]`的形式，或一个元组类型（我们将在后面学习）。\n\n### 5.8.2 实参展开(Rest Arguments)\n\n反之，我们可以使用 `spread` 语法从数组中提供可变数量的参数。例如，数组的 `push` 方法需要任意数量的参数。\n\n```tsx\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\narr1.push(...arr2);\n```\n\n请注意，一般来说，TypeScript并不假定数组是不可变的。这可能会导致一些令人惊讶的行为。\n\n```tsx\n// 推断的类型是 number[] -- \"一个有零或多个数字的数组\"。\n// 不专指两个数字\nconst args = [8, 5];\nconst angle = Math.atan2(...args);\n```\n\n<img src=\"/img/TypeScript/05-06.png\" alt=\"image-20211122191044837\" style=\"zoom: 50%;\" />\n\n这种情况的最佳解决方案取决于你的代码，但一般来说，`const context` 是最直接的解决方案。\n\n```tsx\n// 推断为2个长度的元组\nconst args = [8, 5] as const;\n// 正确\nconst angle = Math.atan2(...args);\n```\n\n## 5.9 参数解构\n\n你可以使用参数重构来方便地将作为参数提供的对象，解压到函数主体的一个或多个局部变量中。在JavaScript中，它看起来像这样：\n\n```tsx\nfunction sum({ a, b, c }) {\n  console.log(a + b + c);\n}\nsum({ a: 10, b: 3, c: 9 });\n```\n\n对象的类型注解在解构的语法之后：\n\n```tsx\nfunction sum({ a, b, c }: { a: number; b: number; c: number }) {\n  console.log(a + b + c);\n}\n```\n\n这看起来有点啰嗦，但你也可以在这里使用一个命名的类型：\n\n```tsx\n// 与之前的例子相同\ntype ABC = { a: number; b: number; c: number };\nfunction sum({ a, b, c }: ABC) {\n  console.log(a + b + c);\n}\n```\n\n## 5.10 函数的可分配性\n\n### 5.10.1 返回 `void` 类型\n\n函数的 `void` 返回类型可以产生一些不寻常的，但却是预期的行为。\n\n返回类型为 `void` 的上下文类型并不强迫函数不返回东西。另一种说法是，一个具有 `void`返回类型的上下文函数类型（`type vf = () => void`），在实现时，可以返回任何其他的值，但它会被忽略。\n\n因此，以下`（）=> void`类型的实现是有效的：\n\n```tsx\ntype voidFunc = () => void;\n\nconst f1: voidFunc = () => {\n  return true;\n};\n\nconst f2: voidFunc = () => true;\n\nconst f3: voidFunc = function () {\n  return true;\n};\n```\n\n而当这些函数之一的返回值被分配给另一个变量时，它将保留 `void` 的类型：\n\n```tsx\nconst v1 = f1();\nconst v2 = f2();\nconst v3 = f3();\n```\n\n这种行为的存在使得下面的代码是有效的，即使 `Array.prototype.push`返回一个数字，而`Array.prototype.forEach`方法期望一个返回类型为`void`的函数：\n\n```tsx\nconst src = [1, 2, 3];\nconst dst = [0];\n\nsrc.forEach((el) => dst.push(el));\n```\n\n还有一个需要注意的特殊情况，当一个字面的函数定义有一个 `void` 的返回类型时，该函数必须不返回任何东西。\n\n```tsx\nfunction f2(): void {\n  return true;\n}\n\nconst f3 = function (): void {\n  return true;\n};\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/t7q4nWcpJxZz12D.png\" alt=\"image-20211122220703542\" style=\"zoom:50%;\" />\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-5、基础篇：函数更多",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao3000q94v31nwr0uli",
        "content": "<h1 id=\"五、函数更多\"><a href=\"#五、函数更多\" class=\"headerlink\" title=\"五、函数更多\"></a>五、函数更多</h1><p>函数是任何应用程序的基本构件，无论它们是本地函数，从另一个模块导入，还是一个类上的方法。它们也是值，就像其他值一样，TypeScript有很多方法来描述如何调用函数。让我们来学习一下如何编写描述函数的类型。</p>\n<h2 id=\"5-1-函数类型表达式\"><a href=\"#5-1-函数类型表达式\" class=\"headerlink\" title=\"5.1 函数类型表达式\"></a>5.1 函数类型表达式</h2><p>描述一个函数的最简单方法是用一个函数类型表达式。这些类型在语法上类似于箭头函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greeter</span>(<span class=\"params\"><span class=\"attr\">fn</span>: (a: <span class=\"built_in\">string</span>) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">fn</span>(<span class=\"string\">&quot;Hello, World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printToConsole</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greeter</span>(printToConsole);</span><br></pre></td></tr></table></figure>\n\n<p>语法<code>(a: string) =&gt; void</code>意味着 “有一个参数的函数，名为 <code>a</code>，类型为字符串，没有返回值”。就像函数声明一样，如果没有指定参数类型，它就隐含为 <code>any</code> 类型。</p>\n<p>当然，我们可以用一个类型别名来命名一个函数类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">GreetFunction</span> = <span class=\"function\">(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greeter</span>(<span class=\"params\"><span class=\"attr\">fn</span>: <span class=\"title class_\">GreetFunction</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-调用签名\"><a href=\"#5-2-调用签名\" class=\"headerlink\" title=\"5.2 调用签名\"></a>5.2 调用签名</h2><p>在JavaScript中，除了可调用之外，函数还可以有属性。然而，函数类型表达式的语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以在一个对象类型中写一个<em>调用签名</em>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DescribableFunction</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  (<span class=\"attr\">someArg</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">fn</span>: <span class=\"title class_\">DescribableFunction</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fn.<span class=\"property\">description</span> + <span class=\"string\">&quot; returned &quot;</span> + <span class=\"title function_\">fn</span>(<span class=\"number\">6</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn1.<span class=\"property\">description</span> = <span class=\"string\">&quot;balabala...&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">doSomething</span>(fn1);</span><br></pre></td></tr></table></figure>\n\n<p>注意，与函数类型表达式相比，语法略有不同：在参数列表和返回类型之间使用<code>:</code>而不是<code>=&gt;</code>。</p>\n<h2 id=\"5-3-构造签名\"><a href=\"#5-3-构造签名\" class=\"headerlink\" title=\"5.3 构造签名\"></a>5.3 构造签名</h2><p>JavaScript函数也可以用 <code>new</code> 操作符来调用。TypeScript将这些称为构造函数，因为它们通常会创建一个新的对象。你可以通过在调用签名前面添加 <code>new</code> 关键字来写一个构造签名。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ctor</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">s</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">s</span> = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">SomeConstructor</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">new</span> (<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Ctor</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">ctor</span>: <span class=\"title class_\">SomeConstructor</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">ctor</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"title function_\">fn</span>(<span class=\"title class_\">Ctor</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(f.<span class=\"property\">s</span>);</span><br></pre></td></tr></table></figure>\n\n<p>有些对象，如 JavaScript 的 <code>Date</code> 对象，可以在有 <code>new</code> 或没有 <code>new</code> 的情况下被调用。你可以在同一类型中任意地结合调用和构造签名。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">CallOrConstruct</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">new</span> (<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Date</span>;</span><br><span class=\"line\">  (<span class=\"attr\">n</span>?: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">date</span>: <span class=\"title class_\">CallOrConstruct</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> <span class=\"title function_\">date</span>(<span class=\"string\">&quot;2021-11-20&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"title function_\">date</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再举一个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ClockConstructor</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">new</span> (<span class=\"attr\">hour</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">minute</span>: <span class=\"built_in\">number</span>): <span class=\"title class_\">ClockInterface</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ClockInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">tick</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createClock</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">ctor</span>: <span class=\"title class_\">ClockConstructor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">hour</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">minute</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">ClockInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">ctor</span>(hour, minute);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DigitalClock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ClockInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">h</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">m</span>: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">  <span class=\"title function_\">tick</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;beep beep&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AnalogClock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ClockInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">h</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">m</span>: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">  <span class=\"title function_\">tick</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;tick tock&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = <span class=\"title function_\">createClock</span>(<span class=\"title class_\">DigitalClock</span>, <span class=\"number\">12</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = <span class=\"title function_\">createClock</span>(<span class=\"title class_\">AnalogClock</span>, <span class=\"number\">7</span>, <span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4-泛型函数\"><a href=\"#5-4-泛型函数\" class=\"headerlink\" title=\"5.4 泛型函数\"></a>5.4 泛型函数</h2><p>在写一个函数时，输入的类型与输出的类型有关，或者两个输入的类型以某种方式相关，这是常见的。让我们考虑一下一个返回数组中第一个元素的函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">firstElement</span>(<span class=\"params\"><span class=\"attr\">arr</span>: <span class=\"built_in\">any</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数完成了它的工作，但不幸的是它的返回类型是 <code>any</code>。如果该函数返回数组元素的类型会更好。</p>\n<p>在TypeScript中，当我们想描述两个值之间的对应关系时，会使用泛型。我们通过在函数签名中声明一个类型参数来做到这一点：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> firstElement&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>[]): <span class=\"title class_\">Type</span> | <span class=\"literal\">undefined</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过给这个函数添加一个类型参数 <code>Type</code>，并在两个地方使用它，我们已经在函数的输入（数组）和输出（返回值）之间建立了一个联系。现在当我们调用它时，一个更具体的类型就出来了：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// s 是 &#x27;string&#x27; 类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"title function_\">firstElement</span>([<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>]);</span><br><span class=\"line\"><span class=\"comment\">// n 是 &#x27;number&#x27; 类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> n = <span class=\"title function_\">firstElement</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"comment\">// u 是 undefined 类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> u = <span class=\"title function_\">firstElement</span>([]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-1-类型推断\"><a href=\"#5-4-1-类型推断\" class=\"headerlink\" title=\"5.4.1 类型推断\"></a>5.4.1 类型推断</h3><p>请注意，在这个例子中，我们没有必要指定类型。类型是由TypeScript推断出来的–自动选择。</p>\n<p>我们也可以使用多个类型参数。例如，一个独立版本的map看起来是这样的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> map&lt;<span class=\"title class_\">Input</span>, <span class=\"title class_\">Output</span>&gt;(</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: <span class=\"title class_\">Input</span>[],</span><br><span class=\"line\">  <span class=\"attr\">func</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"title class_\">Input</span></span>) =&gt;</span> <span class=\"title class_\">Output</span>,</span><br><span class=\"line\">): <span class=\"title class_\">Output</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.<span class=\"title function_\">map</span>(func);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数&#x27;n&#x27;是&#x27;字符串&#x27;类型。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;parsed&#x27;是&#x27;number[]&#x27;类型。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> parsed = <span class=\"title function_\">map</span>([<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;3&quot;</span>], <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> <span class=\"built_in\">parseInt</span>(n));</span><br></pre></td></tr></table></figure>\n\n<p>请注意，在这个例子中，TypeScript可以推断出输入类型参数的类型（从给定的字符串数组），以及基于函数表达式的返回值（数字）的输出类型参数。</p>\n<h3 id=\"5-4-2-限制条件\"><a href=\"#5-4-2-限制条件\" class=\"headerlink\" title=\"5.4.2 限制条件\"></a>5.4.2 限制条件</h3><p>我们已经写了一些通用函数，可以对任何类型的值进行操作。有时我们想把两个值联系起来，但只能对某个值的子集进行操作。在这种情况下，我们可以使用一个约束条件来限制一个类型参数可以接受的类型。</p>\n<p>让我们写一个函数，返回两个值中较长的值。要做到这一点，我们需要一个长度属性，是一个数字。我们通过写一个扩展子句将类型参数限制在这个类型上。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> longest&lt;<span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">length</span>: <span class=\"built_in\">number</span> &#125;&gt;(<span class=\"attr\">a</span>: <span class=\"title class_\">Type</span>, <span class=\"attr\">b</span>: <span class=\"title class_\">Type</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.<span class=\"property\">length</span> &gt;= b.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// longerArray 的类型是 &#x27;number[]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> longerArray = <span class=\"title function_\">longest</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"comment\">// longerString 是 &#x27;alice&#x27;|&#x27;bob&#x27; 的类型。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> longerString = <span class=\"title function_\">longest</span>(<span class=\"string\">&quot;alice&quot;</span>, <span class=\"string\">&quot;bob&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 错误! 数字没有&#x27;长度&#x27;属性</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> notOK = <span class=\"title function_\">longest</span>(<span class=\"number\">10</span>, <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/WjBVzACtyJ87q1H.png\" alt=\"image-20211121103833933\" style=\"zoom:50%;\" />\n\n<p>在这个例子中，有一些有趣的事情需要注意。我们允许TypeScript推断 <code>longest</code> 的返回类型。返回类型推断也适用于通用函数。</p>\n<p>因为我们将 Type 约束为<code> &#123; length: number &#125;</code>，所以我们被允许访问 <code>a</code> 和 <code>b</code> 参数的 <code>.length</code> 属性。如果没有类型约束，我们就不能访问这些属性，因为这些值可能是一些没有长度属性的其他类型。</p>\n<p><code>longerArray</code> 和 <code>longerString</code> 的类型是根据参数推断出来的。记住，泛型就是把两个或多个具有相同类型的值联系起来。</p>\n<p>最后，正如我们所希望的，对 <code>longest(10, 100)</code> 的调用被拒绝了，因为数字类型没有一个<code>.length</code>属性。</p>\n<h3 id=\"5-4-3-使用受限值\"><a href=\"#5-4-3-使用受限值\" class=\"headerlink\" title=\"5.4.3 使用受限值\"></a>5.4.3 使用受限值</h3><p>这里有一个使用通用约束条件时的常见错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> minimumLength&lt;<span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">length</span>: <span class=\"built_in\">number</span> &#125;&gt;(</span><br><span class=\"line\">  <span class=\"attr\">obj</span>: <span class=\"title class_\">Type</span>,</span><br><span class=\"line\">  <span class=\"attr\">minimum</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.<span class=\"property\">length</span> &gt;= minimum) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">length</span>: minimum &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/04-12.png\" alt=\"image-20211121104538424\" style=\"zoom:40%;\" />\n\n<p>看起来这个函数没有问题–Type被限制为{ length: number }，而且这个函数要么返回Type，要么返回一个与该限制相匹配的值。问题是，该函数承诺返回与传入的对象相同的类型，而不仅仅是与约束条件相匹配的一些对象。如果这段代码是合法的，你可以写出肯定无法工作的代码。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#x27;arr&#x27; 获得值： &#123; length: 6 &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"title function_\">minimumLength</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">//在此崩溃，因为数组有一个&#x27;切片&#x27;方法，但没有返回对象!</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n\n<p>![image-20211121105340359](Users&#x2F;felix&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211121105340359.png)</p>\n<h3 id=\"5-4-4-指定类型参数\"><a href=\"#5-4-4-指定类型参数\" class=\"headerlink\" title=\"5.4.4 指定类型参数\"></a>5.4.4 指定类型参数</h3><p>TypeScript 通常可以推断出通用调用中的预期类型参数，但并非总是如此。例如，假设你写了一个函数来合并两个数组：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> combine&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arr1</span>: <span class=\"title class_\">Type</span>[], <span class=\"attr\">arr2</span>: <span class=\"title class_\">Type</span>[]): <span class=\"title class_\">Type</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr1.<span class=\"title function_\">concat</span>(arr2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常情况下，用不匹配的数组调用这个函数是一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"title function_\">combine</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"string\">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/a7IfnzN9h3mAHKk.png\" alt=\"image-20211121110056686\" style=\"zoom:40%;\" />\n\n<p>然而，如果你打算这样做，你可以手动指定类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = combine&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"string\">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-5-编写优秀通用函数的准则\"><a href=\"#5-4-5-编写优秀通用函数的准则\" class=\"headerlink\" title=\"5.4.5 编写优秀通用函数的准则\"></a>5.4.5 编写优秀通用函数的准则</h3><p>编写泛型函数很有趣，而且很容易被类型参数所迷惑。有太多的类型参数或在不需要的地方使用约束，会使推理不那么成功，使你的函数的调用者感到沮丧。</p>\n<ul>\n<li><strong>类型参数下推</strong></li>\n</ul>\n<p>下面是两种看似相似的函数写法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> firstElement1&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>[]) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> firstElement2&lt;<span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[]&gt;(<span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a: number (推荐)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"title function_\">firstElement1</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"comment\">// b: any (不推荐)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"title function_\">firstElement2</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>乍一看，这些可能是相同的，但 <code>firstElement1</code> 是写这个函数的一个更好的方法。它的推断返回类型是Type，但 <code>firstElement2</code> 的推断返回类型是 <code>any</code>，因为TypeScript必须使用约束类型来解析<code>arr[0]</code>表达式，而不是在调用期间 “等待 “解析该元素。</p>\n<blockquote>\n<p><strong>规则：</strong>在可能的情况下，使用类型参数本身，而不是对其进行约束</p>\n</blockquote>\n<ul>\n<li><strong>使用更少的类型参数</strong></li>\n</ul>\n<p>下面是另一对类似的函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> filter1&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>[], <span class=\"attr\">func</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>): <span class=\"title class_\">Type</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.<span class=\"title function_\">filter</span>(func);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> filter2&lt;<span class=\"title class_\">Type</span>, <span class=\"title class_\">Func</span> <span class=\"title function_\">extends</span> (<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>) =&gt; <span class=\"built_in\">boolean</span>&gt;(</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>[],</span><br><span class=\"line\">  <span class=\"attr\">func</span>: <span class=\"title class_\">Func</span>,</span><br><span class=\"line\">): <span class=\"title class_\">Type</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.<span class=\"title function_\">filter</span>(func);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们已经创建了一个类型参数 <code>Func</code>，它并不涉及两个值。这总是一个值得标记的坏习惯，因为它意味着想要指定类型参数的调用者必须无缘无故地手动指定一个额外的类型参数。<code>Func</code>除了使函数更难阅读和推理外，什么也没做。</p>\n<blockquote>\n<p><strong>规则：</strong>总是尽可能少地使用类型参数</p>\n</blockquote>\n<ul>\n<li><strong>类型参数应出现两次</strong></li>\n</ul>\n<p>有时我们会忘记，一个函数可能不需要是通用的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> greet&lt;<span class=\"title class_\">Str</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt;(<span class=\"attr\">s</span>: <span class=\"title class_\">Str</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们完全可以写一个更简单的版本：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>记住，类型参数是用来关联多个值的类型的。如果一个类型参数在函数签名中只使用一次，那么它就没有任何关系。</p>\n<blockquote>\n<p><strong>规则：</strong>如果一个类型的参数只出现在一个地方，请重新考虑你是否真的需要它</p>\n</blockquote>\n<h2 id=\"5-5-可选参数\"><a href=\"#5-5-可选参数\" class=\"headerlink\" title=\"5.5 可选参数\"></a>5.5 可选参数</h2><p>JavaScript中的函数经常需要一个可变数量的参数。例如，<code>number</code> 的 <code>toFixed</code>方法需要一个可选的数字计数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">n</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n.<span class=\"title function_\">toFixed</span>()); <span class=\"comment\">// 0 个参数</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n.<span class=\"title function_\">toFixed</span>(<span class=\"number\">3</span>)); <span class=\"comment\">// 1 个参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以在TypeScript中通过将参数用 <code>?</code>标记：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">x</span>?: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(); <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然参数被指定为 <code>number</code> 类型，但 <code>x</code> 参数实际上将具有 <code>number | undefined</code> 类型，因为在JavaScript中未指定的参数会得到 <code>undefined</code> 的值。</p>\n<p>你也可以提供一个参数默认值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">x = <span class=\"number\">10</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在在 <code>f</code> 的主体中，<code>x</code> 将具有 <code>number</code> 类型，因为任何 <code>undefined</code> 的参数将被替换为 <code>10</code>。请注意，当一个参数是可选的，调用者总是可以传递未定义的参数，因为这只是模拟一个 “丢失 “的参数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">x</span>?: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下调用都是正确的</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();</span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">undefined</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-5-1-回调中的可选参数\"><a href=\"#5-5-1-回调中的可选参数\" class=\"headerlink\" title=\"5.5.1 回调中的可选参数\"></a>5.5.1 回调中的可选参数</h3><p>一旦你了解了可选参数和函数类型表达式，在编写调用回调的函数时就很容易犯以下错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myForEach</span>(<span class=\"params\"><span class=\"attr\">arr</span>: <span class=\"built_in\">any</span>[], <span class=\"attr\">callback</span>: (arg: <span class=\"built_in\">any</span>, index?: <span class=\"built_in\">number</span>) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">callback</span>(arr[i], i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在写 <code>index?</code> 作为一个可选参数时，通常是想让这些调用都是合法的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">myForEach</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a));</span><br><span class=\"line\"><span class=\"title function_\">myForEach</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\">(<span class=\"params\">a, i</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, i));</span><br></pre></td></tr></table></figure>\n\n<p>这实际上意味着回调可能会被调用，只有一个参数。换句话说，该函数定义说，实现可能是这样的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myForEach</span>(<span class=\"params\"><span class=\"attr\">arr</span>: <span class=\"built_in\">any</span>[], <span class=\"attr\">callback</span>: (arg: <span class=\"built_in\">any</span>, index?: <span class=\"built_in\">number</span>) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 我现在不想提供索引</span></span><br><span class=\"line\">    <span class=\"title function_\">callback</span>(arr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反过来，TypeScript会强制执行这个意思，并发出实际上不可能的错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">myForEach</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\">(<span class=\"params\">a, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i.<span class=\"title function_\">toFixed</span>());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/04-14.png\" alt=\"image-20211121151911039\" style=\"zoom:40%;\" />\n\n<p>在JavaScript中，如果你调用一个形参多于实参的函数，额外的参数会被简单地忽略。TypeScript的行为也是如此。参数较少的函数（相同的类型）总是可以取代参数较多的函数的位置。</p>\n<blockquote>\n<p>当为回调写一个函数类型时，永远不要写一个可选参数，除非你打算在不传递该参数的情况下调用函数。</p>\n</blockquote>\n<h2 id=\"5-6-函数重载\"><a href=\"#5-6-函数重载\" class=\"headerlink\" title=\"5.6 函数重载\"></a>5.6 函数重载</h2><p>一些 JavaScript 函数可以在不同的参数数量和类型中被调用。例如，你可能会写一个函数来产生一个Date，它需要一个时间戳（一个参数）或一个月&#x2F;日&#x2F;年规格（三个参数）。</p>\n<p>在TypeScript中，我们可以通过编写重载签名来指定一个可以以不同方式调用的函数。要做到这一点，要写一些数量的函数签名（通常是两个或更多），然后是函数的主体：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeDate</span>(<span class=\"params\"><span class=\"attr\">timestamp</span>: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Date</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeDate</span>(<span class=\"params\"><span class=\"attr\">m</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">d</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Date</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeDate</span>(<span class=\"params\"><span class=\"attr\">mOrTimestamp</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">d</span>?: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>?: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (d !== <span class=\"literal\">undefined</span> &amp;&amp; y !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(y, mOrTimestamp, d);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(mOrTimestamp);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> d1 = <span class=\"title function_\">makeDate</span>(<span class=\"number\">12345678</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> d2 = <span class=\"title function_\">makeDate</span>(<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> d3 = <span class=\"title function_\">makeDate</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/04-15.png\" alt=\"image-20211121153802236\" style=\"zoom:42%;\" />\n\n<p>在这个例子中，我们写了两个重载：一个接受一个参数，另一个接受三个参数。这前两个签名被称为重载签名。</p>\n<p>然后，我们写了一个具有兼容签名的函数实现。函数有一个实现签名，但这个签名不能被直接调用。即使我们写了一个在所需参数之后有两个可选参数的函数，它也不能以两个参数被调用！</p>\n<h3 id=\"5-6-1-重载签名和实现签名\"><a href=\"#5-6-1-重载签名和实现签名\" class=\"headerlink\" title=\"5.6.1 重载签名和实现签名\"></a>5.6.1 重载签名和实现签名</h3><p>这是一个常见的混乱来源。通常我们会写这样的代码，却不明白为什么会出现错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 期望能够以零参数调用</span></span><br><span class=\"line\"><span class=\"title function_\">fn</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/2PbtdUgEz5Ts3Dr.png\" alt=\"image-20211121154720160\" style=\"zoom:50%;\" />\n\n<p>同样，用于编写函数体的签名不能从外面 “看到”。</p>\n<blockquote>\n<p>实现的签名从外面是看不到的。在编写重载函数时，你应该总是在函数的实现上面有两个或多个签名。</p>\n</blockquote>\n<p>实现签名也必须与重载签名兼容。例如，这些函数有错误，因为实现签名没有以正确的方式匹配重载：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">boolean</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"comment\">// 参数类型不正确</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">boolean</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/saCfOyHuShpilg3.png\" alt=\"image-20211121160302934\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回类型不正确</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;oops&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/4OAqJInZEdRftuv.png\" alt=\"image-20211121160413329\" style=\"zoom: 50%;\" />\n\n<h3 id=\"5-6-2-编写好的重载\"><a href=\"#5-6-2-编写好的重载\" class=\"headerlink\" title=\"5.6.2 编写好的重载\"></a>5.6.2 编写好的重载</h3><p>和泛型一样，在使用函数重载时，有一些准则是你应该遵循的。遵循这些原则将使你的函数更容易调用，更容易理解，更容易实现。</p>\n<p>让我们考虑一个返回字符串或数组长度的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">len</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">len</span>(<span class=\"params\"><span class=\"attr\">arr</span>: <span class=\"built_in\">any</span>[]</span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">len</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"property\">length</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数是好的；我们可以用字符串或数组来调用它。然而，我们不能用一个可能是字符串或数组的值来调用它，因为TypeScript只能将一个函数调用解析为一个重载：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">len</span>(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"title function_\">len</span>([<span class=\"number\">0</span>]); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"title function_\">len</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &gt; <span class=\"number\">0.5</span> ? <span class=\"string\">&quot;hello&quot;</span> : [<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/6NRbiq5Dp3ulKhg.png\" alt=\"image-20211121161500523\" style=\"zoom:50%;\" />\n\n<p>因为两个重载都有相同的参数数量和相同的返回类型，我们可以改写一个非重载版本的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">len</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">any</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"property\">length</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">len</span>(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"title function_\">len</span>([<span class=\"number\">0</span>]); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"title function_\">len</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &gt; <span class=\"number\">0.5</span> ? <span class=\"string\">&quot;hello&quot;</span> : [<span class=\"number\">0</span>]); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<p>这就好得多了! 调用者可以用任何一种值来调用它，而且作为额外的奖励，我们不需要找出一个正确的实现签名。</p>\n<blockquote>\n<p>在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数</p>\n</blockquote>\n<h3 id=\"5-6-3-函数内This的声明\"><a href=\"#5-6-3-函数内This的声明\" class=\"headerlink\" title=\"5.6.3 函数内This的声明\"></a>5.6.3 函数内<code>This</code>的声明</h3><p>TypeScript会通过代码流分析来推断函数中的 <code>this</code> 应该是什么，比如下面的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">admin</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">becomeAdmin</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">admin</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript理解函数 <code>user.becomeAdmin</code> 有一个对应的 <code>this</code>，它是外部对象 <code>user</code>。这个对于很多情况来说已经足够了，但是有很多情况下你需要更多的控制 <code>this</code> 代表什么对象。JavaScript规范规定，你不能有一个叫 <code>this</code>的参数，所以TypeScript使用这个语法空间，让你在函数体中声明<code>this</code>的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">admin</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> DB &#123;</span><br><span class=\"line\">  <span class=\"title function_\">filterUsers</span>(<span class=\"attr\">filter</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">User</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>): <span class=\"title class_\">User</span>[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">db</span>: <span class=\"variable constant_\">DB</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">filterUsers</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">filter</span>: (<span class=\"variable language_\">this</span>: User) =&gt; <span class=\"built_in\">boolean</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user1 = &#123;</span><br><span class=\"line\">      <span class=\"attr\">admin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user2 = &#123;</span><br><span class=\"line\">      <span class=\"attr\">admin</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [user1, user2];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> admins = db.<span class=\"title function_\">filterUsers</span>(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">User</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">admin</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这种模式在回调式API中很常见，另一个对象通常控制你的函数何时被调用。注意，你需要使用函数而不是箭头函数来获得这种行为。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">admin</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> DB &#123;</span><br><span class=\"line\">  <span class=\"title function_\">filterUsers</span>(<span class=\"attr\">filter</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">User</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>): <span class=\"title class_\">User</span>[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">db</span>: <span class=\"variable constant_\">DB</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">filterUsers</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">filter</span>: (<span class=\"variable language_\">this</span>: User) =&gt; <span class=\"built_in\">boolean</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user1 = &#123;</span><br><span class=\"line\">      <span class=\"attr\">admin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user2 = &#123;</span><br><span class=\"line\">      <span class=\"attr\">admin</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [user1, user2];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 不能为箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> admins = db.<span class=\"title function_\">filterUsers</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">admin</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/vYImhS8FQOHgJfT.png\" alt=\"image-20211121164923229\" style=\"zoom:40%;\" />\n\n<h2 id=\"5-7-需要了解的其他类型\"><a href=\"#5-7-需要了解的其他类型\" class=\"headerlink\" title=\"5.7 需要了解的其他类型\"></a>5.7 需要了解的其他类型</h2><p>有一些额外的类型你会想要认识，它们在处理函数类型时经常出现。像所有的类型一样，你可以在任何地方使用它们，但这些类型在函数的上下文中特别相关。</p>\n<h3 id=\"5-7-1-void\"><a href=\"#5-7-1-void\" class=\"headerlink\" title=\"5.7.1 void\"></a>5.7.1 <code>void</code></h3><p><code>void</code>表示没有返回值的函数的返回值。当一个函数没有任何返回语句，或者没有从这些返回语句中返回任何明确的值时，它都是推断出来的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推断出的返回类型是void</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">noop</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在JavaScript中，一个不返回任何值的函数将隐含地返回<code>undefinded</code>的值。然而，在TypeScript中，<code>void</code>和<code>undefined</code>是不一样的。在本章末尾有进一步的细节。</p>\n<blockquote>\n<p><code>void</code>与<code>undefined</code>不一样。</p>\n</blockquote>\n<h3 id=\"5-7-2-object\"><a href=\"#5-7-2-object\" class=\"headerlink\" title=\"5.7.2 object\"></a>5.7.2 <code>object</code></h3><p>特殊类型 <code>object</code> 指的是任何不是基元的值（<code>string</code>、<code>number</code>、<code>bigint</code>、<code>boolean</code>、<code>symbol</code>、<code>null </code>或 <code>undefined</code>）。这与空对象类型<code>&#123; &#125;</code>不同，也与全局类型 <code>Object</code> 不同。你很可能永远不会使用 <code>Object</code>。</p>\n<blockquote>\n<p><code>object</code>不是<code>Object</code>。始终使用<code>object</code>!</p>\n</blockquote>\n<p>请注意，在JavaScript中，函数值是对象。它们有属性，在它们的原型链中有<code>Object.prototype</code>，是 <code>Object</code>的实例，你可以对它们调用 <code>Object.key</code>，等等。由于这个原因，函数类型在TypeScript中被认为是<code>object</code>。</p>\n<h3 id=\"5-7-3-unknown\"><a href=\"#5-7-3-unknown\" class=\"headerlink\" title=\"5.7.3 unknown\"></a>5.7.3 <code>unknown</code></h3><p><code>unknown</code>类型代表任何值。这与 <code>any</code> 类型类似，但更安全，因为对未知 <code>unknown</code> 值做任何事情都是不合法的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">  a.<span class=\"title function_\">b</span>(); <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">unknown</span></span>) &#123;</span><br><span class=\"line\">  a.<span class=\"title function_\">b</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/pl7s6ZDr8QKAJgh.png\" alt=\"image-20211121172520948\" style=\"zoom:50%;\" />\n\n<p>这在描述函数类型时很有用，因为你可以描述接受任何值的函数，而不需要在函数体中有 <code>any</code> 值。</p>\n<p>反之，你可以描述一个返回未知类型的值的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">safeParse</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">unknown</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要小心对待&#x27;obj&#x27;!</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"title function_\">safeParse</span>(someRandomString);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-7-4-never\"><a href=\"#5-7-4-never\" class=\"headerlink\" title=\"5.7.4 never\"></a>5.7.4 <code>never</code></h3><p>有些函数永远不会返回一个值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fail</span>(<span class=\"params\"><span class=\"attr\">msg</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">never</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>never</code>类型表示永远不会被观察到的值。在一个返回类型中，这意味着函数抛出一个异常或终止程序的执行。</p>\n<p><code>never</code>也出现在TypeScript确定一个 <code>union</code> 中没有任何东西的时候。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做一些事</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 再做一些事</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    x; <span class=\"comment\">// &#x27;never&#x27;!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-7-5-Function\"><a href=\"#5-7-5-Function\" class=\"headerlink\" title=\"5.7.5 Function\"></a>5.7.5 <code>Function</code></h3><p>全局性的 <code>Function</code> 类型描述了诸如 <code>bind</code>、<code>call</code>、<code>apply</code>和其他存在于JavaScript中所有函数值的属性。它还有一个特殊的属性，即 <code>Function</code> 类型的值总是可以被调用；这些调用返回 <code>any</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">f</span>: <span class=\"title class_\">Function</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">f</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个无类型的函数调用，一般来说最好避免，因为 <code>any</code> 返回类型都不安全。</p>\n<p>如果你需要接受一个任意的函数，但不打算调用它，一般来说，<code>() =&gt; void</code>的类型比较安全。</p>\n<h2 id=\"5-8-参数展开运算符\"><a href=\"#5-8-参数展开运算符\" class=\"headerlink\" title=\"5.8 参数展开运算符\"></a>5.8 参数展开运算符</h2><h3 id=\"5-8-1-形参展开-Rest-Parameters\"><a href=\"#5-8-1-形参展开-Rest-Parameters\" class=\"headerlink\" title=\"5.8.1 形参展开(Rest Parameters)\"></a>5.8.1 形参展开(Rest Parameters)</h3><p>除了使用可选参数或重载来制作可以接受各种固定参数数量的函数之外，我们还可以使用休止参数来定义接受无限制数量的参数的函数。</p>\n<p><code>rest</code>参数出现在所有其他参数之后，并使用<code>...</code>的语法：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiply</span>(<span class=\"params\"><span class=\"attr\">n</span>: <span class=\"built_in\">number</span>, ...<span class=\"attr\">m</span>: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> n * x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#x27;a&#x27; 获得的值 [10, 20, 30, 40]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"title function_\">multiply</span>(<span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在TypeScript中，这些参数的类型注解是隐含的 <code>any[]</code>，而不是<code>any</code>，任何给出的类型注解必须是<code>Array&lt;T&gt;</code>或<code>T[]</code>的形式，或一个元组类型（我们将在后面学习）。</p>\n<h3 id=\"5-8-2-实参展开-Rest-Arguments\"><a href=\"#5-8-2-实参展开-Rest-Arguments\" class=\"headerlink\" title=\"5.8.2 实参展开(Rest Arguments)\"></a>5.8.2 实参展开(Rest Arguments)</h3><p>反之，我们可以使用 <code>spread</code> 语法从数组中提供可变数量的参数。例如，数组的 <code>push</code> 方法需要任意数量的参数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">arr1.<span class=\"title function_\">push</span>(...arr2);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，一般来说，TypeScript并不假定数组是不可变的。这可能会导致一些令人惊讶的行为。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推断的类型是 number[] -- &quot;一个有零或多个数字的数组&quot;。</span></span><br><span class=\"line\"><span class=\"comment\">// 不专指两个数字</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> args = [<span class=\"number\">8</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> angle = <span class=\"title class_\">Math</span>.<span class=\"title function_\">atan2</span>(...args);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/05-06.png\" alt=\"image-20211122191044837\" style=\"zoom: 50%;\" />\n\n<p>这种情况的最佳解决方案取决于你的代码，但一般来说，<code>const context</code> 是最直接的解决方案。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推断为2个长度的元组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> args = [<span class=\"number\">8</span>, <span class=\"number\">5</span>] <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> angle = <span class=\"title class_\">Math</span>.<span class=\"title function_\">atan2</span>(...args);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-9-参数解构\"><a href=\"#5-9-参数解构\" class=\"headerlink\" title=\"5.9 参数解构\"></a>5.9 参数解构</h2><p>你可以使用参数重构来方便地将作为参数提供的对象，解压到函数主体的一个或多个局部变量中。在JavaScript中，它看起来像这样：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sum</span>(<span class=\"params\">&#123; a, b, c &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a + b + c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">sum</span>(&#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span>, <span class=\"attr\">c</span>: <span class=\"number\">9</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>对象的类型注解在解构的语法之后：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sum</span>(<span class=\"params\">&#123; a, b, c &#125;: &#123; a: <span class=\"built_in\">number</span>; b: <span class=\"built_in\">number</span>; c: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a + b + c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这看起来有点啰嗦，但你也可以在这里使用一个命名的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 与之前的例子相同</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">ABC</span> = &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">c</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sum</span>(<span class=\"params\">&#123; a, b, c &#125;: ABC</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a + b + c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-10-函数的可分配性\"><a href=\"#5-10-函数的可分配性\" class=\"headerlink\" title=\"5.10 函数的可分配性\"></a>5.10 函数的可分配性</h2><h3 id=\"5-10-1-返回-void-类型\"><a href=\"#5-10-1-返回-void-类型\" class=\"headerlink\" title=\"5.10.1 返回 void 类型\"></a>5.10.1 返回 <code>void</code> 类型</h3><p>函数的 <code>void</code> 返回类型可以产生一些不寻常的，但却是预期的行为。</p>\n<p>返回类型为 <code>void</code> 的上下文类型并不强迫函数不返回东西。另一种说法是，一个具有 <code>void</code>返回类型的上下文函数类型（<code>type vf = () =&gt; void</code>），在实现时，可以返回任何其他的值，但它会被忽略。</p>\n<p>因此，以下<code>（）=&gt; void</code>类型的实现是有效的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> voidFunc = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">f1</span>: voidFunc = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">f2</span>: voidFunc = <span class=\"function\">() =&gt;</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">f3</span>: voidFunc = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>而当这些函数之一的返回值被分配给另一个变量时，它将保留 <code>void</code> 的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> v1 = <span class=\"title function_\">f1</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> v2 = <span class=\"title function_\">f2</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> v3 = <span class=\"title function_\">f3</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这种行为的存在使得下面的代码是有效的，即使 <code>Array.prototype.push</code>返回一个数字，而<code>Array.prototype.forEach</code>方法期望一个返回类型为<code>void</code>的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> src = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> dst = [<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">src.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">el</span>) =&gt;</span> dst.<span class=\"title function_\">push</span>(el));</span><br></pre></td></tr></table></figure>\n\n<p>还有一个需要注意的特殊情况，当一个字面的函数定义有一个 <code>void</code> 的返回类型时，该函数必须不返回任何东西。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f3 = <span class=\"keyword\">function</span> (<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/t7q4nWcpJxZz12D.png\" alt=\"image-20211122220703542\" style=\"zoom:50%;\" />\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"五、函数更多\"><a href=\"#五、函数更多\" class=\"headerlink\" title=\"五、函数更多\"></a>五、函数更多</h1><p>函数是任何应用程序的基本构件，无论它们是本地函数，从另一个模块导入，还是一个类上的方法。它们也是值，就像其他值一样，TypeScript有很多方法来描述如何调用函数。让我们来学习一下如何编写描述函数的类型。</p>\n<h2 id=\"5-1-函数类型表达式\"><a href=\"#5-1-函数类型表达式\" class=\"headerlink\" title=\"5.1 函数类型表达式\"></a>5.1 函数类型表达式</h2><p>描述一个函数的最简单方法是用一个函数类型表达式。这些类型在语法上类似于箭头函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greeter</span>(<span class=\"params\"><span class=\"attr\">fn</span>: (a: <span class=\"built_in\">string</span>) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">fn</span>(<span class=\"string\">&quot;Hello, World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printToConsole</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greeter</span>(printToConsole);</span><br></pre></td></tr></table></figure>\n\n<p>语法<code>(a: string) =&gt; void</code>意味着 “有一个参数的函数，名为 <code>a</code>，类型为字符串，没有返回值”。就像函数声明一样，如果没有指定参数类型，它就隐含为 <code>any</code> 类型。</p>\n<p>当然，我们可以用一个类型别名来命名一个函数类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">GreetFunction</span> = <span class=\"function\">(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greeter</span>(<span class=\"params\"><span class=\"attr\">fn</span>: <span class=\"title class_\">GreetFunction</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-调用签名\"><a href=\"#5-2-调用签名\" class=\"headerlink\" title=\"5.2 调用签名\"></a>5.2 调用签名</h2><p>在JavaScript中，除了可调用之外，函数还可以有属性。然而，函数类型表达式的语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以在一个对象类型中写一个<em>调用签名</em>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DescribableFunction</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  (<span class=\"attr\">someArg</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">fn</span>: <span class=\"title class_\">DescribableFunction</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fn.<span class=\"property\">description</span> + <span class=\"string\">&quot; returned &quot;</span> + <span class=\"title function_\">fn</span>(<span class=\"number\">6</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn1.<span class=\"property\">description</span> = <span class=\"string\">&quot;balabala...&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">doSomething</span>(fn1);</span><br></pre></td></tr></table></figure>\n\n<p>注意，与函数类型表达式相比，语法略有不同：在参数列表和返回类型之间使用<code>:</code>而不是<code>=&gt;</code>。</p>\n<h2 id=\"5-3-构造签名\"><a href=\"#5-3-构造签名\" class=\"headerlink\" title=\"5.3 构造签名\"></a>5.3 构造签名</h2><p>JavaScript函数也可以用 <code>new</code> 操作符来调用。TypeScript将这些称为构造函数，因为它们通常会创建一个新的对象。你可以通过在调用签名前面添加 <code>new</code> 关键字来写一个构造签名。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ctor</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">s</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">s</span> = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">SomeConstructor</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">new</span> (<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Ctor</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">ctor</span>: <span class=\"title class_\">SomeConstructor</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">ctor</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"title function_\">fn</span>(<span class=\"title class_\">Ctor</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(f.<span class=\"property\">s</span>);</span><br></pre></td></tr></table></figure>\n\n<p>有些对象，如 JavaScript 的 <code>Date</code> 对象，可以在有 <code>new</code> 或没有 <code>new</code> 的情况下被调用。你可以在同一类型中任意地结合调用和构造签名。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">CallOrConstruct</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">new</span> (<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Date</span>;</span><br><span class=\"line\">  (<span class=\"attr\">n</span>?: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">date</span>: <span class=\"title class_\">CallOrConstruct</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> d = <span class=\"keyword\">new</span> <span class=\"title function_\">date</span>(<span class=\"string\">&quot;2021-11-20&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"title function_\">date</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再举一个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ClockConstructor</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">new</span> (<span class=\"attr\">hour</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">minute</span>: <span class=\"built_in\">number</span>): <span class=\"title class_\">ClockInterface</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ClockInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">tick</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createClock</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">ctor</span>: <span class=\"title class_\">ClockConstructor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">hour</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">minute</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">ClockInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">ctor</span>(hour, minute);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DigitalClock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ClockInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">h</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">m</span>: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">  <span class=\"title function_\">tick</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;beep beep&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AnalogClock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ClockInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">h</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">m</span>: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">  <span class=\"title function_\">tick</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;tick tock&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = <span class=\"title function_\">createClock</span>(<span class=\"title class_\">DigitalClock</span>, <span class=\"number\">12</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = <span class=\"title function_\">createClock</span>(<span class=\"title class_\">AnalogClock</span>, <span class=\"number\">7</span>, <span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4-泛型函数\"><a href=\"#5-4-泛型函数\" class=\"headerlink\" title=\"5.4 泛型函数\"></a>5.4 泛型函数</h2><p>在写一个函数时，输入的类型与输出的类型有关，或者两个输入的类型以某种方式相关，这是常见的。让我们考虑一下一个返回数组中第一个元素的函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">firstElement</span>(<span class=\"params\"><span class=\"attr\">arr</span>: <span class=\"built_in\">any</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数完成了它的工作，但不幸的是它的返回类型是 <code>any</code>。如果该函数返回数组元素的类型会更好。</p>\n<p>在TypeScript中，当我们想描述两个值之间的对应关系时，会使用泛型。我们通过在函数签名中声明一个类型参数来做到这一点：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> firstElement&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>[]): <span class=\"title class_\">Type</span> | <span class=\"literal\">undefined</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过给这个函数添加一个类型参数 <code>Type</code>，并在两个地方使用它，我们已经在函数的输入（数组）和输出（返回值）之间建立了一个联系。现在当我们调用它时，一个更具体的类型就出来了：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// s 是 &#x27;string&#x27; 类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"title function_\">firstElement</span>([<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>]);</span><br><span class=\"line\"><span class=\"comment\">// n 是 &#x27;number&#x27; 类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> n = <span class=\"title function_\">firstElement</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"comment\">// u 是 undefined 类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> u = <span class=\"title function_\">firstElement</span>([]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-1-类型推断\"><a href=\"#5-4-1-类型推断\" class=\"headerlink\" title=\"5.4.1 类型推断\"></a>5.4.1 类型推断</h3><p>请注意，在这个例子中，我们没有必要指定类型。类型是由TypeScript推断出来的–自动选择。</p>\n<p>我们也可以使用多个类型参数。例如，一个独立版本的map看起来是这样的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> map&lt;<span class=\"title class_\">Input</span>, <span class=\"title class_\">Output</span>&gt;(</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: <span class=\"title class_\">Input</span>[],</span><br><span class=\"line\">  <span class=\"attr\">func</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"title class_\">Input</span></span>) =&gt;</span> <span class=\"title class_\">Output</span>,</span><br><span class=\"line\">): <span class=\"title class_\">Output</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.<span class=\"title function_\">map</span>(func);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数&#x27;n&#x27;是&#x27;字符串&#x27;类型。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;parsed&#x27;是&#x27;number[]&#x27;类型。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> parsed = <span class=\"title function_\">map</span>([<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;3&quot;</span>], <span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> <span class=\"built_in\">parseInt</span>(n));</span><br></pre></td></tr></table></figure>\n\n<p>请注意，在这个例子中，TypeScript可以推断出输入类型参数的类型（从给定的字符串数组），以及基于函数表达式的返回值（数字）的输出类型参数。</p>\n<h3 id=\"5-4-2-限制条件\"><a href=\"#5-4-2-限制条件\" class=\"headerlink\" title=\"5.4.2 限制条件\"></a>5.4.2 限制条件</h3><p>我们已经写了一些通用函数，可以对任何类型的值进行操作。有时我们想把两个值联系起来，但只能对某个值的子集进行操作。在这种情况下，我们可以使用一个约束条件来限制一个类型参数可以接受的类型。</p>\n<p>让我们写一个函数，返回两个值中较长的值。要做到这一点，我们需要一个长度属性，是一个数字。我们通过写一个扩展子句将类型参数限制在这个类型上。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> longest&lt;<span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">length</span>: <span class=\"built_in\">number</span> &#125;&gt;(<span class=\"attr\">a</span>: <span class=\"title class_\">Type</span>, <span class=\"attr\">b</span>: <span class=\"title class_\">Type</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a.<span class=\"property\">length</span> &gt;= b.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// longerArray 的类型是 &#x27;number[]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> longerArray = <span class=\"title function_\">longest</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"comment\">// longerString 是 &#x27;alice&#x27;|&#x27;bob&#x27; 的类型。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> longerString = <span class=\"title function_\">longest</span>(<span class=\"string\">&quot;alice&quot;</span>, <span class=\"string\">&quot;bob&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 错误! 数字没有&#x27;长度&#x27;属性</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> notOK = <span class=\"title function_\">longest</span>(<span class=\"number\">10</span>, <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/WjBVzACtyJ87q1H.png\" alt=\"image-20211121103833933\" style=\"zoom:50%;\" />\n\n<p>在这个例子中，有一些有趣的事情需要注意。我们允许TypeScript推断 <code>longest</code> 的返回类型。返回类型推断也适用于通用函数。</p>\n<p>因为我们将 Type 约束为<code> &#123; length: number &#125;</code>，所以我们被允许访问 <code>a</code> 和 <code>b</code> 参数的 <code>.length</code> 属性。如果没有类型约束，我们就不能访问这些属性，因为这些值可能是一些没有长度属性的其他类型。</p>\n<p><code>longerArray</code> 和 <code>longerString</code> 的类型是根据参数推断出来的。记住，泛型就是把两个或多个具有相同类型的值联系起来。</p>\n<p>最后，正如我们所希望的，对 <code>longest(10, 100)</code> 的调用被拒绝了，因为数字类型没有一个<code>.length</code>属性。</p>\n<h3 id=\"5-4-3-使用受限值\"><a href=\"#5-4-3-使用受限值\" class=\"headerlink\" title=\"5.4.3 使用受限值\"></a>5.4.3 使用受限值</h3><p>这里有一个使用通用约束条件时的常见错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> minimumLength&lt;<span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">length</span>: <span class=\"built_in\">number</span> &#125;&gt;(</span><br><span class=\"line\">  <span class=\"attr\">obj</span>: <span class=\"title class_\">Type</span>,</span><br><span class=\"line\">  <span class=\"attr\">minimum</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">): <span class=\"title class_\">Type</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.<span class=\"property\">length</span> &gt;= minimum) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">length</span>: minimum &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/04-12.png\" alt=\"image-20211121104538424\" style=\"zoom:40%;\" />\n\n<p>看起来这个函数没有问题–Type被限制为{ length: number }，而且这个函数要么返回Type，要么返回一个与该限制相匹配的值。问题是，该函数承诺返回与传入的对象相同的类型，而不仅仅是与约束条件相匹配的一些对象。如果这段代码是合法的，你可以写出肯定无法工作的代码。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#x27;arr&#x27; 获得值： &#123; length: 6 &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"title function_\">minimumLength</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">//在此崩溃，因为数组有一个&#x27;切片&#x27;方法，但没有返回对象!</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n\n<p>![image-20211121105340359](Users&#x2F;felix&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211121105340359.png)</p>\n<h3 id=\"5-4-4-指定类型参数\"><a href=\"#5-4-4-指定类型参数\" class=\"headerlink\" title=\"5.4.4 指定类型参数\"></a>5.4.4 指定类型参数</h3><p>TypeScript 通常可以推断出通用调用中的预期类型参数，但并非总是如此。例如，假设你写了一个函数来合并两个数组：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> combine&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arr1</span>: <span class=\"title class_\">Type</span>[], <span class=\"attr\">arr2</span>: <span class=\"title class_\">Type</span>[]): <span class=\"title class_\">Type</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr1.<span class=\"title function_\">concat</span>(arr2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常情况下，用不匹配的数组调用这个函数是一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"title function_\">combine</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"string\">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/a7IfnzN9h3mAHKk.png\" alt=\"image-20211121110056686\" style=\"zoom:40%;\" />\n\n<p>然而，如果你打算这样做，你可以手动指定类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = combine&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"string\">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-5-编写优秀通用函数的准则\"><a href=\"#5-4-5-编写优秀通用函数的准则\" class=\"headerlink\" title=\"5.4.5 编写优秀通用函数的准则\"></a>5.4.5 编写优秀通用函数的准则</h3><p>编写泛型函数很有趣，而且很容易被类型参数所迷惑。有太多的类型参数或在不需要的地方使用约束，会使推理不那么成功，使你的函数的调用者感到沮丧。</p>\n<ul>\n<li><strong>类型参数下推</strong></li>\n</ul>\n<p>下面是两种看似相似的函数写法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> firstElement1&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>[]) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> firstElement2&lt;<span class=\"title class_\">Type</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[]&gt;(<span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a: number (推荐)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"title function_\">firstElement1</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"comment\">// b: any (不推荐)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"title function_\">firstElement2</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>乍一看，这些可能是相同的，但 <code>firstElement1</code> 是写这个函数的一个更好的方法。它的推断返回类型是Type，但 <code>firstElement2</code> 的推断返回类型是 <code>any</code>，因为TypeScript必须使用约束类型来解析<code>arr[0]</code>表达式，而不是在调用期间 “等待 “解析该元素。</p>\n<blockquote>\n<p><strong>规则：</strong>在可能的情况下，使用类型参数本身，而不是对其进行约束</p>\n</blockquote>\n<ul>\n<li><strong>使用更少的类型参数</strong></li>\n</ul>\n<p>下面是另一对类似的函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> filter1&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>[], <span class=\"attr\">func</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>): <span class=\"title class_\">Type</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.<span class=\"title function_\">filter</span>(func);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> filter2&lt;<span class=\"title class_\">Type</span>, <span class=\"title class_\">Func</span> <span class=\"title function_\">extends</span> (<span class=\"attr\">arg</span>: <span class=\"title class_\">Type</span>) =&gt; <span class=\"built_in\">boolean</span>&gt;(</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: <span class=\"title class_\">Type</span>[],</span><br><span class=\"line\">  <span class=\"attr\">func</span>: <span class=\"title class_\">Func</span>,</span><br><span class=\"line\">): <span class=\"title class_\">Type</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.<span class=\"title function_\">filter</span>(func);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们已经创建了一个类型参数 <code>Func</code>，它并不涉及两个值。这总是一个值得标记的坏习惯，因为它意味着想要指定类型参数的调用者必须无缘无故地手动指定一个额外的类型参数。<code>Func</code>除了使函数更难阅读和推理外，什么也没做。</p>\n<blockquote>\n<p><strong>规则：</strong>总是尽可能少地使用类型参数</p>\n</blockquote>\n<ul>\n<li><strong>类型参数应出现两次</strong></li>\n</ul>\n<p>有时我们会忘记，一个函数可能不需要是通用的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> greet&lt;<span class=\"title class_\">Str</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>&gt;(<span class=\"attr\">s</span>: <span class=\"title class_\">Str</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"string\">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们完全可以写一个更简单的版本：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>记住，类型参数是用来关联多个值的类型的。如果一个类型参数在函数签名中只使用一次，那么它就没有任何关系。</p>\n<blockquote>\n<p><strong>规则：</strong>如果一个类型的参数只出现在一个地方，请重新考虑你是否真的需要它</p>\n</blockquote>\n<h2 id=\"5-5-可选参数\"><a href=\"#5-5-可选参数\" class=\"headerlink\" title=\"5.5 可选参数\"></a>5.5 可选参数</h2><p>JavaScript中的函数经常需要一个可变数量的参数。例如，<code>number</code> 的 <code>toFixed</code>方法需要一个可选的数字计数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">n</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n.<span class=\"title function_\">toFixed</span>()); <span class=\"comment\">// 0 个参数</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n.<span class=\"title function_\">toFixed</span>(<span class=\"number\">3</span>)); <span class=\"comment\">// 1 个参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以在TypeScript中通过将参数用 <code>?</code>标记：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">x</span>?: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(); <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然参数被指定为 <code>number</code> 类型，但 <code>x</code> 参数实际上将具有 <code>number | undefined</code> 类型，因为在JavaScript中未指定的参数会得到 <code>undefined</code> 的值。</p>\n<p>你也可以提供一个参数默认值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">x = <span class=\"number\">10</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在在 <code>f</code> 的主体中，<code>x</code> 将具有 <code>number</code> 类型，因为任何 <code>undefined</code> 的参数将被替换为 <code>10</code>。请注意，当一个参数是可选的，调用者总是可以传递未定义的参数，因为这只是模拟一个 “丢失 “的参数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">x</span>?: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下调用都是正确的</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();</span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">undefined</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-5-1-回调中的可选参数\"><a href=\"#5-5-1-回调中的可选参数\" class=\"headerlink\" title=\"5.5.1 回调中的可选参数\"></a>5.5.1 回调中的可选参数</h3><p>一旦你了解了可选参数和函数类型表达式，在编写调用回调的函数时就很容易犯以下错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myForEach</span>(<span class=\"params\"><span class=\"attr\">arr</span>: <span class=\"built_in\">any</span>[], <span class=\"attr\">callback</span>: (arg: <span class=\"built_in\">any</span>, index?: <span class=\"built_in\">number</span>) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">callback</span>(arr[i], i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在写 <code>index?</code> 作为一个可选参数时，通常是想让这些调用都是合法的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">myForEach</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a));</span><br><span class=\"line\"><span class=\"title function_\">myForEach</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\">(<span class=\"params\">a, i</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, i));</span><br></pre></td></tr></table></figure>\n\n<p>这实际上意味着回调可能会被调用，只有一个参数。换句话说，该函数定义说，实现可能是这样的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myForEach</span>(<span class=\"params\"><span class=\"attr\">arr</span>: <span class=\"built_in\">any</span>[], <span class=\"attr\">callback</span>: (arg: <span class=\"built_in\">any</span>, index?: <span class=\"built_in\">number</span>) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 我现在不想提供索引</span></span><br><span class=\"line\">    <span class=\"title function_\">callback</span>(arr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反过来，TypeScript会强制执行这个意思，并发出实际上不可能的错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">myForEach</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\">(<span class=\"params\">a, i</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i.<span class=\"title function_\">toFixed</span>());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/04-14.png\" alt=\"image-20211121151911039\" style=\"zoom:40%;\" />\n\n<p>在JavaScript中，如果你调用一个形参多于实参的函数，额外的参数会被简单地忽略。TypeScript的行为也是如此。参数较少的函数（相同的类型）总是可以取代参数较多的函数的位置。</p>\n<blockquote>\n<p>当为回调写一个函数类型时，永远不要写一个可选参数，除非你打算在不传递该参数的情况下调用函数。</p>\n</blockquote>\n<h2 id=\"5-6-函数重载\"><a href=\"#5-6-函数重载\" class=\"headerlink\" title=\"5.6 函数重载\"></a>5.6 函数重载</h2><p>一些 JavaScript 函数可以在不同的参数数量和类型中被调用。例如，你可能会写一个函数来产生一个Date，它需要一个时间戳（一个参数）或一个月&#x2F;日&#x2F;年规格（三个参数）。</p>\n<p>在TypeScript中，我们可以通过编写重载签名来指定一个可以以不同方式调用的函数。要做到这一点，要写一些数量的函数签名（通常是两个或更多），然后是函数的主体：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeDate</span>(<span class=\"params\"><span class=\"attr\">timestamp</span>: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Date</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeDate</span>(<span class=\"params\"><span class=\"attr\">m</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">d</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Date</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeDate</span>(<span class=\"params\"><span class=\"attr\">mOrTimestamp</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">d</span>?: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>?: <span class=\"built_in\">number</span></span>): <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (d !== <span class=\"literal\">undefined</span> &amp;&amp; y !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(y, mOrTimestamp, d);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(mOrTimestamp);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> d1 = <span class=\"title function_\">makeDate</span>(<span class=\"number\">12345678</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> d2 = <span class=\"title function_\">makeDate</span>(<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> d3 = <span class=\"title function_\">makeDate</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/04-15.png\" alt=\"image-20211121153802236\" style=\"zoom:42%;\" />\n\n<p>在这个例子中，我们写了两个重载：一个接受一个参数，另一个接受三个参数。这前两个签名被称为重载签名。</p>\n<p>然后，我们写了一个具有兼容签名的函数实现。函数有一个实现签名，但这个签名不能被直接调用。即使我们写了一个在所需参数之后有两个可选参数的函数，它也不能以两个参数被调用！</p>\n<h3 id=\"5-6-1-重载签名和实现签名\"><a href=\"#5-6-1-重载签名和实现签名\" class=\"headerlink\" title=\"5.6.1 重载签名和实现签名\"></a>5.6.1 重载签名和实现签名</h3><p>这是一个常见的混乱来源。通常我们会写这样的代码，却不明白为什么会出现错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 期望能够以零参数调用</span></span><br><span class=\"line\"><span class=\"title function_\">fn</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/2PbtdUgEz5Ts3Dr.png\" alt=\"image-20211121154720160\" style=\"zoom:50%;\" />\n\n<p>同样，用于编写函数体的签名不能从外面 “看到”。</p>\n<blockquote>\n<p>实现的签名从外面是看不到的。在编写重载函数时，你应该总是在函数的实现上面有两个或多个签名。</p>\n</blockquote>\n<p>实现签名也必须与重载签名兼容。例如，这些函数有错误，因为实现签名没有以正确的方式匹配重载：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">boolean</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"comment\">// 参数类型不正确</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">boolean</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/saCfOyHuShpilg3.png\" alt=\"image-20211121160302934\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回类型不正确</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;oops&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/4OAqJInZEdRftuv.png\" alt=\"image-20211121160413329\" style=\"zoom: 50%;\" />\n\n<h3 id=\"5-6-2-编写好的重载\"><a href=\"#5-6-2-编写好的重载\" class=\"headerlink\" title=\"5.6.2 编写好的重载\"></a>5.6.2 编写好的重载</h3><p>和泛型一样，在使用函数重载时，有一些准则是你应该遵循的。遵循这些原则将使你的函数更容易调用，更容易理解，更容易实现。</p>\n<p>让我们考虑一个返回字符串或数组长度的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">len</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">len</span>(<span class=\"params\"><span class=\"attr\">arr</span>: <span class=\"built_in\">any</span>[]</span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">len</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"property\">length</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数是好的；我们可以用字符串或数组来调用它。然而，我们不能用一个可能是字符串或数组的值来调用它，因为TypeScript只能将一个函数调用解析为一个重载：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">len</span>(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"title function_\">len</span>([<span class=\"number\">0</span>]); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"title function_\">len</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &gt; <span class=\"number\">0.5</span> ? <span class=\"string\">&quot;hello&quot;</span> : [<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/6NRbiq5Dp3ulKhg.png\" alt=\"image-20211121161500523\" style=\"zoom:50%;\" />\n\n<p>因为两个重载都有相同的参数数量和相同的返回类型，我们可以改写一个非重载版本的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">len</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">any</span>[] | <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.<span class=\"property\">length</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">len</span>(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"title function_\">len</span>([<span class=\"number\">0</span>]); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"title function_\">len</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>() &gt; <span class=\"number\">0.5</span> ? <span class=\"string\">&quot;hello&quot;</span> : [<span class=\"number\">0</span>]); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<p>这就好得多了! 调用者可以用任何一种值来调用它，而且作为额外的奖励，我们不需要找出一个正确的实现签名。</p>\n<blockquote>\n<p>在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数</p>\n</blockquote>\n<h3 id=\"5-6-3-函数内This的声明\"><a href=\"#5-6-3-函数内This的声明\" class=\"headerlink\" title=\"5.6.3 函数内This的声明\"></a>5.6.3 函数内<code>This</code>的声明</h3><p>TypeScript会通过代码流分析来推断函数中的 <code>this</code> 应该是什么，比如下面的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"number\">123</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">admin</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">becomeAdmin</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">admin</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript理解函数 <code>user.becomeAdmin</code> 有一个对应的 <code>this</code>，它是外部对象 <code>user</code>。这个对于很多情况来说已经足够了，但是有很多情况下你需要更多的控制 <code>this</code> 代表什么对象。JavaScript规范规定，你不能有一个叫 <code>this</code>的参数，所以TypeScript使用这个语法空间，让你在函数体中声明<code>this</code>的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">admin</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> DB &#123;</span><br><span class=\"line\">  <span class=\"title function_\">filterUsers</span>(<span class=\"attr\">filter</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">User</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>): <span class=\"title class_\">User</span>[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">db</span>: <span class=\"variable constant_\">DB</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">filterUsers</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">filter</span>: (<span class=\"variable language_\">this</span>: User) =&gt; <span class=\"built_in\">boolean</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user1 = &#123;</span><br><span class=\"line\">      <span class=\"attr\">admin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user2 = &#123;</span><br><span class=\"line\">      <span class=\"attr\">admin</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [user1, user2];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> admins = db.<span class=\"title function_\">filterUsers</span>(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">User</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">admin</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这种模式在回调式API中很常见，另一个对象通常控制你的函数何时被调用。注意，你需要使用函数而不是箭头函数来获得这种行为。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">admin</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> DB &#123;</span><br><span class=\"line\">  <span class=\"title function_\">filterUsers</span>(<span class=\"attr\">filter</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">User</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>): <span class=\"title class_\">User</span>[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">db</span>: <span class=\"variable constant_\">DB</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">filterUsers</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">filter</span>: (<span class=\"variable language_\">this</span>: User) =&gt; <span class=\"built_in\">boolean</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user1 = &#123;</span><br><span class=\"line\">      <span class=\"attr\">admin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user2 = &#123;</span><br><span class=\"line\">      <span class=\"attr\">admin</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [user1, user2];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 不能为箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> admins = db.<span class=\"title function_\">filterUsers</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">admin</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/vYImhS8FQOHgJfT.png\" alt=\"image-20211121164923229\" style=\"zoom:40%;\" />\n\n<h2 id=\"5-7-需要了解的其他类型\"><a href=\"#5-7-需要了解的其他类型\" class=\"headerlink\" title=\"5.7 需要了解的其他类型\"></a>5.7 需要了解的其他类型</h2><p>有一些额外的类型你会想要认识，它们在处理函数类型时经常出现。像所有的类型一样，你可以在任何地方使用它们，但这些类型在函数的上下文中特别相关。</p>\n<h3 id=\"5-7-1-void\"><a href=\"#5-7-1-void\" class=\"headerlink\" title=\"5.7.1 void\"></a>5.7.1 <code>void</code></h3><p><code>void</code>表示没有返回值的函数的返回值。当一个函数没有任何返回语句，或者没有从这些返回语句中返回任何明确的值时，它都是推断出来的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推断出的返回类型是void</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">noop</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在JavaScript中，一个不返回任何值的函数将隐含地返回<code>undefinded</code>的值。然而，在TypeScript中，<code>void</code>和<code>undefined</code>是不一样的。在本章末尾有进一步的细节。</p>\n<blockquote>\n<p><code>void</code>与<code>undefined</code>不一样。</p>\n</blockquote>\n<h3 id=\"5-7-2-object\"><a href=\"#5-7-2-object\" class=\"headerlink\" title=\"5.7.2 object\"></a>5.7.2 <code>object</code></h3><p>特殊类型 <code>object</code> 指的是任何不是基元的值（<code>string</code>、<code>number</code>、<code>bigint</code>、<code>boolean</code>、<code>symbol</code>、<code>null </code>或 <code>undefined</code>）。这与空对象类型<code>&#123; &#125;</code>不同，也与全局类型 <code>Object</code> 不同。你很可能永远不会使用 <code>Object</code>。</p>\n<blockquote>\n<p><code>object</code>不是<code>Object</code>。始终使用<code>object</code>!</p>\n</blockquote>\n<p>请注意，在JavaScript中，函数值是对象。它们有属性，在它们的原型链中有<code>Object.prototype</code>，是 <code>Object</code>的实例，你可以对它们调用 <code>Object.key</code>，等等。由于这个原因，函数类型在TypeScript中被认为是<code>object</code>。</p>\n<h3 id=\"5-7-3-unknown\"><a href=\"#5-7-3-unknown\" class=\"headerlink\" title=\"5.7.3 unknown\"></a>5.7.3 <code>unknown</code></h3><p><code>unknown</code>类型代表任何值。这与 <code>any</code> 类型类似，但更安全，因为对未知 <code>unknown</code> 值做任何事情都是不合法的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">  a.<span class=\"title function_\">b</span>(); <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">unknown</span></span>) &#123;</span><br><span class=\"line\">  a.<span class=\"title function_\">b</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/pl7s6ZDr8QKAJgh.png\" alt=\"image-20211121172520948\" style=\"zoom:50%;\" />\n\n<p>这在描述函数类型时很有用，因为你可以描述接受任何值的函数，而不需要在函数体中有 <code>any</code> 值。</p>\n<p>反之，你可以描述一个返回未知类型的值的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">safeParse</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">unknown</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要小心对待&#x27;obj&#x27;!</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"title function_\">safeParse</span>(someRandomString);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-7-4-never\"><a href=\"#5-7-4-never\" class=\"headerlink\" title=\"5.7.4 never\"></a>5.7.4 <code>never</code></h3><p>有些函数永远不会返回一个值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fail</span>(<span class=\"params\"><span class=\"attr\">msg</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">never</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>never</code>类型表示永远不会被观察到的值。在一个返回类型中，这意味着函数抛出一个异常或终止程序的执行。</p>\n<p><code>never</code>也出现在TypeScript确定一个 <code>union</code> 中没有任何东西的时候。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 做一些事</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 再做一些事</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    x; <span class=\"comment\">// &#x27;never&#x27;!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-7-5-Function\"><a href=\"#5-7-5-Function\" class=\"headerlink\" title=\"5.7.5 Function\"></a>5.7.5 <code>Function</code></h3><p>全局性的 <code>Function</code> 类型描述了诸如 <code>bind</code>、<code>call</code>、<code>apply</code>和其他存在于JavaScript中所有函数值的属性。它还有一个特殊的属性，即 <code>Function</code> 类型的值总是可以被调用；这些调用返回 <code>any</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">f</span>: <span class=\"title class_\">Function</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">f</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个无类型的函数调用，一般来说最好避免，因为 <code>any</code> 返回类型都不安全。</p>\n<p>如果你需要接受一个任意的函数，但不打算调用它，一般来说，<code>() =&gt; void</code>的类型比较安全。</p>\n<h2 id=\"5-8-参数展开运算符\"><a href=\"#5-8-参数展开运算符\" class=\"headerlink\" title=\"5.8 参数展开运算符\"></a>5.8 参数展开运算符</h2><h3 id=\"5-8-1-形参展开-Rest-Parameters\"><a href=\"#5-8-1-形参展开-Rest-Parameters\" class=\"headerlink\" title=\"5.8.1 形参展开(Rest Parameters)\"></a>5.8.1 形参展开(Rest Parameters)</h3><p>除了使用可选参数或重载来制作可以接受各种固定参数数量的函数之外，我们还可以使用休止参数来定义接受无限制数量的参数的函数。</p>\n<p><code>rest</code>参数出现在所有其他参数之后，并使用<code>...</code>的语法：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">multiply</span>(<span class=\"params\"><span class=\"attr\">n</span>: <span class=\"built_in\">number</span>, ...<span class=\"attr\">m</span>: <span class=\"built_in\">number</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> n * x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#x27;a&#x27; 获得的值 [10, 20, 30, 40]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"title function_\">multiply</span>(<span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在TypeScript中，这些参数的类型注解是隐含的 <code>any[]</code>，而不是<code>any</code>，任何给出的类型注解必须是<code>Array&lt;T&gt;</code>或<code>T[]</code>的形式，或一个元组类型（我们将在后面学习）。</p>\n<h3 id=\"5-8-2-实参展开-Rest-Arguments\"><a href=\"#5-8-2-实参展开-Rest-Arguments\" class=\"headerlink\" title=\"5.8.2 实参展开(Rest Arguments)\"></a>5.8.2 实参展开(Rest Arguments)</h3><p>反之，我们可以使用 <code>spread</code> 语法从数组中提供可变数量的参数。例如，数组的 <code>push</code> 方法需要任意数量的参数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">arr1.<span class=\"title function_\">push</span>(...arr2);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，一般来说，TypeScript并不假定数组是不可变的。这可能会导致一些令人惊讶的行为。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推断的类型是 number[] -- &quot;一个有零或多个数字的数组&quot;。</span></span><br><span class=\"line\"><span class=\"comment\">// 不专指两个数字</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> args = [<span class=\"number\">8</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> angle = <span class=\"title class_\">Math</span>.<span class=\"title function_\">atan2</span>(...args);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/05-06.png\" alt=\"image-20211122191044837\" style=\"zoom: 50%;\" />\n\n<p>这种情况的最佳解决方案取决于你的代码，但一般来说，<code>const context</code> 是最直接的解决方案。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推断为2个长度的元组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> args = [<span class=\"number\">8</span>, <span class=\"number\">5</span>] <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> angle = <span class=\"title class_\">Math</span>.<span class=\"title function_\">atan2</span>(...args);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-9-参数解构\"><a href=\"#5-9-参数解构\" class=\"headerlink\" title=\"5.9 参数解构\"></a>5.9 参数解构</h2><p>你可以使用参数重构来方便地将作为参数提供的对象，解压到函数主体的一个或多个局部变量中。在JavaScript中，它看起来像这样：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sum</span>(<span class=\"params\">&#123; a, b, c &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a + b + c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">sum</span>(&#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span>, <span class=\"attr\">c</span>: <span class=\"number\">9</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>对象的类型注解在解构的语法之后：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sum</span>(<span class=\"params\">&#123; a, b, c &#125;: &#123; a: <span class=\"built_in\">number</span>; b: <span class=\"built_in\">number</span>; c: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a + b + c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这看起来有点啰嗦，但你也可以在这里使用一个命名的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 与之前的例子相同</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">ABC</span> = &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">c</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sum</span>(<span class=\"params\">&#123; a, b, c &#125;: ABC</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a + b + c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-10-函数的可分配性\"><a href=\"#5-10-函数的可分配性\" class=\"headerlink\" title=\"5.10 函数的可分配性\"></a>5.10 函数的可分配性</h2><h3 id=\"5-10-1-返回-void-类型\"><a href=\"#5-10-1-返回-void-类型\" class=\"headerlink\" title=\"5.10.1 返回 void 类型\"></a>5.10.1 返回 <code>void</code> 类型</h3><p>函数的 <code>void</code> 返回类型可以产生一些不寻常的，但却是预期的行为。</p>\n<p>返回类型为 <code>void</code> 的上下文类型并不强迫函数不返回东西。另一种说法是，一个具有 <code>void</code>返回类型的上下文函数类型（<code>type vf = () =&gt; void</code>），在实现时，可以返回任何其他的值，但它会被忽略。</p>\n<p>因此，以下<code>（）=&gt; void</code>类型的实现是有效的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> voidFunc = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">f1</span>: voidFunc = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">f2</span>: voidFunc = <span class=\"function\">() =&gt;</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">f3</span>: voidFunc = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>而当这些函数之一的返回值被分配给另一个变量时，它将保留 <code>void</code> 的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> v1 = <span class=\"title function_\">f1</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> v2 = <span class=\"title function_\">f2</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> v3 = <span class=\"title function_\">f3</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这种行为的存在使得下面的代码是有效的，即使 <code>Array.prototype.push</code>返回一个数字，而<code>Array.prototype.forEach</code>方法期望一个返回类型为<code>void</code>的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> src = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> dst = [<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">src.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">el</span>) =&gt;</span> dst.<span class=\"title function_\">push</span>(el));</span><br></pre></td></tr></table></figure>\n\n<p>还有一个需要注意的特殊情况，当一个字面的函数定义有一个 <code>void</code> 的返回类型时，该函数必须不返回任何东西。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f3 = <span class=\"keyword\">function</span> (<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/t7q4nWcpJxZz12D.png\" alt=\"image-20211122220703542\" style=\"zoom:50%;\" />\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "1-9、基础篇：模块",
        "toc": true,
        "abbrlink": 40444,
        "date": "2024-01-28T11:48:50.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 九、模块\n\nJavaScript有很长的历史，有不同的方式来处理模块化的代码。TypeScript从2012年开始出现，已经实现了对许多这些格式的支持，但随着时间的推移，社区和JavaScript规范已经趋向于一种名为ES模块（或ES6模块）的格式。你可能知道它是`import/export`语法。\n\nES Modules在2015年被加入到JavaScript规范中，到2020年，在大多数网络浏览器和JavaScript运行时中都有广泛的支持。\n\n为了突出重点，本手册将涵盖ES Modules及其流行的前驱CommonJS `module.exports =`语法。\n\n## 9.1 如何定义JavaScript模块\n\n在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级`import`或`export`的文件都被认为是一个模块。\n\n相反，一个没有任何顶级导入或导出声明的文件被视为一个脚本，其内容可在全局范围内使用（因此也可用于模块）。\n\n模块在自己的范围内执行，而不是在全局范围内。这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地用某种导出形式导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用导入的形式将其导入。\n\n## 9.2 非模块\n\n在我们开始之前，重要的是要了解TypeScript认为什么才是模块。JavaScript规范声明，任何没有 `export`或顶层 `await` 的JavaScript文件都应该被认为是一个脚本而不是一个模块。\n\n在一个脚本文件中，变量和类型被声明为在共享的全局范围内，并且假定你会使用`outFile`编译器选项将多个输入文件加入一个输出文件，或者在你的HTML中使用多个`<script>`标签来加载这些文件（顺序正确！）。\n\n如果你有一个目前没有任何导入或导出的文件，但你希望被当作一个模块来处理，请添加这一行：\n\n```tsx\nexport {};\n```\n\n这将改变该文件，使其成为一个什么都不输出的模块。无论你的模块目标是什么，这个语法都有效。\n\n## 9.3 TypeScript 中的模块\n\n在TypeScript中编写基于模块的代码时，有三个主要方面需要考虑：\n\n- **语法：**我想用什么语法来导入和导出东西？\n- **模块解析：**模块名称（或路径）和磁盘上的文件之间是什么关系？\n- **模块输出目标：**我编译出来的JavaScript模块应该是什么样子的？\n\n### 9.3.1 ES模块语法\n\n一个文件可以通过`export default`声明一个主要出口：\n\n```tsx\n// @filename: hello.ts\nexport default function helloWorld() {\n  console.log(\"Hello, world!\");\n}\n```\n\n然后通过以下方式导入：\n\n```tsx\nimport hello from \"./hello.js\";\nhello();\n```\n\n除了默认的导出，你还可以通过省略`default`的`export`，实现有一个以上的变量和函数的导出。\n\n```tsx\n// @filename: maths.ts\nexport var pi = 3.14;\nexport let squareTwo = 1.41;\nexport const phi = 1.61;\nexport class RandomNumberGenerator {}\nexport function absolute(num: number) {\n  if (num < 0) return num * -1;\n  return num;\n}\n```\n\n这些可以通过 `import` 语法在另一个文件中使用：\n\n```tsx\nimport { pi, phi, absolute } from \"./maths.js\";\nconsole.log(pi);\n\n// const absPhi: number\nconst absPhi = absolute(phi);\n```\n\n### 9.3.2 额外的导入语法\n\n可以使用 `import {old as new}` 这样的格式来重命名一个导入：\n\n```tsx\nimport { pi as π } from \"./maths.js\";\n// (alias)\nvar π: number;\n// import π\nconsole.log(π);\n```\n\n你可以将上述语法混合并匹配到一个单一的 `import` 中：\n\n```tsx\n// @filename: maths.ts\nexport const pi = 3.14;\nexport default class RandomNumberGenerator {}\n\n// @filename: app.ts\nimport RNGen, { pi as π } from \"./maths.js\";\n\n// (alias) class RNGen\n// import RNGen\nRNGen;\n\n// (alias) const π: 3.14\n// import π\nconsole.log(π);\n```\n\n你可以把所有导出的对象，用`* as name`，把它们放到一个命名空间：\n\n```tsx\n// @filename: app.ts\nimport * as math from \"./maths.js\";\n\nconsole.log(math.pi);\n// const positivePhi: number\nconst positivePhi = math.absolute(math.phi);\n```\n\n你可以通过`import \"./file \"`导入一个文件，而不把任何变量纳入你的当前模块：\n\n```tsx\n// @filename: app.ts\nimport \"./maths.js\";\n\nconsole.log(\"3.14\");\n```\n\n在这种情况下，`import` 没有任何作用。然而，`maths.ts`中的所有代码都被解析了，这可能引发影响其他对象的副作用。\n\n### 9.3.3 TypeScript特定的ES模块语法\n\n类型可以使用与JavaScript值相同的语法进行导出和导入。\n\n```tsx\n// @filename: animal.ts\nexport type Cat = { breed: string; yearOfBirth: number };\n\nexport interface Dog {\n  breeds: string[];\n  yearOfBirth: number;\n}\n\n// @filename: app.ts\nimport { Cat, Dog } from \"./animal.js\";\ntype Animals = Cat | Dog;\n```\n\nTypeScript用两个概念扩展了 `import` 语法，用于声明一个类型的导入。\n\n- `import type`\n\n这是一个导入语句，只能导入类型：\n\n```tsx\n// @filename: animal.ts\nexport type Cat = { breed: string; yearOfBirth: number };\nexport type Dog = { breeds: string[]; yearOfBirth: number };\nexport const createCatName = () => \"fluffy\";\n\n// @filename: valid.ts\nimport type { Cat, Dog } from \"./animal.js\";\nexport type Animals = Cat | Dog;\n\n// @filename: app.ts\nimport type { createCatName } from \"./animal.js\";\nconst name = createCatName();\n```\n\n<img src=\"/img/TypeScript/10-06.png\" alt=\"image-20211219080726659\" style=\"zoom:67%;\" />\n\n- **内联类型导入**\n\nTypeScript 4.5还允许以type为前缀的单个导入，以表明导入的引用是一个类型：\n\n```tsx\n// @filename: app.ts\nimport { createCatName, type Cat, type Dog } from \"./animal.js\";\n\nexport type Animals = Cat | Dog;\nconst name = createCatName();\n```\n\n### 9.3.4 ES模块语法与CommonJS行为\n\nTypeScript有ES Module语法，它直接与CommonJS和AMD的`require`相关联。使用ES Module的 `import` 在大多数情况下与这些环境的`require`相同，但这种语法确保你在TypeScript文件中与CommonJS的输出有1对1的匹配：\n\n```tsx\nimport fs = require(\"fs\");\nconst code = fs.readFileSync(\"hello.ts\", \"utf8\");\n```\n\n## 9.4 CommonJS 语法\n\nCommonJS是npm上大多数模块的交付格式。即使你使用上面的ES模块语法进行编写，对CommonJS语法的工作方式有一个简单的了解也会帮助你更容易地进行调试。\n\n### 9.4.1 导出\n\n标识符是通过在一个全局调用的 `module` 上设置 `exports` 属性来导出的。\n\n```tsx\nfunction absolute(num: number) {\n  if (num < 0) return num * -1;\n  return num;\n}\n\nmodule.exports = {\n  pi: 3.14,\n  squareTwo: 1.41,\n  phi: 1.61,\n  absolute,\n};\n```\n\n然后这些文件可以通过`require`语句导入：\n\n```tsx\nconst maths = require(\"maths\");\n// pi: any\nmaths.pi;\n```\n\n或者你可以使用JavaScript中的析构功能来简化一下：\n\n```tsx\nconst { squareTwo } = require(\"maths\");\n// const squareTwo: any\nsquareTwo;\n```\n\n### 9.4.2 CommonJS和ES模块的互操作性\n\n关于默认导入和模块命名空间对象导入之间的区别，CommonJS和ES Modules之间存在着功能上的不匹配。\n\n这个后面章节会详细介绍。\n\n## 9.5 TypeScript的模块解析选项\n\n模块解析是指从`import`或`require`语句中获取一个字符串，并确定该字符串所指的文件的过程。\n\nTypeScript包括两种解析策略。经典和Node。当编译器选项 `module`不是`commonjs`时，经典策略是默认的，是为了向后兼容。Node策略复制了Node.js在CommonJS模式下的工作方式，对`.ts`和`.d.ts`有额外的检查。\n\n在TypeScript中，有许多TSConfig标志影响模块策略： [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution), [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl), [`paths`](https://www.typescriptlang.org/tsconfig#paths), [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs).\n\n关于这些策略如何工作的全部细节，你可以参考《[模块解析](https://www.typescriptlang.org/docs/handbook/module-resolution.html)》。\n\n## 9.6 TypeScript的模块输出选项\n\n有两个选项会影响JavaScript输出：\n\n- `target`，它决定了哪些JS功能被降级（转换为在旧的JavaScript运行时运行），哪些保持不变\n- `module`，它决定了哪些代码用于模块之间的相互作用。\n\n你使用的`target`是由你期望运行TypeScript代码的JavaScript运行时中的可用功能决定的。这可能是：你支持的最古老的网络浏览器，你期望运行的最低版本的Node.js，或者可能来自于你的运行时的独特约束——比如Electron。\n\n所有模块之间的通信都是通过模块加载器进行的，编译器选项 `module` 决定使用哪一个。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖项。\n\n例如，这里是一个使用ES模块语法的TypeScript文件，展示了`module`的一些不同选项：\n\n```tsx\nimport { valueOfPi } from \"./constants.js\";\nexport const twoPi = valueOfPi * 2;\n```\n\n- ES2020\n\n```tsx\nimport { valueOfPi } from \"./constants.js\";\nexport const twoPi = valueOfPi * 2;\n```\n\n- CommonJS\n\n```tsx\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_js_1 = require(\"./constants.js\");\nexports.twoPi = constants_js_1.valueOfPi * 2;\n```\n\n- #### UMD\n\n```tsx\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([\"require\", \"exports\", \"./constants.js\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", { value: true });\n  exports.twoPi = void 0;\n  const constants_js_1 = require(\"./constants.js\");\n  exports.twoPi = constants_js_1.valueOfPi * 2;\n});\n```\n\n> 请注意，ES2020实际上与原来的index.ts相同。\n\n你可以在[TSConfig 模块参考](https://www.typescriptlang.org/tsconfig#module) 中看到所有可用的选项以及它们发出的JavaScript代码是什么样子。\n\n## 9.7 TypeScript 命名空间\n\nTypeScript有自己的模块格式，称为 `命名空间(namespaces)`，这比ES模块标准要早。这种语法对于创建复杂的定义文件有很多有用的功能，并且在 [DefinitelyTyped](https://www.typescriptlang.org/dt)中仍然被积极使用。虽然没有被废弃，但命名空间中的大部分功能都存在于ES Modules中，我们建议你使用它来与JavaScript的方向保持一致。你可以在 [namespaces参考页](https://www.typescriptlang.org/docs/handbook/namespaces.html)中了解更多关于命名空间的信息。\n\n——基础篇完——\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-9、基础篇：模块.md",
        "raw": "---\ntitle: 1-9、基础篇：模块\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 40444\ndate: 2024-01-28 19:48:50\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 九、模块\n\nJavaScript有很长的历史，有不同的方式来处理模块化的代码。TypeScript从2012年开始出现，已经实现了对许多这些格式的支持，但随着时间的推移，社区和JavaScript规范已经趋向于一种名为ES模块（或ES6模块）的格式。你可能知道它是`import/export`语法。\n\nES Modules在2015年被加入到JavaScript规范中，到2020年，在大多数网络浏览器和JavaScript运行时中都有广泛的支持。\n\n为了突出重点，本手册将涵盖ES Modules及其流行的前驱CommonJS `module.exports =`语法。\n\n## 9.1 如何定义JavaScript模块\n\n在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级`import`或`export`的文件都被认为是一个模块。\n\n相反，一个没有任何顶级导入或导出声明的文件被视为一个脚本，其内容可在全局范围内使用（因此也可用于模块）。\n\n模块在自己的范围内执行，而不是在全局范围内。这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地用某种导出形式导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用导入的形式将其导入。\n\n## 9.2 非模块\n\n在我们开始之前，重要的是要了解TypeScript认为什么才是模块。JavaScript规范声明，任何没有 `export`或顶层 `await` 的JavaScript文件都应该被认为是一个脚本而不是一个模块。\n\n在一个脚本文件中，变量和类型被声明为在共享的全局范围内，并且假定你会使用`outFile`编译器选项将多个输入文件加入一个输出文件，或者在你的HTML中使用多个`<script>`标签来加载这些文件（顺序正确！）。\n\n如果你有一个目前没有任何导入或导出的文件，但你希望被当作一个模块来处理，请添加这一行：\n\n```tsx\nexport {};\n```\n\n这将改变该文件，使其成为一个什么都不输出的模块。无论你的模块目标是什么，这个语法都有效。\n\n## 9.3 TypeScript 中的模块\n\n在TypeScript中编写基于模块的代码时，有三个主要方面需要考虑：\n\n- **语法：**我想用什么语法来导入和导出东西？\n- **模块解析：**模块名称（或路径）和磁盘上的文件之间是什么关系？\n- **模块输出目标：**我编译出来的JavaScript模块应该是什么样子的？\n\n### 9.3.1 ES模块语法\n\n一个文件可以通过`export default`声明一个主要出口：\n\n```tsx\n// @filename: hello.ts\nexport default function helloWorld() {\n  console.log(\"Hello, world!\");\n}\n```\n\n然后通过以下方式导入：\n\n```tsx\nimport hello from \"./hello.js\";\nhello();\n```\n\n除了默认的导出，你还可以通过省略`default`的`export`，实现有一个以上的变量和函数的导出。\n\n```tsx\n// @filename: maths.ts\nexport var pi = 3.14;\nexport let squareTwo = 1.41;\nexport const phi = 1.61;\nexport class RandomNumberGenerator {}\nexport function absolute(num: number) {\n  if (num < 0) return num * -1;\n  return num;\n}\n```\n\n这些可以通过 `import` 语法在另一个文件中使用：\n\n```tsx\nimport { pi, phi, absolute } from \"./maths.js\";\nconsole.log(pi);\n\n// const absPhi: number\nconst absPhi = absolute(phi);\n```\n\n### 9.3.2 额外的导入语法\n\n可以使用 `import {old as new}` 这样的格式来重命名一个导入：\n\n```tsx\nimport { pi as π } from \"./maths.js\";\n// (alias)\nvar π: number;\n// import π\nconsole.log(π);\n```\n\n你可以将上述语法混合并匹配到一个单一的 `import` 中：\n\n```tsx\n// @filename: maths.ts\nexport const pi = 3.14;\nexport default class RandomNumberGenerator {}\n\n// @filename: app.ts\nimport RNGen, { pi as π } from \"./maths.js\";\n\n// (alias) class RNGen\n// import RNGen\nRNGen;\n\n// (alias) const π: 3.14\n// import π\nconsole.log(π);\n```\n\n你可以把所有导出的对象，用`* as name`，把它们放到一个命名空间：\n\n```tsx\n// @filename: app.ts\nimport * as math from \"./maths.js\";\n\nconsole.log(math.pi);\n// const positivePhi: number\nconst positivePhi = math.absolute(math.phi);\n```\n\n你可以通过`import \"./file \"`导入一个文件，而不把任何变量纳入你的当前模块：\n\n```tsx\n// @filename: app.ts\nimport \"./maths.js\";\n\nconsole.log(\"3.14\");\n```\n\n在这种情况下，`import` 没有任何作用。然而，`maths.ts`中的所有代码都被解析了，这可能引发影响其他对象的副作用。\n\n### 9.3.3 TypeScript特定的ES模块语法\n\n类型可以使用与JavaScript值相同的语法进行导出和导入。\n\n```tsx\n// @filename: animal.ts\nexport type Cat = { breed: string; yearOfBirth: number };\n\nexport interface Dog {\n  breeds: string[];\n  yearOfBirth: number;\n}\n\n// @filename: app.ts\nimport { Cat, Dog } from \"./animal.js\";\ntype Animals = Cat | Dog;\n```\n\nTypeScript用两个概念扩展了 `import` 语法，用于声明一个类型的导入。\n\n- `import type`\n\n这是一个导入语句，只能导入类型：\n\n```tsx\n// @filename: animal.ts\nexport type Cat = { breed: string; yearOfBirth: number };\nexport type Dog = { breeds: string[]; yearOfBirth: number };\nexport const createCatName = () => \"fluffy\";\n\n// @filename: valid.ts\nimport type { Cat, Dog } from \"./animal.js\";\nexport type Animals = Cat | Dog;\n\n// @filename: app.ts\nimport type { createCatName } from \"./animal.js\";\nconst name = createCatName();\n```\n\n<img src=\"/img/TypeScript/10-06.png\" alt=\"image-20211219080726659\" style=\"zoom:67%;\" />\n\n- **内联类型导入**\n\nTypeScript 4.5还允许以type为前缀的单个导入，以表明导入的引用是一个类型：\n\n```tsx\n// @filename: app.ts\nimport { createCatName, type Cat, type Dog } from \"./animal.js\";\n\nexport type Animals = Cat | Dog;\nconst name = createCatName();\n```\n\n### 9.3.4 ES模块语法与CommonJS行为\n\nTypeScript有ES Module语法，它直接与CommonJS和AMD的`require`相关联。使用ES Module的 `import` 在大多数情况下与这些环境的`require`相同，但这种语法确保你在TypeScript文件中与CommonJS的输出有1对1的匹配：\n\n```tsx\nimport fs = require(\"fs\");\nconst code = fs.readFileSync(\"hello.ts\", \"utf8\");\n```\n\n## 9.4 CommonJS 语法\n\nCommonJS是npm上大多数模块的交付格式。即使你使用上面的ES模块语法进行编写，对CommonJS语法的工作方式有一个简单的了解也会帮助你更容易地进行调试。\n\n### 9.4.1 导出\n\n标识符是通过在一个全局调用的 `module` 上设置 `exports` 属性来导出的。\n\n```tsx\nfunction absolute(num: number) {\n  if (num < 0) return num * -1;\n  return num;\n}\n\nmodule.exports = {\n  pi: 3.14,\n  squareTwo: 1.41,\n  phi: 1.61,\n  absolute,\n};\n```\n\n然后这些文件可以通过`require`语句导入：\n\n```tsx\nconst maths = require(\"maths\");\n// pi: any\nmaths.pi;\n```\n\n或者你可以使用JavaScript中的析构功能来简化一下：\n\n```tsx\nconst { squareTwo } = require(\"maths\");\n// const squareTwo: any\nsquareTwo;\n```\n\n### 9.4.2 CommonJS和ES模块的互操作性\n\n关于默认导入和模块命名空间对象导入之间的区别，CommonJS和ES Modules之间存在着功能上的不匹配。\n\n这个后面章节会详细介绍。\n\n## 9.5 TypeScript的模块解析选项\n\n模块解析是指从`import`或`require`语句中获取一个字符串，并确定该字符串所指的文件的过程。\n\nTypeScript包括两种解析策略。经典和Node。当编译器选项 `module`不是`commonjs`时，经典策略是默认的，是为了向后兼容。Node策略复制了Node.js在CommonJS模式下的工作方式，对`.ts`和`.d.ts`有额外的检查。\n\n在TypeScript中，有许多TSConfig标志影响模块策略： [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution), [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl), [`paths`](https://www.typescriptlang.org/tsconfig#paths), [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs).\n\n关于这些策略如何工作的全部细节，你可以参考《[模块解析](https://www.typescriptlang.org/docs/handbook/module-resolution.html)》。\n\n## 9.6 TypeScript的模块输出选项\n\n有两个选项会影响JavaScript输出：\n\n- `target`，它决定了哪些JS功能被降级（转换为在旧的JavaScript运行时运行），哪些保持不变\n- `module`，它决定了哪些代码用于模块之间的相互作用。\n\n你使用的`target`是由你期望运行TypeScript代码的JavaScript运行时中的可用功能决定的。这可能是：你支持的最古老的网络浏览器，你期望运行的最低版本的Node.js，或者可能来自于你的运行时的独特约束——比如Electron。\n\n所有模块之间的通信都是通过模块加载器进行的，编译器选项 `module` 决定使用哪一个。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖项。\n\n例如，这里是一个使用ES模块语法的TypeScript文件，展示了`module`的一些不同选项：\n\n```tsx\nimport { valueOfPi } from \"./constants.js\";\nexport const twoPi = valueOfPi * 2;\n```\n\n- ES2020\n\n```tsx\nimport { valueOfPi } from \"./constants.js\";\nexport const twoPi = valueOfPi * 2;\n```\n\n- CommonJS\n\n```tsx\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.twoPi = void 0;\nconst constants_js_1 = require(\"./constants.js\");\nexports.twoPi = constants_js_1.valueOfPi * 2;\n```\n\n- #### UMD\n\n```tsx\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([\"require\", \"exports\", \"./constants.js\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", { value: true });\n  exports.twoPi = void 0;\n  const constants_js_1 = require(\"./constants.js\");\n  exports.twoPi = constants_js_1.valueOfPi * 2;\n});\n```\n\n> 请注意，ES2020实际上与原来的index.ts相同。\n\n你可以在[TSConfig 模块参考](https://www.typescriptlang.org/tsconfig#module) 中看到所有可用的选项以及它们发出的JavaScript代码是什么样子。\n\n## 9.7 TypeScript 命名空间\n\nTypeScript有自己的模块格式，称为 `命名空间(namespaces)`，这比ES模块标准要早。这种语法对于创建复杂的定义文件有很多有用的功能，并且在 [DefinitelyTyped](https://www.typescriptlang.org/dt)中仍然被积极使用。虽然没有被废弃，但命名空间中的大部分功能都存在于ES Modules中，我们建议你使用它来与JavaScript的方向保持一致。你可以在 [namespaces参考页](https://www.typescriptlang.org/docs/handbook/namespaces.html)中了解更多关于命名空间的信息。\n\n——基础篇完——\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-9、基础篇：模块",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao4000s94v3969ceik2",
        "content": "<h1 id=\"九、模块\"><a href=\"#九、模块\" class=\"headerlink\" title=\"九、模块\"></a>九、模块</h1><p>JavaScript有很长的历史，有不同的方式来处理模块化的代码。TypeScript从2012年开始出现，已经实现了对许多这些格式的支持，但随着时间的推移，社区和JavaScript规范已经趋向于一种名为ES模块（或ES6模块）的格式。你可能知道它是<code>import/export</code>语法。</p>\n<p>ES Modules在2015年被加入到JavaScript规范中，到2020年，在大多数网络浏览器和JavaScript运行时中都有广泛的支持。</p>\n<p>为了突出重点，本手册将涵盖ES Modules及其流行的前驱CommonJS <code>module.exports =</code>语法。</p>\n<h2 id=\"9-1-如何定义JavaScript模块\"><a href=\"#9-1-如何定义JavaScript模块\" class=\"headerlink\" title=\"9.1 如何定义JavaScript模块\"></a>9.1 如何定义JavaScript模块</h2><p>在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级<code>import</code>或<code>export</code>的文件都被认为是一个模块。</p>\n<p>相反，一个没有任何顶级导入或导出声明的文件被视为一个脚本，其内容可在全局范围内使用（因此也可用于模块）。</p>\n<p>模块在自己的范围内执行，而不是在全局范围内。这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地用某种导出形式导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用导入的形式将其导入。</p>\n<h2 id=\"9-2-非模块\"><a href=\"#9-2-非模块\" class=\"headerlink\" title=\"9.2 非模块\"></a>9.2 非模块</h2><p>在我们开始之前，重要的是要了解TypeScript认为什么才是模块。JavaScript规范声明，任何没有 <code>export</code>或顶层 <code>await</code> 的JavaScript文件都应该被认为是一个脚本而不是一个模块。</p>\n<p>在一个脚本文件中，变量和类型被声明为在共享的全局范围内，并且假定你会使用<code>outFile</code>编译器选项将多个输入文件加入一个输出文件，或者在你的HTML中使用多个<code>&lt;script&gt;</code>标签来加载这些文件（顺序正确！）。</p>\n<p>如果你有一个目前没有任何导入或导出的文件，但你希望被当作一个模块来处理，请添加这一行：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这将改变该文件，使其成为一个什么都不输出的模块。无论你的模块目标是什么，这个语法都有效。</p>\n<h2 id=\"9-3-TypeScript-中的模块\"><a href=\"#9-3-TypeScript-中的模块\" class=\"headerlink\" title=\"9.3 TypeScript 中的模块\"></a>9.3 TypeScript 中的模块</h2><p>在TypeScript中编写基于模块的代码时，有三个主要方面需要考虑：</p>\n<ul>\n<li><strong>语法：</strong>我想用什么语法来导入和导出东西？</li>\n<li><strong>模块解析：</strong>模块名称（或路径）和磁盘上的文件之间是什么关系？</li>\n<li><strong>模块输出目标：</strong>我编译出来的JavaScript模块应该是什么样子的？</li>\n</ul>\n<h3 id=\"9-3-1-ES模块语法\"><a href=\"#9-3-1-ES模块语法\" class=\"headerlink\" title=\"9.3.1 ES模块语法\"></a>9.3.1 ES模块语法</h3><p>一个文件可以通过<code>export default</code>声明一个主要出口：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: hello.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">helloWorld</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后通过以下方式导入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hello <span class=\"keyword\">from</span> <span class=\"string\">&quot;./hello.js&quot;</span>;</span><br><span class=\"line\"><span class=\"title function_\">hello</span>();</span><br></pre></td></tr></table></figure>\n\n<p>除了默认的导出，你还可以通过省略<code>default</code>的<code>export</code>，实现有一个以上的变量和函数的导出。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: maths.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> pi = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> squareTwo = <span class=\"number\">1.41</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> phi = <span class=\"number\">1.61</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RandomNumberGenerator</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">absolute</span>(<span class=\"params\"><span class=\"attr\">num</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> num * -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些可以通过 <code>import</code> 语法在另一个文件中使用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; pi, phi, absolute &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pi);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const absPhi: number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> absPhi = <span class=\"title function_\">absolute</span>(phi);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-3-2-额外的导入语法\"><a href=\"#9-3-2-额外的导入语法\" class=\"headerlink\" title=\"9.3.2 额外的导入语法\"></a>9.3.2 额外的导入语法</h3><p>可以使用 <code>import &#123;old as new&#125;</code> 这样的格式来重命名一个导入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; pi <span class=\"keyword\">as</span> π &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// (alias)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> π: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"comment\">// import π</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(π);</span><br></pre></td></tr></table></figure>\n\n<p>你可以将上述语法混合并匹配到一个单一的 <code>import</code> 中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: maths.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> pi = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RandomNumberGenerator</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">RNGen</span>, &#123; pi <span class=\"keyword\">as</span> π &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (alias) class RNGen</span></span><br><span class=\"line\"><span class=\"comment\">// import RNGen</span></span><br><span class=\"line\"><span class=\"title class_\">RNGen</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (alias) const π: 3.14</span></span><br><span class=\"line\"><span class=\"comment\">// import π</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(π);</span><br></pre></td></tr></table></figure>\n\n<p>你可以把所有导出的对象，用<code>* as name</code>，把它们放到一个命名空间：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> math <span class=\"keyword\">from</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(math.<span class=\"property\">pi</span>);</span><br><span class=\"line\"><span class=\"comment\">// const positivePhi: number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> positivePhi = math.<span class=\"title function_\">absolute</span>(math.<span class=\"property\">phi</span>);</span><br></pre></td></tr></table></figure>\n\n<p>你可以通过<code>import &quot;./file &quot;</code>导入一个文件，而不把任何变量纳入你的当前模块：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;3.14&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，<code>import</code> 没有任何作用。然而，<code>maths.ts</code>中的所有代码都被解析了，这可能引发影响其他对象的副作用。</p>\n<h3 id=\"9-3-3-TypeScript特定的ES模块语法\"><a href=\"#9-3-3-TypeScript特定的ES模块语法\" class=\"headerlink\" title=\"9.3.3 TypeScript特定的ES模块语法\"></a>9.3.3 TypeScript特定的ES模块语法</h3><p>类型可以使用与JavaScript值相同的语法进行导出和导入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: animal.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Cat</span> = &#123; <span class=\"attr\">breed</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">yearOfBirth</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">breeds</span>: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  <span class=\"attr\">yearOfBirth</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Cat</span>, <span class=\"title class_\">Dog</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./animal.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Animals</span> = <span class=\"title class_\">Cat</span> | <span class=\"title class_\">Dog</span>;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript用两个概念扩展了 <code>import</code> 语法，用于声明一个类型的导入。</p>\n<ul>\n<li><code>import type</code></li>\n</ul>\n<p>这是一个导入语句，只能导入类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: animal.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Cat</span> = &#123; <span class=\"attr\">breed</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">yearOfBirth</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Dog</span> = &#123; <span class=\"attr\">breeds</span>: <span class=\"built_in\">string</span>[]; <span class=\"attr\">yearOfBirth</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createCatName</span> = (<span class=\"params\"></span>) =&gt; <span class=\"string\">&quot;fluffy&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @filename: valid.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; <span class=\"title class_\">Cat</span>, <span class=\"title class_\">Dog</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./animal.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Animals</span> = <span class=\"title class_\">Cat</span> | <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; createCatName &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./animal.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"title function_\">createCatName</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-06.png\" alt=\"image-20211219080726659\" style=\"zoom:67%;\" />\n\n<ul>\n<li><strong>内联类型导入</strong></li>\n</ul>\n<p>TypeScript 4.5还允许以type为前缀的单个导入，以表明导入的引用是一个类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createCatName, <span class=\"keyword\">type</span> <span class=\"title class_\">Cat</span>, <span class=\"keyword\">type</span> <span class=\"title class_\">Dog</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./animal.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Animals</span> = <span class=\"title class_\">Cat</span> | <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"title function_\">createCatName</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-3-4-ES模块语法与CommonJS行为\"><a href=\"#9-3-4-ES模块语法与CommonJS行为\" class=\"headerlink\" title=\"9.3.4 ES模块语法与CommonJS行为\"></a>9.3.4 ES模块语法与CommonJS行为</h3><p>TypeScript有ES Module语法，它直接与CommonJS和AMD的<code>require</code>相关联。使用ES Module的 <code>import</code> 在大多数情况下与这些环境的<code>require</code>相同，但这种语法确保你在TypeScript文件中与CommonJS的输出有1对1的匹配：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> code = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;hello.ts&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-4-CommonJS-语法\"><a href=\"#9-4-CommonJS-语法\" class=\"headerlink\" title=\"9.4 CommonJS 语法\"></a>9.4 CommonJS 语法</h2><p>CommonJS是npm上大多数模块的交付格式。即使你使用上面的ES模块语法进行编写，对CommonJS语法的工作方式有一个简单的了解也会帮助你更容易地进行调试。</p>\n<h3 id=\"9-4-1-导出\"><a href=\"#9-4-1-导出\" class=\"headerlink\" title=\"9.4.1 导出\"></a>9.4.1 导出</h3><p>标识符是通过在一个全局调用的 <code>module</code> 上设置 <code>exports</code> 属性来导出的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">absolute</span>(<span class=\"params\"><span class=\"attr\">num</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> num * -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">pi</span>: <span class=\"number\">3.14</span>,</span><br><span class=\"line\">  <span class=\"attr\">squareTwo</span>: <span class=\"number\">1.41</span>,</span><br><span class=\"line\">  <span class=\"attr\">phi</span>: <span class=\"number\">1.61</span>,</span><br><span class=\"line\">  absolute,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后这些文件可以通过<code>require</code>语句导入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> maths = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;maths&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// pi: any</span></span><br><span class=\"line\">maths.<span class=\"property\">pi</span>;</span><br></pre></td></tr></table></figure>\n\n<p>或者你可以使用JavaScript中的析构功能来简化一下：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; squareTwo &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;maths&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// const squareTwo: any</span></span><br><span class=\"line\">squareTwo;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-4-2-CommonJS和ES模块的互操作性\"><a href=\"#9-4-2-CommonJS和ES模块的互操作性\" class=\"headerlink\" title=\"9.4.2 CommonJS和ES模块的互操作性\"></a>9.4.2 CommonJS和ES模块的互操作性</h3><p>关于默认导入和模块命名空间对象导入之间的区别，CommonJS和ES Modules之间存在着功能上的不匹配。</p>\n<p>这个后面章节会详细介绍。</p>\n<h2 id=\"9-5-TypeScript的模块解析选项\"><a href=\"#9-5-TypeScript的模块解析选项\" class=\"headerlink\" title=\"9.5 TypeScript的模块解析选项\"></a>9.5 TypeScript的模块解析选项</h2><p>模块解析是指从<code>import</code>或<code>require</code>语句中获取一个字符串，并确定该字符串所指的文件的过程。</p>\n<p>TypeScript包括两种解析策略。经典和Node。当编译器选项 <code>module</code>不是<code>commonjs</code>时，经典策略是默认的，是为了向后兼容。Node策略复制了Node.js在CommonJS模式下的工作方式，对<code>.ts</code>和<code>.d.ts</code>有额外的检查。</p>\n<p>在TypeScript中，有许多TSConfig标志影响模块策略： <a href=\"https://www.typescriptlang.org/tsconfig#moduleResolution\"><code>moduleResolution</code></a>, <a href=\"https://www.typescriptlang.org/tsconfig#baseUrl\"><code>baseUrl</code></a>, <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a>, <a href=\"https://www.typescriptlang.org/tsconfig#rootDirs\"><code>rootDirs</code></a>.</p>\n<p>关于这些策略如何工作的全部细节，你可以参考《<a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html\">模块解析</a>》。</p>\n<h2 id=\"9-6-TypeScript的模块输出选项\"><a href=\"#9-6-TypeScript的模块输出选项\" class=\"headerlink\" title=\"9.6 TypeScript的模块输出选项\"></a>9.6 TypeScript的模块输出选项</h2><p>有两个选项会影响JavaScript输出：</p>\n<ul>\n<li><code>target</code>，它决定了哪些JS功能被降级（转换为在旧的JavaScript运行时运行），哪些保持不变</li>\n<li><code>module</code>，它决定了哪些代码用于模块之间的相互作用。</li>\n</ul>\n<p>你使用的<code>target</code>是由你期望运行TypeScript代码的JavaScript运行时中的可用功能决定的。这可能是：你支持的最古老的网络浏览器，你期望运行的最低版本的Node.js，或者可能来自于你的运行时的独特约束——比如Electron。</p>\n<p>所有模块之间的通信都是通过模块加载器进行的，编译器选项 <code>module</code> 决定使用哪一个。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖项。</p>\n<p>例如，这里是一个使用ES模块语法的TypeScript文件，展示了<code>module</code>的一些不同选项：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; valueOfPi &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./constants.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> twoPi = valueOfPi * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES2020</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; valueOfPi &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./constants.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> twoPi = valueOfPi * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CommonJS</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(<span class=\"built_in\">exports</span>, <span class=\"string\">&quot;__esModule&quot;</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">twoPi</span> = <span class=\"built_in\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> constants_js_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./constants.js&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">twoPi</span> = constants_js_1.<span class=\"property\">valueOfPi</span> * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h4 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h4></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\">factory</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">module</span> === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v = <span class=\"title function_\">factory</span>(<span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v !== <span class=\"literal\">undefined</span>) <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = v;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; define.<span class=\"property\">amd</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">define</span>([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./constants.js&quot;</span>], factory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(<span class=\"built_in\">exports</span>, <span class=\"string\">&quot;__esModule&quot;</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">twoPi</span> = <span class=\"built_in\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> constants_js_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./constants.js&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">twoPi</span> = constants_js_1.<span class=\"property\">valueOfPi</span> * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>请注意，ES2020实际上与原来的index.ts相同。</p>\n</blockquote>\n<p>你可以在<a href=\"https://www.typescriptlang.org/tsconfig#module\">TSConfig 模块参考</a> 中看到所有可用的选项以及它们发出的JavaScript代码是什么样子。</p>\n<h2 id=\"9-7-TypeScript-命名空间\"><a href=\"#9-7-TypeScript-命名空间\" class=\"headerlink\" title=\"9.7 TypeScript 命名空间\"></a>9.7 TypeScript 命名空间</h2><p>TypeScript有自己的模块格式，称为 <code>命名空间(namespaces)</code>，这比ES模块标准要早。这种语法对于创建复杂的定义文件有很多有用的功能，并且在 <a href=\"https://www.typescriptlang.org/dt\">DefinitelyTyped</a>中仍然被积极使用。虽然没有被废弃，但命名空间中的大部分功能都存在于ES Modules中，我们建议你使用它来与JavaScript的方向保持一致。你可以在 <a href=\"https://www.typescriptlang.org/docs/handbook/namespaces.html\">namespaces参考页</a>中了解更多关于命名空间的信息。</p>\n<p>——基础篇完——</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"九、模块\"><a href=\"#九、模块\" class=\"headerlink\" title=\"九、模块\"></a>九、模块</h1><p>JavaScript有很长的历史，有不同的方式来处理模块化的代码。TypeScript从2012年开始出现，已经实现了对许多这些格式的支持，但随着时间的推移，社区和JavaScript规范已经趋向于一种名为ES模块（或ES6模块）的格式。你可能知道它是<code>import/export</code>语法。</p>\n<p>ES Modules在2015年被加入到JavaScript规范中，到2020年，在大多数网络浏览器和JavaScript运行时中都有广泛的支持。</p>\n<p>为了突出重点，本手册将涵盖ES Modules及其流行的前驱CommonJS <code>module.exports =</code>语法。</p>\n<h2 id=\"9-1-如何定义JavaScript模块\"><a href=\"#9-1-如何定义JavaScript模块\" class=\"headerlink\" title=\"9.1 如何定义JavaScript模块\"></a>9.1 如何定义JavaScript模块</h2><p>在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级<code>import</code>或<code>export</code>的文件都被认为是一个模块。</p>\n<p>相反，一个没有任何顶级导入或导出声明的文件被视为一个脚本，其内容可在全局范围内使用（因此也可用于模块）。</p>\n<p>模块在自己的范围内执行，而不是在全局范围内。这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地用某种导出形式导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用导入的形式将其导入。</p>\n<h2 id=\"9-2-非模块\"><a href=\"#9-2-非模块\" class=\"headerlink\" title=\"9.2 非模块\"></a>9.2 非模块</h2><p>在我们开始之前，重要的是要了解TypeScript认为什么才是模块。JavaScript规范声明，任何没有 <code>export</code>或顶层 <code>await</code> 的JavaScript文件都应该被认为是一个脚本而不是一个模块。</p>\n<p>在一个脚本文件中，变量和类型被声明为在共享的全局范围内，并且假定你会使用<code>outFile</code>编译器选项将多个输入文件加入一个输出文件，或者在你的HTML中使用多个<code>&lt;script&gt;</code>标签来加载这些文件（顺序正确！）。</p>\n<p>如果你有一个目前没有任何导入或导出的文件，但你希望被当作一个模块来处理，请添加这一行：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这将改变该文件，使其成为一个什么都不输出的模块。无论你的模块目标是什么，这个语法都有效。</p>\n<h2 id=\"9-3-TypeScript-中的模块\"><a href=\"#9-3-TypeScript-中的模块\" class=\"headerlink\" title=\"9.3 TypeScript 中的模块\"></a>9.3 TypeScript 中的模块</h2><p>在TypeScript中编写基于模块的代码时，有三个主要方面需要考虑：</p>\n<ul>\n<li><strong>语法：</strong>我想用什么语法来导入和导出东西？</li>\n<li><strong>模块解析：</strong>模块名称（或路径）和磁盘上的文件之间是什么关系？</li>\n<li><strong>模块输出目标：</strong>我编译出来的JavaScript模块应该是什么样子的？</li>\n</ul>\n<h3 id=\"9-3-1-ES模块语法\"><a href=\"#9-3-1-ES模块语法\" class=\"headerlink\" title=\"9.3.1 ES模块语法\"></a>9.3.1 ES模块语法</h3><p>一个文件可以通过<code>export default</code>声明一个主要出口：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: hello.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">helloWorld</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后通过以下方式导入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hello <span class=\"keyword\">from</span> <span class=\"string\">&quot;./hello.js&quot;</span>;</span><br><span class=\"line\"><span class=\"title function_\">hello</span>();</span><br></pre></td></tr></table></figure>\n\n<p>除了默认的导出，你还可以通过省略<code>default</code>的<code>export</code>，实现有一个以上的变量和函数的导出。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: maths.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> pi = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> squareTwo = <span class=\"number\">1.41</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> phi = <span class=\"number\">1.61</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RandomNumberGenerator</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">absolute</span>(<span class=\"params\"><span class=\"attr\">num</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> num * -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些可以通过 <code>import</code> 语法在另一个文件中使用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; pi, phi, absolute &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pi);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const absPhi: number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> absPhi = <span class=\"title function_\">absolute</span>(phi);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-3-2-额外的导入语法\"><a href=\"#9-3-2-额外的导入语法\" class=\"headerlink\" title=\"9.3.2 额外的导入语法\"></a>9.3.2 额外的导入语法</h3><p>可以使用 <code>import &#123;old as new&#125;</code> 这样的格式来重命名一个导入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; pi <span class=\"keyword\">as</span> π &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// (alias)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> π: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"><span class=\"comment\">// import π</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(π);</span><br></pre></td></tr></table></figure>\n\n<p>你可以将上述语法混合并匹配到一个单一的 <code>import</code> 中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: maths.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> pi = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RandomNumberGenerator</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">RNGen</span>, &#123; pi <span class=\"keyword\">as</span> π &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (alias) class RNGen</span></span><br><span class=\"line\"><span class=\"comment\">// import RNGen</span></span><br><span class=\"line\"><span class=\"title class_\">RNGen</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (alias) const π: 3.14</span></span><br><span class=\"line\"><span class=\"comment\">// import π</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(π);</span><br></pre></td></tr></table></figure>\n\n<p>你可以把所有导出的对象，用<code>* as name</code>，把它们放到一个命名空间：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> math <span class=\"keyword\">from</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(math.<span class=\"property\">pi</span>);</span><br><span class=\"line\"><span class=\"comment\">// const positivePhi: number</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> positivePhi = math.<span class=\"title function_\">absolute</span>(math.<span class=\"property\">phi</span>);</span><br></pre></td></tr></table></figure>\n\n<p>你可以通过<code>import &quot;./file &quot;</code>导入一个文件，而不把任何变量纳入你的当前模块：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./maths.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;3.14&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，<code>import</code> 没有任何作用。然而，<code>maths.ts</code>中的所有代码都被解析了，这可能引发影响其他对象的副作用。</p>\n<h3 id=\"9-3-3-TypeScript特定的ES模块语法\"><a href=\"#9-3-3-TypeScript特定的ES模块语法\" class=\"headerlink\" title=\"9.3.3 TypeScript特定的ES模块语法\"></a>9.3.3 TypeScript特定的ES模块语法</h3><p>类型可以使用与JavaScript值相同的语法进行导出和导入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: animal.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Cat</span> = &#123; <span class=\"attr\">breed</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">yearOfBirth</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">breeds</span>: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  <span class=\"attr\">yearOfBirth</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Cat</span>, <span class=\"title class_\">Dog</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./animal.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Animals</span> = <span class=\"title class_\">Cat</span> | <span class=\"title class_\">Dog</span>;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript用两个概念扩展了 <code>import</code> 语法，用于声明一个类型的导入。</p>\n<ul>\n<li><code>import type</code></li>\n</ul>\n<p>这是一个导入语句，只能导入类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: animal.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Cat</span> = &#123; <span class=\"attr\">breed</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">yearOfBirth</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Dog</span> = &#123; <span class=\"attr\">breeds</span>: <span class=\"built_in\">string</span>[]; <span class=\"attr\">yearOfBirth</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createCatName</span> = (<span class=\"params\"></span>) =&gt; <span class=\"string\">&quot;fluffy&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @filename: valid.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; <span class=\"title class_\">Cat</span>, <span class=\"title class_\">Dog</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./animal.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Animals</span> = <span class=\"title class_\">Cat</span> | <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; createCatName &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./animal.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"title function_\">createCatName</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-06.png\" alt=\"image-20211219080726659\" style=\"zoom:67%;\" />\n\n<ul>\n<li><strong>内联类型导入</strong></li>\n</ul>\n<p>TypeScript 4.5还允许以type为前缀的单个导入，以表明导入的引用是一个类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @filename: app.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createCatName, <span class=\"keyword\">type</span> <span class=\"title class_\">Cat</span>, <span class=\"keyword\">type</span> <span class=\"title class_\">Dog</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./animal.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Animals</span> = <span class=\"title class_\">Cat</span> | <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"title function_\">createCatName</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-3-4-ES模块语法与CommonJS行为\"><a href=\"#9-3-4-ES模块语法与CommonJS行为\" class=\"headerlink\" title=\"9.3.4 ES模块语法与CommonJS行为\"></a>9.3.4 ES模块语法与CommonJS行为</h3><p>TypeScript有ES Module语法，它直接与CommonJS和AMD的<code>require</code>相关联。使用ES Module的 <code>import</code> 在大多数情况下与这些环境的<code>require</code>相同，但这种语法确保你在TypeScript文件中与CommonJS的输出有1对1的匹配：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> code = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;hello.ts&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-4-CommonJS-语法\"><a href=\"#9-4-CommonJS-语法\" class=\"headerlink\" title=\"9.4 CommonJS 语法\"></a>9.4 CommonJS 语法</h2><p>CommonJS是npm上大多数模块的交付格式。即使你使用上面的ES模块语法进行编写，对CommonJS语法的工作方式有一个简单的了解也会帮助你更容易地进行调试。</p>\n<h3 id=\"9-4-1-导出\"><a href=\"#9-4-1-导出\" class=\"headerlink\" title=\"9.4.1 导出\"></a>9.4.1 导出</h3><p>标识符是通过在一个全局调用的 <code>module</code> 上设置 <code>exports</code> 属性来导出的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">absolute</span>(<span class=\"params\"><span class=\"attr\">num</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> num * -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">pi</span>: <span class=\"number\">3.14</span>,</span><br><span class=\"line\">  <span class=\"attr\">squareTwo</span>: <span class=\"number\">1.41</span>,</span><br><span class=\"line\">  <span class=\"attr\">phi</span>: <span class=\"number\">1.61</span>,</span><br><span class=\"line\">  absolute,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后这些文件可以通过<code>require</code>语句导入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> maths = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;maths&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// pi: any</span></span><br><span class=\"line\">maths.<span class=\"property\">pi</span>;</span><br></pre></td></tr></table></figure>\n\n<p>或者你可以使用JavaScript中的析构功能来简化一下：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; squareTwo &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;maths&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// const squareTwo: any</span></span><br><span class=\"line\">squareTwo;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-4-2-CommonJS和ES模块的互操作性\"><a href=\"#9-4-2-CommonJS和ES模块的互操作性\" class=\"headerlink\" title=\"9.4.2 CommonJS和ES模块的互操作性\"></a>9.4.2 CommonJS和ES模块的互操作性</h3><p>关于默认导入和模块命名空间对象导入之间的区别，CommonJS和ES Modules之间存在着功能上的不匹配。</p>\n<p>这个后面章节会详细介绍。</p>\n<h2 id=\"9-5-TypeScript的模块解析选项\"><a href=\"#9-5-TypeScript的模块解析选项\" class=\"headerlink\" title=\"9.5 TypeScript的模块解析选项\"></a>9.5 TypeScript的模块解析选项</h2><p>模块解析是指从<code>import</code>或<code>require</code>语句中获取一个字符串，并确定该字符串所指的文件的过程。</p>\n<p>TypeScript包括两种解析策略。经典和Node。当编译器选项 <code>module</code>不是<code>commonjs</code>时，经典策略是默认的，是为了向后兼容。Node策略复制了Node.js在CommonJS模式下的工作方式，对<code>.ts</code>和<code>.d.ts</code>有额外的检查。</p>\n<p>在TypeScript中，有许多TSConfig标志影响模块策略： <a href=\"https://www.typescriptlang.org/tsconfig#moduleResolution\"><code>moduleResolution</code></a>, <a href=\"https://www.typescriptlang.org/tsconfig#baseUrl\"><code>baseUrl</code></a>, <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a>, <a href=\"https://www.typescriptlang.org/tsconfig#rootDirs\"><code>rootDirs</code></a>.</p>\n<p>关于这些策略如何工作的全部细节，你可以参考《<a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html\">模块解析</a>》。</p>\n<h2 id=\"9-6-TypeScript的模块输出选项\"><a href=\"#9-6-TypeScript的模块输出选项\" class=\"headerlink\" title=\"9.6 TypeScript的模块输出选项\"></a>9.6 TypeScript的模块输出选项</h2><p>有两个选项会影响JavaScript输出：</p>\n<ul>\n<li><code>target</code>，它决定了哪些JS功能被降级（转换为在旧的JavaScript运行时运行），哪些保持不变</li>\n<li><code>module</code>，它决定了哪些代码用于模块之间的相互作用。</li>\n</ul>\n<p>你使用的<code>target</code>是由你期望运行TypeScript代码的JavaScript运行时中的可用功能决定的。这可能是：你支持的最古老的网络浏览器，你期望运行的最低版本的Node.js，或者可能来自于你的运行时的独特约束——比如Electron。</p>\n<p>所有模块之间的通信都是通过模块加载器进行的，编译器选项 <code>module</code> 决定使用哪一个。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖项。</p>\n<p>例如，这里是一个使用ES模块语法的TypeScript文件，展示了<code>module</code>的一些不同选项：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; valueOfPi &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./constants.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> twoPi = valueOfPi * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES2020</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; valueOfPi &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./constants.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> twoPi = valueOfPi * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CommonJS</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(<span class=\"built_in\">exports</span>, <span class=\"string\">&quot;__esModule&quot;</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">twoPi</span> = <span class=\"built_in\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> constants_js_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./constants.js&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">twoPi</span> = constants_js_1.<span class=\"property\">valueOfPi</span> * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h4 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h4></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\">factory</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">module</span> === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v = <span class=\"title function_\">factory</span>(<span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v !== <span class=\"literal\">undefined</span>) <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = v;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; define.<span class=\"property\">amd</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">define</span>([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./constants.js&quot;</span>], factory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;use strict&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(<span class=\"built_in\">exports</span>, <span class=\"string\">&quot;__esModule&quot;</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">twoPi</span> = <span class=\"built_in\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> constants_js_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./constants.js&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">twoPi</span> = constants_js_1.<span class=\"property\">valueOfPi</span> * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>请注意，ES2020实际上与原来的index.ts相同。</p>\n</blockquote>\n<p>你可以在<a href=\"https://www.typescriptlang.org/tsconfig#module\">TSConfig 模块参考</a> 中看到所有可用的选项以及它们发出的JavaScript代码是什么样子。</p>\n<h2 id=\"9-7-TypeScript-命名空间\"><a href=\"#9-7-TypeScript-命名空间\" class=\"headerlink\" title=\"9.7 TypeScript 命名空间\"></a>9.7 TypeScript 命名空间</h2><p>TypeScript有自己的模块格式，称为 <code>命名空间(namespaces)</code>，这比ES模块标准要早。这种语法对于创建复杂的定义文件有很多有用的功能，并且在 <a href=\"https://www.typescriptlang.org/dt\">DefinitelyTyped</a>中仍然被积极使用。虽然没有被废弃，但命名空间中的大部分功能都存在于ES Modules中，我们建议你使用它来与JavaScript的方向保持一致。你可以在 <a href=\"https://www.typescriptlang.org/docs/handbook/namespaces.html\">namespaces参考页</a>中了解更多关于命名空间的信息。</p>\n<p>——基础篇完——</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "1-6、基础篇：对象类型",
        "toc": true,
        "swiper_index": 6,
        "swiper_cover": "/img/recommend/recommend_06.jpg",
        "swiper_desc": "1-6、基础篇：对象类型",
        "abbrlink": 59398,
        "date": "2024-01-28T11:41:23.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 六、对象类型\n\n在JavaScript中，我们分组和传递数据的基本方式是通过对象。在TypeScript中，我们通过对象类型来表示这些对象。\n\n正如我们所见，它们可以是匿名的：\n\n```tsx\nfunction greet(person: { name: string; age: number }) {\n  return \"Hello \" + person.name;\n}\n```\n\n或者可以通过使用一个接口来命名它们：\n\n```tsx\ninterface Person {\n  name: string;\n  age: number;\n}\n\nfunction greet(person: Person) {\n  return \"Hello \" + person.name;\n}\n```\n\n或一个类型别名：\n\n```tsx\ntype Person = {\n  name: string;\n  age: number;\n};\n\nfunction greet(person: Person) {\n  return \"Hello \" + person.name;\n}\n```\n\n在上面的三个例子中，我们写了一些函数，这些函数接收包含属性 `name`（必须是一个 `string`）和 `age`（必须是一个 `number`）的对象。\n\n## 6.1 属性修改器\n\n对象类型中的每个属性都可以指定几件事：类型、属性是否是可选的，以及属性是否可以被写入。\n\n### 6.1.1 可选属性\n\n很多时候，我们会发现自己处理的对象可能有一个属性设置。在这些情况下，我们可以在这些属性的名字后面加上一个问号（？），把它们标记为可选的。\n\n```tsx\ntype Shape = {};\n\ninterface PaintOptions {\n  shape: Shape;\n  xPos?: number;\n  yPos?: number;\n}\n\nfunction paintShape(opts: PaintOptions) {\n  // ...\n}\n\nconst shape: Shape = {};\npaintShape({ shape });\npaintShape({ shape, xPos: 100 });\npaintShape({ shape, yPos: 100 });\npaintShape({ shape, xPos: 100, yPos: 100 });\n```\n\n在这个例子中，`xPos`和`yPos`都被认为是可选的。我们可以选择提供它们中的任何一个，所以上面对`paintShape`的每个调用都是有效的。所有的可选性实际上是说，如果属性被设置，它最好有一个特定的类型。\n\n我们也可以从这些属性中读取，但当我们在`strictNullChecks`下读取时，TypeScript会告诉我们它们可能是未定义的。\n\n```tsx\nfunction paintShape(opts: PaintOptions) {\n  let xPos = opts.xPos;\n  let yPos = opts.yPos;\n  // ...\n}\n```\n\n在JavaScript中，即使该属性从未被设置过，我们仍然可以访问它--它只是会给我们未定义的值。我们可以专门处理未定义。\n\n```tsx\nfunction paintShape(opts: PaintOptions) {\n  let xPos = opts.xPos === undefined ? 0 : opts.xPos;\n  let yPos = opts.yPos === undefined ? 0 : opts.yPos;\n  // ...\n}\n```\n\n请注意，这种为未指定的值设置默认值的模式非常普遍，以至于JavaScript有语法来支持它。\n\n```tsx\nfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {\n  console.log(\"x coordinate at\", xPos);\n  console.log(\"y coordinate at\", yPos);\n  // ...\n}\n```\n\n在这里，我们为 `paintShape` 的参数使用了一个解构模式，并为 `xPos` 和 `yPos` 提供了默认值。现在 `xPos` 和 `yPos` 都肯定存在于 `paintShape` 的主体中，但对于 `paintShape` 的任何调用者来说是可选的。\n\n> 请注意，目前还没有办法将类型注释放在解构模式中。这是因为下面的语法在JavaScript中已经有了不同的含义。\n\n```tsx\nfunction draw({ shape: Shape, xPos: number = 100 /*...*/ }) {\n  render(shape);\n  render(xPos);\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/GItsFTdQPJl9Svf.png\" alt=\"image-20211127082617191\" style=\"zoom:50%;\" />\n\n在一个对象解构模式中，`shape: Shape` 意味着 \"获取属性 `shape`，并在本地重新定义为一个名为 `Shape` 的变量。同样，`xPos: number` 创建一个名为number的变量，其值基于参数的 `xPos`。\n\n### 6.1.2 只读属性\n\n对于TypeScript，属性也可以被标记为只读。虽然它不会在运行时改变任何行为，但在类型检查期间，一个标记为只读的属性不能被写入。\n\n```tsx\ninterface SomeType {\n  readonly prop: string;\n}\n\nfunction doSomething(obj: SomeType) {\n  // 可以读取 'obj.prop'.\n  console.log(`prop has the value '${obj.prop}'.`);\n\n  // 但不能重新设置值\n  obj.prop = \"hello\";\n}\n```\n\n<img src=\"/img/TypeScript/06-02.png\" alt=\"image-20211127083551809\" style=\"zoom:50%;\" />\n\n使用 `readonly` 修饰符并不一定意味着一个值是完全不可改变的。或者换句话说，它的内部内容不能被改变，它只是意味着该属性本身不能被重新写入。\n\n```tsx\ninterface Home {\n  readonly resident: { name: string; age: number };\n}\n\nfunction visitForBirthday(home: Home) {\n  // 我们可以从'home.resident'读取和更新属性。\n  console.log(`Happy birthday ${home.resident.name}!`);\n  home.resident.age++;\n}\n\nfunction evict(home: Home) {\n  // 但是我们不能写到'home'上的'resident'属性本身。\n  home.resident = {\n    name: \"Victor the Evictor\",\n    age: 42,\n  };\n}\n```\n\n<img src=\"/img/TypeScript/06-03.png\" alt=\"image-20211127084012491\" style=\"zoom:50%;\" />\n\n管理对 `readonly` 含义的预期是很重要的。在TypeScript的开发过程中，对于一个对象应该如何被使用的问题，它是有用的信号。TypeScript在检查两个类型的属性是否兼容时，并不考虑这些类型的属性是否是 `readonly`，所以 `readony` 属性也可以通过别名来改变。\n\n```tsx\ninterface Person {\n  name: string;\n  age: number;\n}\n\ninterface ReadonlyPerson {\n  readonly name: string;\n  readonly age: number;\n}\n\nlet writablePerson: Person = {\n  name: \"Person McPersonface\",\n  age: 42,\n};\n\n// 正常工作\nlet readonlyPerson: ReadonlyPerson = writablePerson;\n\nconsole.log(readonlyPerson.age); // 打印 '42'\nwritablePerson.age++;\nconsole.log(readonlyPerson.age); // 打印 '43'\n```\n\n### 6.1.3 索引签名\n\n有时你并不提前知道一个类型的所有属性名称，但你知道值的形状。\n\n在这些情况下，你可以使用一个索引签名来描述可能的值的类型，比如说：\n\n```tsx\ninterface StringArray {\n  [index: number]: string;\n}\n\nconst myArray: StringArray = [\"a\", \"b\"];\nconst secondItem = myArray[1];\n```\n\n上面，我们有一个 `StringArray` 接口，它有一个索引签名。这个索引签名指出，当一个 `StringArray` 被数字索引时，它将返回一个字符串。\n\n索引签名的属性类型必须是 `string` 或 `number`。\n\n支持两种类型的索引器是可能的，但是从数字索引器返回的类型必须是字符串索引器返回的类型的子类型。这是因为当用 \"数字 \"进行索引时，JavaScript实际上会在索引到一个对象之前将其转换为 \"字符串\"。这意味着用`100`（一个`数字`）进行索引和用`\"100\"`（一个`字符串`）进行索引是一样的，所以两者需要一致。\n\n```tsx\ninterface Animal {\n  name: string;\n}\n\ninterface Dog extends Animal {\n  breed: string;\n}\n\ninterface NotOkay {\n  [x: number]: Animal;\n  [x: string]: Dog;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/a2rzdbJlqtuoXFw.png\" alt=\"image-20211127090502640\" style=\"zoom:50%;\" />\n\n虽然字符串索引签名是描述 \"字典 \"模式的一种强大方式，但它也强制要求所有的属性与它们的返回类型相匹配。这是因为字符串索引声明 `obj.property` 也可以作为 `obj[\"property\"]`。在下面的例子中，`name`的类型与字符串索引的类型不匹配，类型检查器会给出一个错误：\n\n```tsx\ninterface NumberDictionary {\n  [index: string]: number;\n\n  length: number; // ok\n  name: string;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/AzHPBUGvK5JbQpw.png\" alt=\"image-20211127091044224\" style=\"zoom:50%;\" />\n\n然而，如果索引签名是属性类型的联合，不同类型的属性是可以接受的：\n\n```tsx\ninterface NumberOrStringDictionary {\n  [index: string]: number | string;\n  length: number; // 正确, length 是 number 类型\n  name: string; // 正确, name 是 string 类型\n}\n```\n\n最后，你可以使索引签名为只读，以防止对其索引的赋值：\n\n```tsx\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\n\nlet myArray: ReadonlyStringArray = getReadOnlyStringArray();\nmyArray[2] = \"Mallory\";\n```\n\n<img src=\"/img/TypeScript/06-06.png\" alt=\"image-20211127091423550\" style=\"zoom:50%;\" />\n\n你不能设置 `myArray[2]`，因为这个索引签名是只读的。\n\n## 6.2 扩展类型\n\n有一些类型可能是其他类型的更具体的版本，这是很常见的。例如，我们可能有一个`BasicAddress`类型，描述发送信件和包裹所需的字段。\n\n```tsx\ninterface BasicAddress {\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n```\n\n在某些情况下，这就足够了，但是如果一个地址的小区内有多个单元，那么地址往往有一个单元号与之相关。我们就可以描述一个 `AddressWithUnit`：\n\n```tsx\ninterface AddressWithUnit {\n  name?: string;\n  unit: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n```\n\n这就完成了工作，但这里的缺点是，当我们的变化是纯粹的加法时，我们不得不重复 `BasicAddress` 的所有其他字段。相反，我们可以扩展原始的 `BasicAddress` 类型，只需添加 `AddressWithUnit` 特有的新字段：\n\n```tsx\ninterface BasicAddress {\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n\ninterface AddressWithUnit extends BasicAddress {\n  unit: string;\n}\n```\n\n接口上的 `extends` 关键字，允许我们有效地从其他命名的类型中复制成员，并添加我们想要的任何新成员。这对于减少我们不得不写的类型声明模板，以及表明同一属性的几个不同声明可能是相关的意图来说，是非常有用的。例如，`AddressWithUnit` 不需要重复 `street` 属性，而且因为 `street` 源于 `BasicAddress`，我们会知道这两种类型在某种程度上是相关的。\n\n接口也可以从多个类型中扩展。\n\n```tsx\ninterface Colorful {\n  color: string;\n}\n\ninterface Circle {\n  radius: number;\n}\n\ninterface ColorfulCircle extends Colorful, Circle {}\n\nconst cc: ColorfulCircle = {\n  color: \"red\",\n  radius: 42,\n};\n```\n\n## 6.3 交叉类型\n\n接口允许我们通过扩展其他类型建立起新的类型。TypeScript提供了另一种结构，称为交叉类型，主要用于组合现有的对象类型。\n\n交叉类型是用 `&` 操作符定义的。\n\n```tsx\ninterface Colorful {\n  color: string;\n}\ninterface Circle {\n  radius: number;\n}\n\ntype ColorfulCircle = Colorful & Circle;\n\nconst cc: ColorfulCircle = {\n  color: \"red\",\n  radius: 42,\n};\n```\n\n在这里，我们将 `Colorful` 和 `Circle` 相交，产生了一个新的类型，它拥有 `Colorful` 和 `Circle` 的所有成员。\n\n```tsx\nfunction draw(circle: Colorful & Circle) {\n  console.log(`Color was ${circle.color}`);\n  console.log(`Radius was ${circle.radius}`);\n}\n\n// 正确\ndraw({ color: \"blue\", radius: 42 });\n\n// 错误\ndraw({ color: \"red\", raidus: 42 });\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/EwehSBGIodpYQfj.png\" alt=\"image-20211127095046044\" style=\"zoom:50%;\" />\n\n## 6.7 接口与交叉类型\n\n我们刚刚看了两种组合类型的方法，它们很相似，但实际上有细微的不同。对于接口，我们可以使用 `extends`子句来扩展其他类型，而对于交叉类型，我们也可以做类似的事情，并用类型别名来命名结果。两者之间的主要区别在于如何处理冲突，这种区别通常是你在接口和交叉类型的类型别名之间选择一个的主要原因之一。\n\n<img src=\"https://s2.loli.net/2022/02/22/tYex2cry6HGUgfT.png\" alt=\"image-20211127101912142\" style=\"zoom:50%;\" />\n\n接口可以定义多次，多次的声明会自动合并：\n\n```tsx\ninterface Sister {\n  name: string;\n}\ninterface Sister {\n  age: number;\n}\n\nconst sisterAn: Sister = {\n  name: \"sisterAn\",\n};\n\nconst sisterRan: Sister = {\n  name: \"sisterRan\",\n  age: 12,\n};\n```\n\n<img src=\"/img/TypeScript/06-09.png\" alt=\"image-20211127102424559\" style=\"zoom:50%;\" />\n\n但是类型别名如果定义多次，会报错：\n\n```tsx\ntype Sister = {\n  name: string;\n};\n\ntype Sister = {\n  age: number;\n};\n```\n\n<img src=\"/img/TypeScript/06-10.png\" alt=\"image-20211127102801182\" style=\"zoom:50%;\" />\n\n## 6.8 泛型对象类型\n\n让我们想象一下，一个可以包含任何数值的盒子类型：字符串、数字、长颈鹿，等等。\n\n```tsx\ninterface Box {\n  contents: any;\n}\n```\n\n现在，内容属性的类型是任意，这很有效，但会导致下一步的意外。\n\n我们可以使用 `unknown`，但这意味着在我们已经知道内容类型的情况下，我们需要做预防性检查，或者使用容易出错的类型断言。\n\n```tsx\ninterface Box {\n  contents: unknown;\n}\n\nlet x: Box = {\n  contents: \"hello world\",\n};\n\n// 我们需要检查 'x.contents'\nif (typeof x.contents === \"string\") {\n  console.log(x.contents.toLowerCase());\n}\n\n// 或者用类型断言\nconsole.log((x.contents as string).toLowerCase());\n```\n\n一种安全的方法是为每一种类型的内容搭建不同的盒子类型：\n\n```tsx\ninterface NumberBox {\n  contents: number;\n}\n\ninterface StringBox {\n  contents: string;\n}\n\ninterface BooleanBox {\n  contents: boolean;\n}\n```\n\n但这意味着我们必须创建不同的函数，或函数的重载，以对这些类型进行操作：\n\n```tsx\nfunction setContents(box: StringBox, newContents: string): void;\nfunction setContents(box: NumberBox, newContents: number): void;\nfunction setContents(box: BooleanBox, newContents: boolean): void;\nfunction setContents(box: { contents: any }, newContents: any) {\n  box.contents = newContents;\n}\n```\n\n那是一个很大的模板。此外，我们以后可能需要引入新的类型和重载。这是令人沮丧的，因为我们的盒子类型和重载实际上都是一样的。\n\n相反，我们可以做一个通用的 `Box` 类型，声明一个类型参数：\n\n```tsx\ninterface Box<Type> {\n  contents: Type;\n}\n```\n\n你可以把这句话理解为：\"一个类型的盒子，是它的内容具有类型的东西\"。以后，当我们引用 `Box` 时，我们必须给一个类型参数来代替 ` Type`。\n\n```tsx\nlet box: Box<string>;\n```\n\n把 `Box` 想象成一个真实类型的模板，其中 `Type` 是一个占位符，会被替换成其他类型。当 TypeScript 看到 `Box<string>` 时，它将用字符串替换 `Box<Type>` 中的每个 `Type` 实例，并最终以 `{ contents: string }` 这样的方式工作。换句话说，`Box<string>`和我们之前的`StringBox`工作起来是一样的。\n\n```tsx\ninterface Box<Type> {\n  contents: Type;\n}\ninterface StringBox {\n  contents: string;\n}\n\nlet boxA: Box<string> = { contents: \"hello\" };\nboxA.contents;\n\nlet boxB: StringBox = { contents: \"world\" };\nboxB.contents;\n```\n\n盒子是可重用的，因为Type可以用任何东西来代替。这意味着当我们需要一个新类型的盒子时，我们根本不需要声明一个新的盒子类型（尽管如果我们想的话，我们当然可以）。\n\n```tsx\ninterface Box<Type> {\n  contents: Type;\n}\n\ninterface Apple {\n  // ....\n}\n\n// 等价于 '{ contents: Apple }'.\ntype AppleBox = Box<Apple>;\n```\n\n这也意味着我们可以完全避免重载，而是使用通用函数。\n\n```tsx\nfunction setContents<Type>(box: Box<Type>, newContents: Type) {\n  box.contents = newContents;\n}\n```\n\n值得注意的是，类型别名也可以是通用的。我们可以定义我们新的 `Box<Type>`接口：\n\n```tsx\ninterface Box<Type> {\n  contents: Type;\n}\n```\n\n通过使用一个类型别名来代替：\n\n```tsx\ntype Box<Type> = {\n  contents: Type;\n};\n```\n\n由于类型别名与接口不同，它不仅可以描述对象类型，我们还可以用它来编写其他类型的通用辅助类型。\n\n```tsx\ntype OrNull<Type> = Type | null;\n\ntype OneOrMany<Type> = Type | Type[];\n\ntype OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;\n\ntype OneOrManyOrNullStrings = OneOrManyOrNull<string>;\n```\n\n我们将在稍后回到类型别名。\n\n通用对象类型通常是某种容器类型，它的工作与它们所包含的元素类型无关。数据结构以这种方式工作是很理想的，这样它们就可以在不同的数据类型中重复使用。\n\n## 6.9 数组类型\n\n我们一直在使用这样一种类型：数组类型。每当我们写出 `number[]` 或 `string[]` 这样的类型时，这实际上只是 `Array<number>`和`Array<string>`的缩写。\n\n```tsx\nfunction doSomething(value: Array<string>) {\n  // ...\n}\n\nlet myArray: string[] = [\"hello\", \"world\"];\n\n// 这两样都能用\ndoSomething(myArray);\ndoSomething(new Array(\"hello\", \"world\"));\n```\n\n和上面的 `Box` 类型一样，`Array` 本身也是一个通用类型。\n\n```tsx\ninterface Array<Type> {\n  /**\n   * 获取或设置数组的长度。\n   */\n  length: number;\n\n  /**\n   * 移除数组中的最后一个元素并返回。\n   */\n  pop(): Type | undefined;\n\n  /**\n   * 向一个数组添加新元素，并返回数组的新长度。\n   */\n  push(...items: Type[]): number;\n\n  // ...\n}\n```\n\n现代JavaScript还提供了其他通用的数据结构，比如 `Map<K, V> `, `Set<T>`, 和 `Promise<T>`。这实际上意味着，由于`Map`、`Set`和`Promise`的行为方式，它们可以与任何类型的集合一起工作。\n\n## 6.10 只读数组类型\n\n`ReadonlyArray`是一个特殊的类型，描述了不应该被改变的数组。\n\n```tsx\nfunction doStuff(values: ReadonlyArray<string>) {\n  // 我们可以从 'values' 读数据...\n  const copy = values.slice();\n  console.log(`第一个值是 ${values[0]}`);\n\n  // ...但我们不能改变 'vulues' 的值。\n  values.push(\"hello!\");\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/bBVuXOf5oQqIMgG.png\" alt=\"image-20211127191529424\" style=\"zoom:50%;\" />\n\n和属性的 `readonly` 修饰符一样，它主要是一个我们可以用来了解意图的工具。当我们看到一个返回`ReadonlyArrays` 的函数时，它告诉我们我们根本不打算改变其内容，而当我们看到一个消耗 `ReadonlyArrays`的函数时，它告诉我们可以将任何数组传入该函数，而不用担心它会改变其内容。\n\n与 `Array` 不同，没有一个我们可以使用的 `ReadonlyArray`构造函数。\n\n```tsx\nnew ReadonlyArray(\"red\", \"green\", \"blue\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/3S2e6YC9UQKbGNy.png\" alt=\"image-20211127191946986\" style=\"zoom: 67%;\" />\n\n相反，我们可以将普通的 `Array` 分配给 `ReadonlyArray`。\n\n```tsx\nconst roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];\n```\n\n正如 TypeScript为 `Array<Type>` 提供了 `Type[]` 的速记语法一样，它也为 `ReadonlyArray<Type>`提供了只读`Type[]`的速记语法。\n\n```tsx\nfunction doStuff(values: readonly string[]) {\n  // 我们可以从 'values' 读数据...\n  const copy = values.slice();\n  console.log(`The first value is ${values[0]}`);\n\n  // 但我们不能改变 'vulues' 的值。\n  values.push(\"hello!\");\n}\n```\n\n![image-20211127192458009](https://s2.loli.net/2022/02/22/TngAvtrq5W1LQhc.png)\n\n最后要注意的是，与 `readony` 属性修改器不同，可分配性在普通 `Array` 和 `ReadonlyArray` 之间不是双向的。\n\n```tsx\nlet x: readonly string[] = [];\nlet y: string[] = [];\n\nx = y;\ny = x;\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/fwveBsiLpA7FqNK.png\" alt=\"image-20211127192932203\" style=\"zoom:50%;\" />\n\n## 6.11 元组类型\n\n`Tuple` 类型是另一种 `Array` 类型，它确切地知道包含多少个元素，以及它在特定位置包含哪些类型。\n\n```tsx\ntype StringNumberPair = [string, number];\n```\n\n这里，`StringNumberPair` 是一个 `string` 和 `number` 的元组类型。像 `ReadonlyArray` 一样，它在运行时没有表示，但对TypeScript来说是重要的。对于类型系统来说，`StringNumberPair` 描述了其 索引 0 包含字符串和 索引1 包含数字的数组。\n\n```tsx\nfunction doSomething(pair: [string, number]) {\n  const a = pair[0];\n  const b = pair[1];\n  // ...\n}\n\ndoSomething([\"hello\", 42]);\n```\n\n如果我们试图索引超过元素的数量，我们会得到一个错误：\n\n```tsx\nfunction doSomething(pair: [string, number]) {\n  const c = pair[2];\n}\n```\n\n![image-20211127202845783](https://s2.loli.net/2022/02/22/9nMPvE3DZpdRuTA.png)\n\n我们还可以使用JavaScript的数组析构来对元组进行解构。\n\n```tsx\nfunction doSomething(stringHash: [string, number]) {\n  const [inputString, hash] = stringHash;\n\n  console.log(inputString);\n\n  console.log(hash);\n}\n```\n\n除了这些长度检查，像这样的简单元组类型等同于 `Array` 的版本，它为特定的索引声明属性，并且用数字字面类型声明长度。\n\n```tsx\ninterface StringNumberPair {\n  // 专有属性\n  length: 2;\n  0: string;\n  1: number;\n\n  // 其他 'Array<string | number>' 成员...\n  slice(start?: number, end?: number): Array<string | number>;\n}\n```\n\n另一件你可能感兴趣的事情是，元组可以通过在元素的类型后面写出问号（？）—— 可选的元组，元素只能出现在末尾，而且还影响到长度的类型。\n\n```tsx\ntype Either2dOr3d = [number, number, number?];\n\nfunction setCoordinate(coord: Either2dOr3d) {\n  const [x, y, z] = coord;\n  console.log(`提供的坐标有 ${coord.length} 个维度`);\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/fPVJp1tlRhyHYsW.png\" alt=\"image-20211127204518693\" style=\"zoom:50%;\" />\n\n图元也可以有其余元素，这些元素必须是 `array/tuple` 类型。\n\n```tsx\ntype StringNumberBooleans = [string, number, ...boolean[]];\ntype StringBooleansNumber = [string, ...boolean[], number];\ntype BooleansStringNumber = [...boolean[], string, number];\n```\n\n- `StringNumberBooleans` 描述了一个元组，其前两个元素分别是字符串和数字，但后面可以有任意数量的布尔。\n\n- `StringBooleansNumber` 描述了一个元组，其第一个元素是字符串，然后是任意数量的布尔运算，最后是一个数字。\n\n- `BooleansStringNumber` 描述了一个元组，其起始元素是任意数量的布尔运算，最后是一个字符串，然后是一个数字。\n\n一个有其余元素的元组没有集合的 \"长度\"——它只有一组不同位置的知名元素。\n\n```tsx\nconst a: StringNumberBooleans = [\"hello\", 1];\nconst b: StringNumberBooleans = [\"beautiful\", 2, true];\nconst c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];\n```\n\n为什么可选元素和其余元素可能是有用的？它允许TypeScript将 `tuples` 与参数列表相对应。\n\n```tsx\nfunction readButtonInput(...args: [string, number, ...boolean[]]) {\n  const [name, version, ...input] = args;\n  // ...\n}\n```\n\n基本上等同于：\n\n```tsx\nfunction readButtonInput(name: string, version: number, ...input: boolean[]) {\n  // ...\n}\n```\n\n当你想用一个其余(rest)参数接受可变数量的参数，并且你需要一个最小的元素数量，但你不想引入中间变量时，这很方便。\n\n## 6.12 只读元组类型\n\n关于 `tuple` 类型的最后一点说明：`tuple` 类型有只读特性，可以通过在它们前面粘贴一个`readonly`修饰符来指定——就像数组的速记语法一样。\n\n```tsx\nfunction doSomething(pair: readonly [string, number]) {\n  // ...\n}\n```\n\n正如你所期望的，在TypeScript中不允许向只读元组的任何属性写入。\n\n```tsx\nfunction doSomething(pair: readonly [string, number]) {\n  pair[0] = \"hello!\";\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/mZUgrFvnJG2a9Qw.png\" alt=\"image-20211127210344032\" style=\"zoom:50%;\" />\n\n在大多数代码中，元组往往被创建并不被修改，所以在可能的情况下，将类型注释为只读元组是一个很好的默认。这一点也很重要，因为带有 `const` 断言的数组字面量将被推断为只读元组类型。\n\n```tsx\nlet point = [3, 4] as const;\n\nfunction distanceFromOrigin([x, y]: [number, number]) {\n  return Math.sqrt(x ** 2 + y ** 2);\n}\n\ndistanceFromOrigin(point);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/GOd6ieyPvTsaxrw.png\" alt=\"image-20211127210654160\" style=\"zoom:50%;\" />\n\n在这里，`distanceFromOrigin` 从未修改过它的元素，而是期望一个可变的元组。由于 `point`的类型被推断为只读的 `[3, 4]`，它与 `[number, number]` 不兼容，因为该类型不能保证 `point` 的元素不被修改。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-6、基础篇：对象类型.md",
        "raw": "---\ntitle: 1-6、基础篇：对象类型\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nswiper_index: 6\nswiper_cover: /img/recommend/recommend_06.jpg\nswiper_desc: 1-6、基础篇：对象类型\nabbrlink: 59398\ndate: 2024-01-28 19:41:23\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 六、对象类型\n\n在JavaScript中，我们分组和传递数据的基本方式是通过对象。在TypeScript中，我们通过对象类型来表示这些对象。\n\n正如我们所见，它们可以是匿名的：\n\n```tsx\nfunction greet(person: { name: string; age: number }) {\n  return \"Hello \" + person.name;\n}\n```\n\n或者可以通过使用一个接口来命名它们：\n\n```tsx\ninterface Person {\n  name: string;\n  age: number;\n}\n\nfunction greet(person: Person) {\n  return \"Hello \" + person.name;\n}\n```\n\n或一个类型别名：\n\n```tsx\ntype Person = {\n  name: string;\n  age: number;\n};\n\nfunction greet(person: Person) {\n  return \"Hello \" + person.name;\n}\n```\n\n在上面的三个例子中，我们写了一些函数，这些函数接收包含属性 `name`（必须是一个 `string`）和 `age`（必须是一个 `number`）的对象。\n\n## 6.1 属性修改器\n\n对象类型中的每个属性都可以指定几件事：类型、属性是否是可选的，以及属性是否可以被写入。\n\n### 6.1.1 可选属性\n\n很多时候，我们会发现自己处理的对象可能有一个属性设置。在这些情况下，我们可以在这些属性的名字后面加上一个问号（？），把它们标记为可选的。\n\n```tsx\ntype Shape = {};\n\ninterface PaintOptions {\n  shape: Shape;\n  xPos?: number;\n  yPos?: number;\n}\n\nfunction paintShape(opts: PaintOptions) {\n  // ...\n}\n\nconst shape: Shape = {};\npaintShape({ shape });\npaintShape({ shape, xPos: 100 });\npaintShape({ shape, yPos: 100 });\npaintShape({ shape, xPos: 100, yPos: 100 });\n```\n\n在这个例子中，`xPos`和`yPos`都被认为是可选的。我们可以选择提供它们中的任何一个，所以上面对`paintShape`的每个调用都是有效的。所有的可选性实际上是说，如果属性被设置，它最好有一个特定的类型。\n\n我们也可以从这些属性中读取，但当我们在`strictNullChecks`下读取时，TypeScript会告诉我们它们可能是未定义的。\n\n```tsx\nfunction paintShape(opts: PaintOptions) {\n  let xPos = opts.xPos;\n  let yPos = opts.yPos;\n  // ...\n}\n```\n\n在JavaScript中，即使该属性从未被设置过，我们仍然可以访问它--它只是会给我们未定义的值。我们可以专门处理未定义。\n\n```tsx\nfunction paintShape(opts: PaintOptions) {\n  let xPos = opts.xPos === undefined ? 0 : opts.xPos;\n  let yPos = opts.yPos === undefined ? 0 : opts.yPos;\n  // ...\n}\n```\n\n请注意，这种为未指定的值设置默认值的模式非常普遍，以至于JavaScript有语法来支持它。\n\n```tsx\nfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {\n  console.log(\"x coordinate at\", xPos);\n  console.log(\"y coordinate at\", yPos);\n  // ...\n}\n```\n\n在这里，我们为 `paintShape` 的参数使用了一个解构模式，并为 `xPos` 和 `yPos` 提供了默认值。现在 `xPos` 和 `yPos` 都肯定存在于 `paintShape` 的主体中，但对于 `paintShape` 的任何调用者来说是可选的。\n\n> 请注意，目前还没有办法将类型注释放在解构模式中。这是因为下面的语法在JavaScript中已经有了不同的含义。\n\n```tsx\nfunction draw({ shape: Shape, xPos: number = 100 /*...*/ }) {\n  render(shape);\n  render(xPos);\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/GItsFTdQPJl9Svf.png\" alt=\"image-20211127082617191\" style=\"zoom:50%;\" />\n\n在一个对象解构模式中，`shape: Shape` 意味着 \"获取属性 `shape`，并在本地重新定义为一个名为 `Shape` 的变量。同样，`xPos: number` 创建一个名为number的变量，其值基于参数的 `xPos`。\n\n### 6.1.2 只读属性\n\n对于TypeScript，属性也可以被标记为只读。虽然它不会在运行时改变任何行为，但在类型检查期间，一个标记为只读的属性不能被写入。\n\n```tsx\ninterface SomeType {\n  readonly prop: string;\n}\n\nfunction doSomething(obj: SomeType) {\n  // 可以读取 'obj.prop'.\n  console.log(`prop has the value '${obj.prop}'.`);\n\n  // 但不能重新设置值\n  obj.prop = \"hello\";\n}\n```\n\n<img src=\"/img/TypeScript/06-02.png\" alt=\"image-20211127083551809\" style=\"zoom:50%;\" />\n\n使用 `readonly` 修饰符并不一定意味着一个值是完全不可改变的。或者换句话说，它的内部内容不能被改变，它只是意味着该属性本身不能被重新写入。\n\n```tsx\ninterface Home {\n  readonly resident: { name: string; age: number };\n}\n\nfunction visitForBirthday(home: Home) {\n  // 我们可以从'home.resident'读取和更新属性。\n  console.log(`Happy birthday ${home.resident.name}!`);\n  home.resident.age++;\n}\n\nfunction evict(home: Home) {\n  // 但是我们不能写到'home'上的'resident'属性本身。\n  home.resident = {\n    name: \"Victor the Evictor\",\n    age: 42,\n  };\n}\n```\n\n<img src=\"/img/TypeScript/06-03.png\" alt=\"image-20211127084012491\" style=\"zoom:50%;\" />\n\n管理对 `readonly` 含义的预期是很重要的。在TypeScript的开发过程中，对于一个对象应该如何被使用的问题，它是有用的信号。TypeScript在检查两个类型的属性是否兼容时，并不考虑这些类型的属性是否是 `readonly`，所以 `readony` 属性也可以通过别名来改变。\n\n```tsx\ninterface Person {\n  name: string;\n  age: number;\n}\n\ninterface ReadonlyPerson {\n  readonly name: string;\n  readonly age: number;\n}\n\nlet writablePerson: Person = {\n  name: \"Person McPersonface\",\n  age: 42,\n};\n\n// 正常工作\nlet readonlyPerson: ReadonlyPerson = writablePerson;\n\nconsole.log(readonlyPerson.age); // 打印 '42'\nwritablePerson.age++;\nconsole.log(readonlyPerson.age); // 打印 '43'\n```\n\n### 6.1.3 索引签名\n\n有时你并不提前知道一个类型的所有属性名称，但你知道值的形状。\n\n在这些情况下，你可以使用一个索引签名来描述可能的值的类型，比如说：\n\n```tsx\ninterface StringArray {\n  [index: number]: string;\n}\n\nconst myArray: StringArray = [\"a\", \"b\"];\nconst secondItem = myArray[1];\n```\n\n上面，我们有一个 `StringArray` 接口，它有一个索引签名。这个索引签名指出，当一个 `StringArray` 被数字索引时，它将返回一个字符串。\n\n索引签名的属性类型必须是 `string` 或 `number`。\n\n支持两种类型的索引器是可能的，但是从数字索引器返回的类型必须是字符串索引器返回的类型的子类型。这是因为当用 \"数字 \"进行索引时，JavaScript实际上会在索引到一个对象之前将其转换为 \"字符串\"。这意味着用`100`（一个`数字`）进行索引和用`\"100\"`（一个`字符串`）进行索引是一样的，所以两者需要一致。\n\n```tsx\ninterface Animal {\n  name: string;\n}\n\ninterface Dog extends Animal {\n  breed: string;\n}\n\ninterface NotOkay {\n  [x: number]: Animal;\n  [x: string]: Dog;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/a2rzdbJlqtuoXFw.png\" alt=\"image-20211127090502640\" style=\"zoom:50%;\" />\n\n虽然字符串索引签名是描述 \"字典 \"模式的一种强大方式，但它也强制要求所有的属性与它们的返回类型相匹配。这是因为字符串索引声明 `obj.property` 也可以作为 `obj[\"property\"]`。在下面的例子中，`name`的类型与字符串索引的类型不匹配，类型检查器会给出一个错误：\n\n```tsx\ninterface NumberDictionary {\n  [index: string]: number;\n\n  length: number; // ok\n  name: string;\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/AzHPBUGvK5JbQpw.png\" alt=\"image-20211127091044224\" style=\"zoom:50%;\" />\n\n然而，如果索引签名是属性类型的联合，不同类型的属性是可以接受的：\n\n```tsx\ninterface NumberOrStringDictionary {\n  [index: string]: number | string;\n  length: number; // 正确, length 是 number 类型\n  name: string; // 正确, name 是 string 类型\n}\n```\n\n最后，你可以使索引签名为只读，以防止对其索引的赋值：\n\n```tsx\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\n\nlet myArray: ReadonlyStringArray = getReadOnlyStringArray();\nmyArray[2] = \"Mallory\";\n```\n\n<img src=\"/img/TypeScript/06-06.png\" alt=\"image-20211127091423550\" style=\"zoom:50%;\" />\n\n你不能设置 `myArray[2]`，因为这个索引签名是只读的。\n\n## 6.2 扩展类型\n\n有一些类型可能是其他类型的更具体的版本，这是很常见的。例如，我们可能有一个`BasicAddress`类型，描述发送信件和包裹所需的字段。\n\n```tsx\ninterface BasicAddress {\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n```\n\n在某些情况下，这就足够了，但是如果一个地址的小区内有多个单元，那么地址往往有一个单元号与之相关。我们就可以描述一个 `AddressWithUnit`：\n\n```tsx\ninterface AddressWithUnit {\n  name?: string;\n  unit: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n```\n\n这就完成了工作，但这里的缺点是，当我们的变化是纯粹的加法时，我们不得不重复 `BasicAddress` 的所有其他字段。相反，我们可以扩展原始的 `BasicAddress` 类型，只需添加 `AddressWithUnit` 特有的新字段：\n\n```tsx\ninterface BasicAddress {\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n\ninterface AddressWithUnit extends BasicAddress {\n  unit: string;\n}\n```\n\n接口上的 `extends` 关键字，允许我们有效地从其他命名的类型中复制成员，并添加我们想要的任何新成员。这对于减少我们不得不写的类型声明模板，以及表明同一属性的几个不同声明可能是相关的意图来说，是非常有用的。例如，`AddressWithUnit` 不需要重复 `street` 属性，而且因为 `street` 源于 `BasicAddress`，我们会知道这两种类型在某种程度上是相关的。\n\n接口也可以从多个类型中扩展。\n\n```tsx\ninterface Colorful {\n  color: string;\n}\n\ninterface Circle {\n  radius: number;\n}\n\ninterface ColorfulCircle extends Colorful, Circle {}\n\nconst cc: ColorfulCircle = {\n  color: \"red\",\n  radius: 42,\n};\n```\n\n## 6.3 交叉类型\n\n接口允许我们通过扩展其他类型建立起新的类型。TypeScript提供了另一种结构，称为交叉类型，主要用于组合现有的对象类型。\n\n交叉类型是用 `&` 操作符定义的。\n\n```tsx\ninterface Colorful {\n  color: string;\n}\ninterface Circle {\n  radius: number;\n}\n\ntype ColorfulCircle = Colorful & Circle;\n\nconst cc: ColorfulCircle = {\n  color: \"red\",\n  radius: 42,\n};\n```\n\n在这里，我们将 `Colorful` 和 `Circle` 相交，产生了一个新的类型，它拥有 `Colorful` 和 `Circle` 的所有成员。\n\n```tsx\nfunction draw(circle: Colorful & Circle) {\n  console.log(`Color was ${circle.color}`);\n  console.log(`Radius was ${circle.radius}`);\n}\n\n// 正确\ndraw({ color: \"blue\", radius: 42 });\n\n// 错误\ndraw({ color: \"red\", raidus: 42 });\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/EwehSBGIodpYQfj.png\" alt=\"image-20211127095046044\" style=\"zoom:50%;\" />\n\n## 6.7 接口与交叉类型\n\n我们刚刚看了两种组合类型的方法，它们很相似，但实际上有细微的不同。对于接口，我们可以使用 `extends`子句来扩展其他类型，而对于交叉类型，我们也可以做类似的事情，并用类型别名来命名结果。两者之间的主要区别在于如何处理冲突，这种区别通常是你在接口和交叉类型的类型别名之间选择一个的主要原因之一。\n\n<img src=\"https://s2.loli.net/2022/02/22/tYex2cry6HGUgfT.png\" alt=\"image-20211127101912142\" style=\"zoom:50%;\" />\n\n接口可以定义多次，多次的声明会自动合并：\n\n```tsx\ninterface Sister {\n  name: string;\n}\ninterface Sister {\n  age: number;\n}\n\nconst sisterAn: Sister = {\n  name: \"sisterAn\",\n};\n\nconst sisterRan: Sister = {\n  name: \"sisterRan\",\n  age: 12,\n};\n```\n\n<img src=\"/img/TypeScript/06-09.png\" alt=\"image-20211127102424559\" style=\"zoom:50%;\" />\n\n但是类型别名如果定义多次，会报错：\n\n```tsx\ntype Sister = {\n  name: string;\n};\n\ntype Sister = {\n  age: number;\n};\n```\n\n<img src=\"/img/TypeScript/06-10.png\" alt=\"image-20211127102801182\" style=\"zoom:50%;\" />\n\n## 6.8 泛型对象类型\n\n让我们想象一下，一个可以包含任何数值的盒子类型：字符串、数字、长颈鹿，等等。\n\n```tsx\ninterface Box {\n  contents: any;\n}\n```\n\n现在，内容属性的类型是任意，这很有效，但会导致下一步的意外。\n\n我们可以使用 `unknown`，但这意味着在我们已经知道内容类型的情况下，我们需要做预防性检查，或者使用容易出错的类型断言。\n\n```tsx\ninterface Box {\n  contents: unknown;\n}\n\nlet x: Box = {\n  contents: \"hello world\",\n};\n\n// 我们需要检查 'x.contents'\nif (typeof x.contents === \"string\") {\n  console.log(x.contents.toLowerCase());\n}\n\n// 或者用类型断言\nconsole.log((x.contents as string).toLowerCase());\n```\n\n一种安全的方法是为每一种类型的内容搭建不同的盒子类型：\n\n```tsx\ninterface NumberBox {\n  contents: number;\n}\n\ninterface StringBox {\n  contents: string;\n}\n\ninterface BooleanBox {\n  contents: boolean;\n}\n```\n\n但这意味着我们必须创建不同的函数，或函数的重载，以对这些类型进行操作：\n\n```tsx\nfunction setContents(box: StringBox, newContents: string): void;\nfunction setContents(box: NumberBox, newContents: number): void;\nfunction setContents(box: BooleanBox, newContents: boolean): void;\nfunction setContents(box: { contents: any }, newContents: any) {\n  box.contents = newContents;\n}\n```\n\n那是一个很大的模板。此外，我们以后可能需要引入新的类型和重载。这是令人沮丧的，因为我们的盒子类型和重载实际上都是一样的。\n\n相反，我们可以做一个通用的 `Box` 类型，声明一个类型参数：\n\n```tsx\ninterface Box<Type> {\n  contents: Type;\n}\n```\n\n你可以把这句话理解为：\"一个类型的盒子，是它的内容具有类型的东西\"。以后，当我们引用 `Box` 时，我们必须给一个类型参数来代替 ` Type`。\n\n```tsx\nlet box: Box<string>;\n```\n\n把 `Box` 想象成一个真实类型的模板，其中 `Type` 是一个占位符，会被替换成其他类型。当 TypeScript 看到 `Box<string>` 时，它将用字符串替换 `Box<Type>` 中的每个 `Type` 实例，并最终以 `{ contents: string }` 这样的方式工作。换句话说，`Box<string>`和我们之前的`StringBox`工作起来是一样的。\n\n```tsx\ninterface Box<Type> {\n  contents: Type;\n}\ninterface StringBox {\n  contents: string;\n}\n\nlet boxA: Box<string> = { contents: \"hello\" };\nboxA.contents;\n\nlet boxB: StringBox = { contents: \"world\" };\nboxB.contents;\n```\n\n盒子是可重用的，因为Type可以用任何东西来代替。这意味着当我们需要一个新类型的盒子时，我们根本不需要声明一个新的盒子类型（尽管如果我们想的话，我们当然可以）。\n\n```tsx\ninterface Box<Type> {\n  contents: Type;\n}\n\ninterface Apple {\n  // ....\n}\n\n// 等价于 '{ contents: Apple }'.\ntype AppleBox = Box<Apple>;\n```\n\n这也意味着我们可以完全避免重载，而是使用通用函数。\n\n```tsx\nfunction setContents<Type>(box: Box<Type>, newContents: Type) {\n  box.contents = newContents;\n}\n```\n\n值得注意的是，类型别名也可以是通用的。我们可以定义我们新的 `Box<Type>`接口：\n\n```tsx\ninterface Box<Type> {\n  contents: Type;\n}\n```\n\n通过使用一个类型别名来代替：\n\n```tsx\ntype Box<Type> = {\n  contents: Type;\n};\n```\n\n由于类型别名与接口不同，它不仅可以描述对象类型，我们还可以用它来编写其他类型的通用辅助类型。\n\n```tsx\ntype OrNull<Type> = Type | null;\n\ntype OneOrMany<Type> = Type | Type[];\n\ntype OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;\n\ntype OneOrManyOrNullStrings = OneOrManyOrNull<string>;\n```\n\n我们将在稍后回到类型别名。\n\n通用对象类型通常是某种容器类型，它的工作与它们所包含的元素类型无关。数据结构以这种方式工作是很理想的，这样它们就可以在不同的数据类型中重复使用。\n\n## 6.9 数组类型\n\n我们一直在使用这样一种类型：数组类型。每当我们写出 `number[]` 或 `string[]` 这样的类型时，这实际上只是 `Array<number>`和`Array<string>`的缩写。\n\n```tsx\nfunction doSomething(value: Array<string>) {\n  // ...\n}\n\nlet myArray: string[] = [\"hello\", \"world\"];\n\n// 这两样都能用\ndoSomething(myArray);\ndoSomething(new Array(\"hello\", \"world\"));\n```\n\n和上面的 `Box` 类型一样，`Array` 本身也是一个通用类型。\n\n```tsx\ninterface Array<Type> {\n  /**\n   * 获取或设置数组的长度。\n   */\n  length: number;\n\n  /**\n   * 移除数组中的最后一个元素并返回。\n   */\n  pop(): Type | undefined;\n\n  /**\n   * 向一个数组添加新元素，并返回数组的新长度。\n   */\n  push(...items: Type[]): number;\n\n  // ...\n}\n```\n\n现代JavaScript还提供了其他通用的数据结构，比如 `Map<K, V> `, `Set<T>`, 和 `Promise<T>`。这实际上意味着，由于`Map`、`Set`和`Promise`的行为方式，它们可以与任何类型的集合一起工作。\n\n## 6.10 只读数组类型\n\n`ReadonlyArray`是一个特殊的类型，描述了不应该被改变的数组。\n\n```tsx\nfunction doStuff(values: ReadonlyArray<string>) {\n  // 我们可以从 'values' 读数据...\n  const copy = values.slice();\n  console.log(`第一个值是 ${values[0]}`);\n\n  // ...但我们不能改变 'vulues' 的值。\n  values.push(\"hello!\");\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/bBVuXOf5oQqIMgG.png\" alt=\"image-20211127191529424\" style=\"zoom:50%;\" />\n\n和属性的 `readonly` 修饰符一样，它主要是一个我们可以用来了解意图的工具。当我们看到一个返回`ReadonlyArrays` 的函数时，它告诉我们我们根本不打算改变其内容，而当我们看到一个消耗 `ReadonlyArrays`的函数时，它告诉我们可以将任何数组传入该函数，而不用担心它会改变其内容。\n\n与 `Array` 不同，没有一个我们可以使用的 `ReadonlyArray`构造函数。\n\n```tsx\nnew ReadonlyArray(\"red\", \"green\", \"blue\");\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/3S2e6YC9UQKbGNy.png\" alt=\"image-20211127191946986\" style=\"zoom: 67%;\" />\n\n相反，我们可以将普通的 `Array` 分配给 `ReadonlyArray`。\n\n```tsx\nconst roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];\n```\n\n正如 TypeScript为 `Array<Type>` 提供了 `Type[]` 的速记语法一样，它也为 `ReadonlyArray<Type>`提供了只读`Type[]`的速记语法。\n\n```tsx\nfunction doStuff(values: readonly string[]) {\n  // 我们可以从 'values' 读数据...\n  const copy = values.slice();\n  console.log(`The first value is ${values[0]}`);\n\n  // 但我们不能改变 'vulues' 的值。\n  values.push(\"hello!\");\n}\n```\n\n![image-20211127192458009](https://s2.loli.net/2022/02/22/TngAvtrq5W1LQhc.png)\n\n最后要注意的是，与 `readony` 属性修改器不同，可分配性在普通 `Array` 和 `ReadonlyArray` 之间不是双向的。\n\n```tsx\nlet x: readonly string[] = [];\nlet y: string[] = [];\n\nx = y;\ny = x;\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/fwveBsiLpA7FqNK.png\" alt=\"image-20211127192932203\" style=\"zoom:50%;\" />\n\n## 6.11 元组类型\n\n`Tuple` 类型是另一种 `Array` 类型，它确切地知道包含多少个元素，以及它在特定位置包含哪些类型。\n\n```tsx\ntype StringNumberPair = [string, number];\n```\n\n这里，`StringNumberPair` 是一个 `string` 和 `number` 的元组类型。像 `ReadonlyArray` 一样，它在运行时没有表示，但对TypeScript来说是重要的。对于类型系统来说，`StringNumberPair` 描述了其 索引 0 包含字符串和 索引1 包含数字的数组。\n\n```tsx\nfunction doSomething(pair: [string, number]) {\n  const a = pair[0];\n  const b = pair[1];\n  // ...\n}\n\ndoSomething([\"hello\", 42]);\n```\n\n如果我们试图索引超过元素的数量，我们会得到一个错误：\n\n```tsx\nfunction doSomething(pair: [string, number]) {\n  const c = pair[2];\n}\n```\n\n![image-20211127202845783](https://s2.loli.net/2022/02/22/9nMPvE3DZpdRuTA.png)\n\n我们还可以使用JavaScript的数组析构来对元组进行解构。\n\n```tsx\nfunction doSomething(stringHash: [string, number]) {\n  const [inputString, hash] = stringHash;\n\n  console.log(inputString);\n\n  console.log(hash);\n}\n```\n\n除了这些长度检查，像这样的简单元组类型等同于 `Array` 的版本，它为特定的索引声明属性，并且用数字字面类型声明长度。\n\n```tsx\ninterface StringNumberPair {\n  // 专有属性\n  length: 2;\n  0: string;\n  1: number;\n\n  // 其他 'Array<string | number>' 成员...\n  slice(start?: number, end?: number): Array<string | number>;\n}\n```\n\n另一件你可能感兴趣的事情是，元组可以通过在元素的类型后面写出问号（？）—— 可选的元组，元素只能出现在末尾，而且还影响到长度的类型。\n\n```tsx\ntype Either2dOr3d = [number, number, number?];\n\nfunction setCoordinate(coord: Either2dOr3d) {\n  const [x, y, z] = coord;\n  console.log(`提供的坐标有 ${coord.length} 个维度`);\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/fPVJp1tlRhyHYsW.png\" alt=\"image-20211127204518693\" style=\"zoom:50%;\" />\n\n图元也可以有其余元素，这些元素必须是 `array/tuple` 类型。\n\n```tsx\ntype StringNumberBooleans = [string, number, ...boolean[]];\ntype StringBooleansNumber = [string, ...boolean[], number];\ntype BooleansStringNumber = [...boolean[], string, number];\n```\n\n- `StringNumberBooleans` 描述了一个元组，其前两个元素分别是字符串和数字，但后面可以有任意数量的布尔。\n\n- `StringBooleansNumber` 描述了一个元组，其第一个元素是字符串，然后是任意数量的布尔运算，最后是一个数字。\n\n- `BooleansStringNumber` 描述了一个元组，其起始元素是任意数量的布尔运算，最后是一个字符串，然后是一个数字。\n\n一个有其余元素的元组没有集合的 \"长度\"——它只有一组不同位置的知名元素。\n\n```tsx\nconst a: StringNumberBooleans = [\"hello\", 1];\nconst b: StringNumberBooleans = [\"beautiful\", 2, true];\nconst c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];\n```\n\n为什么可选元素和其余元素可能是有用的？它允许TypeScript将 `tuples` 与参数列表相对应。\n\n```tsx\nfunction readButtonInput(...args: [string, number, ...boolean[]]) {\n  const [name, version, ...input] = args;\n  // ...\n}\n```\n\n基本上等同于：\n\n```tsx\nfunction readButtonInput(name: string, version: number, ...input: boolean[]) {\n  // ...\n}\n```\n\n当你想用一个其余(rest)参数接受可变数量的参数，并且你需要一个最小的元素数量，但你不想引入中间变量时，这很方便。\n\n## 6.12 只读元组类型\n\n关于 `tuple` 类型的最后一点说明：`tuple` 类型有只读特性，可以通过在它们前面粘贴一个`readonly`修饰符来指定——就像数组的速记语法一样。\n\n```tsx\nfunction doSomething(pair: readonly [string, number]) {\n  // ...\n}\n```\n\n正如你所期望的，在TypeScript中不允许向只读元组的任何属性写入。\n\n```tsx\nfunction doSomething(pair: readonly [string, number]) {\n  pair[0] = \"hello!\";\n}\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/mZUgrFvnJG2a9Qw.png\" alt=\"image-20211127210344032\" style=\"zoom:50%;\" />\n\n在大多数代码中，元组往往被创建并不被修改，所以在可能的情况下，将类型注释为只读元组是一个很好的默认。这一点也很重要，因为带有 `const` 断言的数组字面量将被推断为只读元组类型。\n\n```tsx\nlet point = [3, 4] as const;\n\nfunction distanceFromOrigin([x, y]: [number, number]) {\n  return Math.sqrt(x ** 2 + y ** 2);\n}\n\ndistanceFromOrigin(point);\n```\n\n<img src=\"https://s2.loli.net/2022/02/22/GOd6ieyPvTsaxrw.png\" alt=\"image-20211127210654160\" style=\"zoom:50%;\" />\n\n在这里，`distanceFromOrigin` 从未修改过它的元素，而是期望一个可变的元组。由于 `point`的类型被推断为只读的 `[3, 4]`，它与 `[number, number]` 不兼容，因为该类型不能保证 `point` 的元素不被修改。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-6、基础篇：对象类型",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao4000x94v30fobhc9a",
        "content": "<h1 id=\"六、对象类型\"><a href=\"#六、对象类型\" class=\"headerlink\" title=\"六、对象类型\"></a>六、对象类型</h1><p>在JavaScript中，我们分组和传递数据的基本方式是通过对象。在TypeScript中，我们通过对象类型来表示这些对象。</p>\n<p>正如我们所见，它们可以是匿名的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">person</span>: &#123; name: <span class=\"built_in\">string</span>; age: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello &quot;</span> + person.<span class=\"property\">name</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者可以通过使用一个接口来命名它们：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">person</span>: <span class=\"title class_\">Person</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello &quot;</span> + person.<span class=\"property\">name</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或一个类型别名：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Person</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">person</span>: <span class=\"title class_\">Person</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello &quot;</span> + person.<span class=\"property\">name</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的三个例子中，我们写了一些函数，这些函数接收包含属性 <code>name</code>（必须是一个 <code>string</code>）和 <code>age</code>（必须是一个 <code>number</code>）的对象。</p>\n<h2 id=\"6-1-属性修改器\"><a href=\"#6-1-属性修改器\" class=\"headerlink\" title=\"6.1 属性修改器\"></a>6.1 属性修改器</h2><p>对象类型中的每个属性都可以指定几件事：类型、属性是否是可选的，以及属性是否可以被写入。</p>\n<h3 id=\"6-1-1-可选属性\"><a href=\"#6-1-1-可选属性\" class=\"headerlink\" title=\"6.1.1 可选属性\"></a>6.1.1 可选属性</h3><p>很多时候，我们会发现自己处理的对象可能有一个属性设置。在这些情况下，我们可以在这些属性的名字后面加上一个问号（？），把它们标记为可选的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">PaintOptions</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span>;</span><br><span class=\"line\">  <span class=\"attr\">xPos</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">yPos</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">paintShape</span>(<span class=\"params\"><span class=\"attr\">opts</span>: <span class=\"title class_\">PaintOptions</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span> = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title function_\">paintShape</span>(&#123; shape &#125;);</span><br><span class=\"line\"><span class=\"title function_\">paintShape</span>(&#123; shape, <span class=\"attr\">xPos</span>: <span class=\"number\">100</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">paintShape</span>(&#123; shape, <span class=\"attr\">yPos</span>: <span class=\"number\">100</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">paintShape</span>(&#123; shape, <span class=\"attr\">xPos</span>: <span class=\"number\">100</span>, <span class=\"attr\">yPos</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>xPos</code>和<code>yPos</code>都被认为是可选的。我们可以选择提供它们中的任何一个，所以上面对<code>paintShape</code>的每个调用都是有效的。所有的可选性实际上是说，如果属性被设置，它最好有一个特定的类型。</p>\n<p>我们也可以从这些属性中读取，但当我们在<code>strictNullChecks</code>下读取时，TypeScript会告诉我们它们可能是未定义的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">paintShape</span>(<span class=\"params\"><span class=\"attr\">opts</span>: <span class=\"title class_\">PaintOptions</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xPos = opts.<span class=\"property\">xPos</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> yPos = opts.<span class=\"property\">yPos</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在JavaScript中，即使该属性从未被设置过，我们仍然可以访问它–它只是会给我们未定义的值。我们可以专门处理未定义。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">paintShape</span>(<span class=\"params\"><span class=\"attr\">opts</span>: <span class=\"title class_\">PaintOptions</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xPos = opts.<span class=\"property\">xPos</span> === <span class=\"literal\">undefined</span> ? <span class=\"number\">0</span> : opts.<span class=\"property\">xPos</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> yPos = opts.<span class=\"property\">yPos</span> === <span class=\"literal\">undefined</span> ? <span class=\"number\">0</span> : opts.<span class=\"property\">yPos</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这种为未指定的值设置默认值的模式非常普遍，以至于JavaScript有语法来支持它。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">paintShape</span>(<span class=\"params\">&#123; shape, xPos = <span class=\"number\">0</span>, yPos = <span class=\"number\">0</span> &#125;: <span class=\"title class_\">PaintOptions</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;x coordinate at&quot;</span>, xPos);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;y coordinate at&quot;</span>, yPos);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们为 <code>paintShape</code> 的参数使用了一个解构模式，并为 <code>xPos</code> 和 <code>yPos</code> 提供了默认值。现在 <code>xPos</code> 和 <code>yPos</code> 都肯定存在于 <code>paintShape</code> 的主体中，但对于 <code>paintShape</code> 的任何调用者来说是可选的。</p>\n<blockquote>\n<p>请注意，目前还没有办法将类型注释放在解构模式中。这是因为下面的语法在JavaScript中已经有了不同的含义。</p>\n</blockquote>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">draw</span>(<span class=\"params\">&#123; shape: Shape, xPos: <span class=\"built_in\">number</span> = <span class=\"number\">100</span> /*...*/ &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(shape);</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(xPos);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/GItsFTdQPJl9Svf.png\" alt=\"image-20211127082617191\" style=\"zoom:50%;\" />\n\n<p>在一个对象解构模式中，<code>shape: Shape</code> 意味着 “获取属性 <code>shape</code>，并在本地重新定义为一个名为 <code>Shape</code> 的变量。同样，<code>xPos: number</code> 创建一个名为number的变量，其值基于参数的 <code>xPos</code>。</p>\n<h3 id=\"6-1-2-只读属性\"><a href=\"#6-1-2-只读属性\" class=\"headerlink\" title=\"6.1.2 只读属性\"></a>6.1.2 只读属性</h3><p>对于TypeScript，属性也可以被标记为只读。虽然它不会在运行时改变任何行为，但在类型检查期间，一个标记为只读的属性不能被写入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">SomeType</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">prop</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">obj</span>: <span class=\"title class_\">SomeType</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 可以读取 &#x27;obj.prop&#x27;.</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`prop has the value &#x27;<span class=\"subst\">$&#123;obj.prop&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 但不能重新设置值</span></span><br><span class=\"line\">  obj.<span class=\"property\">prop</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-02.png\" alt=\"image-20211127083551809\" style=\"zoom:50%;\" />\n\n<p>使用 <code>readonly</code> 修饰符并不一定意味着一个值是完全不可改变的。或者换句话说，它的内部内容不能被改变，它只是意味着该属性本身不能被重新写入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Home</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">resident</span>: &#123; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">age</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">visitForBirthday</span>(<span class=\"params\"><span class=\"attr\">home</span>: <span class=\"title class_\">Home</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以从&#x27;home.resident&#x27;读取和更新属性。</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Happy birthday <span class=\"subst\">$&#123;home.resident.name&#125;</span>!`</span>);</span><br><span class=\"line\">  home.<span class=\"property\">resident</span>.<span class=\"property\">age</span>++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">evict</span>(<span class=\"params\"><span class=\"attr\">home</span>: <span class=\"title class_\">Home</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 但是我们不能写到&#x27;home&#x27;上的&#x27;resident&#x27;属性本身。</span></span><br><span class=\"line\">  home.<span class=\"property\">resident</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;Victor the Evictor&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-03.png\" alt=\"image-20211127084012491\" style=\"zoom:50%;\" />\n\n<p>管理对 <code>readonly</code> 含义的预期是很重要的。在TypeScript的开发过程中，对于一个对象应该如何被使用的问题，它是有用的信号。TypeScript在检查两个类型的属性是否兼容时，并不考虑这些类型的属性是否是 <code>readonly</code>，所以 <code>readony</code> 属性也可以通过别名来改变。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ReadonlyPerson</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">writablePerson</span>: <span class=\"title class_\">Person</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;Person McPersonface&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正常工作</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">readonlyPerson</span>: <span class=\"title class_\">ReadonlyPerson</span> = writablePerson;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(readonlyPerson.<span class=\"property\">age</span>); <span class=\"comment\">// 打印 &#x27;42&#x27;</span></span><br><span class=\"line\">writablePerson.<span class=\"property\">age</span>++;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(readonlyPerson.<span class=\"property\">age</span>); <span class=\"comment\">// 打印 &#x27;43&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-3-索引签名\"><a href=\"#6-1-3-索引签名\" class=\"headerlink\" title=\"6.1.3 索引签名\"></a>6.1.3 索引签名</h3><p>有时你并不提前知道一个类型的所有属性名称，但你知道值的形状。</p>\n<p>在这些情况下，你可以使用一个索引签名来描述可能的值的类型，比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringArray</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">index</span>: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">myArray</span>: <span class=\"title class_\">StringArray</span> = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> secondItem = myArray[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<p>上面，我们有一个 <code>StringArray</code> 接口，它有一个索引签名。这个索引签名指出，当一个 <code>StringArray</code> 被数字索引时，它将返回一个字符串。</p>\n<p>索引签名的属性类型必须是 <code>string</code> 或 <code>number</code>。</p>\n<p>支持两种类型的索引器是可能的，但是从数字索引器返回的类型必须是字符串索引器返回的类型的子类型。这是因为当用 “数字 “进行索引时，JavaScript实际上会在索引到一个对象之前将其转换为 “字符串”。这意味着用<code>100</code>（一个<code>数字</code>）进行索引和用<code>&quot;100&quot;</code>（一个<code>字符串</code>）进行索引是一样的，所以两者需要一致。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">breed</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NotOkay</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">x</span>: <span class=\"built_in\">number</span>]: <span class=\"title class_\">Animal</span>;</span><br><span class=\"line\">  [<span class=\"attr\">x</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/a2rzdbJlqtuoXFw.png\" alt=\"image-20211127090502640\" style=\"zoom:50%;\" />\n\n<p>虽然字符串索引签名是描述 “字典 “模式的一种强大方式，但它也强制要求所有的属性与它们的返回类型相匹配。这是因为字符串索引声明 <code>obj.property</code> 也可以作为 <code>obj[&quot;property&quot;]</code>。在下面的例子中，<code>name</code>的类型与字符串索引的类型不匹配，类型检查器会给出一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NumberDictionary</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">index</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>; <span class=\"comment\">// ok</span></span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/AzHPBUGvK5JbQpw.png\" alt=\"image-20211127091044224\" style=\"zoom:50%;\" />\n\n<p>然而，如果索引签名是属性类型的联合，不同类型的属性是可以接受的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NumberOrStringDictionary</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">index</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>; <span class=\"comment\">// 正确, length 是 number 类型</span></span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; <span class=\"comment\">// 正确, name 是 string 类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，你可以使索引签名为只读，以防止对其索引的赋值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ReadonlyStringArray</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> [<span class=\"attr\">index</span>: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myArray</span>: <span class=\"title class_\">ReadonlyStringArray</span> = <span class=\"title function_\">getReadOnlyStringArray</span>();</span><br><span class=\"line\">myArray[<span class=\"number\">2</span>] = <span class=\"string\">&quot;Mallory&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-06.png\" alt=\"image-20211127091423550\" style=\"zoom:50%;\" />\n\n<p>你不能设置 <code>myArray[2]</code>，因为这个索引签名是只读的。</p>\n<h2 id=\"6-2-扩展类型\"><a href=\"#6-2-扩展类型\" class=\"headerlink\" title=\"6.2 扩展类型\"></a>6.2 扩展类型</h2><p>有一些类型可能是其他类型的更具体的版本，这是很常见的。例如，我们可能有一个<code>BasicAddress</code>类型，描述发送信件和包裹所需的字段。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">BasicAddress</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">street</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">postalCode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在某些情况下，这就足够了，但是如果一个地址的小区内有多个单元，那么地址往往有一个单元号与之相关。我们就可以描述一个 <code>AddressWithUnit</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">AddressWithUnit</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">unit</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">street</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">postalCode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就完成了工作，但这里的缺点是，当我们的变化是纯粹的加法时，我们不得不重复 <code>BasicAddress</code> 的所有其他字段。相反，我们可以扩展原始的 <code>BasicAddress</code> 类型，只需添加 <code>AddressWithUnit</code> 特有的新字段：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">BasicAddress</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">street</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">postalCode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">AddressWithUnit</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BasicAddress</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">unit</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口上的 <code>extends</code> 关键字，允许我们有效地从其他命名的类型中复制成员，并添加我们想要的任何新成员。这对于减少我们不得不写的类型声明模板，以及表明同一属性的几个不同声明可能是相关的意图来说，是非常有用的。例如，<code>AddressWithUnit</code> 不需要重复 <code>street</code> 属性，而且因为 <code>street</code> 源于 <code>BasicAddress</code>，我们会知道这两种类型在某种程度上是相关的。</p>\n<p>接口也可以从多个类型中扩展。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Colorful</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">color</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ColorfulCircle</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Colorful</span>, <span class=\"title class_\">Circle</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">cc</span>: <span class=\"title class_\">ColorfulCircle</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">color</span>: <span class=\"string\">&quot;red&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-3-交叉类型\"><a href=\"#6-3-交叉类型\" class=\"headerlink\" title=\"6.3 交叉类型\"></a>6.3 交叉类型</h2><p>接口允许我们通过扩展其他类型建立起新的类型。TypeScript提供了另一种结构，称为交叉类型，主要用于组合现有的对象类型。</p>\n<p>交叉类型是用 <code>&amp;</code> 操作符定义的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Colorful</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">color</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ColorfulCircle</span> = <span class=\"title class_\">Colorful</span> &amp; <span class=\"title class_\">Circle</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">cc</span>: <span class=\"title class_\">ColorfulCircle</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">color</span>: <span class=\"string\">&quot;red&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们将 <code>Colorful</code> 和 <code>Circle</code> 相交，产生了一个新的类型，它拥有 <code>Colorful</code> 和 <code>Circle</code> 的所有成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">draw</span>(<span class=\"params\"><span class=\"attr\">circle</span>: <span class=\"title class_\">Colorful</span> &amp; <span class=\"title class_\">Circle</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Color was <span class=\"subst\">$&#123;circle.color&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Radius was <span class=\"subst\">$&#123;circle.radius&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"title function_\">draw</span>(&#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;blue&quot;</span>, <span class=\"attr\">radius</span>: <span class=\"number\">42</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"title function_\">draw</span>(&#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;red&quot;</span>, <span class=\"attr\">raidus</span>: <span class=\"number\">42</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/EwehSBGIodpYQfj.png\" alt=\"image-20211127095046044\" style=\"zoom:50%;\" />\n\n<h2 id=\"6-7-接口与交叉类型\"><a href=\"#6-7-接口与交叉类型\" class=\"headerlink\" title=\"6.7 接口与交叉类型\"></a>6.7 接口与交叉类型</h2><p>我们刚刚看了两种组合类型的方法，它们很相似，但实际上有细微的不同。对于接口，我们可以使用 <code>extends</code>子句来扩展其他类型，而对于交叉类型，我们也可以做类似的事情，并用类型别名来命名结果。两者之间的主要区别在于如何处理冲突，这种区别通常是你在接口和交叉类型的类型别名之间选择一个的主要原因之一。</p>\n<img src=\"https://s2.loli.net/2022/02/22/tYex2cry6HGUgfT.png\" alt=\"image-20211127101912142\" style=\"zoom:50%;\" />\n\n<p>接口可以定义多次，多次的声明会自动合并：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Sister</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Sister</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">sisterAn</span>: <span class=\"title class_\">Sister</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;sisterAn&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">sisterRan</span>: <span class=\"title class_\">Sister</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;sisterRan&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">12</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-09.png\" alt=\"image-20211127102424559\" style=\"zoom:50%;\" />\n\n<p>但是类型别名如果定义多次，会报错：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Sister</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Sister</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-10.png\" alt=\"image-20211127102801182\" style=\"zoom:50%;\" />\n\n<h2 id=\"6-8-泛型对象类型\"><a href=\"#6-8-泛型对象类型\" class=\"headerlink\" title=\"6.8 泛型对象类型\"></a>6.8 泛型对象类型</h2><p>让我们想象一下，一个可以包含任何数值的盒子类型：字符串、数字、长颈鹿，等等。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，内容属性的类型是任意，这很有效，但会导致下一步的意外。</p>\n<p>我们可以使用 <code>unknown</code>，但这意味着在我们已经知道内容类型的情况下，我们需要做预防性检查，或者使用容易出错的类型断言。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">unknown</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"title class_\">Box</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"string\">&quot;hello world&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们需要检查 &#x27;x.contents&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x.<span class=\"property\">contents</span> === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"property\">contents</span>.<span class=\"title function_\">toLowerCase</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者用类型断言</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>((x.<span class=\"property\">contents</span> <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).<span class=\"title function_\">toLowerCase</span>());</span><br></pre></td></tr></table></figure>\n\n<p>一种安全的方法是为每一种类型的内容搭建不同的盒子类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NumberBox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringBox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">BooleanBox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这意味着我们必须创建不同的函数，或函数的重载，以对这些类型进行操作：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setContents</span>(<span class=\"params\"><span class=\"attr\">box</span>: <span class=\"title class_\">StringBox</span>, <span class=\"attr\">newContents</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setContents</span>(<span class=\"params\"><span class=\"attr\">box</span>: <span class=\"title class_\">NumberBox</span>, <span class=\"attr\">newContents</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setContents</span>(<span class=\"params\"><span class=\"attr\">box</span>: <span class=\"title class_\">BooleanBox</span>, <span class=\"attr\">newContents</span>: <span class=\"built_in\">boolean</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setContents</span>(<span class=\"params\"><span class=\"attr\">box</span>: &#123; contents: <span class=\"built_in\">any</span> &#125;, <span class=\"attr\">newContents</span>: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">  box.<span class=\"property\">contents</span> = newContents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那是一个很大的模板。此外，我们以后可能需要引入新的类型和重载。这是令人沮丧的，因为我们的盒子类型和重载实际上都是一样的。</p>\n<p>相反，我们可以做一个通用的 <code>Box</code> 类型，声明一个类型参数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以把这句话理解为：”一个类型的盒子，是它的内容具有类型的东西”。以后，当我们引用 <code>Box</code> 时，我们必须给一个类型参数来代替 <code> Type</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">box</span>: <span class=\"title class_\">Box</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>把 <code>Box</code> 想象成一个真实类型的模板，其中 <code>Type</code> 是一个占位符，会被替换成其他类型。当 TypeScript 看到 <code>Box&lt;string&gt;</code> 时，它将用字符串替换 <code>Box&lt;Type&gt;</code> 中的每个 <code>Type</code> 实例，并最终以 <code>&#123; contents: string &#125;</code> 这样的方式工作。换句话说，<code>Box&lt;string&gt;</code>和我们之前的<code>StringBox</code>工作起来是一样的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringBox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">boxA</span>: <span class=\"title class_\">Box</span>&lt;<span class=\"built_in\">string</span>&gt; = &#123; <span class=\"attr\">contents</span>: <span class=\"string\">&quot;hello&quot;</span> &#125;;</span><br><span class=\"line\">boxA.<span class=\"property\">contents</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">boxB</span>: <span class=\"title class_\">StringBox</span> = &#123; <span class=\"attr\">contents</span>: <span class=\"string\">&quot;world&quot;</span> &#125;;</span><br><span class=\"line\">boxB.<span class=\"property\">contents</span>;</span><br></pre></td></tr></table></figure>\n\n<p>盒子是可重用的，因为Type可以用任何东西来代替。这意味着当我们需要一个新类型的盒子时，我们根本不需要声明一个新的盒子类型（尽管如果我们想的话，我们当然可以）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Apple</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于 &#x27;&#123; contents: Apple &#125;&#x27;.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">AppleBox</span> = <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Apple</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>这也意味着我们可以完全避免重载，而是使用通用函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> setContents&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">box</span>: <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt;, <span class=\"attr\">newContents</span>: <span class=\"title class_\">Type</span>) &#123;</span><br><span class=\"line\">  box.<span class=\"property\">contents</span> = newContents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，类型别名也可以是通用的。我们可以定义我们新的 <code>Box&lt;Type&gt;</code>接口：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过使用一个类型别名来代替：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于类型别名与接口不同，它不仅可以描述对象类型，我们还可以用它来编写其他类型的通用辅助类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OrNull</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OneOrMany</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> | <span class=\"title class_\">Type</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OneOrManyOrNull</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">OrNull</span>&lt;<span class=\"title class_\">OneOrMany</span>&lt;<span class=\"title class_\">Type</span>&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OneOrManyOrNullStrings</span> = <span class=\"title class_\">OneOrManyOrNull</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>我们将在稍后回到类型别名。</p>\n<p>通用对象类型通常是某种容器类型，它的工作与它们所包含的元素类型无关。数据结构以这种方式工作是很理想的，这样它们就可以在不同的数据类型中重复使用。</p>\n<h2 id=\"6-9-数组类型\"><a href=\"#6-9-数组类型\" class=\"headerlink\" title=\"6.9 数组类型\"></a>6.9 数组类型</h2><p>我们一直在使用这样一种类型：数组类型。每当我们写出 <code>number[]</code> 或 <code>string[]</code> 这样的类型时，这实际上只是 <code>Array&lt;number&gt;</code>和<code>Array&lt;string&gt;</code>的缩写。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">string</span>&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myArray</span>: <span class=\"built_in\">string</span>[] = [<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这两样都能用</span></span><br><span class=\"line\"><span class=\"title function_\">doSomething</span>(myArray);</span><br><span class=\"line\"><span class=\"title function_\">doSomething</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>和上面的 <code>Box</code> 类型一样，<code>Array</code> 本身也是一个通用类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 获取或设置数组的长度。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 移除数组中的最后一个元素并返回。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"title function_\">pop</span>(): <span class=\"title class_\">Type</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 向一个数组添加新元素，并返回数组的新长度。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"title function_\">push</span>(...<span class=\"attr\">items</span>: <span class=\"title class_\">Type</span>[]): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现代JavaScript还提供了其他通用的数据结构，比如 <code>Map&lt;K, V&gt; </code>, <code>Set&lt;T&gt;</code>, 和 <code>Promise&lt;T&gt;</code>。这实际上意味着，由于<code>Map</code>、<code>Set</code>和<code>Promise</code>的行为方式，它们可以与任何类型的集合一起工作。</p>\n<h2 id=\"6-10-只读数组类型\"><a href=\"#6-10-只读数组类型\" class=\"headerlink\" title=\"6.10 只读数组类型\"></a>6.10 只读数组类型</h2><p><code>ReadonlyArray</code>是一个特殊的类型，描述了不应该被改变的数组。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doStuff</span>(<span class=\"params\"><span class=\"attr\">values</span>: <span class=\"title class_\">ReadonlyArray</span>&lt;<span class=\"built_in\">string</span>&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以从 &#x27;values&#x27; 读数据...</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = values.<span class=\"title function_\">slice</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`第一个值是 <span class=\"subst\">$&#123;values[<span class=\"number\">0</span>]&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...但我们不能改变 &#x27;vulues&#x27; 的值。</span></span><br><span class=\"line\">  values.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;hello!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/bBVuXOf5oQqIMgG.png\" alt=\"image-20211127191529424\" style=\"zoom:50%;\" />\n\n<p>和属性的 <code>readonly</code> 修饰符一样，它主要是一个我们可以用来了解意图的工具。当我们看到一个返回<code>ReadonlyArrays</code> 的函数时，它告诉我们我们根本不打算改变其内容，而当我们看到一个消耗 <code>ReadonlyArrays</code>的函数时，它告诉我们可以将任何数组传入该函数，而不用担心它会改变其内容。</p>\n<p>与 <code>Array</code> 不同，没有一个我们可以使用的 <code>ReadonlyArray</code>构造函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ReadonlyArray</span>(<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/3S2e6YC9UQKbGNy.png\" alt=\"image-20211127191946986\" style=\"zoom: 67%;\" />\n\n<p>相反，我们可以将普通的 <code>Array</code> 分配给 <code>ReadonlyArray</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">roArray</span>: <span class=\"title class_\">ReadonlyArray</span>&lt;<span class=\"built_in\">string</span>&gt; = [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>正如 TypeScript为 <code>Array&lt;Type&gt;</code> 提供了 <code>Type[]</code> 的速记语法一样，它也为 <code>ReadonlyArray&lt;Type&gt;</code>提供了只读<code>Type[]</code>的速记语法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doStuff</span>(<span class=\"params\"><span class=\"attr\">values</span>: <span class=\"keyword\">readonly</span> <span class=\"built_in\">string</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以从 &#x27;values&#x27; 读数据...</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = values.<span class=\"title function_\">slice</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`The first value is <span class=\"subst\">$&#123;values[<span class=\"number\">0</span>]&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 但我们不能改变 &#x27;vulues&#x27; 的值。</span></span><br><span class=\"line\">  values.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;hello!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2022/02/22/TngAvtrq5W1LQhc.png\" alt=\"image-20211127192458009\"></p>\n<p>最后要注意的是，与 <code>readony</code> 属性修改器不同，可分配性在普通 <code>Array</code> 和 <code>ReadonlyArray</code> 之间不是双向的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"keyword\">readonly</span> <span class=\"built_in\">string</span>[] = [];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">y</span>: <span class=\"built_in\">string</span>[] = [];</span><br><span class=\"line\"></span><br><span class=\"line\">x = y;</span><br><span class=\"line\">y = x;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/fwveBsiLpA7FqNK.png\" alt=\"image-20211127192932203\" style=\"zoom:50%;\" />\n\n<h2 id=\"6-11-元组类型\"><a href=\"#6-11-元组类型\" class=\"headerlink\" title=\"6.11 元组类型\"></a>6.11 元组类型</h2><p><code>Tuple</code> 类型是另一种 <code>Array</code> 类型，它确切地知道包含多少个元素，以及它在特定位置包含哪些类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StringNumberPair</span> = [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br></pre></td></tr></table></figure>\n\n<p>这里，<code>StringNumberPair</code> 是一个 <code>string</code> 和 <code>number</code> 的元组类型。像 <code>ReadonlyArray</code> 一样，它在运行时没有表示，但对TypeScript来说是重要的。对于类型系统来说，<code>StringNumberPair</code> 描述了其 索引 0 包含字符串和 索引1 包含数字的数组。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">pair</span>: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = pair[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = pair[<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">doSomething</span>([<span class=\"string\">&quot;hello&quot;</span>, <span class=\"number\">42</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>如果我们试图索引超过元素的数量，我们会得到一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">pair</span>: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> c = pair[<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2022/02/22/9nMPvE3DZpdRuTA.png\" alt=\"image-20211127202845783\"></p>\n<p>我们还可以使用JavaScript的数组析构来对元组进行解构。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">stringHash</span>: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [inputString, hash] = stringHash;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(inputString);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(hash);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了这些长度检查，像这样的简单元组类型等同于 <code>Array</code> 的版本，它为特定的索引声明属性，并且用数字字面类型声明长度。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringNumberPair</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 专有属性</span></span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他 &#x27;Array&lt;string | number&gt;&#x27; 成员...</span></span><br><span class=\"line\">  <span class=\"title function_\">slice</span>(<span class=\"attr\">start</span>?: <span class=\"built_in\">number</span>, <span class=\"attr\">end</span>?: <span class=\"built_in\">number</span>): <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一件你可能感兴趣的事情是，元组可以通过在元素的类型后面写出问号（？）—— 可选的元组，元素只能出现在末尾，而且还影响到长度的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Either2</span>dOr3d = [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>?];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setCoordinate</span>(<span class=\"params\"><span class=\"attr\">coord</span>: <span class=\"title class_\">Either2</span>dOr3d</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [x, y, z] = coord;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`提供的坐标有 <span class=\"subst\">$&#123;coord.length&#125;</span> 个维度`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/fPVJp1tlRhyHYsW.png\" alt=\"image-20211127204518693\" style=\"zoom:50%;\" />\n\n<p>图元也可以有其余元素，这些元素必须是 <code>array/tuple</code> 类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StringNumberBooleans</span> = [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>, ...<span class=\"built_in\">boolean</span>[]];</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StringBooleansNumber</span> = [<span class=\"built_in\">string</span>, ...<span class=\"built_in\">boolean</span>[], <span class=\"built_in\">number</span>];</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">BooleansStringNumber</span> = [...<span class=\"built_in\">boolean</span>[], <span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>StringNumberBooleans</code> 描述了一个元组，其前两个元素分别是字符串和数字，但后面可以有任意数量的布尔。</p>\n</li>\n<li><p><code>StringBooleansNumber</code> 描述了一个元组，其第一个元素是字符串，然后是任意数量的布尔运算，最后是一个数字。</p>\n</li>\n<li><p><code>BooleansStringNumber</code> 描述了一个元组，其起始元素是任意数量的布尔运算，最后是一个字符串，然后是一个数字。</p>\n</li>\n</ul>\n<p>一个有其余元素的元组没有集合的 “长度”——它只有一组不同位置的知名元素。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: <span class=\"title class_\">StringNumberBooleans</span> = [<span class=\"string\">&quot;hello&quot;</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">b</span>: <span class=\"title class_\">StringNumberBooleans</span> = [<span class=\"string\">&quot;beautiful&quot;</span>, <span class=\"number\">2</span>, <span class=\"literal\">true</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">c</span>: <span class=\"title class_\">StringNumberBooleans</span> = [<span class=\"string\">&quot;world&quot;</span>, <span class=\"number\">3</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n\n<p>为什么可选元素和其余元素可能是有用的？它允许TypeScript将 <code>tuples</code> 与参数列表相对应。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">readButtonInput</span>(<span class=\"params\">...<span class=\"attr\">args</span>: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>, ...<span class=\"built_in\">boolean</span>[]]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [name, version, ...input] = args;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本上等同于：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">readButtonInput</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">version</span>: <span class=\"built_in\">number</span>, ...<span class=\"attr\">input</span>: <span class=\"built_in\">boolean</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你想用一个其余(rest)参数接受可变数量的参数，并且你需要一个最小的元素数量，但你不想引入中间变量时，这很方便。</p>\n<h2 id=\"6-12-只读元组类型\"><a href=\"#6-12-只读元组类型\" class=\"headerlink\" title=\"6.12 只读元组类型\"></a>6.12 只读元组类型</h2><p>关于 <code>tuple</code> 类型的最后一点说明：<code>tuple</code> 类型有只读特性，可以通过在它们前面粘贴一个<code>readonly</code>修饰符来指定——就像数组的速记语法一样。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">pair</span>: <span class=\"keyword\">readonly</span> [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正如你所期望的，在TypeScript中不允许向只读元组的任何属性写入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">pair</span>: <span class=\"keyword\">readonly</span> [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  pair[<span class=\"number\">0</span>] = <span class=\"string\">&quot;hello!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/mZUgrFvnJG2a9Qw.png\" alt=\"image-20211127210344032\" style=\"zoom:50%;\" />\n\n<p>在大多数代码中，元组往往被创建并不被修改，所以在可能的情况下，将类型注释为只读元组是一个很好的默认。这一点也很重要，因为带有 <code>const</code> 断言的数组字面量将被推断为只读元组类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> point = [<span class=\"number\">3</span>, <span class=\"number\">4</span>] <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">distanceFromOrigin</span>(<span class=\"params\">[x, y]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">sqrt</span>(x ** <span class=\"number\">2</span> + y ** <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">distanceFromOrigin</span>(point);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/GOd6ieyPvTsaxrw.png\" alt=\"image-20211127210654160\" style=\"zoom:50%;\" />\n\n<p>在这里，<code>distanceFromOrigin</code> 从未修改过它的元素，而是期望一个可变的元组。由于 <code>point</code>的类型被推断为只读的 <code>[3, 4]</code>，它与 <code>[number, number]</code> 不兼容，因为该类型不能保证 <code>point</code> 的元素不被修改。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"六、对象类型\"><a href=\"#六、对象类型\" class=\"headerlink\" title=\"六、对象类型\"></a>六、对象类型</h1><p>在JavaScript中，我们分组和传递数据的基本方式是通过对象。在TypeScript中，我们通过对象类型来表示这些对象。</p>\n<p>正如我们所见，它们可以是匿名的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">person</span>: &#123; name: <span class=\"built_in\">string</span>; age: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello &quot;</span> + person.<span class=\"property\">name</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者可以通过使用一个接口来命名它们：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">person</span>: <span class=\"title class_\">Person</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello &quot;</span> + person.<span class=\"property\">name</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或一个类型别名：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Person</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">person</span>: <span class=\"title class_\">Person</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello &quot;</span> + person.<span class=\"property\">name</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的三个例子中，我们写了一些函数，这些函数接收包含属性 <code>name</code>（必须是一个 <code>string</code>）和 <code>age</code>（必须是一个 <code>number</code>）的对象。</p>\n<h2 id=\"6-1-属性修改器\"><a href=\"#6-1-属性修改器\" class=\"headerlink\" title=\"6.1 属性修改器\"></a>6.1 属性修改器</h2><p>对象类型中的每个属性都可以指定几件事：类型、属性是否是可选的，以及属性是否可以被写入。</p>\n<h3 id=\"6-1-1-可选属性\"><a href=\"#6-1-1-可选属性\" class=\"headerlink\" title=\"6.1.1 可选属性\"></a>6.1.1 可选属性</h3><p>很多时候，我们会发现自己处理的对象可能有一个属性设置。在这些情况下，我们可以在这些属性的名字后面加上一个问号（？），把它们标记为可选的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Shape</span> = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">PaintOptions</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span>;</span><br><span class=\"line\">  <span class=\"attr\">xPos</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">yPos</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">paintShape</span>(<span class=\"params\"><span class=\"attr\">opts</span>: <span class=\"title class_\">PaintOptions</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">shape</span>: <span class=\"title class_\">Shape</span> = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title function_\">paintShape</span>(&#123; shape &#125;);</span><br><span class=\"line\"><span class=\"title function_\">paintShape</span>(&#123; shape, <span class=\"attr\">xPos</span>: <span class=\"number\">100</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">paintShape</span>(&#123; shape, <span class=\"attr\">yPos</span>: <span class=\"number\">100</span> &#125;);</span><br><span class=\"line\"><span class=\"title function_\">paintShape</span>(&#123; shape, <span class=\"attr\">xPos</span>: <span class=\"number\">100</span>, <span class=\"attr\">yPos</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>xPos</code>和<code>yPos</code>都被认为是可选的。我们可以选择提供它们中的任何一个，所以上面对<code>paintShape</code>的每个调用都是有效的。所有的可选性实际上是说，如果属性被设置，它最好有一个特定的类型。</p>\n<p>我们也可以从这些属性中读取，但当我们在<code>strictNullChecks</code>下读取时，TypeScript会告诉我们它们可能是未定义的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">paintShape</span>(<span class=\"params\"><span class=\"attr\">opts</span>: <span class=\"title class_\">PaintOptions</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xPos = opts.<span class=\"property\">xPos</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> yPos = opts.<span class=\"property\">yPos</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在JavaScript中，即使该属性从未被设置过，我们仍然可以访问它–它只是会给我们未定义的值。我们可以专门处理未定义。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">paintShape</span>(<span class=\"params\"><span class=\"attr\">opts</span>: <span class=\"title class_\">PaintOptions</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xPos = opts.<span class=\"property\">xPos</span> === <span class=\"literal\">undefined</span> ? <span class=\"number\">0</span> : opts.<span class=\"property\">xPos</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> yPos = opts.<span class=\"property\">yPos</span> === <span class=\"literal\">undefined</span> ? <span class=\"number\">0</span> : opts.<span class=\"property\">yPos</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这种为未指定的值设置默认值的模式非常普遍，以至于JavaScript有语法来支持它。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">paintShape</span>(<span class=\"params\">&#123; shape, xPos = <span class=\"number\">0</span>, yPos = <span class=\"number\">0</span> &#125;: <span class=\"title class_\">PaintOptions</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;x coordinate at&quot;</span>, xPos);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;y coordinate at&quot;</span>, yPos);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们为 <code>paintShape</code> 的参数使用了一个解构模式，并为 <code>xPos</code> 和 <code>yPos</code> 提供了默认值。现在 <code>xPos</code> 和 <code>yPos</code> 都肯定存在于 <code>paintShape</code> 的主体中，但对于 <code>paintShape</code> 的任何调用者来说是可选的。</p>\n<blockquote>\n<p>请注意，目前还没有办法将类型注释放在解构模式中。这是因为下面的语法在JavaScript中已经有了不同的含义。</p>\n</blockquote>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">draw</span>(<span class=\"params\">&#123; shape: Shape, xPos: <span class=\"built_in\">number</span> = <span class=\"number\">100</span> /*...*/ &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(shape);</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(xPos);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/GItsFTdQPJl9Svf.png\" alt=\"image-20211127082617191\" style=\"zoom:50%;\" />\n\n<p>在一个对象解构模式中，<code>shape: Shape</code> 意味着 “获取属性 <code>shape</code>，并在本地重新定义为一个名为 <code>Shape</code> 的变量。同样，<code>xPos: number</code> 创建一个名为number的变量，其值基于参数的 <code>xPos</code>。</p>\n<h3 id=\"6-1-2-只读属性\"><a href=\"#6-1-2-只读属性\" class=\"headerlink\" title=\"6.1.2 只读属性\"></a>6.1.2 只读属性</h3><p>对于TypeScript，属性也可以被标记为只读。虽然它不会在运行时改变任何行为，但在类型检查期间，一个标记为只读的属性不能被写入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">SomeType</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">prop</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">obj</span>: <span class=\"title class_\">SomeType</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 可以读取 &#x27;obj.prop&#x27;.</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`prop has the value &#x27;<span class=\"subst\">$&#123;obj.prop&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 但不能重新设置值</span></span><br><span class=\"line\">  obj.<span class=\"property\">prop</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-02.png\" alt=\"image-20211127083551809\" style=\"zoom:50%;\" />\n\n<p>使用 <code>readonly</code> 修饰符并不一定意味着一个值是完全不可改变的。或者换句话说，它的内部内容不能被改变，它只是意味着该属性本身不能被重新写入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Home</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">resident</span>: &#123; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">age</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">visitForBirthday</span>(<span class=\"params\"><span class=\"attr\">home</span>: <span class=\"title class_\">Home</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以从&#x27;home.resident&#x27;读取和更新属性。</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Happy birthday <span class=\"subst\">$&#123;home.resident.name&#125;</span>!`</span>);</span><br><span class=\"line\">  home.<span class=\"property\">resident</span>.<span class=\"property\">age</span>++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">evict</span>(<span class=\"params\"><span class=\"attr\">home</span>: <span class=\"title class_\">Home</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 但是我们不能写到&#x27;home&#x27;上的&#x27;resident&#x27;属性本身。</span></span><br><span class=\"line\">  home.<span class=\"property\">resident</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;Victor the Evictor&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-03.png\" alt=\"image-20211127084012491\" style=\"zoom:50%;\" />\n\n<p>管理对 <code>readonly</code> 含义的预期是很重要的。在TypeScript的开发过程中，对于一个对象应该如何被使用的问题，它是有用的信号。TypeScript在检查两个类型的属性是否兼容时，并不考虑这些类型的属性是否是 <code>readonly</code>，所以 <code>readony</code> 属性也可以通过别名来改变。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ReadonlyPerson</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">writablePerson</span>: <span class=\"title class_\">Person</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;Person McPersonface&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正常工作</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">readonlyPerson</span>: <span class=\"title class_\">ReadonlyPerson</span> = writablePerson;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(readonlyPerson.<span class=\"property\">age</span>); <span class=\"comment\">// 打印 &#x27;42&#x27;</span></span><br><span class=\"line\">writablePerson.<span class=\"property\">age</span>++;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(readonlyPerson.<span class=\"property\">age</span>); <span class=\"comment\">// 打印 &#x27;43&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-3-索引签名\"><a href=\"#6-1-3-索引签名\" class=\"headerlink\" title=\"6.1.3 索引签名\"></a>6.1.3 索引签名</h3><p>有时你并不提前知道一个类型的所有属性名称，但你知道值的形状。</p>\n<p>在这些情况下，你可以使用一个索引签名来描述可能的值的类型，比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringArray</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">index</span>: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">myArray</span>: <span class=\"title class_\">StringArray</span> = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> secondItem = myArray[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<p>上面，我们有一个 <code>StringArray</code> 接口，它有一个索引签名。这个索引签名指出，当一个 <code>StringArray</code> 被数字索引时，它将返回一个字符串。</p>\n<p>索引签名的属性类型必须是 <code>string</code> 或 <code>number</code>。</p>\n<p>支持两种类型的索引器是可能的，但是从数字索引器返回的类型必须是字符串索引器返回的类型的子类型。这是因为当用 “数字 “进行索引时，JavaScript实际上会在索引到一个对象之前将其转换为 “字符串”。这意味着用<code>100</code>（一个<code>数字</code>）进行索引和用<code>&quot;100&quot;</code>（一个<code>字符串</code>）进行索引是一样的，所以两者需要一致。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">breed</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NotOkay</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">x</span>: <span class=\"built_in\">number</span>]: <span class=\"title class_\">Animal</span>;</span><br><span class=\"line\">  [<span class=\"attr\">x</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/a2rzdbJlqtuoXFw.png\" alt=\"image-20211127090502640\" style=\"zoom:50%;\" />\n\n<p>虽然字符串索引签名是描述 “字典 “模式的一种强大方式，但它也强制要求所有的属性与它们的返回类型相匹配。这是因为字符串索引声明 <code>obj.property</code> 也可以作为 <code>obj[&quot;property&quot;]</code>。在下面的例子中，<code>name</code>的类型与字符串索引的类型不匹配，类型检查器会给出一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NumberDictionary</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">index</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>; <span class=\"comment\">// ok</span></span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/AzHPBUGvK5JbQpw.png\" alt=\"image-20211127091044224\" style=\"zoom:50%;\" />\n\n<p>然而，如果索引签名是属性类型的联合，不同类型的属性是可以接受的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NumberOrStringDictionary</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">index</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span> | <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>; <span class=\"comment\">// 正确, length 是 number 类型</span></span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>; <span class=\"comment\">// 正确, name 是 string 类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，你可以使索引签名为只读，以防止对其索引的赋值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ReadonlyStringArray</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> [<span class=\"attr\">index</span>: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myArray</span>: <span class=\"title class_\">ReadonlyStringArray</span> = <span class=\"title function_\">getReadOnlyStringArray</span>();</span><br><span class=\"line\">myArray[<span class=\"number\">2</span>] = <span class=\"string\">&quot;Mallory&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-06.png\" alt=\"image-20211127091423550\" style=\"zoom:50%;\" />\n\n<p>你不能设置 <code>myArray[2]</code>，因为这个索引签名是只读的。</p>\n<h2 id=\"6-2-扩展类型\"><a href=\"#6-2-扩展类型\" class=\"headerlink\" title=\"6.2 扩展类型\"></a>6.2 扩展类型</h2><p>有一些类型可能是其他类型的更具体的版本，这是很常见的。例如，我们可能有一个<code>BasicAddress</code>类型，描述发送信件和包裹所需的字段。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">BasicAddress</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">street</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">postalCode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在某些情况下，这就足够了，但是如果一个地址的小区内有多个单元，那么地址往往有一个单元号与之相关。我们就可以描述一个 <code>AddressWithUnit</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">AddressWithUnit</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">unit</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">street</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">postalCode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就完成了工作，但这里的缺点是，当我们的变化是纯粹的加法时，我们不得不重复 <code>BasicAddress</code> 的所有其他字段。相反，我们可以扩展原始的 <code>BasicAddress</code> 类型，只需添加 <code>AddressWithUnit</code> 特有的新字段：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">BasicAddress</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">street</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">postalCode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">AddressWithUnit</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BasicAddress</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">unit</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口上的 <code>extends</code> 关键字，允许我们有效地从其他命名的类型中复制成员，并添加我们想要的任何新成员。这对于减少我们不得不写的类型声明模板，以及表明同一属性的几个不同声明可能是相关的意图来说，是非常有用的。例如，<code>AddressWithUnit</code> 不需要重复 <code>street</code> 属性，而且因为 <code>street</code> 源于 <code>BasicAddress</code>，我们会知道这两种类型在某种程度上是相关的。</p>\n<p>接口也可以从多个类型中扩展。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Colorful</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">color</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ColorfulCircle</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Colorful</span>, <span class=\"title class_\">Circle</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">cc</span>: <span class=\"title class_\">ColorfulCircle</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">color</span>: <span class=\"string\">&quot;red&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-3-交叉类型\"><a href=\"#6-3-交叉类型\" class=\"headerlink\" title=\"6.3 交叉类型\"></a>6.3 交叉类型</h2><p>接口允许我们通过扩展其他类型建立起新的类型。TypeScript提供了另一种结构，称为交叉类型，主要用于组合现有的对象类型。</p>\n<p>交叉类型是用 <code>&amp;</code> 操作符定义的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Colorful</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">color</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ColorfulCircle</span> = <span class=\"title class_\">Colorful</span> &amp; <span class=\"title class_\">Circle</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">cc</span>: <span class=\"title class_\">ColorfulCircle</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">color</span>: <span class=\"string\">&quot;red&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们将 <code>Colorful</code> 和 <code>Circle</code> 相交，产生了一个新的类型，它拥有 <code>Colorful</code> 和 <code>Circle</code> 的所有成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">draw</span>(<span class=\"params\"><span class=\"attr\">circle</span>: <span class=\"title class_\">Colorful</span> &amp; <span class=\"title class_\">Circle</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Color was <span class=\"subst\">$&#123;circle.color&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Radius was <span class=\"subst\">$&#123;circle.radius&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"title function_\">draw</span>(&#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;blue&quot;</span>, <span class=\"attr\">radius</span>: <span class=\"number\">42</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"title function_\">draw</span>(&#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;red&quot;</span>, <span class=\"attr\">raidus</span>: <span class=\"number\">42</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/EwehSBGIodpYQfj.png\" alt=\"image-20211127095046044\" style=\"zoom:50%;\" />\n\n<h2 id=\"6-7-接口与交叉类型\"><a href=\"#6-7-接口与交叉类型\" class=\"headerlink\" title=\"6.7 接口与交叉类型\"></a>6.7 接口与交叉类型</h2><p>我们刚刚看了两种组合类型的方法，它们很相似，但实际上有细微的不同。对于接口，我们可以使用 <code>extends</code>子句来扩展其他类型，而对于交叉类型，我们也可以做类似的事情，并用类型别名来命名结果。两者之间的主要区别在于如何处理冲突，这种区别通常是你在接口和交叉类型的类型别名之间选择一个的主要原因之一。</p>\n<img src=\"https://s2.loli.net/2022/02/22/tYex2cry6HGUgfT.png\" alt=\"image-20211127101912142\" style=\"zoom:50%;\" />\n\n<p>接口可以定义多次，多次的声明会自动合并：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Sister</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Sister</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">sisterAn</span>: <span class=\"title class_\">Sister</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;sisterAn&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">sisterRan</span>: <span class=\"title class_\">Sister</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;sisterRan&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">12</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-09.png\" alt=\"image-20211127102424559\" style=\"zoom:50%;\" />\n\n<p>但是类型别名如果定义多次，会报错：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Sister</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Sister</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/06-10.png\" alt=\"image-20211127102801182\" style=\"zoom:50%;\" />\n\n<h2 id=\"6-8-泛型对象类型\"><a href=\"#6-8-泛型对象类型\" class=\"headerlink\" title=\"6.8 泛型对象类型\"></a>6.8 泛型对象类型</h2><p>让我们想象一下，一个可以包含任何数值的盒子类型：字符串、数字、长颈鹿，等等。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，内容属性的类型是任意，这很有效，但会导致下一步的意外。</p>\n<p>我们可以使用 <code>unknown</code>，但这意味着在我们已经知道内容类型的情况下，我们需要做预防性检查，或者使用容易出错的类型断言。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">unknown</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"title class_\">Box</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"string\">&quot;hello world&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们需要检查 &#x27;x.contents&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x.<span class=\"property\">contents</span> === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x.<span class=\"property\">contents</span>.<span class=\"title function_\">toLowerCase</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者用类型断言</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>((x.<span class=\"property\">contents</span> <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).<span class=\"title function_\">toLowerCase</span>());</span><br></pre></td></tr></table></figure>\n\n<p>一种安全的方法是为每一种类型的内容搭建不同的盒子类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NumberBox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringBox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">BooleanBox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这意味着我们必须创建不同的函数，或函数的重载，以对这些类型进行操作：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setContents</span>(<span class=\"params\"><span class=\"attr\">box</span>: <span class=\"title class_\">StringBox</span>, <span class=\"attr\">newContents</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setContents</span>(<span class=\"params\"><span class=\"attr\">box</span>: <span class=\"title class_\">NumberBox</span>, <span class=\"attr\">newContents</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setContents</span>(<span class=\"params\"><span class=\"attr\">box</span>: <span class=\"title class_\">BooleanBox</span>, <span class=\"attr\">newContents</span>: <span class=\"built_in\">boolean</span></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setContents</span>(<span class=\"params\"><span class=\"attr\">box</span>: &#123; contents: <span class=\"built_in\">any</span> &#125;, <span class=\"attr\">newContents</span>: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">  box.<span class=\"property\">contents</span> = newContents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那是一个很大的模板。此外，我们以后可能需要引入新的类型和重载。这是令人沮丧的，因为我们的盒子类型和重载实际上都是一样的。</p>\n<p>相反，我们可以做一个通用的 <code>Box</code> 类型，声明一个类型参数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以把这句话理解为：”一个类型的盒子，是它的内容具有类型的东西”。以后，当我们引用 <code>Box</code> 时，我们必须给一个类型参数来代替 <code> Type</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">box</span>: <span class=\"title class_\">Box</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>把 <code>Box</code> 想象成一个真实类型的模板，其中 <code>Type</code> 是一个占位符，会被替换成其他类型。当 TypeScript 看到 <code>Box&lt;string&gt;</code> 时，它将用字符串替换 <code>Box&lt;Type&gt;</code> 中的每个 <code>Type</code> 实例，并最终以 <code>&#123; contents: string &#125;</code> 这样的方式工作。换句话说，<code>Box&lt;string&gt;</code>和我们之前的<code>StringBox</code>工作起来是一样的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringBox</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">boxA</span>: <span class=\"title class_\">Box</span>&lt;<span class=\"built_in\">string</span>&gt; = &#123; <span class=\"attr\">contents</span>: <span class=\"string\">&quot;hello&quot;</span> &#125;;</span><br><span class=\"line\">boxA.<span class=\"property\">contents</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">boxB</span>: <span class=\"title class_\">StringBox</span> = &#123; <span class=\"attr\">contents</span>: <span class=\"string\">&quot;world&quot;</span> &#125;;</span><br><span class=\"line\">boxB.<span class=\"property\">contents</span>;</span><br></pre></td></tr></table></figure>\n\n<p>盒子是可重用的，因为Type可以用任何东西来代替。这意味着当我们需要一个新类型的盒子时，我们根本不需要声明一个新的盒子类型（尽管如果我们想的话，我们当然可以）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Apple</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于 &#x27;&#123; contents: Apple &#125;&#x27;.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">AppleBox</span> = <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Apple</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>这也意味着我们可以完全避免重载，而是使用通用函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> setContents&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">box</span>: <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt;, <span class=\"attr\">newContents</span>: <span class=\"title class_\">Type</span>) &#123;</span><br><span class=\"line\">  box.<span class=\"property\">contents</span> = newContents;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，类型别名也可以是通用的。我们可以定义我们新的 <code>Box&lt;Type&gt;</code>接口：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过使用一个类型别名来代替：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; = &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于类型别名与接口不同，它不仅可以描述对象类型，我们还可以用它来编写其他类型的通用辅助类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OrNull</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> | <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OneOrMany</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">Type</span> | <span class=\"title class_\">Type</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OneOrManyOrNull</span>&lt;<span class=\"title class_\">Type</span>&gt; = <span class=\"title class_\">OrNull</span>&lt;<span class=\"title class_\">OneOrMany</span>&lt;<span class=\"title class_\">Type</span>&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">OneOrManyOrNullStrings</span> = <span class=\"title class_\">OneOrManyOrNull</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>我们将在稍后回到类型别名。</p>\n<p>通用对象类型通常是某种容器类型，它的工作与它们所包含的元素类型无关。数据结构以这种方式工作是很理想的，这样它们就可以在不同的数据类型中重复使用。</p>\n<h2 id=\"6-9-数组类型\"><a href=\"#6-9-数组类型\" class=\"headerlink\" title=\"6.9 数组类型\"></a>6.9 数组类型</h2><p>我们一直在使用这样一种类型：数组类型。每当我们写出 <code>number[]</code> 或 <code>string[]</code> 这样的类型时，这实际上只是 <code>Array&lt;number&gt;</code>和<code>Array&lt;string&gt;</code>的缩写。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">string</span>&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myArray</span>: <span class=\"built_in\">string</span>[] = [<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这两样都能用</span></span><br><span class=\"line\"><span class=\"title function_\">doSomething</span>(myArray);</span><br><span class=\"line\"><span class=\"title function_\">doSomething</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>和上面的 <code>Box</code> 类型一样，<code>Array</code> 本身也是一个通用类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Array</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 获取或设置数组的长度。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 移除数组中的最后一个元素并返回。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"title function_\">pop</span>(): <span class=\"title class_\">Type</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 向一个数组添加新元素，并返回数组的新长度。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"title function_\">push</span>(...<span class=\"attr\">items</span>: <span class=\"title class_\">Type</span>[]): <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现代JavaScript还提供了其他通用的数据结构，比如 <code>Map&lt;K, V&gt; </code>, <code>Set&lt;T&gt;</code>, 和 <code>Promise&lt;T&gt;</code>。这实际上意味着，由于<code>Map</code>、<code>Set</code>和<code>Promise</code>的行为方式，它们可以与任何类型的集合一起工作。</p>\n<h2 id=\"6-10-只读数组类型\"><a href=\"#6-10-只读数组类型\" class=\"headerlink\" title=\"6.10 只读数组类型\"></a>6.10 只读数组类型</h2><p><code>ReadonlyArray</code>是一个特殊的类型，描述了不应该被改变的数组。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doStuff</span>(<span class=\"params\"><span class=\"attr\">values</span>: <span class=\"title class_\">ReadonlyArray</span>&lt;<span class=\"built_in\">string</span>&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以从 &#x27;values&#x27; 读数据...</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = values.<span class=\"title function_\">slice</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`第一个值是 <span class=\"subst\">$&#123;values[<span class=\"number\">0</span>]&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...但我们不能改变 &#x27;vulues&#x27; 的值。</span></span><br><span class=\"line\">  values.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;hello!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/bBVuXOf5oQqIMgG.png\" alt=\"image-20211127191529424\" style=\"zoom:50%;\" />\n\n<p>和属性的 <code>readonly</code> 修饰符一样，它主要是一个我们可以用来了解意图的工具。当我们看到一个返回<code>ReadonlyArrays</code> 的函数时，它告诉我们我们根本不打算改变其内容，而当我们看到一个消耗 <code>ReadonlyArrays</code>的函数时，它告诉我们可以将任何数组传入该函数，而不用担心它会改变其内容。</p>\n<p>与 <code>Array</code> 不同，没有一个我们可以使用的 <code>ReadonlyArray</code>构造函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ReadonlyArray</span>(<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/3S2e6YC9UQKbGNy.png\" alt=\"image-20211127191946986\" style=\"zoom: 67%;\" />\n\n<p>相反，我们可以将普通的 <code>Array</code> 分配给 <code>ReadonlyArray</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">roArray</span>: <span class=\"title class_\">ReadonlyArray</span>&lt;<span class=\"built_in\">string</span>&gt; = [<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>正如 TypeScript为 <code>Array&lt;Type&gt;</code> 提供了 <code>Type[]</code> 的速记语法一样，它也为 <code>ReadonlyArray&lt;Type&gt;</code>提供了只读<code>Type[]</code>的速记语法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doStuff</span>(<span class=\"params\"><span class=\"attr\">values</span>: <span class=\"keyword\">readonly</span> <span class=\"built_in\">string</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以从 &#x27;values&#x27; 读数据...</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> copy = values.<span class=\"title function_\">slice</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`The first value is <span class=\"subst\">$&#123;values[<span class=\"number\">0</span>]&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 但我们不能改变 &#x27;vulues&#x27; 的值。</span></span><br><span class=\"line\">  values.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;hello!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2022/02/22/TngAvtrq5W1LQhc.png\" alt=\"image-20211127192458009\"></p>\n<p>最后要注意的是，与 <code>readony</code> 属性修改器不同，可分配性在普通 <code>Array</code> 和 <code>ReadonlyArray</code> 之间不是双向的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"keyword\">readonly</span> <span class=\"built_in\">string</span>[] = [];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">y</span>: <span class=\"built_in\">string</span>[] = [];</span><br><span class=\"line\"></span><br><span class=\"line\">x = y;</span><br><span class=\"line\">y = x;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/fwveBsiLpA7FqNK.png\" alt=\"image-20211127192932203\" style=\"zoom:50%;\" />\n\n<h2 id=\"6-11-元组类型\"><a href=\"#6-11-元组类型\" class=\"headerlink\" title=\"6.11 元组类型\"></a>6.11 元组类型</h2><p><code>Tuple</code> 类型是另一种 <code>Array</code> 类型，它确切地知道包含多少个元素，以及它在特定位置包含哪些类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StringNumberPair</span> = [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br></pre></td></tr></table></figure>\n\n<p>这里，<code>StringNumberPair</code> 是一个 <code>string</code> 和 <code>number</code> 的元组类型。像 <code>ReadonlyArray</code> 一样，它在运行时没有表示，但对TypeScript来说是重要的。对于类型系统来说，<code>StringNumberPair</code> 描述了其 索引 0 包含字符串和 索引1 包含数字的数组。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">pair</span>: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = pair[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = pair[<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">doSomething</span>([<span class=\"string\">&quot;hello&quot;</span>, <span class=\"number\">42</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>如果我们试图索引超过元素的数量，我们会得到一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">pair</span>: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> c = pair[<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2022/02/22/9nMPvE3DZpdRuTA.png\" alt=\"image-20211127202845783\"></p>\n<p>我们还可以使用JavaScript的数组析构来对元组进行解构。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">stringHash</span>: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [inputString, hash] = stringHash;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(inputString);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(hash);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了这些长度检查，像这样的简单元组类型等同于 <code>Array</code> 的版本，它为特定的索引声明属性，并且用数字字面类型声明长度。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringNumberPair</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 专有属性</span></span><br><span class=\"line\">  <span class=\"attr\">length</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 其他 &#x27;Array&lt;string | number&gt;&#x27; 成员...</span></span><br><span class=\"line\">  <span class=\"title function_\">slice</span>(<span class=\"attr\">start</span>?: <span class=\"built_in\">number</span>, <span class=\"attr\">end</span>?: <span class=\"built_in\">number</span>): <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一件你可能感兴趣的事情是，元组可以通过在元素的类型后面写出问号（？）—— 可选的元组，元素只能出现在末尾，而且还影响到长度的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Either2</span>dOr3d = [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>?];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setCoordinate</span>(<span class=\"params\"><span class=\"attr\">coord</span>: <span class=\"title class_\">Either2</span>dOr3d</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [x, y, z] = coord;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`提供的坐标有 <span class=\"subst\">$&#123;coord.length&#125;</span> 个维度`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/fPVJp1tlRhyHYsW.png\" alt=\"image-20211127204518693\" style=\"zoom:50%;\" />\n\n<p>图元也可以有其余元素，这些元素必须是 <code>array/tuple</code> 类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StringNumberBooleans</span> = [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>, ...<span class=\"built_in\">boolean</span>[]];</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">StringBooleansNumber</span> = [<span class=\"built_in\">string</span>, ...<span class=\"built_in\">boolean</span>[], <span class=\"built_in\">number</span>];</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">BooleansStringNumber</span> = [...<span class=\"built_in\">boolean</span>[], <span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>StringNumberBooleans</code> 描述了一个元组，其前两个元素分别是字符串和数字，但后面可以有任意数量的布尔。</p>\n</li>\n<li><p><code>StringBooleansNumber</code> 描述了一个元组，其第一个元素是字符串，然后是任意数量的布尔运算，最后是一个数字。</p>\n</li>\n<li><p><code>BooleansStringNumber</code> 描述了一个元组，其起始元素是任意数量的布尔运算，最后是一个字符串，然后是一个数字。</p>\n</li>\n</ul>\n<p>一个有其余元素的元组没有集合的 “长度”——它只有一组不同位置的知名元素。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">a</span>: <span class=\"title class_\">StringNumberBooleans</span> = [<span class=\"string\">&quot;hello&quot;</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">b</span>: <span class=\"title class_\">StringNumberBooleans</span> = [<span class=\"string\">&quot;beautiful&quot;</span>, <span class=\"number\">2</span>, <span class=\"literal\">true</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">c</span>: <span class=\"title class_\">StringNumberBooleans</span> = [<span class=\"string\">&quot;world&quot;</span>, <span class=\"number\">3</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n\n<p>为什么可选元素和其余元素可能是有用的？它允许TypeScript将 <code>tuples</code> 与参数列表相对应。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">readButtonInput</span>(<span class=\"params\">...<span class=\"attr\">args</span>: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>, ...<span class=\"built_in\">boolean</span>[]]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [name, version, ...input] = args;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本上等同于：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">readButtonInput</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">version</span>: <span class=\"built_in\">number</span>, ...<span class=\"attr\">input</span>: <span class=\"built_in\">boolean</span>[]</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你想用一个其余(rest)参数接受可变数量的参数，并且你需要一个最小的元素数量，但你不想引入中间变量时，这很方便。</p>\n<h2 id=\"6-12-只读元组类型\"><a href=\"#6-12-只读元组类型\" class=\"headerlink\" title=\"6.12 只读元组类型\"></a>6.12 只读元组类型</h2><p>关于 <code>tuple</code> 类型的最后一点说明：<code>tuple</code> 类型有只读特性，可以通过在它们前面粘贴一个<code>readonly</code>修饰符来指定——就像数组的速记语法一样。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">pair</span>: <span class=\"keyword\">readonly</span> [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正如你所期望的，在TypeScript中不允许向只读元组的任何属性写入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"><span class=\"attr\">pair</span>: <span class=\"keyword\">readonly</span> [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  pair[<span class=\"number\">0</span>] = <span class=\"string\">&quot;hello!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/mZUgrFvnJG2a9Qw.png\" alt=\"image-20211127210344032\" style=\"zoom:50%;\" />\n\n<p>在大多数代码中，元组往往被创建并不被修改，所以在可能的情况下，将类型注释为只读元组是一个很好的默认。这一点也很重要，因为带有 <code>const</code> 断言的数组字面量将被推断为只读元组类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> point = [<span class=\"number\">3</span>, <span class=\"number\">4</span>] <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">distanceFromOrigin</span>(<span class=\"params\">[x, y]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">sqrt</span>(x ** <span class=\"number\">2</span> + y ** <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">distanceFromOrigin</span>(point);</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://s2.loli.net/2022/02/22/GOd6ieyPvTsaxrw.png\" alt=\"image-20211127210654160\" style=\"zoom:50%;\" />\n\n<p>在这里，<code>distanceFromOrigin</code> 从未修改过它的元素，而是期望一个可变的元组。由于 <code>point</code>的类型被推断为只读的 <code>[3, 4]</code>，它与 <code>[number, number]</code> 不兼容，因为该类型不能保证 <code>point</code> 的元素不被修改。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "1-8、基础篇：类",
        "toc": true,
        "abbrlink": 55025,
        "date": "2024-01-28T11:48:15.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_01.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 八、类\n\nTypeScript提供了对ES2015中引入的 `class` 关键词的完全支持。\n\n与其他JavaScript语言功能一样，TypeScript增加了类型注释和其他语法，允许你表达类和其他类型之间的关系。\n\n## 8.1 类成员\n\n这里有一个最基本的类——一个空的类：\n\n```tsx\nclass Point {}\n```\n\n这个类还不是很有用，所以我们开始添加一些成员。\n\n### 8.1.1 类属性\n\n在一个类上声明字段，创建一个公共的可写属性：A mapped type is a generic type which uses a union of `PropertyKey`s (frequently created [via a `keyof`](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)) to iterate through keys to create a type:\n\n```\n\n```\n\n```tsx\nclass Point {\n  x: number;\n  y: number;\n}\n\nconst pt = new Point();\npt.x = 0;\npt.y = 0;\n```\n\n与其他位置一样，类型注解是可选的，但如果不指定，将是一个隐含的 `any` 类型。\n\n字段也可以有初始化器；这些初始化器将在类被实例化时自动运行。\n\n```tsx\nclass Point {\n  x = 0;\n  y = 0;\n}\n\nconst pt = new Point();\n// Prints 0, 0\nconsole.log(`${pt.x}, ${pt.y}`);\n```\n\n就像 `const`、`let`和`var`一样，一个类属性的初始化器将被用来推断其类型。\n\n```tsx\nconst pt = new Point();\npt.x = \"0\";\n```\n\n<img src=\"/img/TypeScript/09-01.png\" alt=\"image-20211129114803786\" style=\"zoom:50%;\" />\n\n- `--strictPropertyInitialization`\n\n`strictPropertyInitialization`设置控制是否需要在构造函数中初始化类字段。\n\n<img src=\"/img/TypeScript/09-02.png\" alt=\"image-20211129115145529\" style=\"zoom:50%;\" />\n\n```tsx\nclass BadGreeter {\n  name: string;\n}\n```\n\n<img src=\"/img/TypeScript/09-04.png\" alt=\"image-20211129115341214\" style=\"zoom:50%;\" />\n\n```tsx\nclass GoodGreeter {\n  name: string;\n\n  constructor() {\n    this.name = \"hello\";\n  }\n}\n```\n\n请注意，该字段需要在构造函数本身中初始化。TypeScript不会分析你从构造函数中调用的方法来检测初始化，因为派生类可能会覆盖这些方法而无法初始化成员。\n\n如果你打算通过构造函数以外的方式来确定初始化一个字段（例如，也许一个外部库为你填充了你的类的一部分），你可以使用确定的赋值断言操作符 `！`。\n\n```tsx\nclass OKGreeter {\n  // 没有初始化，但没报错。\n  name!: string;\n}\n```\n\n### 8.1.2 `readonly`\n\n字段的前缀可以是 `readonly` 修饰符。这可以防止在构造函数之外对该字段进行赋值。\n\n```tsx\nclass Greeter {\n  readonly name: string = \"world\";\n\n  constructor(otherName?: string) {\n    if (otherName !== undefined) {\n      this.name = otherName;\n    }\n  }\n\n  err() {\n    this.name = \"not ok\";\n  }\n}\nconst g = new Greeter();\ng.name = \"also not ok\";\n```\n\n<img src=\"/img/TypeScript/09-05.png\" alt=\"image-20211129120222803\" style=\"zoom:50%;\" />\n\n### 8.1.3 构造器\n\n类构造函数与函数非常相似。你可以添加带有类型注释的参数、默认值和重载：\n\n```tsx\nclass Point {\n  x: number;\n  y: number;\n\n  // 带默认值的正常签名\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n}\n```\n\n```tsx\nclass Point {\n  // 重载\n  constructor(x: number, y: string);\n  constructor(s: string);\n  constructor(xs: any, y?: any) {\n    // ...\n  }\n}\n```\n\n类的构造函数签名和函数签名之间只有一些区别：\n\n- 构造函数不能有类型参数--这属于外层类的声明，我们将在后面学习。\n\n- 构造函数不能有返回类型注释——类的实例类型总是被返回的。\n\n**Super 调用**\n\n就像在JavaScript中一样，如果你有一个基类，在使用任何 `this.`成员之前，你需要在构造器主体中调用`super();`。\n\n```tsx\nclass Base {\n  k = 4;\n}\n\nclass Derived extends Base {\n  constructor() {\n    // 在ES5中打印一个错误的值；在ES6中抛出异常。\n    console.log(this.k);\n    super();\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-06.png\" alt=\"image-20211129135259853\" style=\"zoom:50%;\" />\n\n在JavaScript中，忘记调用 `super` 是一个很容易犯的错误，但TypeScript会在必要时告诉你。\n\n### 8.1.4 方法\n\n一个类上的函数属性被称为方法。方法可以使用与函数和构造函数相同的所有类型注释。\n\n```tsx\nclass Point {\n  x = 10;\n  y = 10;\n\n  scale(n: number): void {\n    this.x *= n;\n    this.y *= n;\n  }\n}\n```\n\n除了标准的类型注解，TypeScript并没有为方法添加其他新的东西。\n\n请注意，在一个方法体中，仍然必须通过`this`访问字段和其他方法。方法体中的非限定名称将总是指代包围范围内的东西。\n\n```tsx\nlet x: number = 0;\n\nclass C {\n  x: string = \"hello\";\n\n  m() {\n    // 这是在试图修改第1行的'x'，而不是类属性。\n    x = \"world\";\n  }\n}\n```\n\n### 8.1.5 Getters / Setters\n\n类也可以有访问器：\n\n```tsx\nclass C {\n  _length = 0;\n  get length() {\n    return this._length;\n  }\n  set length(value) {\n    this._length = value;\n  }\n}\n```\n\n> 请注意，一个没有额外逻辑的字段支持的`get/set`对在JavaScript中很少有用。如果你不需要在`get/set`操作中添加额外的逻辑，暴露公共字段也是可以的。\n\nTypeScript对访问器有一些特殊的推理规则：\n\n- 如果存在 `get`，但没有`set`，则该属性自动是只读的\n\n- 如果没有指定`setter`参数的类型，它将从`getter`的返回类型中推断出来\n\n- 访问器和设置器必须有相同的成员可见性\n\n从TypeScript 4.3开始，可以有不同类型的访问器用于获取和设置。\n\n```tsx\nclass Thing {\n  _size = 0;\n\n  get size(): number {\n    return this._size;\n  }\n\n  set size(value: string | number | boolean) {\n    let num = Number(value);\n\n    // 不允许NaN、Infinity等\n\n    if (!Number.isFinite(num)) {\n      this._size = 0;\n      return;\n    }\n\n    this._size = num;\n  }\n}\n```\n\n### 8.1.6 索引签名\n\n类可以声明索引签名；这些签名的作用与其他对象类型的索引签名相同。\n\n```tsx\nclass MyClass {\n  [s: string]: boolean | ((s: string) => boolean);\n\n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n```\n\n因为索引签名类型需要同时捕获方法的类型，所以要有用地使用这些类型并不容易。一般来说，最好将索引数据存储在另一个地方，而不是在类实例本身。\n\n## 8.2 类继承\n\n像其他具有面向对象特性的语言一样，JavaScript中的类可以继承自基类。\n\n### 8.2.1 `implements`子句\n\n你可以使用一个 `implements` 子句来检查一个类，是否满足了一个特定的接口。如果一个类不能正确地实现它，就会发出一个错误。\n\n```tsx\ninterface Pingable {\n  ping(): void;\n}\n\nclass Sonar implements Pingable {\n  ping() {\n    console.log(\"ping!\");\n  }\n}\n\nclass Ball implements Pingable {\n  pong() {\n    console.log(\"pong!\");\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-07.png\" alt=\"image-20211129154149915\" style=\"zoom:50%;\" />\n\n类也可以实现多个接口，例如 `class C implements A, B {`\n\n**注意事项**\n\n重要的是要明白， `implements` 子句只是检查类是否可以被当作接口类型来对待。它根本不会改变类的类型或其方法。一个常见的错误来源是认为 `implements` 子句会改变类的类型--它不会！它不会。\n\n```tsx\ninterface Checkable {\n  check(name: string): boolean;\n}\n\nclass NameChecker implements Checkable {\n  check(s) {\n    // any：注意这里没有错误\n    return s.toLowercse() === \"ok\";\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-08.png\" alt=\"image-20211129163841634\" style=\"zoom:50%;\" />\n\n在这个例子中，我们也许期望 `s` 的类型会受到 `check`的`name: string`参数的影响。事实并非如此--实现子句并没有改变类主体的检查方式或其类型的推断。\n\n同样地，实现一个带有可选属性的接口并不能创建该属性。\n\n```tsx\ninterface A {\n  x: number;\n  y?: number;\n}\nclass C implements A {\n  x = 0;\n}\nconst c = new C();\nc.y = 10;\n```\n\n<img src=\"/img/TypeScript/09-09.png\" alt=\"image-20211129164354121\" style=\"zoom:50%;\" />\n\n### 8.2.2 `extends`子句\n\n类可以从基类中扩展出来。派生类拥有其基类的所有属性和方法，也可以定义额外的成员。\n\n```tsx\nclass Animal {\n  move() {\n    console.log(\"Moving along!\");\n  }\n}\n\nclass Dog extends Animal {\n  woof(times: number) {\n    for (let i = 0; i < times; i++) {\n      console.log(\"woof!\");\n    }\n  }\n}\n\nconst d = new Dog();\n// 基类的类方法\nd.move();\n// 派生的类方法\nd.woof(3);\n```\n\n### 8.2.3 重写方法\n\n派生类也可以覆盖基类的一个字段或属性。你可以使用`super.`语法来访问基类方法。注意，因为JavaScript类是一个简单的查找对象，没有 \"超级字段 \"的概念。\n\nTypeScript强制要求派生类总是其基类的一个子类型。\n\n例如，这里有一个合法的方法来覆盖一个方法。\n\n```tsx\nclass Base {\n  greet() {\n    console.log(\"Hello, world!\");\n  }\n}\n\nclass Derived extends Base {\n  greet(name?: string) {\n    if (name === undefined) {\n      super.greet();\n    } else {\n      console.log(`Hello, ${name.toUpperCase()}`);\n    }\n  }\n}\n\nconst d = new Derived();\nd.greet();\nd.greet(\"reader\");\n```\n\n派生类遵循其基类契约是很重要的。请记住，通过基类引用来引用派生类实例是非常常见的（而且总是合法的！）。\n\n```tsx\n// 通过基类引用对派生实例进行取别名\nconst b: Base = d;\n// 没问题\nb.greet();\n```\n\n如果`Derived`没有遵守Base的约定怎么办？\n\n```tsx\nclass Base {\n  greet() {\n    console.log(\"Hello, world!\");\n  }\n}\n\nclass Derived extends Base {\n  // 使这个参数成为必需的\n  greet(name: string) {\n    console.log(`Hello, ${name.toUpperCase()}`);\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-10.png\" alt=\"image-20211129191159846\" style=\"zoom:50%;\" />\n\n如果我们不顾错误编译这段代码，这个样本就会崩溃：\n\n```tsx\nconst b: Base = new Derived();\n// 崩溃，因为 \"名称 \"将是 undefined。\nb.greet();\n```\n\n<img src=\"/img/TypeScript/09-11.png\" alt=\"image-20211129191741373\" style=\"zoom:50%;\" />\n\n### 8.2.4 初始化顺序\n\n在某些情况下，JavaScript类的初始化顺序可能会令人惊讶。让我们考虑一下这段代码：\n\n```tsx\nclass Base {\n  name = \"base\";\n  constructor() {\n    console.log(\"My name is \" + this.name);\n  }\n}\n\nclass Derived extends Base {\n  name = \"derived\";\n}\n\n// 打印 \"base\", 而不是 \"derived\"\nconst d = new Derived();\n```\n\n这里发生了什么？\n\n按照JavaScript的定义，类初始化的顺序是：\n\n- 基类的字段被初始化\n- 基类构造函数运行\n- 派生类的字段被初始化\n- 派生类构造函数运行\n\n这意味着基类构造函数在自己的构造函数中看到了自己的name值，因为派生类的字段初始化还没有运行。\n\n### 8.2.5 继承内置类型\n\n> 注意：如果你不打算继承Array、Error、Map等内置类型，或者你的编译目标明确设置为ES6/ES2015或以上，你可以跳过本节。\n\n在ES2015中，返回对象的构造函数隐含地替代了`super(...)`的任何调用者的`this`的值。生成的构造函数代码有必要捕获`super(...)`的任何潜在返回值并将其替换为`this`。\n\n因此，子类化`Error`、`Array`等可能不再像预期那样工作。这是由于`Error`、`Array`等的构造函数使用ECMAScript 6的`new.target`来调整原型链；然而，在ECMAScript 5中调用构造函数时，没有办法确保`new.target`的值。其他的下级编译器一般默认有同样的限制。\n\n对于一个像下面这样的子类：\n\n```tsx\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n  }\n  sayHello() {\n    return \"hello \" + this.message;\n  }\n}\n```\n\n你可能会发现：\n\n- 方法在构造这些子类所返回的对象上可能是未定义的，所以调用 `sayHello` 会导致错误。\n\n<img src=\"/img/TypeScript/09-12.png\" alt=\"image-20211129205005544\" style=\"zoom:50%;\" />\n\n- `instanceof`将在子类的实例和它们的实例之间被打破，所以`（new MsgError()）instanceof MsgError`将返回`false`。\n\n<img src=\"/img/TypeScript/09-13.png\" alt=\"image-20211129205309009\" style=\"zoom:50%;\" />\n\n作为建议，你可以在任何`super(...)`调用后立即手动调整原型。\n\n```tsx\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n\n    // 明确地设置原型。\n    Object.setPrototypeOf(this, MsgError.prototype);\n  }\n\n  sayHello() {\n    return \"hello \" + this.message;\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-14.png\" alt=\"image-20211129205721788\" style=\"zoom:50%;\" />\n\n然而，`MsgError`的任何子类也必须手动设置原型。对于不支持`Object.setPrototypeOf`的运行时，你可以使用`__proto__`来代替。\n\n不幸的是，这些变通方法在`Internet Explorer 10`和更早的版本上不起作用。我们可以手动将原型中的方法复制到实例本身（例如`MsgError.prototype`到`this`），但是原型链本身不能被修复。\n\n## 8.2 成员的可见性\n\n你可以使用TypeScript来控制某些方法或属性对类外的代码是否可见。\n\n### 8.2.1 `public`\n\n类成员的默认可见性是公共(`public`)的。一个公共(`public`)成员可以在任何地方被访问。\n\n```tsx\nclass Greeter {\n  public greet() {\n    console.log(\"hi!\");\n  }\n}\nconst g = new Greeter();\ng.greet();\n```\n\n因为`public`已经是默认的可见性修饰符，所以你永远不需要在类成员上写它，但为了风格/可读性的原因，可能会选择这样做。\n\n### 8.2.2 `protected`\n\n受保护的(`protected`)成员只对它们所声明的类的子类可见。\n\n```tsx\nclass Greeter {\n  public greet() {\n    console.log(\"Hello, \" + this.getName());\n  }\n  protected getName() {\n    return \"hi\";\n  }\n}\n\nclass SpecialGreeter extends Greeter {\n  public howdy() {\n    // 在此可以访问受保护的成员\n    console.log(\"Howdy, \" + this.getName());\n  }\n}\nconst g = new SpecialGreeter();\ng.greet(); // 没有问题\ng.getName(); // 无权访问\n```\n\n<img src=\"/img/TypeScript/09-15.png\" alt=\"image-20211130102051422\" style=\"zoom:50%;\" />\n\n- **受保护成员的暴露**\n\n派生类需要遵循它们的基类契约，但可以选择公开具有更多能力的基类的子类型。这包括将受保护的成员变成公开。\n\n```tsx\nclass Base {\n  protected m = 10;\n}\nclass Derived extends Base {\n  // 没有修饰符，所以默认为'公共'('public')\n  m = 15;\n}\nconst d = new Derived();\nconsole.log(d.m); // OK\n```\n\n### 8.2.3 `private`\n\n`private`和`protected`一样，但不允许从子类中访问该成员。\n\n```tsx\nclass Base {\n  private x = 0;\n}\nconst b = new Base();\n// 不能从类外访问\nconsole.log(b.x);\n```\n\n<img src=\"/img/TypeScript/09-17.png\" alt=\"image-20211130104530638\" style=\"zoom:50%;\" />\n\n```tsx\nclass Base {\n  private x = 0;\n}\nconst b = new Base();\n\nclass Derived extends Base {\n  showX() {\n    // 不能在子类中访问\n    console.log(this.x);\n  }\n}\n```\n\n因为私有(`private`)成员对派生类是不可见的，所以派生类不能增加其可见性。\n\n- **跨实例的私有访问**\n\n不同的OOP语言对同一个类的不同实例，是否可以访问对方的私有成员，有不同的处理方法。虽然像Java、C#、C++、Swift和PHP等语言允许这样做，但Ruby不允许。\n\nTypeScript确实允许跨实例的私有访问：\n\n```tsx\nclass A {\n  private x = 10;\n\n  public sameAs(other: A) {\n    // 可以访问\n    return other.x === this.x;\n  }\n}\n```\n\n- **注意事项**\n\n像TypeScript类型系统的其他方面一样，`private`和`protected`只在类型检查中被强制执行。\n\n这意味着JavaScript的运行时结构，如`in`或简单的属性查询，仍然可以访问一个私有或保护的成员。\n\n```tsx\nclass MySafe {\n  private secretKey = 12345;\n}\n```\n\n```tsx\n// 在JS环境中...\nconst s = new MySafe();\n// 将打印 12345\nconsole.log(s.secretKey);\n```\n\n`private`也允许在类型检查时使用括号符号进行访问。这使得私有声明的字段可能更容易被单元测试之类的东西所访问，缺点是这些字段是软性私有的，不能严格执行私有特性。\n\n```tsx\nclass MySafe {\n  private secretKey = 12345;\n}\n\nconst s = new MySafe();\n\n// 在类型检查期间不允许\nconsole.log(s.secretKey);\n\n// 正确\nconsole.log(s[\"secretKey\"]);\n```\n\n<img src=\"/img/TypeScript/09-19.png\" alt=\"image-20211130135104155\" style=\"zoom:50%;\" />\n\n与TypeScript的 `private`不同，JavaScript的`private`字段（#）在编译后仍然是`private`的，并且不提供前面提到的像括号符号访问那样的转义窗口，使其成为硬`private`。\n\n```tsx\nclass Dog {\n  #barkAmount = 0;\n  personality = \"happy\";\n\n  constructor() {\n    // 0\n    console.log(this.#barkAmount);\n  }\n}\n\nconst dog = new Dog();\n// undefined\nconsole.log(dog.barkAmount);\n```\n\n<img src=\"/img/TypeScript/09-20.png\" alt=\"image-20211130154613004\" style=\"zoom:50%;\" />\n\n当编译到ES2021或更少时，TypeScript将使用WeakMaps来代替 `#`。\n\n```tsx\n\"use strict\";\nvar _Dog_barkAmount;\nclass Dog {\n  constructor() {\n    _Dog_barkAmount.set(this, 0);\n    this.personality = \"happy\";\n  }\n}\n_Dog_barkAmount = new WeakMap();\n```\n\n如果你需要保护你的类中的值免受恶意行为的影响，你应该使用提供硬运行时隐私的机制，如闭包、`WeakMaps`或私有字段。请注意，这些在运行时增加的隐私检查可能会影响性能。\n\n## 8.3 静态成员\n\n类可以有静态成员。这些成员并不与类的特定实例相关联。它们可以通过类的构造函数对象本身来访问。\n\n```tsx\nclass MyClass {\n  static x = 0;\n  static printX() {\n    console.log(MyClass.x);\n  }\n}\nconsole.log(MyClass.x);\nMyClass.printX();\n```\n\n静态成员也可以使用相同的`public`、`protected`和`private`可见性修饰符。\n\n```tsx\nclass MyClass {\n  private static x = 0;\n}\nconsole.log(MyClass.x);\n```\n\n<img src=\"/img/TypeScript/09-21.png\" alt=\"image-20211130161046623\" style=\"zoom:50%;\" />\n\n静态成员也会被继承。\n\n```tsx\nclass Base {\n  static getGreeting() {\n    return \"Hello world\";\n  }\n}\nclass Derived extends Base {\n  myGreeting = Derived.getGreeting();\n}\n```\n\n### 8.3.1 特殊静态名称\n\n一般来说，从函数原型覆盖属性是不安全的/不可能的。因为类本身就是可以用`new`调用的函数，所以某些静态名称不能使用。像`name`、`length`和`call`这样的函数属性，定义为静态成员是无效的。\n\n```tsx\nclass S {\n  static name = \"S!\";\n}\n```\n\n<img src=\"/img/TypeScript/09-22.png\" alt=\"image-20211203133418242\" style=\"zoom:50%;\" />\n\n### 8.3.2 为什么没有静态类？\n\nTypeScript（和JavaScript）没有像C#和Java那样有一个叫做静态类的结构。\n\n这些结构体的存在，只是因为这些语言强制所有的数据和函数都在一个类里面；因为这个限制在TypeScript中不存在，所以不需要它们。一个只有一个实例的类，在JavaScript/TypeScript中通常只是表示为一个普通的对象。\n\n例如，我们不需要TypeScript中的 \"静态类 \"语法，因为一个普通的对象（甚至是顶级函数）也可以完成这个工作。\n\n```tsx\n// 不需要 \"static\" class\nclass MyStaticClass {\n  static doSomething() {}\n}\n\n// 首选 (备选 1)\nfunction doSomething() {}\n\n// 首选 (备选 2)\nconst MyHelperObject = {\n  dosomething() {},\n};\n```\n\n## 8.4 类里的 `static `区块\n\n静态块允许你写一串有自己作用域的语句，可以访问包含类中的私有字段。这意味着我们可以用写语句的所有能力来写初始化代码，不泄露变量，并能完全访问我们类的内部结构。\n\n```tsx\nclass Foo {\n  static #count = 0;\n\n  get count() {\n    return Foo.#count;\n  }\n\n  static {\n    try {\n      const lastInstances = {\n        length: 100,\n      };\n      Foo.#count += lastInstances.length;\n    } catch {}\n  }\n}\n```\n\n## 8.5 泛型类\n\n类，和接口一样，可以是泛型的。当一个泛型类用new实例化时，其类型参数的推断方式与函数调用的方式相同。\n\n```tsx\nclass Box<Type> {\n  contents: Type;\n  constructor(value: Type) {\n    this.contents = value;\n  }\n}\n\n// const b: Box<string>\nconst b = new Box(\"hello!\");\n```\n\n类可以像接口一样使用通用约束和默认值。\n\n- 静态成员中的类型参数\n\n这段代码是不合法的，可能并不明显，为什么呢？\n\n```tsx\nclass Box<Type> {\n  // 静态成员不能引用类的类型参数。\n  static defaultValue: Type;\n}\n\n// Box<string>.defaultValue = 'hello'\n// console.log(Box<number>.defaultValue)\n```\n\n请记住，类型总是被完全擦除的! 在运行时，只有一个Box.defaultValue属性。这意味着设置Box<string>.defaultValue（如果有可能的话）也会改变Box<number>.defaultValue，这可不是什么好事。一个泛型类的静态成员永远不能引用该类的类型参数。\n\n## 8.6 类运行时中的`this`\n\n重要的是要记住，TypeScript并没有改变JavaScript的运行时行为，而JavaScript的运行时行为偶尔很奇特。\n\n比如，JavaScript对这一点的处理确实是不寻常的：\n\n```tsx\nclass MyClass {\n  name = \"MyClass\";\n  getName() {\n    return this.name;\n  }\n}\nconst c = new MyClass();\nconst obj = {\n  name: \"obj\",\n  getName: c.getName,\n};\n\n// 输出 \"obj\", 而不是 \"MyClass\"\nconsole.log(obj.getName());\n```\n\n长话短说，默认情况下，函数内this的值取决于函数的调用方式。在这个例子中，因为函数是通过obj引用调用的，所以它的this值是obj而不是类实例。\n\n这很少是你希望发生的事情! TypeScript提供了一些方法来减轻或防止这种错误。\n\n**1、箭头函数**\n\n如果你有一个经常会被调用的函数，失去了它的 `this` 上下文，那么使用一个箭头函数而不是方法定义是有意义的。\n\n```tsx\nclass MyClass {\n  name = \"MyClass\";\n  getName = () => {\n    return this.name;\n  };\n}\nconst c = new MyClass();\nconst g = c.getName;\n// 输出 \"MyClass\"\nconsole.log(g());\n```\n\n这有一些权衡：\n\n- `this` 值保证在运行时是正确的，即使是没有经过TypeScript检查的代码也是如此。\n\n- 这将使用更多的内存，因为每个类实例将有它自己的副本，每个函数都是这样定义的。\n\n- 你不能在派生类中使用`super.getName`，因为在原型链中没有入口可以获取基类方法。\n\n**2、`this` 参数**\n\n在方法或函数定义中，一个名为`this`的初始参数在TypeScript中具有特殊的意义。这些参数在编译过程中会被删除。\n\n```tsx\n// 带有 \"this\" 参数的 TypeScript 输入\nfunction fn(this: SomeType, x: number) {\n  /* ... */\n}\n```\n\n```tsx\n// 编译后的JavaScript结果\nfunction fn(x) {\n  /* ... */\n}\n```\n\nTypeScript检查调用带有`this`参数的函数，是否在正确的上下文中进行。我们可以不使用箭头函数，而是在方法定义中添加一个`this`参数，以静态地确保方法被正确调用。\n\n```tsx\nclass MyClass {\n  name = \"MyClass\";\n  getName(this: MyClass) {\n    return this.name;\n  }\n}\nconst c = new MyClass();\n// 正确\nc.getName();\n\n// 错误\nconst g = c.getName;\nconsole.log(g());\n```\n\n<img src=\"/img/TypeScript/09-23.png\" alt=\"image-20211210093534818\" style=\"zoom: 67%;\" />\n\n这种方法做出了与箭头函数方法相反的取舍：\n\n- JavaScript调用者仍然可能在不知不觉中错误地使用类方法\n- 每个类定义只有一个函数被分配，而不是每个类实例一个函数\n- 基类方法定义仍然可以通过 `super`调用。\n\n## 8.7 `this`类型\n\n在类中，一个叫做 `this`的特殊类型动态地指向当前类的类型。让我们来看看这有什么用：\n\n```tsx\nclass Box {\n  contents: string = \"\";\n  // (method) Box.set(value: string): this\n  set(value: string) {\n    this.contents = value;\n    return this;\n  }\n}\n```\n\n在这里，TypeScript推断出 `set`的返回类型是`this`，而不是`Box`。现在让我们做一个Box的子类：\n\n```tsx\nclass ClearableBox extends Box {\n  clear() {\n    this.contents = \"\";\n  }\n}\nconst a = new ClearableBox();\n\n// const b: ClearableBox\nconst b = a.set(\"hello\");\nconsole.log(b);\n```\n\n<img src=\"/img/TypeScript/09-24.png\" alt=\"image-20211210095241472\" style=\"zoom:50%;\" align=\"left\" />\n\n你也可以在参数类型注释中使用 `this`：\n\n```tsx\nclass Box {\n  content: string = \"\";\n  sameAs(other: this) {\n    return other.content === this.content;\n  }\n}\nconst box = new Box();\nconsole.log(box.sameAs(box));\n```\n\n这与其他写法不同：Box，如果你有一个派生类，它的 `sameAs` 方法现在只接受该同一派生类的其他实例。\n\n```tsx\nclass Box {\n  content: string = \"\";\n  sameAs(other: this) {\n    return other.content === this.content;\n  }\n}\n\nclass DerivedBox extends Box {\n  otherContent: string = \"?\";\n}\n\nconst base = new Box();\nconst derived = new DerivedBox();\nderived.sameAs(base);\n```\n\n<img src=\"/img/TypeScript/09-25.png\" alt=\"image-20211210102234118\" style=\"zoom:50%;\" />\n\n## 8.8 基于类型守卫的`this`\n\n你可以在类和接口的方法的返回位置使用 `this is Type` 。当与类型缩小混合时（例如if语句），目标对象的类型将被缩小到指定的Type。\n\n```tsx\nclass FileSystemObject {\n  isFile(): this is FileRep {\n    return this instanceof FileRep;\n  }\n  isDirectory(): this is Directory {\n    return this instanceof Directory;\n  }\n  isNetworked(): this is Networked & this {\n    return this.networked;\n  }\n  constructor(\n    public path: string,\n    private networked: boolean,\n  ) {}\n}\nclass FileRep extends FileSystemObject {\n  constructor(\n    path: string,\n    public content: string,\n  ) {\n    super(path, false);\n  }\n}\nclass Directory extends FileSystemObject {\n  children: FileSystemObject[];\n}\ninterface Networked {\n  host: string;\n}\nconst fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\");\nif (fso.isFile()) {\n  // const fso: FileRep\n  fso.content;\n} else if (fso.isDirectory()) {\n  // const fso: Directory\n  fso.children;\n} else if (fso.isNetworked()) {\n  // const fso: Networked & FileSystemObject\n  fso.host;\n}\n```\n\n基于 `this` 的类型保护的一个常见用例，是允许对一个特定字段进行懒惰验证。例如，这种情况下，当 `hasValue`被验证为真时，就会从框内持有的值中删除一个未定义值。\n\n```tsx\nclass Box<T> {\n  value?: T;\n\n  hasValue(): this is { value: T } {\n    return this.value !== undefined;\n  }\n}\nconst box = new Box();\nbox.value = \"Gameboy\";\n\n// (property) Box<unknown>.value?: unknownbox.value;\nif (box.hasValue()) {\n  // (property) value: unknown\n  box.value;\n}\n```\n\n## 8.9 参数属性\n\nTypeScript提供了特殊的语法，可以将构造函数参数变成具有相同名称和值的类属性。这些被称为参数属性，通过在构造函数参数前加上可见性修饰符 `public`、`private`、`protected`或`readonly`中的一个来创建。由此产生的字段会得到这些修饰符。\n\n```tsx\nclass Params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number,\n  ) {\n    // No body necessary\n  }\n}\n\nconst a = new Params(1, 2, 3);\n\n// (property) Params.x: number\nconsole.log(a.x);\nconsole.log(a.z);\n```\n\n<img src=\"/img/TypeScript/10-01.png\" alt=\"image-20211214162348578\" style=\"zoom: 60%;\" />\n\n## 8.10 类表达式\n\n类表达式与类声明非常相似。唯一真正的区别是，类表达式不需要一个名字，尽管我们可以通过它们最终绑定的任何标识符来引用它们。\n\n```tsx\nconst someClass = class<Type> {\n  content: Type;\n  constructor(value: Type) {\n    this.content = value;\n  }\n};\n\n// const m: someClass<string>\nconst m = new someClass(\"Hello, world\");\n```\n\n## 8.11 抽象类和成员\n\nTypeScript中的类、方法和字段可以是抽象的。\n\n一个抽象的方法或抽象的字段是一个没有提供实现的方法或字段。这些成员必须存在于一个抽象类中，不能直接实例化。\n\n抽象类的作用是作为子类的基类，实现所有的抽象成员。当一个类没有任何抽象成员时，我们就说它是具体的。\n\n让我们看一个例子：\n\n```tsx\nabstract class Base {\n  abstract getName(): string;\n  printName() {\n    console.log(\"Hello, \" + this.getName());\n  }\n}\nconst b = new Base();\n```\n\n<img src=\"/img/TypeScript/10-02.png\" alt=\"image-20211219063509036\" style=\"zoom:60%;\" />\n\n我们不能用 `new`来实例化`Base`，因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员。\n\n```tsx\nclass Derived extends Base {\n  getName() {\n    return \"world\";\n  }\n}\nconst d = new Derived();\nd.printName();\n```\n\n<img src=\"/img/TypeScript/10-03.png\" alt=\"image-20211219064030984\" style=\"zoom:60%;\" />\n\n- **抽象构造签名**\n\n有时你想接受一些类的构造函数，产生一个从某些抽象类派生出来的类的实例。\n\n例如，你可能想写这样的代码：\n\n```tsx\nfunction greet(ctor: typeof Base) {\n  const instance = new ctor();\n  instance.printName();\n}\n```\n\n<img src=\"/img/TypeScript/10-04.png\" alt=\"image-20211219064506944\" style=\"zoom:67%;\" />\n\nTypeScript正确地告诉你，你正试图实例化一个抽象类。毕竟，鉴于greet的定义，写这段代码是完全合法的，它最终会构造一个抽象类。\n\n```tsx\n// 槽糕\ngreet(Base);\n```\n\n相反，你想写一个函数，接受具有结构化签名的东西：\n\n```tsx\nfunction greet(ctor: new () => Base) {\n  const instance = new ctor();\n  instance.printName();\n}\ngreet(Derived);\ngreet(Base);\n```\n\n<img src=\"/img/TypeScript/10-05.png\" alt=\"image-20211219065154437\" style=\"zoom:67%;\" />\n\n现在TypeScript正确地告诉你哪些类的构造函数可以被调用：`Derived`可以，因为它是具体的，但`Base`不能。\n\n## 8.12 类之间的关系\n\n在大多数情况下，TypeScript中的类在结构上与其他类型相同，是可以比较的。\n\n例如，这两个类可以互相替代使用，因为它们是相同的：\n\n```tsx\nclass Point1 {\n  x = 0;\n  y = 0;\n}\nclass Point2 {\n  x = 0;\n  y = 0;\n}\n\n// 正确\nconst p: Point1 = new Point2();\n```\n\n同样地，即使没有明确的继承，类之间的子类型关系也是存在的：\n\n```tsx\nclass Person {\n  name: string;\n  age: number;\n}\nclass Employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n\n// 正确\nconst p: Person = new Employee();\n```\n\n这听起来很简单，但有几种情况似乎比其他情况更奇怪。\n\n空的类没有成员。在一个结构化类型系统中，一个没有成员的类型通常是其他任何东西的超类型。所以如果你写了一个空类（不要！），任何东西都可以用来代替它。\n\n```tsx\nclass Empty {}\n\nfunction fn(x: Empty) {\n  // 不能用'x'做任何事\n}\n\n// 以下调用均可\n!fn(window);\nfn({});\nfn(fn);\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/1-8、基础篇：类.md",
        "raw": "---\ntitle: 1-8、基础篇：类\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 55025\ndate: 2024-01-28 19:48:15\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 八、类\n\nTypeScript提供了对ES2015中引入的 `class` 关键词的完全支持。\n\n与其他JavaScript语言功能一样，TypeScript增加了类型注释和其他语法，允许你表达类和其他类型之间的关系。\n\n## 8.1 类成员\n\n这里有一个最基本的类——一个空的类：\n\n```tsx\nclass Point {}\n```\n\n这个类还不是很有用，所以我们开始添加一些成员。\n\n### 8.1.1 类属性\n\n在一个类上声明字段，创建一个公共的可写属性：A mapped type is a generic type which uses a union of `PropertyKey`s (frequently created [via a `keyof`](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)) to iterate through keys to create a type:\n\n```\n\n```\n\n```tsx\nclass Point {\n  x: number;\n  y: number;\n}\n\nconst pt = new Point();\npt.x = 0;\npt.y = 0;\n```\n\n与其他位置一样，类型注解是可选的，但如果不指定，将是一个隐含的 `any` 类型。\n\n字段也可以有初始化器；这些初始化器将在类被实例化时自动运行。\n\n```tsx\nclass Point {\n  x = 0;\n  y = 0;\n}\n\nconst pt = new Point();\n// Prints 0, 0\nconsole.log(`${pt.x}, ${pt.y}`);\n```\n\n就像 `const`、`let`和`var`一样，一个类属性的初始化器将被用来推断其类型。\n\n```tsx\nconst pt = new Point();\npt.x = \"0\";\n```\n\n<img src=\"/img/TypeScript/09-01.png\" alt=\"image-20211129114803786\" style=\"zoom:50%;\" />\n\n- `--strictPropertyInitialization`\n\n`strictPropertyInitialization`设置控制是否需要在构造函数中初始化类字段。\n\n<img src=\"/img/TypeScript/09-02.png\" alt=\"image-20211129115145529\" style=\"zoom:50%;\" />\n\n```tsx\nclass BadGreeter {\n  name: string;\n}\n```\n\n<img src=\"/img/TypeScript/09-04.png\" alt=\"image-20211129115341214\" style=\"zoom:50%;\" />\n\n```tsx\nclass GoodGreeter {\n  name: string;\n\n  constructor() {\n    this.name = \"hello\";\n  }\n}\n```\n\n请注意，该字段需要在构造函数本身中初始化。TypeScript不会分析你从构造函数中调用的方法来检测初始化，因为派生类可能会覆盖这些方法而无法初始化成员。\n\n如果你打算通过构造函数以外的方式来确定初始化一个字段（例如，也许一个外部库为你填充了你的类的一部分），你可以使用确定的赋值断言操作符 `！`。\n\n```tsx\nclass OKGreeter {\n  // 没有初始化，但没报错。\n  name!: string;\n}\n```\n\n### 8.1.2 `readonly`\n\n字段的前缀可以是 `readonly` 修饰符。这可以防止在构造函数之外对该字段进行赋值。\n\n```tsx\nclass Greeter {\n  readonly name: string = \"world\";\n\n  constructor(otherName?: string) {\n    if (otherName !== undefined) {\n      this.name = otherName;\n    }\n  }\n\n  err() {\n    this.name = \"not ok\";\n  }\n}\nconst g = new Greeter();\ng.name = \"also not ok\";\n```\n\n<img src=\"/img/TypeScript/09-05.png\" alt=\"image-20211129120222803\" style=\"zoom:50%;\" />\n\n### 8.1.3 构造器\n\n类构造函数与函数非常相似。你可以添加带有类型注释的参数、默认值和重载：\n\n```tsx\nclass Point {\n  x: number;\n  y: number;\n\n  // 带默认值的正常签名\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n}\n```\n\n```tsx\nclass Point {\n  // 重载\n  constructor(x: number, y: string);\n  constructor(s: string);\n  constructor(xs: any, y?: any) {\n    // ...\n  }\n}\n```\n\n类的构造函数签名和函数签名之间只有一些区别：\n\n- 构造函数不能有类型参数--这属于外层类的声明，我们将在后面学习。\n\n- 构造函数不能有返回类型注释——类的实例类型总是被返回的。\n\n**Super 调用**\n\n就像在JavaScript中一样，如果你有一个基类，在使用任何 `this.`成员之前，你需要在构造器主体中调用`super();`。\n\n```tsx\nclass Base {\n  k = 4;\n}\n\nclass Derived extends Base {\n  constructor() {\n    // 在ES5中打印一个错误的值；在ES6中抛出异常。\n    console.log(this.k);\n    super();\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-06.png\" alt=\"image-20211129135259853\" style=\"zoom:50%;\" />\n\n在JavaScript中，忘记调用 `super` 是一个很容易犯的错误，但TypeScript会在必要时告诉你。\n\n### 8.1.4 方法\n\n一个类上的函数属性被称为方法。方法可以使用与函数和构造函数相同的所有类型注释。\n\n```tsx\nclass Point {\n  x = 10;\n  y = 10;\n\n  scale(n: number): void {\n    this.x *= n;\n    this.y *= n;\n  }\n}\n```\n\n除了标准的类型注解，TypeScript并没有为方法添加其他新的东西。\n\n请注意，在一个方法体中，仍然必须通过`this`访问字段和其他方法。方法体中的非限定名称将总是指代包围范围内的东西。\n\n```tsx\nlet x: number = 0;\n\nclass C {\n  x: string = \"hello\";\n\n  m() {\n    // 这是在试图修改第1行的'x'，而不是类属性。\n    x = \"world\";\n  }\n}\n```\n\n### 8.1.5 Getters / Setters\n\n类也可以有访问器：\n\n```tsx\nclass C {\n  _length = 0;\n  get length() {\n    return this._length;\n  }\n  set length(value) {\n    this._length = value;\n  }\n}\n```\n\n> 请注意，一个没有额外逻辑的字段支持的`get/set`对在JavaScript中很少有用。如果你不需要在`get/set`操作中添加额外的逻辑，暴露公共字段也是可以的。\n\nTypeScript对访问器有一些特殊的推理规则：\n\n- 如果存在 `get`，但没有`set`，则该属性自动是只读的\n\n- 如果没有指定`setter`参数的类型，它将从`getter`的返回类型中推断出来\n\n- 访问器和设置器必须有相同的成员可见性\n\n从TypeScript 4.3开始，可以有不同类型的访问器用于获取和设置。\n\n```tsx\nclass Thing {\n  _size = 0;\n\n  get size(): number {\n    return this._size;\n  }\n\n  set size(value: string | number | boolean) {\n    let num = Number(value);\n\n    // 不允许NaN、Infinity等\n\n    if (!Number.isFinite(num)) {\n      this._size = 0;\n      return;\n    }\n\n    this._size = num;\n  }\n}\n```\n\n### 8.1.6 索引签名\n\n类可以声明索引签名；这些签名的作用与其他对象类型的索引签名相同。\n\n```tsx\nclass MyClass {\n  [s: string]: boolean | ((s: string) => boolean);\n\n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n```\n\n因为索引签名类型需要同时捕获方法的类型，所以要有用地使用这些类型并不容易。一般来说，最好将索引数据存储在另一个地方，而不是在类实例本身。\n\n## 8.2 类继承\n\n像其他具有面向对象特性的语言一样，JavaScript中的类可以继承自基类。\n\n### 8.2.1 `implements`子句\n\n你可以使用一个 `implements` 子句来检查一个类，是否满足了一个特定的接口。如果一个类不能正确地实现它，就会发出一个错误。\n\n```tsx\ninterface Pingable {\n  ping(): void;\n}\n\nclass Sonar implements Pingable {\n  ping() {\n    console.log(\"ping!\");\n  }\n}\n\nclass Ball implements Pingable {\n  pong() {\n    console.log(\"pong!\");\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-07.png\" alt=\"image-20211129154149915\" style=\"zoom:50%;\" />\n\n类也可以实现多个接口，例如 `class C implements A, B {`\n\n**注意事项**\n\n重要的是要明白， `implements` 子句只是检查类是否可以被当作接口类型来对待。它根本不会改变类的类型或其方法。一个常见的错误来源是认为 `implements` 子句会改变类的类型--它不会！它不会。\n\n```tsx\ninterface Checkable {\n  check(name: string): boolean;\n}\n\nclass NameChecker implements Checkable {\n  check(s) {\n    // any：注意这里没有错误\n    return s.toLowercse() === \"ok\";\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-08.png\" alt=\"image-20211129163841634\" style=\"zoom:50%;\" />\n\n在这个例子中，我们也许期望 `s` 的类型会受到 `check`的`name: string`参数的影响。事实并非如此--实现子句并没有改变类主体的检查方式或其类型的推断。\n\n同样地，实现一个带有可选属性的接口并不能创建该属性。\n\n```tsx\ninterface A {\n  x: number;\n  y?: number;\n}\nclass C implements A {\n  x = 0;\n}\nconst c = new C();\nc.y = 10;\n```\n\n<img src=\"/img/TypeScript/09-09.png\" alt=\"image-20211129164354121\" style=\"zoom:50%;\" />\n\n### 8.2.2 `extends`子句\n\n类可以从基类中扩展出来。派生类拥有其基类的所有属性和方法，也可以定义额外的成员。\n\n```tsx\nclass Animal {\n  move() {\n    console.log(\"Moving along!\");\n  }\n}\n\nclass Dog extends Animal {\n  woof(times: number) {\n    for (let i = 0; i < times; i++) {\n      console.log(\"woof!\");\n    }\n  }\n}\n\nconst d = new Dog();\n// 基类的类方法\nd.move();\n// 派生的类方法\nd.woof(3);\n```\n\n### 8.2.3 重写方法\n\n派生类也可以覆盖基类的一个字段或属性。你可以使用`super.`语法来访问基类方法。注意，因为JavaScript类是一个简单的查找对象，没有 \"超级字段 \"的概念。\n\nTypeScript强制要求派生类总是其基类的一个子类型。\n\n例如，这里有一个合法的方法来覆盖一个方法。\n\n```tsx\nclass Base {\n  greet() {\n    console.log(\"Hello, world!\");\n  }\n}\n\nclass Derived extends Base {\n  greet(name?: string) {\n    if (name === undefined) {\n      super.greet();\n    } else {\n      console.log(`Hello, ${name.toUpperCase()}`);\n    }\n  }\n}\n\nconst d = new Derived();\nd.greet();\nd.greet(\"reader\");\n```\n\n派生类遵循其基类契约是很重要的。请记住，通过基类引用来引用派生类实例是非常常见的（而且总是合法的！）。\n\n```tsx\n// 通过基类引用对派生实例进行取别名\nconst b: Base = d;\n// 没问题\nb.greet();\n```\n\n如果`Derived`没有遵守Base的约定怎么办？\n\n```tsx\nclass Base {\n  greet() {\n    console.log(\"Hello, world!\");\n  }\n}\n\nclass Derived extends Base {\n  // 使这个参数成为必需的\n  greet(name: string) {\n    console.log(`Hello, ${name.toUpperCase()}`);\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-10.png\" alt=\"image-20211129191159846\" style=\"zoom:50%;\" />\n\n如果我们不顾错误编译这段代码，这个样本就会崩溃：\n\n```tsx\nconst b: Base = new Derived();\n// 崩溃，因为 \"名称 \"将是 undefined。\nb.greet();\n```\n\n<img src=\"/img/TypeScript/09-11.png\" alt=\"image-20211129191741373\" style=\"zoom:50%;\" />\n\n### 8.2.4 初始化顺序\n\n在某些情况下，JavaScript类的初始化顺序可能会令人惊讶。让我们考虑一下这段代码：\n\n```tsx\nclass Base {\n  name = \"base\";\n  constructor() {\n    console.log(\"My name is \" + this.name);\n  }\n}\n\nclass Derived extends Base {\n  name = \"derived\";\n}\n\n// 打印 \"base\", 而不是 \"derived\"\nconst d = new Derived();\n```\n\n这里发生了什么？\n\n按照JavaScript的定义，类初始化的顺序是：\n\n- 基类的字段被初始化\n- 基类构造函数运行\n- 派生类的字段被初始化\n- 派生类构造函数运行\n\n这意味着基类构造函数在自己的构造函数中看到了自己的name值，因为派生类的字段初始化还没有运行。\n\n### 8.2.5 继承内置类型\n\n> 注意：如果你不打算继承Array、Error、Map等内置类型，或者你的编译目标明确设置为ES6/ES2015或以上，你可以跳过本节。\n\n在ES2015中，返回对象的构造函数隐含地替代了`super(...)`的任何调用者的`this`的值。生成的构造函数代码有必要捕获`super(...)`的任何潜在返回值并将其替换为`this`。\n\n因此，子类化`Error`、`Array`等可能不再像预期那样工作。这是由于`Error`、`Array`等的构造函数使用ECMAScript 6的`new.target`来调整原型链；然而，在ECMAScript 5中调用构造函数时，没有办法确保`new.target`的值。其他的下级编译器一般默认有同样的限制。\n\n对于一个像下面这样的子类：\n\n```tsx\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n  }\n  sayHello() {\n    return \"hello \" + this.message;\n  }\n}\n```\n\n你可能会发现：\n\n- 方法在构造这些子类所返回的对象上可能是未定义的，所以调用 `sayHello` 会导致错误。\n\n<img src=\"/img/TypeScript/09-12.png\" alt=\"image-20211129205005544\" style=\"zoom:50%;\" />\n\n- `instanceof`将在子类的实例和它们的实例之间被打破，所以`（new MsgError()）instanceof MsgError`将返回`false`。\n\n<img src=\"/img/TypeScript/09-13.png\" alt=\"image-20211129205309009\" style=\"zoom:50%;\" />\n\n作为建议，你可以在任何`super(...)`调用后立即手动调整原型。\n\n```tsx\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n\n    // 明确地设置原型。\n    Object.setPrototypeOf(this, MsgError.prototype);\n  }\n\n  sayHello() {\n    return \"hello \" + this.message;\n  }\n}\n```\n\n<img src=\"/img/TypeScript/09-14.png\" alt=\"image-20211129205721788\" style=\"zoom:50%;\" />\n\n然而，`MsgError`的任何子类也必须手动设置原型。对于不支持`Object.setPrototypeOf`的运行时，你可以使用`__proto__`来代替。\n\n不幸的是，这些变通方法在`Internet Explorer 10`和更早的版本上不起作用。我们可以手动将原型中的方法复制到实例本身（例如`MsgError.prototype`到`this`），但是原型链本身不能被修复。\n\n## 8.2 成员的可见性\n\n你可以使用TypeScript来控制某些方法或属性对类外的代码是否可见。\n\n### 8.2.1 `public`\n\n类成员的默认可见性是公共(`public`)的。一个公共(`public`)成员可以在任何地方被访问。\n\n```tsx\nclass Greeter {\n  public greet() {\n    console.log(\"hi!\");\n  }\n}\nconst g = new Greeter();\ng.greet();\n```\n\n因为`public`已经是默认的可见性修饰符，所以你永远不需要在类成员上写它，但为了风格/可读性的原因，可能会选择这样做。\n\n### 8.2.2 `protected`\n\n受保护的(`protected`)成员只对它们所声明的类的子类可见。\n\n```tsx\nclass Greeter {\n  public greet() {\n    console.log(\"Hello, \" + this.getName());\n  }\n  protected getName() {\n    return \"hi\";\n  }\n}\n\nclass SpecialGreeter extends Greeter {\n  public howdy() {\n    // 在此可以访问受保护的成员\n    console.log(\"Howdy, \" + this.getName());\n  }\n}\nconst g = new SpecialGreeter();\ng.greet(); // 没有问题\ng.getName(); // 无权访问\n```\n\n<img src=\"/img/TypeScript/09-15.png\" alt=\"image-20211130102051422\" style=\"zoom:50%;\" />\n\n- **受保护成员的暴露**\n\n派生类需要遵循它们的基类契约，但可以选择公开具有更多能力的基类的子类型。这包括将受保护的成员变成公开。\n\n```tsx\nclass Base {\n  protected m = 10;\n}\nclass Derived extends Base {\n  // 没有修饰符，所以默认为'公共'('public')\n  m = 15;\n}\nconst d = new Derived();\nconsole.log(d.m); // OK\n```\n\n### 8.2.3 `private`\n\n`private`和`protected`一样，但不允许从子类中访问该成员。\n\n```tsx\nclass Base {\n  private x = 0;\n}\nconst b = new Base();\n// 不能从类外访问\nconsole.log(b.x);\n```\n\n<img src=\"/img/TypeScript/09-17.png\" alt=\"image-20211130104530638\" style=\"zoom:50%;\" />\n\n```tsx\nclass Base {\n  private x = 0;\n}\nconst b = new Base();\n\nclass Derived extends Base {\n  showX() {\n    // 不能在子类中访问\n    console.log(this.x);\n  }\n}\n```\n\n因为私有(`private`)成员对派生类是不可见的，所以派生类不能增加其可见性。\n\n- **跨实例的私有访问**\n\n不同的OOP语言对同一个类的不同实例，是否可以访问对方的私有成员，有不同的处理方法。虽然像Java、C#、C++、Swift和PHP等语言允许这样做，但Ruby不允许。\n\nTypeScript确实允许跨实例的私有访问：\n\n```tsx\nclass A {\n  private x = 10;\n\n  public sameAs(other: A) {\n    // 可以访问\n    return other.x === this.x;\n  }\n}\n```\n\n- **注意事项**\n\n像TypeScript类型系统的其他方面一样，`private`和`protected`只在类型检查中被强制执行。\n\n这意味着JavaScript的运行时结构，如`in`或简单的属性查询，仍然可以访问一个私有或保护的成员。\n\n```tsx\nclass MySafe {\n  private secretKey = 12345;\n}\n```\n\n```tsx\n// 在JS环境中...\nconst s = new MySafe();\n// 将打印 12345\nconsole.log(s.secretKey);\n```\n\n`private`也允许在类型检查时使用括号符号进行访问。这使得私有声明的字段可能更容易被单元测试之类的东西所访问，缺点是这些字段是软性私有的，不能严格执行私有特性。\n\n```tsx\nclass MySafe {\n  private secretKey = 12345;\n}\n\nconst s = new MySafe();\n\n// 在类型检查期间不允许\nconsole.log(s.secretKey);\n\n// 正确\nconsole.log(s[\"secretKey\"]);\n```\n\n<img src=\"/img/TypeScript/09-19.png\" alt=\"image-20211130135104155\" style=\"zoom:50%;\" />\n\n与TypeScript的 `private`不同，JavaScript的`private`字段（#）在编译后仍然是`private`的，并且不提供前面提到的像括号符号访问那样的转义窗口，使其成为硬`private`。\n\n```tsx\nclass Dog {\n  #barkAmount = 0;\n  personality = \"happy\";\n\n  constructor() {\n    // 0\n    console.log(this.#barkAmount);\n  }\n}\n\nconst dog = new Dog();\n// undefined\nconsole.log(dog.barkAmount);\n```\n\n<img src=\"/img/TypeScript/09-20.png\" alt=\"image-20211130154613004\" style=\"zoom:50%;\" />\n\n当编译到ES2021或更少时，TypeScript将使用WeakMaps来代替 `#`。\n\n```tsx\n\"use strict\";\nvar _Dog_barkAmount;\nclass Dog {\n  constructor() {\n    _Dog_barkAmount.set(this, 0);\n    this.personality = \"happy\";\n  }\n}\n_Dog_barkAmount = new WeakMap();\n```\n\n如果你需要保护你的类中的值免受恶意行为的影响，你应该使用提供硬运行时隐私的机制，如闭包、`WeakMaps`或私有字段。请注意，这些在运行时增加的隐私检查可能会影响性能。\n\n## 8.3 静态成员\n\n类可以有静态成员。这些成员并不与类的特定实例相关联。它们可以通过类的构造函数对象本身来访问。\n\n```tsx\nclass MyClass {\n  static x = 0;\n  static printX() {\n    console.log(MyClass.x);\n  }\n}\nconsole.log(MyClass.x);\nMyClass.printX();\n```\n\n静态成员也可以使用相同的`public`、`protected`和`private`可见性修饰符。\n\n```tsx\nclass MyClass {\n  private static x = 0;\n}\nconsole.log(MyClass.x);\n```\n\n<img src=\"/img/TypeScript/09-21.png\" alt=\"image-20211130161046623\" style=\"zoom:50%;\" />\n\n静态成员也会被继承。\n\n```tsx\nclass Base {\n  static getGreeting() {\n    return \"Hello world\";\n  }\n}\nclass Derived extends Base {\n  myGreeting = Derived.getGreeting();\n}\n```\n\n### 8.3.1 特殊静态名称\n\n一般来说，从函数原型覆盖属性是不安全的/不可能的。因为类本身就是可以用`new`调用的函数，所以某些静态名称不能使用。像`name`、`length`和`call`这样的函数属性，定义为静态成员是无效的。\n\n```tsx\nclass S {\n  static name = \"S!\";\n}\n```\n\n<img src=\"/img/TypeScript/09-22.png\" alt=\"image-20211203133418242\" style=\"zoom:50%;\" />\n\n### 8.3.2 为什么没有静态类？\n\nTypeScript（和JavaScript）没有像C#和Java那样有一个叫做静态类的结构。\n\n这些结构体的存在，只是因为这些语言强制所有的数据和函数都在一个类里面；因为这个限制在TypeScript中不存在，所以不需要它们。一个只有一个实例的类，在JavaScript/TypeScript中通常只是表示为一个普通的对象。\n\n例如，我们不需要TypeScript中的 \"静态类 \"语法，因为一个普通的对象（甚至是顶级函数）也可以完成这个工作。\n\n```tsx\n// 不需要 \"static\" class\nclass MyStaticClass {\n  static doSomething() {}\n}\n\n// 首选 (备选 1)\nfunction doSomething() {}\n\n// 首选 (备选 2)\nconst MyHelperObject = {\n  dosomething() {},\n};\n```\n\n## 8.4 类里的 `static `区块\n\n静态块允许你写一串有自己作用域的语句，可以访问包含类中的私有字段。这意味着我们可以用写语句的所有能力来写初始化代码，不泄露变量，并能完全访问我们类的内部结构。\n\n```tsx\nclass Foo {\n  static #count = 0;\n\n  get count() {\n    return Foo.#count;\n  }\n\n  static {\n    try {\n      const lastInstances = {\n        length: 100,\n      };\n      Foo.#count += lastInstances.length;\n    } catch {}\n  }\n}\n```\n\n## 8.5 泛型类\n\n类，和接口一样，可以是泛型的。当一个泛型类用new实例化时，其类型参数的推断方式与函数调用的方式相同。\n\n```tsx\nclass Box<Type> {\n  contents: Type;\n  constructor(value: Type) {\n    this.contents = value;\n  }\n}\n\n// const b: Box<string>\nconst b = new Box(\"hello!\");\n```\n\n类可以像接口一样使用通用约束和默认值。\n\n- 静态成员中的类型参数\n\n这段代码是不合法的，可能并不明显，为什么呢？\n\n```tsx\nclass Box<Type> {\n  // 静态成员不能引用类的类型参数。\n  static defaultValue: Type;\n}\n\n// Box<string>.defaultValue = 'hello'\n// console.log(Box<number>.defaultValue)\n```\n\n请记住，类型总是被完全擦除的! 在运行时，只有一个Box.defaultValue属性。这意味着设置Box<string>.defaultValue（如果有可能的话）也会改变Box<number>.defaultValue，这可不是什么好事。一个泛型类的静态成员永远不能引用该类的类型参数。\n\n## 8.6 类运行时中的`this`\n\n重要的是要记住，TypeScript并没有改变JavaScript的运行时行为，而JavaScript的运行时行为偶尔很奇特。\n\n比如，JavaScript对这一点的处理确实是不寻常的：\n\n```tsx\nclass MyClass {\n  name = \"MyClass\";\n  getName() {\n    return this.name;\n  }\n}\nconst c = new MyClass();\nconst obj = {\n  name: \"obj\",\n  getName: c.getName,\n};\n\n// 输出 \"obj\", 而不是 \"MyClass\"\nconsole.log(obj.getName());\n```\n\n长话短说，默认情况下，函数内this的值取决于函数的调用方式。在这个例子中，因为函数是通过obj引用调用的，所以它的this值是obj而不是类实例。\n\n这很少是你希望发生的事情! TypeScript提供了一些方法来减轻或防止这种错误。\n\n**1、箭头函数**\n\n如果你有一个经常会被调用的函数，失去了它的 `this` 上下文，那么使用一个箭头函数而不是方法定义是有意义的。\n\n```tsx\nclass MyClass {\n  name = \"MyClass\";\n  getName = () => {\n    return this.name;\n  };\n}\nconst c = new MyClass();\nconst g = c.getName;\n// 输出 \"MyClass\"\nconsole.log(g());\n```\n\n这有一些权衡：\n\n- `this` 值保证在运行时是正确的，即使是没有经过TypeScript检查的代码也是如此。\n\n- 这将使用更多的内存，因为每个类实例将有它自己的副本，每个函数都是这样定义的。\n\n- 你不能在派生类中使用`super.getName`，因为在原型链中没有入口可以获取基类方法。\n\n**2、`this` 参数**\n\n在方法或函数定义中，一个名为`this`的初始参数在TypeScript中具有特殊的意义。这些参数在编译过程中会被删除。\n\n```tsx\n// 带有 \"this\" 参数的 TypeScript 输入\nfunction fn(this: SomeType, x: number) {\n  /* ... */\n}\n```\n\n```tsx\n// 编译后的JavaScript结果\nfunction fn(x) {\n  /* ... */\n}\n```\n\nTypeScript检查调用带有`this`参数的函数，是否在正确的上下文中进行。我们可以不使用箭头函数，而是在方法定义中添加一个`this`参数，以静态地确保方法被正确调用。\n\n```tsx\nclass MyClass {\n  name = \"MyClass\";\n  getName(this: MyClass) {\n    return this.name;\n  }\n}\nconst c = new MyClass();\n// 正确\nc.getName();\n\n// 错误\nconst g = c.getName;\nconsole.log(g());\n```\n\n<img src=\"/img/TypeScript/09-23.png\" alt=\"image-20211210093534818\" style=\"zoom: 67%;\" />\n\n这种方法做出了与箭头函数方法相反的取舍：\n\n- JavaScript调用者仍然可能在不知不觉中错误地使用类方法\n- 每个类定义只有一个函数被分配，而不是每个类实例一个函数\n- 基类方法定义仍然可以通过 `super`调用。\n\n## 8.7 `this`类型\n\n在类中，一个叫做 `this`的特殊类型动态地指向当前类的类型。让我们来看看这有什么用：\n\n```tsx\nclass Box {\n  contents: string = \"\";\n  // (method) Box.set(value: string): this\n  set(value: string) {\n    this.contents = value;\n    return this;\n  }\n}\n```\n\n在这里，TypeScript推断出 `set`的返回类型是`this`，而不是`Box`。现在让我们做一个Box的子类：\n\n```tsx\nclass ClearableBox extends Box {\n  clear() {\n    this.contents = \"\";\n  }\n}\nconst a = new ClearableBox();\n\n// const b: ClearableBox\nconst b = a.set(\"hello\");\nconsole.log(b);\n```\n\n<img src=\"/img/TypeScript/09-24.png\" alt=\"image-20211210095241472\" style=\"zoom:50%;\" align=\"left\" />\n\n你也可以在参数类型注释中使用 `this`：\n\n```tsx\nclass Box {\n  content: string = \"\";\n  sameAs(other: this) {\n    return other.content === this.content;\n  }\n}\nconst box = new Box();\nconsole.log(box.sameAs(box));\n```\n\n这与其他写法不同：Box，如果你有一个派生类，它的 `sameAs` 方法现在只接受该同一派生类的其他实例。\n\n```tsx\nclass Box {\n  content: string = \"\";\n  sameAs(other: this) {\n    return other.content === this.content;\n  }\n}\n\nclass DerivedBox extends Box {\n  otherContent: string = \"?\";\n}\n\nconst base = new Box();\nconst derived = new DerivedBox();\nderived.sameAs(base);\n```\n\n<img src=\"/img/TypeScript/09-25.png\" alt=\"image-20211210102234118\" style=\"zoom:50%;\" />\n\n## 8.8 基于类型守卫的`this`\n\n你可以在类和接口的方法的返回位置使用 `this is Type` 。当与类型缩小混合时（例如if语句），目标对象的类型将被缩小到指定的Type。\n\n```tsx\nclass FileSystemObject {\n  isFile(): this is FileRep {\n    return this instanceof FileRep;\n  }\n  isDirectory(): this is Directory {\n    return this instanceof Directory;\n  }\n  isNetworked(): this is Networked & this {\n    return this.networked;\n  }\n  constructor(\n    public path: string,\n    private networked: boolean,\n  ) {}\n}\nclass FileRep extends FileSystemObject {\n  constructor(\n    path: string,\n    public content: string,\n  ) {\n    super(path, false);\n  }\n}\nclass Directory extends FileSystemObject {\n  children: FileSystemObject[];\n}\ninterface Networked {\n  host: string;\n}\nconst fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\");\nif (fso.isFile()) {\n  // const fso: FileRep\n  fso.content;\n} else if (fso.isDirectory()) {\n  // const fso: Directory\n  fso.children;\n} else if (fso.isNetworked()) {\n  // const fso: Networked & FileSystemObject\n  fso.host;\n}\n```\n\n基于 `this` 的类型保护的一个常见用例，是允许对一个特定字段进行懒惰验证。例如，这种情况下，当 `hasValue`被验证为真时，就会从框内持有的值中删除一个未定义值。\n\n```tsx\nclass Box<T> {\n  value?: T;\n\n  hasValue(): this is { value: T } {\n    return this.value !== undefined;\n  }\n}\nconst box = new Box();\nbox.value = \"Gameboy\";\n\n// (property) Box<unknown>.value?: unknownbox.value;\nif (box.hasValue()) {\n  // (property) value: unknown\n  box.value;\n}\n```\n\n## 8.9 参数属性\n\nTypeScript提供了特殊的语法，可以将构造函数参数变成具有相同名称和值的类属性。这些被称为参数属性，通过在构造函数参数前加上可见性修饰符 `public`、`private`、`protected`或`readonly`中的一个来创建。由此产生的字段会得到这些修饰符。\n\n```tsx\nclass Params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number,\n  ) {\n    // No body necessary\n  }\n}\n\nconst a = new Params(1, 2, 3);\n\n// (property) Params.x: number\nconsole.log(a.x);\nconsole.log(a.z);\n```\n\n<img src=\"/img/TypeScript/10-01.png\" alt=\"image-20211214162348578\" style=\"zoom: 60%;\" />\n\n## 8.10 类表达式\n\n类表达式与类声明非常相似。唯一真正的区别是，类表达式不需要一个名字，尽管我们可以通过它们最终绑定的任何标识符来引用它们。\n\n```tsx\nconst someClass = class<Type> {\n  content: Type;\n  constructor(value: Type) {\n    this.content = value;\n  }\n};\n\n// const m: someClass<string>\nconst m = new someClass(\"Hello, world\");\n```\n\n## 8.11 抽象类和成员\n\nTypeScript中的类、方法和字段可以是抽象的。\n\n一个抽象的方法或抽象的字段是一个没有提供实现的方法或字段。这些成员必须存在于一个抽象类中，不能直接实例化。\n\n抽象类的作用是作为子类的基类，实现所有的抽象成员。当一个类没有任何抽象成员时，我们就说它是具体的。\n\n让我们看一个例子：\n\n```tsx\nabstract class Base {\n  abstract getName(): string;\n  printName() {\n    console.log(\"Hello, \" + this.getName());\n  }\n}\nconst b = new Base();\n```\n\n<img src=\"/img/TypeScript/10-02.png\" alt=\"image-20211219063509036\" style=\"zoom:60%;\" />\n\n我们不能用 `new`来实例化`Base`，因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员。\n\n```tsx\nclass Derived extends Base {\n  getName() {\n    return \"world\";\n  }\n}\nconst d = new Derived();\nd.printName();\n```\n\n<img src=\"/img/TypeScript/10-03.png\" alt=\"image-20211219064030984\" style=\"zoom:60%;\" />\n\n- **抽象构造签名**\n\n有时你想接受一些类的构造函数，产生一个从某些抽象类派生出来的类的实例。\n\n例如，你可能想写这样的代码：\n\n```tsx\nfunction greet(ctor: typeof Base) {\n  const instance = new ctor();\n  instance.printName();\n}\n```\n\n<img src=\"/img/TypeScript/10-04.png\" alt=\"image-20211219064506944\" style=\"zoom:67%;\" />\n\nTypeScript正确地告诉你，你正试图实例化一个抽象类。毕竟，鉴于greet的定义，写这段代码是完全合法的，它最终会构造一个抽象类。\n\n```tsx\n// 槽糕\ngreet(Base);\n```\n\n相反，你想写一个函数，接受具有结构化签名的东西：\n\n```tsx\nfunction greet(ctor: new () => Base) {\n  const instance = new ctor();\n  instance.printName();\n}\ngreet(Derived);\ngreet(Base);\n```\n\n<img src=\"/img/TypeScript/10-05.png\" alt=\"image-20211219065154437\" style=\"zoom:67%;\" />\n\n现在TypeScript正确地告诉你哪些类的构造函数可以被调用：`Derived`可以，因为它是具体的，但`Base`不能。\n\n## 8.12 类之间的关系\n\n在大多数情况下，TypeScript中的类在结构上与其他类型相同，是可以比较的。\n\n例如，这两个类可以互相替代使用，因为它们是相同的：\n\n```tsx\nclass Point1 {\n  x = 0;\n  y = 0;\n}\nclass Point2 {\n  x = 0;\n  y = 0;\n}\n\n// 正确\nconst p: Point1 = new Point2();\n```\n\n同样地，即使没有明确的继承，类之间的子类型关系也是存在的：\n\n```tsx\nclass Person {\n  name: string;\n  age: number;\n}\nclass Employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n\n// 正确\nconst p: Person = new Employee();\n```\n\n这听起来很简单，但有几种情况似乎比其他情况更奇怪。\n\n空的类没有成员。在一个结构化类型系统中，一个没有成员的类型通常是其他任何东西的超类型。所以如果你写了一个空类（不要！），任何东西都可以用来代替它。\n\n```tsx\nclass Empty {}\n\nfunction fn(x: Empty) {\n  // 不能用'x'做任何事\n}\n\n// 以下调用均可\n!fn(window);\nfn({});\nfn(fn);\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/1-8、基础篇：类",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao5000z94v393mm5n9z",
        "content": "<h1 id=\"八、类\"><a href=\"#八、类\" class=\"headerlink\" title=\"八、类\"></a>八、类</h1><p>TypeScript提供了对ES2015中引入的 <code>class</code> 关键词的完全支持。</p>\n<p>与其他JavaScript语言功能一样，TypeScript增加了类型注释和其他语法，允许你表达类和其他类型之间的关系。</p>\n<h2 id=\"8-1-类成员\"><a href=\"#8-1-类成员\" class=\"headerlink\" title=\"8.1 类成员\"></a>8.1 类成员</h2><p>这里有一个最基本的类——一个空的类：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类还不是很有用，所以我们开始添加一些成员。</p>\n<h3 id=\"8-1-1-类属性\"><a href=\"#8-1-1-类属性\" class=\"headerlink\" title=\"8.1.1 类属性\"></a>8.1.1 类属性</h3><p>在一个类上声明字段，创建一个公共的可写属性：A mapped type is a generic type which uses a union of <code>PropertyKey</code>s (frequently created <a href=\"https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html\">via a <code>keyof</code></a>) to iterate through keys to create a type:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pt = <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>();</span><br><span class=\"line\">pt.<span class=\"property\">x</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">pt.<span class=\"property\">y</span> = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>与其他位置一样，类型注解是可选的，但如果不指定，将是一个隐含的 <code>any</code> 类型。</p>\n<p>字段也可以有初始化器；这些初始化器将在类被实例化时自动运行。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pt = <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>();</span><br><span class=\"line\"><span class=\"comment\">// Prints 0, 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;pt.x&#125;</span>, <span class=\"subst\">$&#123;pt.y&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>就像 <code>const</code>、<code>let</code>和<code>var</code>一样，一个类属性的初始化器将被用来推断其类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pt = <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>();</span><br><span class=\"line\">pt.<span class=\"property\">x</span> = <span class=\"string\">&quot;0&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-01.png\" alt=\"image-20211129114803786\" style=\"zoom:50%;\" />\n\n<ul>\n<li><code>--strictPropertyInitialization</code></li>\n</ul>\n<p><code>strictPropertyInitialization</code>设置控制是否需要在构造函数中初始化类字段。</p>\n<img src=\"/img/TypeScript/09-02.png\" alt=\"image-20211129115145529\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BadGreeter</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-04.png\" alt=\"image-20211129115341214\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GoodGreeter</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，该字段需要在构造函数本身中初始化。TypeScript不会分析你从构造函数中调用的方法来检测初始化，因为派生类可能会覆盖这些方法而无法初始化成员。</p>\n<p>如果你打算通过构造函数以外的方式来确定初始化一个字段（例如，也许一个外部库为你填充了你的类的一部分），你可以使用确定的赋值断言操作符 <code>！</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OKGreeter</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 没有初始化，但没报错。</span></span><br><span class=\"line\">  name!: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-2-readonly\"><a href=\"#8-1-2-readonly\" class=\"headerlink\" title=\"8.1.2 readonly\"></a>8.1.2 <code>readonly</code></h3><p>字段的前缀可以是 <code>readonly</code> 修饰符。这可以防止在构造函数之外对该字段进行赋值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">otherName</span>?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (otherName !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = otherName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">err</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = <span class=\"string\">&quot;not ok&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"keyword\">new</span> <span class=\"title class_\">Greeter</span>();</span><br><span class=\"line\">g.<span class=\"property\">name</span> = <span class=\"string\">&quot;also not ok&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-05.png\" alt=\"image-20211129120222803\" style=\"zoom:50%;\" />\n\n<h3 id=\"8-1-3-构造器\"><a href=\"#8-1-3-构造器\" class=\"headerlink\" title=\"8.1.3 构造器\"></a>8.1.3 构造器</h3><p>类构造函数与函数非常相似。你可以添加带有类型注释的参数、默认值和重载：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 带默认值的正常签名</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">x</span> = x;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">y</span> = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 重载</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">string</span></span>);</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>);</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">xs</span>: <span class=\"built_in\">any</span>, <span class=\"attr\">y</span>?: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类的构造函数签名和函数签名之间只有一些区别：</p>\n<ul>\n<li><p>构造函数不能有类型参数–这属于外层类的声明，我们将在后面学习。</p>\n</li>\n<li><p>构造函数不能有返回类型注释——类的实例类型总是被返回的。</p>\n</li>\n</ul>\n<p><strong>Super 调用</strong></p>\n<p>就像在JavaScript中一样，如果你有一个基类，在使用任何 <code>this.</code>成员之前，你需要在构造器主体中调用<code>super();</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  k = <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在ES5中打印一个错误的值；在ES6中抛出异常。</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">k</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-06.png\" alt=\"image-20211129135259853\" style=\"zoom:50%;\" />\n\n<p>在JavaScript中，忘记调用 <code>super</code> 是一个很容易犯的错误，但TypeScript会在必要时告诉你。</p>\n<h3 id=\"8-1-4-方法\"><a href=\"#8-1-4-方法\" class=\"headerlink\" title=\"8.1.4 方法\"></a>8.1.4 方法</h3><p>一个类上的函数属性被称为方法。方法可以使用与函数和构造函数相同的所有类型注释。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">10</span>;</span><br><span class=\"line\">  y = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">scale</span>(<span class=\"attr\">n</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">x</span> *= n;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">y</span> *= n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了标准的类型注解，TypeScript并没有为方法添加其他新的东西。</p>\n<p>请注意，在一个方法体中，仍然必须通过<code>this</code>访问字段和其他方法。方法体中的非限定名称将总是指代包围范围内的东西。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">m</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是在试图修改第1行的&#x27;x&#x27;，而不是类属性。</span></span><br><span class=\"line\">    x = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-5-Getters-Setters\"><a href=\"#8-1-5-Getters-Setters\" class=\"headerlink\" title=\"8.1.5 Getters &#x2F; Setters\"></a>8.1.5 Getters &#x2F; Setters</h3><p>类也可以有访问器：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  _length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">length</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_length</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">length</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_length</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>请注意，一个没有额外逻辑的字段支持的<code>get/set</code>对在JavaScript中很少有用。如果你不需要在<code>get/set</code>操作中添加额外的逻辑，暴露公共字段也是可以的。</p>\n</blockquote>\n<p>TypeScript对访问器有一些特殊的推理规则：</p>\n<ul>\n<li><p>如果存在 <code>get</code>，但没有<code>set</code>，则该属性自动是只读的</p>\n</li>\n<li><p>如果没有指定<code>setter</code>参数的类型，它将从<code>getter</code>的返回类型中推断出来</p>\n</li>\n<li><p>访问器和设置器必须有相同的成员可见性</p>\n</li>\n</ul>\n<p>从TypeScript 4.3开始，可以有不同类型的访问器用于获取和设置。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Thing</span> &#123;</span><br><span class=\"line\">  _size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">size</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_size</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">size</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = <span class=\"title class_\">Number</span>(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不允许NaN、Infinity等</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title class_\">Number</span>.<span class=\"built_in\">isFinite</span>(num)) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">_size</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_size</span> = num;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-6-索引签名\"><a href=\"#8-1-6-索引签名\" class=\"headerlink\" title=\"8.1.6 索引签名\"></a>8.1.6 索引签名</h3><p>类可以声明索引签名；这些签名的作用与其他对象类型的索引签名相同。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">boolean</span> | (<span class=\"function\">(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">check</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>[s] <span class=\"keyword\">as</span> <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为索引签名类型需要同时捕获方法的类型，所以要有用地使用这些类型并不容易。一般来说，最好将索引数据存储在另一个地方，而不是在类实例本身。</p>\n<h2 id=\"8-2-类继承\"><a href=\"#8-2-类继承\" class=\"headerlink\" title=\"8.2 类继承\"></a>8.2 类继承</h2><p>像其他具有面向对象特性的语言一样，JavaScript中的类可以继承自基类。</p>\n<h3 id=\"8-2-1-implements子句\"><a href=\"#8-2-1-implements子句\" class=\"headerlink\" title=\"8.2.1 implements子句\"></a>8.2.1 <code>implements</code>子句</h3><p>你可以使用一个 <code>implements</code> 子句来检查一个类，是否满足了一个特定的接口。如果一个类不能正确地实现它，就会发出一个错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Pingable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">ping</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sonar</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Pingable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">ping</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;ping!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ball</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Pingable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">pong</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;pong!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-07.png\" alt=\"image-20211129154149915\" style=\"zoom:50%;\" />\n\n<p>类也可以实现多个接口，例如 <code>class C implements A, B &#123;</code></p>\n<p><strong>注意事项</strong></p>\n<p>重要的是要明白， <code>implements</code> 子句只是检查类是否可以被当作接口类型来对待。它根本不会改变类的类型或其方法。一个常见的错误来源是认为 <code>implements</code> 子句会改变类的类型–它不会！它不会。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Checkable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">check</span>(<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NameChecker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Checkable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">check</span>(<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// any：注意这里没有错误</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"title function_\">toLowercse</span>() === <span class=\"string\">&quot;ok&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-08.png\" alt=\"image-20211129163841634\" style=\"zoom:50%;\" />\n\n<p>在这个例子中，我们也许期望 <code>s</code> 的类型会受到 <code>check</code>的<code>name: string</code>参数的影响。事实并非如此–实现子句并没有改变类主体的检查方式或其类型的推断。</p>\n<p>同样地，实现一个带有可选属性的接口并不能创建该属性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> <span class=\"keyword\">implements</span> A &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> <span class=\"title function_\">C</span>();</span><br><span class=\"line\">c.<span class=\"property\">y</span> = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-09.png\" alt=\"image-20211129164354121\" style=\"zoom:50%;\" />\n\n<h3 id=\"8-2-2-extends子句\"><a href=\"#8-2-2-extends子句\" class=\"headerlink\" title=\"8.2.2 extends子句\"></a>8.2.2 <code>extends</code>子句</h3><p>类可以从基类中扩展出来。派生类拥有其基类的所有属性和方法，也可以定义额外的成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">move</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Moving along!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">woof</span>(<span class=\"params\"><span class=\"attr\">times</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; times; i++) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;woof!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"><span class=\"comment\">// 基类的类方法</span></span><br><span class=\"line\">d.<span class=\"title function_\">move</span>();</span><br><span class=\"line\"><span class=\"comment\">// 派生的类方法</span></span><br><span class=\"line\">d.<span class=\"title function_\">woof</span>(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-2-3-重写方法\"><a href=\"#8-2-3-重写方法\" class=\"headerlink\" title=\"8.2.3 重写方法\"></a>8.2.3 重写方法</h3><p>派生类也可以覆盖基类的一个字段或属性。你可以使用<code>super.</code>语法来访问基类方法。注意，因为JavaScript类是一个简单的查找对象，没有 “超级字段 “的概念。</p>\n<p>TypeScript强制要求派生类总是其基类的一个子类型。</p>\n<p>例如，这里有一个合法的方法来覆盖一个方法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">name</span>?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">super</span>.<span class=\"title function_\">greet</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br><span class=\"line\">d.<span class=\"title function_\">greet</span>();</span><br><span class=\"line\">d.<span class=\"title function_\">greet</span>(<span class=\"string\">&quot;reader&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>派生类遵循其基类契约是很重要的。请记住，通过基类引用来引用派生类实例是非常常见的（而且总是合法的！）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过基类引用对派生实例进行取别名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">b</span>: <span class=\"title class_\">Base</span> = d;</span><br><span class=\"line\"><span class=\"comment\">// 没问题</span></span><br><span class=\"line\">b.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>Derived</code>没有遵守Base的约定怎么办？</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使这个参数成为必需的</span></span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-10.png\" alt=\"image-20211129191159846\" style=\"zoom:50%;\" />\n\n<p>如果我们不顾错误编译这段代码，这个样本就会崩溃：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">b</span>: <span class=\"title class_\">Base</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br><span class=\"line\"><span class=\"comment\">// 崩溃，因为 &quot;名称 &quot;将是 undefined。</span></span><br><span class=\"line\">b.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-11.png\" alt=\"image-20211129191741373\" style=\"zoom:50%;\" />\n\n<h3 id=\"8-2-4-初始化顺序\"><a href=\"#8-2-4-初始化顺序\" class=\"headerlink\" title=\"8.2.4 初始化顺序\"></a>8.2.4 初始化顺序</h3><p>在某些情况下，JavaScript类的初始化顺序可能会令人惊讶。让我们考虑一下这段代码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;base&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;My name is &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;derived&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;base&quot;, 而不是 &quot;derived&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这里发生了什么？</p>\n<p>按照JavaScript的定义，类初始化的顺序是：</p>\n<ul>\n<li>基类的字段被初始化</li>\n<li>基类构造函数运行</li>\n<li>派生类的字段被初始化</li>\n<li>派生类构造函数运行</li>\n</ul>\n<p>这意味着基类构造函数在自己的构造函数中看到了自己的name值，因为派生类的字段初始化还没有运行。</p>\n<h3 id=\"8-2-5-继承内置类型\"><a href=\"#8-2-5-继承内置类型\" class=\"headerlink\" title=\"8.2.5 继承内置类型\"></a>8.2.5 继承内置类型</h3><blockquote>\n<p>注意：如果你不打算继承Array、Error、Map等内置类型，或者你的编译目标明确设置为ES6&#x2F;ES2015或以上，你可以跳过本节。</p>\n</blockquote>\n<p>在ES2015中，返回对象的构造函数隐含地替代了<code>super(...)</code>的任何调用者的<code>this</code>的值。生成的构造函数代码有必要捕获<code>super(...)</code>的任何潜在返回值并将其替换为<code>this</code>。</p>\n<p>因此，子类化<code>Error</code>、<code>Array</code>等可能不再像预期那样工作。这是由于<code>Error</code>、<code>Array</code>等的构造函数使用ECMAScript 6的<code>new.target</code>来调整原型链；然而，在ECMAScript 5中调用构造函数时，没有办法确保<code>new.target</code>的值。其他的下级编译器一般默认有同样的限制。</p>\n<p>对于一个像下面这样的子类：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MsgError</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">m</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(m);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">sayHello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">message</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可能会发现：</p>\n<ul>\n<li>方法在构造这些子类所返回的对象上可能是未定义的，所以调用 <code>sayHello</code> 会导致错误。</li>\n</ul>\n<img src=\"/img/TypeScript/09-12.png\" alt=\"image-20211129205005544\" style=\"zoom:50%;\" />\n\n<ul>\n<li><code>instanceof</code>将在子类的实例和它们的实例之间被打破，所以<code>（new MsgError()）instanceof MsgError</code>将返回<code>false</code>。</li>\n</ul>\n<img src=\"/img/TypeScript/09-13.png\" alt=\"image-20211129205309009\" style=\"zoom:50%;\" />\n\n<p>作为建议，你可以在任何<code>super(...)</code>调用后立即手动调整原型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MsgError</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">m</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 明确地设置原型。</span></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">setPrototypeOf</span>(<span class=\"variable language_\">this</span>, <span class=\"title class_\">MsgError</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">sayHello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">message</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-14.png\" alt=\"image-20211129205721788\" style=\"zoom:50%;\" />\n\n<p>然而，<code>MsgError</code>的任何子类也必须手动设置原型。对于不支持<code>Object.setPrototypeOf</code>的运行时，你可以使用<code>__proto__</code>来代替。</p>\n<p>不幸的是，这些变通方法在<code>Internet Explorer 10</code>和更早的版本上不起作用。我们可以手动将原型中的方法复制到实例本身（例如<code>MsgError.prototype</code>到<code>this</code>），但是原型链本身不能被修复。</p>\n<h2 id=\"8-2-成员的可见性\"><a href=\"#8-2-成员的可见性\" class=\"headerlink\" title=\"8.2 成员的可见性\"></a>8.2 成员的可见性</h2><p>你可以使用TypeScript来控制某些方法或属性对类外的代码是否可见。</p>\n<h3 id=\"8-2-1-public\"><a href=\"#8-2-1-public\" class=\"headerlink\" title=\"8.2.1 public\"></a>8.2.1 <code>public</code></h3><p>类成员的默认可见性是公共(<code>public</code>)的。一个公共(<code>public</code>)成员可以在任何地方被访问。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;hi!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"keyword\">new</span> <span class=\"title class_\">Greeter</span>();</span><br><span class=\"line\">g.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>public</code>已经是默认的可见性修饰符，所以你永远不需要在类成员上写它，但为了风格&#x2F;可读性的原因，可能会选择这样做。</p>\n<h3 id=\"8-2-2-protected\"><a href=\"#8-2-2-protected\" class=\"headerlink\" title=\"8.2.2 protected\"></a>8.2.2 <code>protected</code></h3><p>受保护的(<code>protected</code>)成员只对它们所声明的类的子类可见。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hi&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SpecialGreeter</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">howdy</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在此可以访问受保护的成员</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Howdy, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"keyword\">new</span> <span class=\"title class_\">SpecialGreeter</span>();</span><br><span class=\"line\">g.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 没有问题</span></span><br><span class=\"line\">g.<span class=\"title function_\">getName</span>(); <span class=\"comment\">// 无权访问</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-15.png\" alt=\"image-20211130102051422\" style=\"zoom:50%;\" />\n\n<ul>\n<li><strong>受保护成员的暴露</strong></li>\n</ul>\n<p>派生类需要遵循它们的基类契约，但可以选择公开具有更多能力的基类的子类型。这包括将受保护的成员变成公开。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> m = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 没有修饰符，所以默认为&#x27;公共&#x27;(&#x27;public&#x27;)</span></span><br><span class=\"line\">  m = <span class=\"number\">15</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d.<span class=\"property\">m</span>); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-2-3-private\"><a href=\"#8-2-3-private\" class=\"headerlink\" title=\"8.2.3 private\"></a>8.2.3 <code>private</code></h3><p><code>private</code>和<code>protected</code>一样，但不允许从子类中访问该成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Base</span>();</span><br><span class=\"line\"><span class=\"comment\">// 不能从类外访问</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b.<span class=\"property\">x</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-17.png\" alt=\"image-20211130104530638\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Base</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">showX</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不能在子类中访问</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">x</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为私有(<code>private</code>)成员对派生类是不可见的，所以派生类不能增加其可见性。</p>\n<ul>\n<li><strong>跨实例的私有访问</strong></li>\n</ul>\n<p>不同的OOP语言对同一个类的不同实例，是否可以访问对方的私有成员，有不同的处理方法。虽然像Java、C#、C++、Swift和PHP等语言允许这样做，但Ruby不允许。</p>\n<p>TypeScript确实允许跨实例的私有访问：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">sameAs</span>(<span class=\"params\"><span class=\"attr\">other</span>: A</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以访问</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> other.<span class=\"property\">x</span> === <span class=\"variable language_\">this</span>.<span class=\"property\">x</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>注意事项</strong></li>\n</ul>\n<p>像TypeScript类型系统的其他方面一样，<code>private</code>和<code>protected</code>只在类型检查中被强制执行。</p>\n<p>这意味着JavaScript的运行时结构，如<code>in</code>或简单的属性查询，仍然可以访问一个私有或保护的成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MySafe</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> secretKey = <span class=\"number\">12345</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在JS环境中...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"title class_\">MySafe</span>();</span><br><span class=\"line\"><span class=\"comment\">// 将打印 12345</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"property\">secretKey</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>private</code>也允许在类型检查时使用括号符号进行访问。这使得私有声明的字段可能更容易被单元测试之类的东西所访问，缺点是这些字段是软性私有的，不能严格执行私有特性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MySafe</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> secretKey = <span class=\"number\">12345</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"title class_\">MySafe</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在类型检查期间不允许</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"property\">secretKey</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s[<span class=\"string\">&quot;secretKey&quot;</span>]);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-19.png\" alt=\"image-20211130135104155\" style=\"zoom:50%;\" />\n\n<p>与TypeScript的 <code>private</code>不同，JavaScript的<code>private</code>字段（#）在编译后仍然是<code>private</code>的，并且不提供前面提到的像括号符号访问那样的转义窗口，使其成为硬<code>private</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  #barkAmount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  personality = <span class=\"string\">&quot;happy&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.#barkAmount);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dog = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">barkAmount</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-20.png\" alt=\"image-20211130154613004\" style=\"zoom:50%;\" />\n\n<p>当编译到ES2021或更少时，TypeScript将使用WeakMaps来代替 <code>#</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _Dog_barkAmount;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    _Dog_barkAmount.<span class=\"title function_\">set</span>(<span class=\"variable language_\">this</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">personality</span> = <span class=\"string\">&quot;happy&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_Dog_barkAmount = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakMap</span>();</span><br></pre></td></tr></table></figure>\n\n<p>如果你需要保护你的类中的值免受恶意行为的影响，你应该使用提供硬运行时隐私的机制，如闭包、<code>WeakMaps</code>或私有字段。请注意，这些在运行时增加的隐私检查可能会影响性能。</p>\n<h2 id=\"8-3-静态成员\"><a href=\"#8-3-静态成员\" class=\"headerlink\" title=\"8.3 静态成员\"></a>8.3 静态成员</h2><p>类可以有静态成员。这些成员并不与类的特定实例相关联。它们可以通过类的构造函数对象本身来访问。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">printX</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">MyClass</span>.<span class=\"property\">x</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">MyClass</span>.<span class=\"property\">x</span>);</span><br><span class=\"line\"><span class=\"title class_\">MyClass</span>.<span class=\"title function_\">printX</span>();</span><br></pre></td></tr></table></figure>\n\n<p>静态成员也可以使用相同的<code>public</code>、<code>protected</code>和<code>private</code>可见性修饰符。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">MyClass</span>.<span class=\"property\">x</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-21.png\" alt=\"image-20211130161046623\" style=\"zoom:50%;\" />\n\n<p>静态成员也会被继承。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">getGreeting</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  myGreeting = <span class=\"title class_\">Derived</span>.<span class=\"title function_\">getGreeting</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-1-特殊静态名称\"><a href=\"#8-3-1-特殊静态名称\" class=\"headerlink\" title=\"8.3.1 特殊静态名称\"></a>8.3.1 特殊静态名称</h3><p>一般来说，从函数原型覆盖属性是不安全的&#x2F;不可能的。因为类本身就是可以用<code>new</code>调用的函数，所以某些静态名称不能使用。像<code>name</code>、<code>length</code>和<code>call</code>这样的函数属性，定义为静态成员是无效的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">S</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> name = <span class=\"string\">&quot;S!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-22.png\" alt=\"image-20211203133418242\" style=\"zoom:50%;\" />\n\n<h3 id=\"8-3-2-为什么没有静态类？\"><a href=\"#8-3-2-为什么没有静态类？\" class=\"headerlink\" title=\"8.3.2 为什么没有静态类？\"></a>8.3.2 为什么没有静态类？</h3><p>TypeScript（和JavaScript）没有像C#和Java那样有一个叫做静态类的结构。</p>\n<p>这些结构体的存在，只是因为这些语言强制所有的数据和函数都在一个类里面；因为这个限制在TypeScript中不存在，所以不需要它们。一个只有一个实例的类，在JavaScript&#x2F;TypeScript中通常只是表示为一个普通的对象。</p>\n<p>例如，我们不需要TypeScript中的 “静态类 “语法，因为一个普通的对象（甚至是顶级函数）也可以完成这个工作。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不需要 &quot;static&quot; class</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyStaticClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首选 (备选 1)</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首选 (备选 2)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MyHelperObject</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">dosomething</span>(<span class=\"params\"></span>) &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-4-类里的-static-区块\"><a href=\"#8-4-类里的-static-区块\" class=\"headerlink\" title=\"8.4 类里的 static 区块\"></a>8.4 类里的 <code>static </code>区块</h2><p>静态块允许你写一串有自己作用域的语句，可以访问包含类中的私有字段。这意味着我们可以用写语句的所有能力来写初始化代码，不泄露变量，并能完全访问我们类的内部结构。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> #count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">count</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Foo</span>.#count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> lastInstances = &#123;</span><br><span class=\"line\">        <span class=\"attr\">length</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"title class_\">Foo</span>.#count += lastInstances.<span class=\"property\">length</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-5-泛型类\"><a href=\"#8-5-泛型类\" class=\"headerlink\" title=\"8.5 泛型类\"></a>8.5 泛型类</h2><p>类，和接口一样，可以是泛型的。当一个泛型类用new实例化时，其类型参数的推断方式与函数调用的方式相同。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Type</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">contents</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const b: Box&lt;string&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Box</span>(<span class=\"string\">&quot;hello!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>类可以像接口一样使用通用约束和默认值。</p>\n<ul>\n<li>静态成员中的类型参数</li>\n</ul>\n<p>这段代码是不合法的，可能并不明显，为什么呢？</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 静态成员不能引用类的类型参数。</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"attr\">defaultValue</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Box&lt;string&gt;.defaultValue = &#x27;hello&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(Box&lt;number&gt;.defaultValue)</span></span><br></pre></td></tr></table></figure>\n\n<p>请记住，类型总是被完全擦除的! 在运行时，只有一个Box.defaultValue属性。这意味着设置Box<string>.defaultValue（如果有可能的话）也会改变Box<number>.defaultValue，这可不是什么好事。一个泛型类的静态成员永远不能引用该类的类型参数。</p>\n<h2 id=\"8-6-类运行时中的this\"><a href=\"#8-6-类运行时中的this\" class=\"headerlink\" title=\"8.6 类运行时中的this\"></a>8.6 类运行时中的<code>this</code></h2><p>重要的是要记住，TypeScript并没有改变JavaScript的运行时行为，而JavaScript的运行时行为偶尔很奇特。</p>\n<p>比如，JavaScript对这一点的处理确实是不寻常的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;MyClass&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;obj&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">getName</span>: c.<span class=\"property\">getName</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出 &quot;obj&quot;, 而不是 &quot;MyClass&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">getName</span>());</span><br></pre></td></tr></table></figure>\n\n<p>长话短说，默认情况下，函数内this的值取决于函数的调用方式。在这个例子中，因为函数是通过obj引用调用的，所以它的this值是obj而不是类实例。</p>\n<p>这很少是你希望发生的事情! TypeScript提供了一些方法来减轻或防止这种错误。</p>\n<p><strong>1、箭头函数</strong></p>\n<p>如果你有一个经常会被调用的函数，失去了它的 <code>this</code> 上下文，那么使用一个箭头函数而不是方法定义是有意义的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;MyClass&quot;</span>;</span><br><span class=\"line\">  getName = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = c.<span class=\"property\">getName</span>;</span><br><span class=\"line\"><span class=\"comment\">// 输出 &quot;MyClass&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>());</span><br></pre></td></tr></table></figure>\n\n<p>这有一些权衡：</p>\n<ul>\n<li><p><code>this</code> 值保证在运行时是正确的，即使是没有经过TypeScript检查的代码也是如此。</p>\n</li>\n<li><p>这将使用更多的内存，因为每个类实例将有它自己的副本，每个函数都是这样定义的。</p>\n</li>\n<li><p>你不能在派生类中使用<code>super.getName</code>，因为在原型链中没有入口可以获取基类方法。</p>\n</li>\n</ul>\n<p><strong>2、<code>this</code> 参数</strong></p>\n<p>在方法或函数定义中，一个名为<code>this</code>的初始参数在TypeScript中具有特殊的意义。这些参数在编译过程中会被删除。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带有 &quot;this&quot; 参数的 TypeScript 输入</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">SomeType</span>, <span class=\"attr\">x</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译后的JavaScript结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript检查调用带有<code>this</code>参数的函数，是否在正确的上下文中进行。我们可以不使用箭头函数，而是在方法定义中添加一个<code>this</code>参数，以静态地确保方法被正确调用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;MyClass&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">getName</span>(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">MyClass</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\">c.<span class=\"title function_\">getName</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = c.<span class=\"property\">getName</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>());</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-23.png\" alt=\"image-20211210093534818\" style=\"zoom: 67%;\" />\n\n<p>这种方法做出了与箭头函数方法相反的取舍：</p>\n<ul>\n<li>JavaScript调用者仍然可能在不知不觉中错误地使用类方法</li>\n<li>每个类定义只有一个函数被分配，而不是每个类实例一个函数</li>\n<li>基类方法定义仍然可以通过 <code>super</code>调用。</li>\n</ul>\n<h2 id=\"8-7-this类型\"><a href=\"#8-7-this类型\" class=\"headerlink\" title=\"8.7 this类型\"></a>8.7 <code>this</code>类型</h2><p>在类中，一个叫做 <code>this</code>的特殊类型动态地指向当前类的类型。让我们来看看这有什么用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// (method) Box.set(value: string): this</span></span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">contents</span> = value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，TypeScript推断出 <code>set</code>的返回类型是<code>this</code>，而不是<code>Box</code>。现在让我们做一个Box的子类：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClearableBox</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">contents</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">ClearableBox</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const b: ClearableBox</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = a.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-24.png\" alt=\"image-20211210095241472\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>你也可以在参数类型注释中使用 <code>this</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">sameAs</span>(<span class=\"params\"><span class=\"attr\">other</span>: <span class=\"variable language_\">this</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> other.<span class=\"property\">content</span> === <span class=\"variable language_\">this</span>.<span class=\"property\">content</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> box = <span class=\"keyword\">new</span> <span class=\"title class_\">Box</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(box.<span class=\"title function_\">sameAs</span>(box));</span><br></pre></td></tr></table></figure>\n\n<p>这与其他写法不同：Box，如果你有一个派生类，它的 <code>sameAs</code> 方法现在只接受该同一派生类的其他实例。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">sameAs</span>(<span class=\"params\"><span class=\"attr\">other</span>: <span class=\"variable language_\">this</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> other.<span class=\"property\">content</span> === <span class=\"variable language_\">this</span>.<span class=\"property\">content</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DerivedBox</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">otherContent</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;?&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> base = <span class=\"keyword\">new</span> <span class=\"title class_\">Box</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> derived = <span class=\"keyword\">new</span> <span class=\"title class_\">DerivedBox</span>();</span><br><span class=\"line\">derived.<span class=\"title function_\">sameAs</span>(base);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-25.png\" alt=\"image-20211210102234118\" style=\"zoom:50%;\" />\n\n<h2 id=\"8-8-基于类型守卫的this\"><a href=\"#8-8-基于类型守卫的this\" class=\"headerlink\" title=\"8.8 基于类型守卫的this\"></a>8.8 基于类型守卫的<code>this</code></h2><p>你可以在类和接口的方法的返回位置使用 <code>this is Type</code> 。当与类型缩小混合时（例如if语句），目标对象的类型将被缩小到指定的Type。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSystemObject</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isFile</span>(): <span class=\"variable language_\">this</span> is <span class=\"title class_\">FileRep</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">FileRep</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">isDirectory</span>(): <span class=\"variable language_\">this</span> is <span class=\"title class_\">Directory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Directory</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">isNetworked</span>(): <span class=\"variable language_\">this</span> is <span class=\"title class_\">Networked</span> &amp; <span class=\"variable language_\">this</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">networked</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"attr\">path</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"attr\">networked</span>: <span class=\"built_in\">boolean</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileRep</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">FileSystemObject</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">path</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(path, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Directory</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">FileSystemObject</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">children</span>: <span class=\"title class_\">FileSystemObject</span>[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Networked</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">host</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">fso</span>: <span class=\"title class_\">FileSystemObject</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">FileRep</span>(<span class=\"string\">&quot;foo/bar.txt&quot;</span>, <span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (fso.<span class=\"title function_\">isFile</span>()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// const fso: FileRep</span></span><br><span class=\"line\">  fso.<span class=\"property\">content</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fso.<span class=\"title function_\">isDirectory</span>()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// const fso: Directory</span></span><br><span class=\"line\">  fso.<span class=\"property\">children</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fso.<span class=\"title function_\">isNetworked</span>()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// const fso: Networked &amp; FileSystemObject</span></span><br><span class=\"line\">  fso.<span class=\"property\">host</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基于 <code>this</code> 的类型保护的一个常见用例，是允许对一个特定字段进行懒惰验证。例如，这种情况下，当 <code>hasValue</code>被验证为真时，就会从框内持有的值中删除一个未定义值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>?: T;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">hasValue</span>(): <span class=\"variable language_\">this</span> is &#123; <span class=\"attr\">value</span>: T &#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> box = <span class=\"keyword\">new</span> <span class=\"title class_\">Box</span>();</span><br><span class=\"line\">box.<span class=\"property\">value</span> = <span class=\"string\">&quot;Gameboy&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (property) Box&lt;unknown&gt;.value?: unknownbox.value;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (box.<span class=\"title function_\">hasValue</span>()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// (property) value: unknown</span></span><br><span class=\"line\">  box.<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-9-参数属性\"><a href=\"#8-9-参数属性\" class=\"headerlink\" title=\"8.9 参数属性\"></a>8.9 参数属性</h2><p>TypeScript提供了特殊的语法，可以将构造函数参数变成具有相同名称和值的类属性。这些被称为参数属性，通过在构造函数参数前加上可见性修饰符 <code>public</code>、<code>private</code>、<code>protected</code>或<code>readonly</code>中的一个来创建。由此产生的字段会得到这些修饰符。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Params</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">protected</span> <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"attr\">z</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// No body necessary</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Params</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (property) Params.x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a.<span class=\"property\">x</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a.<span class=\"property\">z</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-01.png\" alt=\"image-20211214162348578\" style=\"zoom: 60%;\" />\n\n<h2 id=\"8-10-类表达式\"><a href=\"#8-10-类表达式\" class=\"headerlink\" title=\"8.10 类表达式\"></a>8.10 类表达式</h2><p>类表达式与类声明非常相似。唯一真正的区别是，类表达式不需要一个名字，尽管我们可以通过它们最终绑定的任何标识符来引用它们。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> someClass = <span class=\"keyword\">class</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Type</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">content</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const m: someClass&lt;string&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"title function_\">someClass</span>(<span class=\"string\">&quot;Hello, world&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-11-抽象类和成员\"><a href=\"#8-11-抽象类和成员\" class=\"headerlink\" title=\"8.11 抽象类和成员\"></a>8.11 抽象类和成员</h2><p>TypeScript中的类、方法和字段可以是抽象的。</p>\n<p>一个抽象的方法或抽象的字段是一个没有提供实现的方法或字段。这些成员必须存在于一个抽象类中，不能直接实例化。</p>\n<p>抽象类的作用是作为子类的基类，实现所有的抽象成员。当一个类没有任何抽象成员时，我们就说它是具体的。</p>\n<p>让我们看一个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"title function_\">getName</span>(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"title function_\">printName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Base</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-02.png\" alt=\"image-20211219063509036\" style=\"zoom:60%;\" />\n\n<p>我们不能用 <code>new</code>来实例化<code>Base</code>，因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br><span class=\"line\">d.<span class=\"title function_\">printName</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-03.png\" alt=\"image-20211219064030984\" style=\"zoom:60%;\" />\n\n<ul>\n<li><strong>抽象构造签名</strong></li>\n</ul>\n<p>有时你想接受一些类的构造函数，产生一个从某些抽象类派生出来的类的实例。</p>\n<p>例如，你可能想写这样的代码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">ctor</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Base</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> <span class=\"title function_\">ctor</span>();</span><br><span class=\"line\">  instance.<span class=\"title function_\">printName</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-04.png\" alt=\"image-20211219064506944\" style=\"zoom:67%;\" />\n\n<p>TypeScript正确地告诉你，你正试图实例化一个抽象类。毕竟，鉴于greet的定义，写这段代码是完全合法的，它最终会构造一个抽象类。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 槽糕</span></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"title class_\">Base</span>);</span><br></pre></td></tr></table></figure>\n\n<p>相反，你想写一个函数，接受具有结构化签名的东西：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">ctor</span>: <span class=\"keyword\">new</span> () =&gt; <span class=\"title class_\">Base</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> <span class=\"title function_\">ctor</span>();</span><br><span class=\"line\">  instance.<span class=\"title function_\">printName</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"title class_\">Derived</span>);</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"title class_\">Base</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-05.png\" alt=\"image-20211219065154437\" style=\"zoom:67%;\" />\n\n<p>现在TypeScript正确地告诉你哪些类的构造函数可以被调用：<code>Derived</code>可以，因为它是具体的，但<code>Base</code>不能。</p>\n<h2 id=\"8-12-类之间的关系\"><a href=\"#8-12-类之间的关系\" class=\"headerlink\" title=\"8.12 类之间的关系\"></a>8.12 类之间的关系</h2><p>在大多数情况下，TypeScript中的类在结构上与其他类型相同，是可以比较的。</p>\n<p>例如，这两个类可以互相替代使用，因为它们是相同的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point1</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point2</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p</span>: <span class=\"title class_\">Point1</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Point2</span>();</span><br></pre></td></tr></table></figure>\n\n<p>同样地，即使没有明确的继承，类之间的子类型关系也是存在的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">salary</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p</span>: <span class=\"title class_\">Person</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这听起来很简单，但有几种情况似乎比其他情况更奇怪。</p>\n<p>空的类没有成员。在一个结构化类型系统中，一个没有成员的类型通常是其他任何东西的超类型。所以如果你写了一个空类（不要！），任何东西都可以用来代替它。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Empty</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Empty</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不能用&#x27;x&#x27;做任何事</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下调用均可</span></span><br><span class=\"line\">!<span class=\"title function_\">fn</span>(<span class=\"variable language_\">window</span>);</span><br><span class=\"line\"><span class=\"title function_\">fn</span>(&#123;&#125;);</span><br><span class=\"line\"><span class=\"title function_\">fn</span>(fn);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"八、类\"><a href=\"#八、类\" class=\"headerlink\" title=\"八、类\"></a>八、类</h1><p>TypeScript提供了对ES2015中引入的 <code>class</code> 关键词的完全支持。</p>\n<p>与其他JavaScript语言功能一样，TypeScript增加了类型注释和其他语法，允许你表达类和其他类型之间的关系。</p>\n<h2 id=\"8-1-类成员\"><a href=\"#8-1-类成员\" class=\"headerlink\" title=\"8.1 类成员\"></a>8.1 类成员</h2><p>这里有一个最基本的类——一个空的类：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类还不是很有用，所以我们开始添加一些成员。</p>\n<h3 id=\"8-1-1-类属性\"><a href=\"#8-1-1-类属性\" class=\"headerlink\" title=\"8.1.1 类属性\"></a>8.1.1 类属性</h3><p>在一个类上声明字段，创建一个公共的可写属性：A mapped type is a generic type which uses a union of <code>PropertyKey</code>s (frequently created <a href=\"https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html\">via a <code>keyof</code></a>) to iterate through keys to create a type:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pt = <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>();</span><br><span class=\"line\">pt.<span class=\"property\">x</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">pt.<span class=\"property\">y</span> = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>与其他位置一样，类型注解是可选的，但如果不指定，将是一个隐含的 <code>any</code> 类型。</p>\n<p>字段也可以有初始化器；这些初始化器将在类被实例化时自动运行。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pt = <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>();</span><br><span class=\"line\"><span class=\"comment\">// Prints 0, 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;pt.x&#125;</span>, <span class=\"subst\">$&#123;pt.y&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>就像 <code>const</code>、<code>let</code>和<code>var</code>一样，一个类属性的初始化器将被用来推断其类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pt = <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>();</span><br><span class=\"line\">pt.<span class=\"property\">x</span> = <span class=\"string\">&quot;0&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-01.png\" alt=\"image-20211129114803786\" style=\"zoom:50%;\" />\n\n<ul>\n<li><code>--strictPropertyInitialization</code></li>\n</ul>\n<p><code>strictPropertyInitialization</code>设置控制是否需要在构造函数中初始化类字段。</p>\n<img src=\"/img/TypeScript/09-02.png\" alt=\"image-20211129115145529\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BadGreeter</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-04.png\" alt=\"image-20211129115341214\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GoodGreeter</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，该字段需要在构造函数本身中初始化。TypeScript不会分析你从构造函数中调用的方法来检测初始化，因为派生类可能会覆盖这些方法而无法初始化成员。</p>\n<p>如果你打算通过构造函数以外的方式来确定初始化一个字段（例如，也许一个外部库为你填充了你的类的一部分），你可以使用确定的赋值断言操作符 <code>！</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OKGreeter</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 没有初始化，但没报错。</span></span><br><span class=\"line\">  name!: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-2-readonly\"><a href=\"#8-1-2-readonly\" class=\"headerlink\" title=\"8.1.2 readonly\"></a>8.1.2 <code>readonly</code></h3><p>字段的前缀可以是 <code>readonly</code> 修饰符。这可以防止在构造函数之外对该字段进行赋值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">otherName</span>?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (otherName !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = otherName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">err</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = <span class=\"string\">&quot;not ok&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"keyword\">new</span> <span class=\"title class_\">Greeter</span>();</span><br><span class=\"line\">g.<span class=\"property\">name</span> = <span class=\"string\">&quot;also not ok&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-05.png\" alt=\"image-20211129120222803\" style=\"zoom:50%;\" />\n\n<h3 id=\"8-1-3-构造器\"><a href=\"#8-1-3-构造器\" class=\"headerlink\" title=\"8.1.3 构造器\"></a>8.1.3 构造器</h3><p>类构造函数与函数非常相似。你可以添加带有类型注释的参数、默认值和重载：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 带默认值的正常签名</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">x</span> = x;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">y</span> = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 重载</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">string</span></span>);</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>);</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">xs</span>: <span class=\"built_in\">any</span>, <span class=\"attr\">y</span>?: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类的构造函数签名和函数签名之间只有一些区别：</p>\n<ul>\n<li><p>构造函数不能有类型参数–这属于外层类的声明，我们将在后面学习。</p>\n</li>\n<li><p>构造函数不能有返回类型注释——类的实例类型总是被返回的。</p>\n</li>\n</ul>\n<p><strong>Super 调用</strong></p>\n<p>就像在JavaScript中一样，如果你有一个基类，在使用任何 <code>this.</code>成员之前，你需要在构造器主体中调用<code>super();</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  k = <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在ES5中打印一个错误的值；在ES6中抛出异常。</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">k</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-06.png\" alt=\"image-20211129135259853\" style=\"zoom:50%;\" />\n\n<p>在JavaScript中，忘记调用 <code>super</code> 是一个很容易犯的错误，但TypeScript会在必要时告诉你。</p>\n<h3 id=\"8-1-4-方法\"><a href=\"#8-1-4-方法\" class=\"headerlink\" title=\"8.1.4 方法\"></a>8.1.4 方法</h3><p>一个类上的函数属性被称为方法。方法可以使用与函数和构造函数相同的所有类型注释。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">10</span>;</span><br><span class=\"line\">  y = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">scale</span>(<span class=\"attr\">n</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">x</span> *= n;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">y</span> *= n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了标准的类型注解，TypeScript并没有为方法添加其他新的东西。</p>\n<p>请注意，在一个方法体中，仍然必须通过<code>this</code>访问字段和其他方法。方法体中的非限定名称将总是指代包围范围内的东西。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">m</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是在试图修改第1行的&#x27;x&#x27;，而不是类属性。</span></span><br><span class=\"line\">    x = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-5-Getters-Setters\"><a href=\"#8-1-5-Getters-Setters\" class=\"headerlink\" title=\"8.1.5 Getters &#x2F; Setters\"></a>8.1.5 Getters &#x2F; Setters</h3><p>类也可以有访问器：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  _length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">length</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_length</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">length</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_length</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>请注意，一个没有额外逻辑的字段支持的<code>get/set</code>对在JavaScript中很少有用。如果你不需要在<code>get/set</code>操作中添加额外的逻辑，暴露公共字段也是可以的。</p>\n</blockquote>\n<p>TypeScript对访问器有一些特殊的推理规则：</p>\n<ul>\n<li><p>如果存在 <code>get</code>，但没有<code>set</code>，则该属性自动是只读的</p>\n</li>\n<li><p>如果没有指定<code>setter</code>参数的类型，它将从<code>getter</code>的返回类型中推断出来</p>\n</li>\n<li><p>访问器和设置器必须有相同的成员可见性</p>\n</li>\n</ul>\n<p>从TypeScript 4.3开始，可以有不同类型的访问器用于获取和设置。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Thing</span> &#123;</span><br><span class=\"line\">  _size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">size</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_size</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">size</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = <span class=\"title class_\">Number</span>(value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不允许NaN、Infinity等</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title class_\">Number</span>.<span class=\"built_in\">isFinite</span>(num)) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">_size</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_size</span> = num;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-6-索引签名\"><a href=\"#8-1-6-索引签名\" class=\"headerlink\" title=\"8.1.6 索引签名\"></a>8.1.6 索引签名</h3><p>类可以声明索引签名；这些签名的作用与其他对象类型的索引签名相同。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">boolean</span> | (<span class=\"function\">(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">boolean</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">check</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>[s] <span class=\"keyword\">as</span> <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为索引签名类型需要同时捕获方法的类型，所以要有用地使用这些类型并不容易。一般来说，最好将索引数据存储在另一个地方，而不是在类实例本身。</p>\n<h2 id=\"8-2-类继承\"><a href=\"#8-2-类继承\" class=\"headerlink\" title=\"8.2 类继承\"></a>8.2 类继承</h2><p>像其他具有面向对象特性的语言一样，JavaScript中的类可以继承自基类。</p>\n<h3 id=\"8-2-1-implements子句\"><a href=\"#8-2-1-implements子句\" class=\"headerlink\" title=\"8.2.1 implements子句\"></a>8.2.1 <code>implements</code>子句</h3><p>你可以使用一个 <code>implements</code> 子句来检查一个类，是否满足了一个特定的接口。如果一个类不能正确地实现它，就会发出一个错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Pingable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">ping</span>(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sonar</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Pingable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">ping</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;ping!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Ball</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Pingable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">pong</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;pong!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-07.png\" alt=\"image-20211129154149915\" style=\"zoom:50%;\" />\n\n<p>类也可以实现多个接口，例如 <code>class C implements A, B &#123;</code></p>\n<p><strong>注意事项</strong></p>\n<p>重要的是要明白， <code>implements</code> 子句只是检查类是否可以被当作接口类型来对待。它根本不会改变类的类型或其方法。一个常见的错误来源是认为 <code>implements</code> 子句会改变类的类型–它不会！它不会。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Checkable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">check</span>(<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NameChecker</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Checkable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">check</span>(<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// any：注意这里没有错误</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"title function_\">toLowercse</span>() === <span class=\"string\">&quot;ok&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-08.png\" alt=\"image-20211129163841634\" style=\"zoom:50%;\" />\n\n<p>在这个例子中，我们也许期望 <code>s</code> 的类型会受到 <code>check</code>的<code>name: string</code>参数的影响。事实并非如此–实现子句并没有改变类主体的检查方式或其类型的推断。</p>\n<p>同样地，实现一个带有可选属性的接口并不能创建该属性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> A &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> <span class=\"keyword\">implements</span> A &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> <span class=\"title function_\">C</span>();</span><br><span class=\"line\">c.<span class=\"property\">y</span> = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-09.png\" alt=\"image-20211129164354121\" style=\"zoom:50%;\" />\n\n<h3 id=\"8-2-2-extends子句\"><a href=\"#8-2-2-extends子句\" class=\"headerlink\" title=\"8.2.2 extends子句\"></a>8.2.2 <code>extends</code>子句</h3><p>类可以从基类中扩展出来。派生类拥有其基类的所有属性和方法，也可以定义额外的成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">move</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Moving along!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">woof</span>(<span class=\"params\"><span class=\"attr\">times</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; times; i++) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;woof!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"><span class=\"comment\">// 基类的类方法</span></span><br><span class=\"line\">d.<span class=\"title function_\">move</span>();</span><br><span class=\"line\"><span class=\"comment\">// 派生的类方法</span></span><br><span class=\"line\">d.<span class=\"title function_\">woof</span>(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-2-3-重写方法\"><a href=\"#8-2-3-重写方法\" class=\"headerlink\" title=\"8.2.3 重写方法\"></a>8.2.3 重写方法</h3><p>派生类也可以覆盖基类的一个字段或属性。你可以使用<code>super.</code>语法来访问基类方法。注意，因为JavaScript类是一个简单的查找对象，没有 “超级字段 “的概念。</p>\n<p>TypeScript强制要求派生类总是其基类的一个子类型。</p>\n<p>例如，这里有一个合法的方法来覆盖一个方法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">name</span>?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">super</span>.<span class=\"title function_\">greet</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br><span class=\"line\">d.<span class=\"title function_\">greet</span>();</span><br><span class=\"line\">d.<span class=\"title function_\">greet</span>(<span class=\"string\">&quot;reader&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>派生类遵循其基类契约是很重要的。请记住，通过基类引用来引用派生类实例是非常常见的（而且总是合法的！）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过基类引用对派生实例进行取别名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">b</span>: <span class=\"title class_\">Base</span> = d;</span><br><span class=\"line\"><span class=\"comment\">// 没问题</span></span><br><span class=\"line\">b.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>Derived</code>没有遵守Base的约定怎么办？</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使这个参数成为必需的</span></span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-10.png\" alt=\"image-20211129191159846\" style=\"zoom:50%;\" />\n\n<p>如果我们不顾错误编译这段代码，这个样本就会崩溃：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">b</span>: <span class=\"title class_\">Base</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br><span class=\"line\"><span class=\"comment\">// 崩溃，因为 &quot;名称 &quot;将是 undefined。</span></span><br><span class=\"line\">b.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-11.png\" alt=\"image-20211129191741373\" style=\"zoom:50%;\" />\n\n<h3 id=\"8-2-4-初始化顺序\"><a href=\"#8-2-4-初始化顺序\" class=\"headerlink\" title=\"8.2.4 初始化顺序\"></a>8.2.4 初始化顺序</h3><p>在某些情况下，JavaScript类的初始化顺序可能会令人惊讶。让我们考虑一下这段代码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;base&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;My name is &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;derived&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;base&quot;, 而不是 &quot;derived&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这里发生了什么？</p>\n<p>按照JavaScript的定义，类初始化的顺序是：</p>\n<ul>\n<li>基类的字段被初始化</li>\n<li>基类构造函数运行</li>\n<li>派生类的字段被初始化</li>\n<li>派生类构造函数运行</li>\n</ul>\n<p>这意味着基类构造函数在自己的构造函数中看到了自己的name值，因为派生类的字段初始化还没有运行。</p>\n<h3 id=\"8-2-5-继承内置类型\"><a href=\"#8-2-5-继承内置类型\" class=\"headerlink\" title=\"8.2.5 继承内置类型\"></a>8.2.5 继承内置类型</h3><blockquote>\n<p>注意：如果你不打算继承Array、Error、Map等内置类型，或者你的编译目标明确设置为ES6&#x2F;ES2015或以上，你可以跳过本节。</p>\n</blockquote>\n<p>在ES2015中，返回对象的构造函数隐含地替代了<code>super(...)</code>的任何调用者的<code>this</code>的值。生成的构造函数代码有必要捕获<code>super(...)</code>的任何潜在返回值并将其替换为<code>this</code>。</p>\n<p>因此，子类化<code>Error</code>、<code>Array</code>等可能不再像预期那样工作。这是由于<code>Error</code>、<code>Array</code>等的构造函数使用ECMAScript 6的<code>new.target</code>来调整原型链；然而，在ECMAScript 5中调用构造函数时，没有办法确保<code>new.target</code>的值。其他的下级编译器一般默认有同样的限制。</p>\n<p>对于一个像下面这样的子类：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MsgError</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">m</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(m);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">sayHello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">message</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可能会发现：</p>\n<ul>\n<li>方法在构造这些子类所返回的对象上可能是未定义的，所以调用 <code>sayHello</code> 会导致错误。</li>\n</ul>\n<img src=\"/img/TypeScript/09-12.png\" alt=\"image-20211129205005544\" style=\"zoom:50%;\" />\n\n<ul>\n<li><code>instanceof</code>将在子类的实例和它们的实例之间被打破，所以<code>（new MsgError()）instanceof MsgError</code>将返回<code>false</code>。</li>\n</ul>\n<img src=\"/img/TypeScript/09-13.png\" alt=\"image-20211129205309009\" style=\"zoom:50%;\" />\n\n<p>作为建议，你可以在任何<code>super(...)</code>调用后立即手动调整原型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MsgError</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">m</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(m);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 明确地设置原型。</span></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">setPrototypeOf</span>(<span class=\"variable language_\">this</span>, <span class=\"title class_\">MsgError</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">sayHello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">message</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-14.png\" alt=\"image-20211129205721788\" style=\"zoom:50%;\" />\n\n<p>然而，<code>MsgError</code>的任何子类也必须手动设置原型。对于不支持<code>Object.setPrototypeOf</code>的运行时，你可以使用<code>__proto__</code>来代替。</p>\n<p>不幸的是，这些变通方法在<code>Internet Explorer 10</code>和更早的版本上不起作用。我们可以手动将原型中的方法复制到实例本身（例如<code>MsgError.prototype</code>到<code>this</code>），但是原型链本身不能被修复。</p>\n<h2 id=\"8-2-成员的可见性\"><a href=\"#8-2-成员的可见性\" class=\"headerlink\" title=\"8.2 成员的可见性\"></a>8.2 成员的可见性</h2><p>你可以使用TypeScript来控制某些方法或属性对类外的代码是否可见。</p>\n<h3 id=\"8-2-1-public\"><a href=\"#8-2-1-public\" class=\"headerlink\" title=\"8.2.1 public\"></a>8.2.1 <code>public</code></h3><p>类成员的默认可见性是公共(<code>public</code>)的。一个公共(<code>public</code>)成员可以在任何地方被访问。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;hi!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"keyword\">new</span> <span class=\"title class_\">Greeter</span>();</span><br><span class=\"line\">g.<span class=\"title function_\">greet</span>();</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>public</code>已经是默认的可见性修饰符，所以你永远不需要在类成员上写它，但为了风格&#x2F;可读性的原因，可能会选择这样做。</p>\n<h3 id=\"8-2-2-protected\"><a href=\"#8-2-2-protected\" class=\"headerlink\" title=\"8.2.2 protected\"></a>8.2.2 <code>protected</code></h3><p>受保护的(<code>protected</code>)成员只对它们所声明的类的子类可见。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hi&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SpecialGreeter</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">howdy</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在此可以访问受保护的成员</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Howdy, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"keyword\">new</span> <span class=\"title class_\">SpecialGreeter</span>();</span><br><span class=\"line\">g.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 没有问题</span></span><br><span class=\"line\">g.<span class=\"title function_\">getName</span>(); <span class=\"comment\">// 无权访问</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-15.png\" alt=\"image-20211130102051422\" style=\"zoom:50%;\" />\n\n<ul>\n<li><strong>受保护成员的暴露</strong></li>\n</ul>\n<p>派生类需要遵循它们的基类契约，但可以选择公开具有更多能力的基类的子类型。这包括将受保护的成员变成公开。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> m = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 没有修饰符，所以默认为&#x27;公共&#x27;(&#x27;public&#x27;)</span></span><br><span class=\"line\">  m = <span class=\"number\">15</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d.<span class=\"property\">m</span>); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-2-3-private\"><a href=\"#8-2-3-private\" class=\"headerlink\" title=\"8.2.3 private\"></a>8.2.3 <code>private</code></h3><p><code>private</code>和<code>protected</code>一样，但不允许从子类中访问该成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Base</span>();</span><br><span class=\"line\"><span class=\"comment\">// 不能从类外访问</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b.<span class=\"property\">x</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-17.png\" alt=\"image-20211130104530638\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Base</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">showX</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不能在子类中访问</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">x</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为私有(<code>private</code>)成员对派生类是不可见的，所以派生类不能增加其可见性。</p>\n<ul>\n<li><strong>跨实例的私有访问</strong></li>\n</ul>\n<p>不同的OOP语言对同一个类的不同实例，是否可以访问对方的私有成员，有不同的处理方法。虽然像Java、C#、C++、Swift和PHP等语言允许这样做，但Ruby不允许。</p>\n<p>TypeScript确实允许跨实例的私有访问：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">sameAs</span>(<span class=\"params\"><span class=\"attr\">other</span>: A</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可以访问</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> other.<span class=\"property\">x</span> === <span class=\"variable language_\">this</span>.<span class=\"property\">x</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>注意事项</strong></li>\n</ul>\n<p>像TypeScript类型系统的其他方面一样，<code>private</code>和<code>protected</code>只在类型检查中被强制执行。</p>\n<p>这意味着JavaScript的运行时结构，如<code>in</code>或简单的属性查询，仍然可以访问一个私有或保护的成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MySafe</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> secretKey = <span class=\"number\">12345</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在JS环境中...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"title class_\">MySafe</span>();</span><br><span class=\"line\"><span class=\"comment\">// 将打印 12345</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"property\">secretKey</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>private</code>也允许在类型检查时使用括号符号进行访问。这使得私有声明的字段可能更容易被单元测试之类的东西所访问，缺点是这些字段是软性私有的，不能严格执行私有特性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MySafe</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> secretKey = <span class=\"number\">12345</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"title class_\">MySafe</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在类型检查期间不允许</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s.<span class=\"property\">secretKey</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s[<span class=\"string\">&quot;secretKey&quot;</span>]);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-19.png\" alt=\"image-20211130135104155\" style=\"zoom:50%;\" />\n\n<p>与TypeScript的 <code>private</code>不同，JavaScript的<code>private</code>字段（#）在编译后仍然是<code>private</code>的，并且不提供前面提到的像括号符号访问那样的转义窗口，使其成为硬<code>private</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  #barkAmount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  personality = <span class=\"string\">&quot;happy&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 0</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.#barkAmount);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dog = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">barkAmount</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-20.png\" alt=\"image-20211130154613004\" style=\"zoom:50%;\" />\n\n<p>当编译到ES2021或更少时，TypeScript将使用WeakMaps来代替 <code>#</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> _Dog_barkAmount;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    _Dog_barkAmount.<span class=\"title function_\">set</span>(<span class=\"variable language_\">this</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">personality</span> = <span class=\"string\">&quot;happy&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_Dog_barkAmount = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakMap</span>();</span><br></pre></td></tr></table></figure>\n\n<p>如果你需要保护你的类中的值免受恶意行为的影响，你应该使用提供硬运行时隐私的机制，如闭包、<code>WeakMaps</code>或私有字段。请注意，这些在运行时增加的隐私检查可能会影响性能。</p>\n<h2 id=\"8-3-静态成员\"><a href=\"#8-3-静态成员\" class=\"headerlink\" title=\"8.3 静态成员\"></a>8.3 静态成员</h2><p>类可以有静态成员。这些成员并不与类的特定实例相关联。它们可以通过类的构造函数对象本身来访问。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">printX</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">MyClass</span>.<span class=\"property\">x</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">MyClass</span>.<span class=\"property\">x</span>);</span><br><span class=\"line\"><span class=\"title class_\">MyClass</span>.<span class=\"title function_\">printX</span>();</span><br></pre></td></tr></table></figure>\n\n<p>静态成员也可以使用相同的<code>public</code>、<code>protected</code>和<code>private</code>可见性修饰符。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">MyClass</span>.<span class=\"property\">x</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-21.png\" alt=\"image-20211130161046623\" style=\"zoom:50%;\" />\n\n<p>静态成员也会被继承。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">getGreeting</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  myGreeting = <span class=\"title class_\">Derived</span>.<span class=\"title function_\">getGreeting</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-1-特殊静态名称\"><a href=\"#8-3-1-特殊静态名称\" class=\"headerlink\" title=\"8.3.1 特殊静态名称\"></a>8.3.1 特殊静态名称</h3><p>一般来说，从函数原型覆盖属性是不安全的&#x2F;不可能的。因为类本身就是可以用<code>new</code>调用的函数，所以某些静态名称不能使用。像<code>name</code>、<code>length</code>和<code>call</code>这样的函数属性，定义为静态成员是无效的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">S</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> name = <span class=\"string\">&quot;S!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-22.png\" alt=\"image-20211203133418242\" style=\"zoom:50%;\" />\n\n<h3 id=\"8-3-2-为什么没有静态类？\"><a href=\"#8-3-2-为什么没有静态类？\" class=\"headerlink\" title=\"8.3.2 为什么没有静态类？\"></a>8.3.2 为什么没有静态类？</h3><p>TypeScript（和JavaScript）没有像C#和Java那样有一个叫做静态类的结构。</p>\n<p>这些结构体的存在，只是因为这些语言强制所有的数据和函数都在一个类里面；因为这个限制在TypeScript中不存在，所以不需要它们。一个只有一个实例的类，在JavaScript&#x2F;TypeScript中通常只是表示为一个普通的对象。</p>\n<p>例如，我们不需要TypeScript中的 “静态类 “语法，因为一个普通的对象（甚至是顶级函数）也可以完成这个工作。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不需要 &quot;static&quot; class</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyStaticClass</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首选 (备选 1)</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首选 (备选 2)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MyHelperObject</span> = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">dosomething</span>(<span class=\"params\"></span>) &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-4-类里的-static-区块\"><a href=\"#8-4-类里的-static-区块\" class=\"headerlink\" title=\"8.4 类里的 static 区块\"></a>8.4 类里的 <code>static </code>区块</h2><p>静态块允许你写一串有自己作用域的语句，可以访问包含类中的私有字段。这意味着我们可以用写语句的所有能力来写初始化代码，不泄露变量，并能完全访问我们类的内部结构。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> #count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">count</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Foo</span>.#count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> lastInstances = &#123;</span><br><span class=\"line\">        <span class=\"attr\">length</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"title class_\">Foo</span>.#count += lastInstances.<span class=\"property\">length</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-5-泛型类\"><a href=\"#8-5-泛型类\" class=\"headerlink\" title=\"8.5 泛型类\"></a>8.5 泛型类</h2><p>类，和接口一样，可以是泛型的。当一个泛型类用new实例化时，其类型参数的推断方式与函数调用的方式相同。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Type</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">contents</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const b: Box&lt;string&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Box</span>(<span class=\"string\">&quot;hello!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>类可以像接口一样使用通用约束和默认值。</p>\n<ul>\n<li>静态成员中的类型参数</li>\n</ul>\n<p>这段代码是不合法的，可能并不明显，为什么呢？</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 静态成员不能引用类的类型参数。</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"attr\">defaultValue</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Box&lt;string&gt;.defaultValue = &#x27;hello&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(Box&lt;number&gt;.defaultValue)</span></span><br></pre></td></tr></table></figure>\n\n<p>请记住，类型总是被完全擦除的! 在运行时，只有一个Box.defaultValue属性。这意味着设置Box<string>.defaultValue（如果有可能的话）也会改变Box<number>.defaultValue，这可不是什么好事。一个泛型类的静态成员永远不能引用该类的类型参数。</p>\n<h2 id=\"8-6-类运行时中的this\"><a href=\"#8-6-类运行时中的this\" class=\"headerlink\" title=\"8.6 类运行时中的this\"></a>8.6 类运行时中的<code>this</code></h2><p>重要的是要记住，TypeScript并没有改变JavaScript的运行时行为，而JavaScript的运行时行为偶尔很奇特。</p>\n<p>比如，JavaScript对这一点的处理确实是不寻常的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;MyClass&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;obj&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">getName</span>: c.<span class=\"property\">getName</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出 &quot;obj&quot;, 而不是 &quot;MyClass&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">getName</span>());</span><br></pre></td></tr></table></figure>\n\n<p>长话短说，默认情况下，函数内this的值取决于函数的调用方式。在这个例子中，因为函数是通过obj引用调用的，所以它的this值是obj而不是类实例。</p>\n<p>这很少是你希望发生的事情! TypeScript提供了一些方法来减轻或防止这种错误。</p>\n<p><strong>1、箭头函数</strong></p>\n<p>如果你有一个经常会被调用的函数，失去了它的 <code>this</code> 上下文，那么使用一个箭头函数而不是方法定义是有意义的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;MyClass&quot;</span>;</span><br><span class=\"line\">  getName = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = c.<span class=\"property\">getName</span>;</span><br><span class=\"line\"><span class=\"comment\">// 输出 &quot;MyClass&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>());</span><br></pre></td></tr></table></figure>\n\n<p>这有一些权衡：</p>\n<ul>\n<li><p><code>this</code> 值保证在运行时是正确的，即使是没有经过TypeScript检查的代码也是如此。</p>\n</li>\n<li><p>这将使用更多的内存，因为每个类实例将有它自己的副本，每个函数都是这样定义的。</p>\n</li>\n<li><p>你不能在派生类中使用<code>super.getName</code>，因为在原型链中没有入口可以获取基类方法。</p>\n</li>\n</ul>\n<p><strong>2、<code>this</code> 参数</strong></p>\n<p>在方法或函数定义中，一个名为<code>this</code>的初始参数在TypeScript中具有特殊的意义。这些参数在编译过程中会被删除。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带有 &quot;this&quot; 参数的 TypeScript 输入</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">SomeType</span>, <span class=\"attr\">x</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译后的JavaScript结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript检查调用带有<code>this</code>参数的函数，是否在正确的上下文中进行。我们可以不使用箭头函数，而是在方法定义中添加一个<code>this</code>参数，以静态地确保方法被正确调用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;MyClass&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">getName</span>(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">MyClass</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\">c.<span class=\"title function_\">getName</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = c.<span class=\"property\">getName</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>());</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-23.png\" alt=\"image-20211210093534818\" style=\"zoom: 67%;\" />\n\n<p>这种方法做出了与箭头函数方法相反的取舍：</p>\n<ul>\n<li>JavaScript调用者仍然可能在不知不觉中错误地使用类方法</li>\n<li>每个类定义只有一个函数被分配，而不是每个类实例一个函数</li>\n<li>基类方法定义仍然可以通过 <code>super</code>调用。</li>\n</ul>\n<h2 id=\"8-7-this类型\"><a href=\"#8-7-this类型\" class=\"headerlink\" title=\"8.7 this类型\"></a>8.7 <code>this</code>类型</h2><p>在类中，一个叫做 <code>this</code>的特殊类型动态地指向当前类的类型。让我们来看看这有什么用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">contents</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// (method) Box.set(value: string): this</span></span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">contents</span> = value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，TypeScript推断出 <code>set</code>的返回类型是<code>this</code>，而不是<code>Box</code>。现在让我们做一个Box的子类：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClearableBox</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clear</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">contents</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">ClearableBox</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const b: ClearableBox</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = a.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-24.png\" alt=\"image-20211210095241472\" style=\"zoom:50%;\" align=\"left\" />\n\n<p>你也可以在参数类型注释中使用 <code>this</code>：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">sameAs</span>(<span class=\"params\"><span class=\"attr\">other</span>: <span class=\"variable language_\">this</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> other.<span class=\"property\">content</span> === <span class=\"variable language_\">this</span>.<span class=\"property\">content</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> box = <span class=\"keyword\">new</span> <span class=\"title class_\">Box</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(box.<span class=\"title function_\">sameAs</span>(box));</span><br></pre></td></tr></table></figure>\n\n<p>这与其他写法不同：Box，如果你有一个派生类，它的 <code>sameAs</code> 方法现在只接受该同一派生类的其他实例。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"title function_\">sameAs</span>(<span class=\"params\"><span class=\"attr\">other</span>: <span class=\"variable language_\">this</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> other.<span class=\"property\">content</span> === <span class=\"variable language_\">this</span>.<span class=\"property\">content</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DerivedBox</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">otherContent</span>: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;?&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> base = <span class=\"keyword\">new</span> <span class=\"title class_\">Box</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> derived = <span class=\"keyword\">new</span> <span class=\"title class_\">DerivedBox</span>();</span><br><span class=\"line\">derived.<span class=\"title function_\">sameAs</span>(base);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/09-25.png\" alt=\"image-20211210102234118\" style=\"zoom:50%;\" />\n\n<h2 id=\"8-8-基于类型守卫的this\"><a href=\"#8-8-基于类型守卫的this\" class=\"headerlink\" title=\"8.8 基于类型守卫的this\"></a>8.8 基于类型守卫的<code>this</code></h2><p>你可以在类和接口的方法的返回位置使用 <code>this is Type</code> 。当与类型缩小混合时（例如if语句），目标对象的类型将被缩小到指定的Type。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSystemObject</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isFile</span>(): <span class=\"variable language_\">this</span> is <span class=\"title class_\">FileRep</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">FileRep</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">isDirectory</span>(): <span class=\"variable language_\">this</span> is <span class=\"title class_\">Directory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Directory</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">isNetworked</span>(): <span class=\"variable language_\">this</span> is <span class=\"title class_\">Networked</span> &amp; <span class=\"variable language_\">this</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">networked</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"attr\">path</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"attr\">networked</span>: <span class=\"built_in\">boolean</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileRep</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">FileSystemObject</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">path</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(path, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Directory</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">FileSystemObject</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">children</span>: <span class=\"title class_\">FileSystemObject</span>[];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Networked</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">host</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">fso</span>: <span class=\"title class_\">FileSystemObject</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">FileRep</span>(<span class=\"string\">&quot;foo/bar.txt&quot;</span>, <span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (fso.<span class=\"title function_\">isFile</span>()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// const fso: FileRep</span></span><br><span class=\"line\">  fso.<span class=\"property\">content</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fso.<span class=\"title function_\">isDirectory</span>()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// const fso: Directory</span></span><br><span class=\"line\">  fso.<span class=\"property\">children</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fso.<span class=\"title function_\">isNetworked</span>()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// const fso: Networked &amp; FileSystemObject</span></span><br><span class=\"line\">  fso.<span class=\"property\">host</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基于 <code>this</code> 的类型保护的一个常见用例，是允许对一个特定字段进行懒惰验证。例如，这种情况下，当 <code>hasValue</code>被验证为真时，就会从框内持有的值中删除一个未定义值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>?: T;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">hasValue</span>(): <span class=\"variable language_\">this</span> is &#123; <span class=\"attr\">value</span>: T &#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> box = <span class=\"keyword\">new</span> <span class=\"title class_\">Box</span>();</span><br><span class=\"line\">box.<span class=\"property\">value</span> = <span class=\"string\">&quot;Gameboy&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (property) Box&lt;unknown&gt;.value?: unknownbox.value;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (box.<span class=\"title function_\">hasValue</span>()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// (property) value: unknown</span></span><br><span class=\"line\">  box.<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-9-参数属性\"><a href=\"#8-9-参数属性\" class=\"headerlink\" title=\"8.9 参数属性\"></a>8.9 参数属性</h2><p>TypeScript提供了特殊的语法，可以将构造函数参数变成具有相同名称和值的类属性。这些被称为参数属性，通过在构造函数参数前加上可见性修饰符 <code>public</code>、<code>private</code>、<code>protected</code>或<code>readonly</code>中的一个来创建。由此产生的字段会得到这些修饰符。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Params</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"keyword\">readonly</span> <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">protected</span> <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">private</span> <span class=\"attr\">z</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// No body necessary</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Params</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (property) Params.x: number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a.<span class=\"property\">x</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a.<span class=\"property\">z</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-01.png\" alt=\"image-20211214162348578\" style=\"zoom: 60%;\" />\n\n<h2 id=\"8-10-类表达式\"><a href=\"#8-10-类表达式\" class=\"headerlink\" title=\"8.10 类表达式\"></a>8.10 类表达式</h2><p>类表达式与类声明非常相似。唯一真正的区别是，类表达式不需要一个名字，尽管我们可以通过它们最终绑定的任何标识符来引用它们。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> someClass = <span class=\"keyword\">class</span>&lt;<span class=\"title class_\">Type</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"title class_\">Type</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Type</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">content</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const m: someClass&lt;string&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"title function_\">someClass</span>(<span class=\"string\">&quot;Hello, world&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-11-抽象类和成员\"><a href=\"#8-11-抽象类和成员\" class=\"headerlink\" title=\"8.11 抽象类和成员\"></a>8.11 抽象类和成员</h2><p>TypeScript中的类、方法和字段可以是抽象的。</p>\n<p>一个抽象的方法或抽象的字段是一个没有提供实现的方法或字段。这些成员必须存在于一个抽象类中，不能直接实例化。</p>\n<p>抽象类的作用是作为子类的基类，实现所有的抽象成员。当一个类没有任何抽象成员时，我们就说它是具体的。</p>\n<p>让我们看一个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"title function_\">getName</span>(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"title function_\">printName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"title function_\">getName</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Base</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-02.png\" alt=\"image-20211219063509036\" style=\"zoom:60%;\" />\n\n<p>我们不能用 <code>new</code>来实例化<code>Base</code>，因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Derived</span>();</span><br><span class=\"line\">d.<span class=\"title function_\">printName</span>();</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-03.png\" alt=\"image-20211219064030984\" style=\"zoom:60%;\" />\n\n<ul>\n<li><strong>抽象构造签名</strong></li>\n</ul>\n<p>有时你想接受一些类的构造函数，产生一个从某些抽象类派生出来的类的实例。</p>\n<p>例如，你可能想写这样的代码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">ctor</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Base</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> <span class=\"title function_\">ctor</span>();</span><br><span class=\"line\">  instance.<span class=\"title function_\">printName</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-04.png\" alt=\"image-20211219064506944\" style=\"zoom:67%;\" />\n\n<p>TypeScript正确地告诉你，你正试图实例化一个抽象类。毕竟，鉴于greet的定义，写这段代码是完全合法的，它最终会构造一个抽象类。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 槽糕</span></span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"title class_\">Base</span>);</span><br></pre></td></tr></table></figure>\n\n<p>相反，你想写一个函数，接受具有结构化签名的东西：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">ctor</span>: <span class=\"keyword\">new</span> () =&gt; <span class=\"title class_\">Base</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> <span class=\"title function_\">ctor</span>();</span><br><span class=\"line\">  instance.<span class=\"title function_\">printName</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"title class_\">Derived</span>);</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"title class_\">Base</span>);</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/10-05.png\" alt=\"image-20211219065154437\" style=\"zoom:67%;\" />\n\n<p>现在TypeScript正确地告诉你哪些类的构造函数可以被调用：<code>Derived</code>可以，因为它是具体的，但<code>Base</code>不能。</p>\n<h2 id=\"8-12-类之间的关系\"><a href=\"#8-12-类之间的关系\" class=\"headerlink\" title=\"8.12 类之间的关系\"></a>8.12 类之间的关系</h2><p>在大多数情况下，TypeScript中的类在结构上与其他类型相同，是可以比较的。</p>\n<p>例如，这两个类可以互相替代使用，因为它们是相同的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point1</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point2</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p</span>: <span class=\"title class_\">Point1</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Point2</span>();</span><br></pre></td></tr></table></figure>\n\n<p>同样地，即使没有明确的继承，类之间的子类型关系也是存在的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">salary</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">p</span>: <span class=\"title class_\">Person</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Employee</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这听起来很简单，但有几种情况似乎比其他情况更奇怪。</p>\n<p>空的类没有成员。在一个结构化类型系统中，一个没有成员的类型通常是其他任何东西的超类型。所以如果你写了一个空类（不要！），任何东西都可以用来代替它。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Empty</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"title class_\">Empty</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不能用&#x27;x&#x27;做任何事</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下调用均可</span></span><br><span class=\"line\">!<span class=\"title function_\">fn</span>(<span class=\"variable language_\">window</span>);</span><br><span class=\"line\"><span class=\"title function_\">fn</span>(&#123;&#125;);</span><br><span class=\"line\"><span class=\"title function_\">fn</span>(fn);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-2、高级篇：类型推断",
        "toc": true,
        "abbrlink": 48617,
        "date": "2024-01-28T11:56:33.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_02.jpeg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 二、类型推断\n\n在TypeScript中，有几个地方在没有显式类型注释的情况下，使用类型推理来提供类型信息。例如，在这段代码中：\n\n```tsx\n// let x: number\nlet x = 3;\n```\n\n`x` 变量的类型被推断为 `number`。这种推断发生在初始化变量和成员、设置参数默认值和确定函数返回类型时。\n\n在大多数情况下，类型推断是直截了当的。在下面的章节中，我们将探讨类型推断的一些细微差别。\n\n## 2.1 最佳公共类型\n\n当从几个表达式中进行类型推断时，这些表达式的类型被用来计算一个 \"最佳公共类型\"。比如说：\n\n```tsx\n// let x: (number | null)[]\nlet x = [0, 1, null];\n```\n\n为了推断上面例子中 `x` 的类型，我们必须考虑每个数组元素的类型。这里我们得到了两个数组类型的选择：`number`和 `null`。最佳公共类型算法考虑了每个候选类型，并选择了与所有其他候选类型兼容的类型。\n\n因为最佳公共类型必须从所提供的候选类型中选择，所以在某些情况下，类型有共同的结构，但没有一个类型是所有候选类型的超级类型。比如说：\n\n```tsx\n// let zoo: (Rhino | Elephant | Snake)[]\n\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n```\n\n理想情况下，我们可能希望 `zoo` 被推断为 `Animal[]`，但是因为数组中没有严格意义上的 `Animal` 类型的对象，所以我们没有对数组元素类型进行推断。为了纠正这一点，当没有一个类型是所有其他候选类型的超级类型时，就明确地提供类型。\n\n```tsx\n// let zoo: Animal[]t\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n```\n\n当没有找到最好的共同类型时，产生的推论是联合数组类型，`(Rhino | Elephant | Snake)[]`。\n\n## 2.2 上下文类型\n\n在TypeScript的某些情况下，类型推理也在 \"另一个方向 \"发挥作用。这被称为 \"上下文类型化\"。当表达式的类型被它的位置所暗示时，上下文类型就发生了。比如说：\n\n```tsx\nwindow.onmousedown = function (mouseEvent) {\n  console.log(mouseEvent.button);\n  console.log(mouseEvent.kangaroo); // Ⓧ 在'MouseEvent'类型上不存在'kangaroo'属性。\n};\n```\n\n在这里，TypeScript 类型检查器使用 `window.onmousedown` 函数的类型来推断赋值右侧的函数表达式的类型。当它这样做时，它能够推断出`mouseEvent`参数的类型，它确实包含一个按钮属性，但不包含袋鼠属性。\n\n这样做的原因是`window`已经在其类型中声明了`onmousedown`。\n\n```tsx\n// 声明有一个名为'window'的全局变量\ndeclare var window: Window & typeof globalThis;\n\n// 这被声明为（简化版）。\ninterface Window extends GlobalEventHandlers {\n  // ...\n}\n\n// 其中定义了很多已知的处理程序事件\ninterface GlobalEventHandlers {\n  onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n  // ...\n}\n```\n\nTypeScript足够聪明，在其他情况下也能推断出类型：\n\n```tsx\nwindow.onscroll = function (uiEvent) {\n  // Ⓧ 属性 \"button\" 不存在于 \"Event\"类型上。\n  console.log(uiEvent.button);\n};\n```\n\n基于上述函数被分配给`Window.onscroll`的事实，TypeScript知道`uiEvent`是一个`UIEvent`，而不是像前面的例子那样是`MouseEvent`。`UIEvent`对象不包含按钮属性，所以TypeScript会抛出一个错误。\n\n如果这个函数不在上下文类型的位置，这个函数的参数将隐含有类型`any`，并且不会发出错误（除非你使用`noImplicitAny`选项）。\n\n```tsx\nconst handler = function (uiEvent) {\n  console.log(uiEvent.button); // <- 正确\n};\n```\n\n我们也可以明确地给函数的参数提供类型信息，以覆盖任何上下文的类型。\n\n```tsx\nwindow.onscroll = function (uiEvent: any) {\n  console.log(uiEvent.button); // <- 现在也没有错误\n};\n```\n\n然而，这段代码将记录 `undefined` 的内容，因为 `uiEvent` 没有名为按钮的属性。\n\n上下文类型化在很多情况下都适用。常见的情况包括函数调用的参数、赋值的右侧、类型断言、对象和数组字面量的成员，以及返回语句。上下文类型也作为最佳普通类型的候选类型。比如说：\n\n```tsx\nfunction createZoo(): Animal[] {\n  return [new Rhino(), new Elephant(), new Snake()];\n}\n```\n\n在这个例子中，最佳普通类型有一组四个候选者。`Animal`, `Rhino`, `Elephant`和 `Snake`。其中，`Animal` 可以被最佳共同类型算法所选择。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-2、高级篇：类型推断.md",
        "raw": "---\ntitle: 2-2、高级篇：类型推断\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 48617\ndate: 2024-01-28 19:56:33\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 二、类型推断\n\n在TypeScript中，有几个地方在没有显式类型注释的情况下，使用类型推理来提供类型信息。例如，在这段代码中：\n\n```tsx\n// let x: number\nlet x = 3;\n```\n\n`x` 变量的类型被推断为 `number`。这种推断发生在初始化变量和成员、设置参数默认值和确定函数返回类型时。\n\n在大多数情况下，类型推断是直截了当的。在下面的章节中，我们将探讨类型推断的一些细微差别。\n\n## 2.1 最佳公共类型\n\n当从几个表达式中进行类型推断时，这些表达式的类型被用来计算一个 \"最佳公共类型\"。比如说：\n\n```tsx\n// let x: (number | null)[]\nlet x = [0, 1, null];\n```\n\n为了推断上面例子中 `x` 的类型，我们必须考虑每个数组元素的类型。这里我们得到了两个数组类型的选择：`number`和 `null`。最佳公共类型算法考虑了每个候选类型，并选择了与所有其他候选类型兼容的类型。\n\n因为最佳公共类型必须从所提供的候选类型中选择，所以在某些情况下，类型有共同的结构，但没有一个类型是所有候选类型的超级类型。比如说：\n\n```tsx\n// let zoo: (Rhino | Elephant | Snake)[]\n\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n```\n\n理想情况下，我们可能希望 `zoo` 被推断为 `Animal[]`，但是因为数组中没有严格意义上的 `Animal` 类型的对象，所以我们没有对数组元素类型进行推断。为了纠正这一点，当没有一个类型是所有其他候选类型的超级类型时，就明确地提供类型。\n\n```tsx\n// let zoo: Animal[]t\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n```\n\n当没有找到最好的共同类型时，产生的推论是联合数组类型，`(Rhino | Elephant | Snake)[]`。\n\n## 2.2 上下文类型\n\n在TypeScript的某些情况下，类型推理也在 \"另一个方向 \"发挥作用。这被称为 \"上下文类型化\"。当表达式的类型被它的位置所暗示时，上下文类型就发生了。比如说：\n\n```tsx\nwindow.onmousedown = function (mouseEvent) {\n  console.log(mouseEvent.button);\n  console.log(mouseEvent.kangaroo); // Ⓧ 在'MouseEvent'类型上不存在'kangaroo'属性。\n};\n```\n\n在这里，TypeScript 类型检查器使用 `window.onmousedown` 函数的类型来推断赋值右侧的函数表达式的类型。当它这样做时，它能够推断出`mouseEvent`参数的类型，它确实包含一个按钮属性，但不包含袋鼠属性。\n\n这样做的原因是`window`已经在其类型中声明了`onmousedown`。\n\n```tsx\n// 声明有一个名为'window'的全局变量\ndeclare var window: Window & typeof globalThis;\n\n// 这被声明为（简化版）。\ninterface Window extends GlobalEventHandlers {\n  // ...\n}\n\n// 其中定义了很多已知的处理程序事件\ninterface GlobalEventHandlers {\n  onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n  // ...\n}\n```\n\nTypeScript足够聪明，在其他情况下也能推断出类型：\n\n```tsx\nwindow.onscroll = function (uiEvent) {\n  // Ⓧ 属性 \"button\" 不存在于 \"Event\"类型上。\n  console.log(uiEvent.button);\n};\n```\n\n基于上述函数被分配给`Window.onscroll`的事实，TypeScript知道`uiEvent`是一个`UIEvent`，而不是像前面的例子那样是`MouseEvent`。`UIEvent`对象不包含按钮属性，所以TypeScript会抛出一个错误。\n\n如果这个函数不在上下文类型的位置，这个函数的参数将隐含有类型`any`，并且不会发出错误（除非你使用`noImplicitAny`选项）。\n\n```tsx\nconst handler = function (uiEvent) {\n  console.log(uiEvent.button); // <- 正确\n};\n```\n\n我们也可以明确地给函数的参数提供类型信息，以覆盖任何上下文的类型。\n\n```tsx\nwindow.onscroll = function (uiEvent: any) {\n  console.log(uiEvent.button); // <- 现在也没有错误\n};\n```\n\n然而，这段代码将记录 `undefined` 的内容，因为 `uiEvent` 没有名为按钮的属性。\n\n上下文类型化在很多情况下都适用。常见的情况包括函数调用的参数、赋值的右侧、类型断言、对象和数组字面量的成员，以及返回语句。上下文类型也作为最佳普通类型的候选类型。比如说：\n\n```tsx\nfunction createZoo(): Animal[] {\n  return [new Rhino(), new Elephant(), new Snake()];\n}\n```\n\n在这个例子中，最佳普通类型有一组四个候选者。`Animal`, `Rhino`, `Elephant`和 `Snake`。其中，`Animal` 可以被最佳共同类型算法所选择。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-2、高级篇：类型推断",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao5001394v30prr82sy",
        "content": "<h1 id=\"二、类型推断\"><a href=\"#二、类型推断\" class=\"headerlink\" title=\"二、类型推断\"></a>二、类型推断</h1><p>在TypeScript中，有几个地方在没有显式类型注释的情况下，使用类型推理来提供类型信息。例如，在这段代码中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>x</code> 变量的类型被推断为 <code>number</code>。这种推断发生在初始化变量和成员、设置参数默认值和确定函数返回类型时。</p>\n<p>在大多数情况下，类型推断是直截了当的。在下面的章节中，我们将探讨类型推断的一些细微差别。</p>\n<h2 id=\"2-1-最佳公共类型\"><a href=\"#2-1-最佳公共类型\" class=\"headerlink\" title=\"2.1 最佳公共类型\"></a>2.1 最佳公共类型</h2><p>当从几个表达式中进行类型推断时，这些表达式的类型被用来计算一个 “最佳公共类型”。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let x: (number | null)[]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">null</span>];</span><br></pre></td></tr></table></figure>\n\n<p>为了推断上面例子中 <code>x</code> 的类型，我们必须考虑每个数组元素的类型。这里我们得到了两个数组类型的选择：<code>number</code>和 <code>null</code>。最佳公共类型算法考虑了每个候选类型，并选择了与所有其他候选类型兼容的类型。</p>\n<p>因为最佳公共类型必须从所提供的候选类型中选择，所以在某些情况下，类型有共同的结构，但没有一个类型是所有候选类型的超级类型。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let zoo: (Rhino | Elephant | Snake)[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = [<span class=\"keyword\">new</span> <span class=\"title class_\">Rhino</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Elephant</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Snake</span>()];</span><br></pre></td></tr></table></figure>\n\n<p>理想情况下，我们可能希望 <code>zoo</code> 被推断为 <code>Animal[]</code>，但是因为数组中没有严格意义上的 <code>Animal</code> 类型的对象，所以我们没有对数组元素类型进行推断。为了纠正这一点，当没有一个类型是所有其他候选类型的超级类型时，就明确地提供类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let zoo: Animal[]t</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">zoo</span>: <span class=\"title class_\">Animal</span>[] = [<span class=\"keyword\">new</span> <span class=\"title class_\">Rhino</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Elephant</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Snake</span>()];</span><br></pre></td></tr></table></figure>\n\n<p>当没有找到最好的共同类型时，产生的推论是联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p>\n<h2 id=\"2-2-上下文类型\"><a href=\"#2-2-上下文类型\" class=\"headerlink\" title=\"2.2 上下文类型\"></a>2.2 上下文类型</h2><p>在TypeScript的某些情况下，类型推理也在 “另一个方向 “发挥作用。这被称为 “上下文类型化”。当表达式的类型被它的位置所暗示时，上下文类型就发生了。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onmousedown</span> = <span class=\"keyword\">function</span> (<span class=\"params\">mouseEvent</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mouseEvent.<span class=\"property\">button</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mouseEvent.<span class=\"property\">kangaroo</span>); <span class=\"comment\">// Ⓧ 在&#x27;MouseEvent&#x27;类型上不存在&#x27;kangaroo&#x27;属性。</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断赋值右侧的函数表达式的类型。当它这样做时，它能够推断出<code>mouseEvent</code>参数的类型，它确实包含一个按钮属性，但不包含袋鼠属性。</p>\n<p>这样做的原因是<code>window</code>已经在其类型中声明了<code>onmousedown</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明有一个名为&#x27;window&#x27;的全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"attr\">window</span>: <span class=\"title class_\">Window</span> &amp; <span class=\"keyword\">typeof</span> globalThis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这被声明为（简化版）。</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Window</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">GlobalEventHandlers</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中定义了很多已知的处理程序事件</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">GlobalEventHandlers</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">onmousedown</span>: (<span class=\"function\">(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">GlobalEventHandlers</span>, <span class=\"attr\">ev</span>: <span class=\"title class_\">MouseEvent</span></span>) =&gt;</span> <span class=\"built_in\">any</span>) | <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript足够聪明，在其他情况下也能推断出类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onscroll</span> = <span class=\"keyword\">function</span> (<span class=\"params\">uiEvent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Ⓧ 属性 &quot;button&quot; 不存在于 &quot;Event&quot;类型上。</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(uiEvent.<span class=\"property\">button</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>基于上述函数被分配给<code>Window.onscroll</code>的事实，TypeScript知道<code>uiEvent</code>是一个<code>UIEvent</code>，而不是像前面的例子那样是<code>MouseEvent</code>。<code>UIEvent</code>对象不包含按钮属性，所以TypeScript会抛出一个错误。</p>\n<p>如果这个函数不在上下文类型的位置，这个函数的参数将隐含有类型<code>any</code>，并且不会发出错误（除非你使用<code>noImplicitAny</code>选项）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handler = <span class=\"keyword\">function</span> (<span class=\"params\">uiEvent</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(uiEvent.<span class=\"property\">button</span>); <span class=\"comment\">// &lt;- 正确</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以明确地给函数的参数提供类型信息，以覆盖任何上下文的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onscroll</span> = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"attr\">uiEvent</span>: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(uiEvent.<span class=\"property\">button</span>); <span class=\"comment\">// &lt;- 现在也没有错误</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然而，这段代码将记录 <code>undefined</code> 的内容，因为 <code>uiEvent</code> 没有名为按钮的属性。</p>\n<p>上下文类型化在很多情况下都适用。常见的情况包括函数调用的参数、赋值的右侧、类型断言、对象和数组字面量的成员，以及返回语句。上下文类型也作为最佳普通类型的候选类型。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createZoo</span>(<span class=\"params\"></span>): <span class=\"title class_\">Animal</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">new</span> <span class=\"title class_\">Rhino</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Elephant</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Snake</span>()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，最佳普通类型有一组四个候选者。<code>Animal</code>, <code>Rhino</code>, <code>Elephant</code>和 <code>Snake</code>。其中，<code>Animal</code> 可以被最佳共同类型算法所选择。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"二、类型推断\"><a href=\"#二、类型推断\" class=\"headerlink\" title=\"二、类型推断\"></a>二、类型推断</h1><p>在TypeScript中，有几个地方在没有显式类型注释的情况下，使用类型推理来提供类型信息。例如，在这段代码中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let x: number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>x</code> 变量的类型被推断为 <code>number</code>。这种推断发生在初始化变量和成员、设置参数默认值和确定函数返回类型时。</p>\n<p>在大多数情况下，类型推断是直截了当的。在下面的章节中，我们将探讨类型推断的一些细微差别。</p>\n<h2 id=\"2-1-最佳公共类型\"><a href=\"#2-1-最佳公共类型\" class=\"headerlink\" title=\"2.1 最佳公共类型\"></a>2.1 最佳公共类型</h2><p>当从几个表达式中进行类型推断时，这些表达式的类型被用来计算一个 “最佳公共类型”。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let x: (number | null)[]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">null</span>];</span><br></pre></td></tr></table></figure>\n\n<p>为了推断上面例子中 <code>x</code> 的类型，我们必须考虑每个数组元素的类型。这里我们得到了两个数组类型的选择：<code>number</code>和 <code>null</code>。最佳公共类型算法考虑了每个候选类型，并选择了与所有其他候选类型兼容的类型。</p>\n<p>因为最佳公共类型必须从所提供的候选类型中选择，所以在某些情况下，类型有共同的结构，但没有一个类型是所有候选类型的超级类型。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let zoo: (Rhino | Elephant | Snake)[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = [<span class=\"keyword\">new</span> <span class=\"title class_\">Rhino</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Elephant</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Snake</span>()];</span><br></pre></td></tr></table></figure>\n\n<p>理想情况下，我们可能希望 <code>zoo</code> 被推断为 <code>Animal[]</code>，但是因为数组中没有严格意义上的 <code>Animal</code> 类型的对象，所以我们没有对数组元素类型进行推断。为了纠正这一点，当没有一个类型是所有其他候选类型的超级类型时，就明确地提供类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// let zoo: Animal[]t</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">zoo</span>: <span class=\"title class_\">Animal</span>[] = [<span class=\"keyword\">new</span> <span class=\"title class_\">Rhino</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Elephant</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Snake</span>()];</span><br></pre></td></tr></table></figure>\n\n<p>当没有找到最好的共同类型时，产生的推论是联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p>\n<h2 id=\"2-2-上下文类型\"><a href=\"#2-2-上下文类型\" class=\"headerlink\" title=\"2.2 上下文类型\"></a>2.2 上下文类型</h2><p>在TypeScript的某些情况下，类型推理也在 “另一个方向 “发挥作用。这被称为 “上下文类型化”。当表达式的类型被它的位置所暗示时，上下文类型就发生了。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onmousedown</span> = <span class=\"keyword\">function</span> (<span class=\"params\">mouseEvent</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mouseEvent.<span class=\"property\">button</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mouseEvent.<span class=\"property\">kangaroo</span>); <span class=\"comment\">// Ⓧ 在&#x27;MouseEvent&#x27;类型上不存在&#x27;kangaroo&#x27;属性。</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断赋值右侧的函数表达式的类型。当它这样做时，它能够推断出<code>mouseEvent</code>参数的类型，它确实包含一个按钮属性，但不包含袋鼠属性。</p>\n<p>这样做的原因是<code>window</code>已经在其类型中声明了<code>onmousedown</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明有一个名为&#x27;window&#x27;的全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"attr\">window</span>: <span class=\"title class_\">Window</span> &amp; <span class=\"keyword\">typeof</span> globalThis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这被声明为（简化版）。</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Window</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">GlobalEventHandlers</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中定义了很多已知的处理程序事件</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">GlobalEventHandlers</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">onmousedown</span>: (<span class=\"function\">(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">GlobalEventHandlers</span>, <span class=\"attr\">ev</span>: <span class=\"title class_\">MouseEvent</span></span>) =&gt;</span> <span class=\"built_in\">any</span>) | <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript足够聪明，在其他情况下也能推断出类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onscroll</span> = <span class=\"keyword\">function</span> (<span class=\"params\">uiEvent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Ⓧ 属性 &quot;button&quot; 不存在于 &quot;Event&quot;类型上。</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(uiEvent.<span class=\"property\">button</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>基于上述函数被分配给<code>Window.onscroll</code>的事实，TypeScript知道<code>uiEvent</code>是一个<code>UIEvent</code>，而不是像前面的例子那样是<code>MouseEvent</code>。<code>UIEvent</code>对象不包含按钮属性，所以TypeScript会抛出一个错误。</p>\n<p>如果这个函数不在上下文类型的位置，这个函数的参数将隐含有类型<code>any</code>，并且不会发出错误（除非你使用<code>noImplicitAny</code>选项）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handler = <span class=\"keyword\">function</span> (<span class=\"params\">uiEvent</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(uiEvent.<span class=\"property\">button</span>); <span class=\"comment\">// &lt;- 正确</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以明确地给函数的参数提供类型信息，以覆盖任何上下文的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onscroll</span> = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"attr\">uiEvent</span>: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(uiEvent.<span class=\"property\">button</span>); <span class=\"comment\">// &lt;- 现在也没有错误</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然而，这段代码将记录 <code>undefined</code> 的内容，因为 <code>uiEvent</code> 没有名为按钮的属性。</p>\n<p>上下文类型化在很多情况下都适用。常见的情况包括函数调用的参数、赋值的右侧、类型断言、对象和数组字面量的成员，以及返回语句。上下文类型也作为最佳普通类型的候选类型。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createZoo</span>(<span class=\"params\"></span>): <span class=\"title class_\">Animal</span>[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">new</span> <span class=\"title class_\">Rhino</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Elephant</span>(), <span class=\"keyword\">new</span> <span class=\"title class_\">Snake</span>()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，最佳普通类型有一组四个候选者。<code>Animal</code>, <code>Rhino</code>, <code>Elephant</code>和 <code>Snake</code>。其中，<code>Animal</code> 可以被最佳共同类型算法所选择。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-1、高级篇：变量声明",
        "toc": true,
        "abbrlink": 48402,
        "date": "2024-01-28T11:53:37.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_02.jpeg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 一、变量声明\n\n`let`和`const`是JavaScript中变量声明的两个相对较新的概念。正如我们前面提到的，`let`在某些方面与`var`相似，但允许用户避免在JavaScript中遇到的一些常见的 \"麻烦\"。\n\n`const`是`let`的一个扩展，它可以防止重新赋值给一个变量。\n\n由于TypeScript是JavaScript的扩展，该语言自然支持`let`和`const`。在这里，我们将进一步阐述这些新的声明，以及为什么它们比`var`更适合。\n\n如果你已经不经意地使用了JavaScript，那么下一节可能是刷新你记忆的一个好方法。如果你对JavaScript中`var`声明的所有怪癖非常熟悉，你可能会发现跳过前面会更容易。\n\n## 1.1 var 变量声明\n\n在JavaScript中声明一个变量，传统上都是用`var`关键字来完成。\n\n```tsx\nvar a = 10;\n```\n\n正如你可能已经发现的，我们刚刚声明了一个名为`a`的变量，其值为`10`。\n\n我们也可以在一个函数中声明一个变量：\n\n```tsx\nfunction f() {\n  var message = \"Hello, world!\";\n  return message;\n}\n```\n\n而我们也可以在其他函数中访问这些相同的变量：\n\n```tsx\nfunction f() {\n  var a = 10;\n  return function g() {\n    var b = a + 1;\n    return b;\n  };\n}\nvar g = f();\ng(); // returns '11'\n```\n\n在上面这个例子中，`g`捕获了`f`中声明的变量`a`。在`g`被调用的任何时候，`a`的值都将与`f`中`a`的值相联系。\n\n```tsx\nfunction f() {\n  var a = 1;\n  a = 2;\n  var b = g();\n  a = 3;\n  return b;\n  function g() {\n    return a;\n  }\n}\nf(); // returns '2'\n```\n\n## 1.2 作用域规则\n\n对于那些习惯于其他语言的人来说，`var`声明有一些奇怪的作用域范围规则。以下面的例子为例：\n\n```tsx\nfunction f(shouldInitialize: boolean) {\n  if (shouldInitialize) {\n    var x = 10;\n  }\n  return x;\n}\nf(true); // 返回 '10'\nf(false); // 返回 'undefined'\n```\n\n有些读者可能会对这个例子产生怀疑。变量`x`是在`if`块中声明的，但我们却能从该块之外访问它。这是因为`var`声明可以在其包含的函数、模块、命名空间或全局范围内的任何地方访问（所有这些我们将在后面讨论），而不考虑包含的块。有些人把这称为`var`作用域或函数作用域。参数也是函数作用域。\n\n这些作用域规则会导致几种类型的错误。它们加剧的一个问题是，多次声明同一个变量并不是一个错误。\n\n```tsx\nfunction sumMatrix(matrix: number[][]) {\n  var sum = 0;\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n```\n\n也许对于一些有经验的JavaScript开发者来说，这很容易被发现，但是内部`for-loop`会意外地覆盖变量`i`，因为`i`指的是同一个函数范围的变量。正如有经验的开发者现在所知道的，类似的各种bug会在代码审查中溜走，并会成为无尽的挫折来源。\n\n## 1.3 变量捕获的怪癖\n\n花点时间猜一猜下面这段话的输出是什么：\n\n```tsx\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\n对于那些不熟悉的人来说，`setTimeout`将尝试在一定数量的毫秒后执行一个函数（尽管要等待其他东西停止运行）。\n\n准备好了吗？看看吧。\n\n```shell\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\n许多JavaScript开发人员对这种行为非常熟悉，但如果你感到惊讶，你肯定不是一个人。大多数人都希望输出的结果是：\n\n```shell\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n还记得我们前面提到的关于变量捕获的问题吗？我们传递给`setTimeout`的每个函数表达式实际上都是指同一范围内的同一个`i`。\n\n让我们花点时间考虑一下这意味着什么。 `setTimeout`将在若干毫秒之后运行一个函数，但只有在`for`循环停止执行之后；当`for`循环停止执行时，`i`的值是`10`。因此，每次给定的函数被调用时，它将打印出`10`!\n\n一个常见的解决方法是使用IIFE--一个立即调用的函数表达式--来捕获每次迭代的`i`。\n\n```tsx\nfor (var i = 0; i < 10; i++) {\n  // 通过调用一个带有其当前值的函数\n  // 捕捉'i'的当前状态\n  (function (i) {\n    setTimeout(function () {\n      console.log(i);\n    }, 100 * i);\n  })(i);\n}\n```\n\n这种看起来很奇怪的模式其实是很常见的。参数列表中的 `i` 实际上是对 `for` 循环中声明的 `i` 的影子，但由于我们对它们的命名相同，所以我们不必对循环体进行过多的修改。\n\n## 1.4 let 变量声明\n\n现在你已经发现`var`有一些问题，这正是`let`语句被引入的原因。除了使用的关键字外，`let`语句的写法与`var`语句相同。\n\n```tsx\nlet hello = \"Hello!\";\n```\n\n关键的区别不在语法上，而在语义上，我们现在要深入研究。\n\n## 1.5 块级作用域\n\n当一个变量使用`let`声明时，它使用了一些人所说的词法范围或块法范围。与用`var`声明的变量不同，`block-scope`变量的作用域会泄露给其包含的函数，而在其最近的包含块或`for-loop`之外是不可见的。\n\n```tsx\nfunction f(input: boolean) {\n  let a = 100;\n  if (input) {\n    // 引用'a'仍然可以\n    let b = a + 1;\n    return b;\n  }\n  // 错误：这里不存在'b'。\n  return b;\n}\n```\n\n在这里，我们有两个局部变量`a`和`b`。`a`的作用域仅限于`f`的主体，而`b`的作用域仅限于包含`if`语句的块。\n\n在`catch`子句中声明的变量也有类似的作用域规则。\n\n```tsx\ntry {\n  throw \"oh no!\";\n} catch (e) {\n  console.log(\"Oh well.\");\n}\n// Error: 这里不存在'e'。\nconsole.log(e);\n```\n\n块级作用域变量的另一个属性是，在它们被实际声明之前，它们不能被读或写到。虽然这些变量在它们的整个作用域中都是 \"存在 \"的，但是直到它们被声明之前的所有点都是它们的时间死角的一部分。这只是一种复杂的说法，你不能在`let`语句之前访问它们，幸运的是TypeScript会让你知道这一点。\n\n```tsx\na++; // 在声明之前使用'a'是非法的。\nlet a;\n```\n\n需要注意的是，你仍然可以在声明之前*捕获*一个块范围的变量。唯一的问题是，在声明之前调用该函数是非法的。如果以ES2015为目标，现代运行时将抛出一个错误；然而，现在TypeScript是允许的，不会将此作为一个错误报告。\n\n```tsx\nfunction foo() {\n  // 可以捕捉到 \"a\"。\n  return a;\n}\n// 在声明'a'之前非法调用'foo'。\n// runtimes应该在这里抛出一个错误\nfoo();\nlet a;\n```\n\nFor more information on temporal dead zones, see relevant content on the [Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).\n\n关于时空死角的更多信息，请看 [Mozilla开发者网络](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)上的相关内容。\n\n## 1.6 重复声明和投影\n\n对于var声明，我们提到，你声明了多少次变量并不重要，你只是得到了一个。\n\n```tsx\nfunction f(x) {\n  var x;\n  var x;\n  if (true) {\n    var x;\n  }\n}\n```\n\n在上面的例子中，所有关于`x`的声明实际上指的是同一个`x`，这是完全有效的。这往往会成为错误的根源。值得庆幸的是，`let`的声明并不那么宽容。\n\n```tsx\nlet x = 10;\nlet x = 20; // 错误：不能在同一范围内重新声明'x'。\n```\n\n变量不一定要都是块范围的，TypeScript才会告诉我们有一个问题。\n\n```tsx\nfunction f(x) {\n  let x = 100; // 错误：干扰了参数声明\n}\n\nfunction g() {\n  let x = 100;\n  var x = 100; // 错误：不能同时有'x'的声明\n}\n```\n\n这并不是说一个块作用域变量永远不能和一个函数作用域变量一起声明。区块作用域变量只是需要在一个明显不同的区块中声明。\n\n```tsx\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100;\n    return x;\n  }\n  return x;\n}\nf(false, 0); // 返回 '0'\nf(true, 0); // 返回 '100'\n```\n\n在一个更加嵌套的作用域中引入一个新名字的行为被称为投影。这是一把双刃剑，因为它可以在意外影射的情况下自行引入某些错误，同时也可以防止某些错误。例如，想象一下我们之前用`let`变量编写的`sumMatrix函`数：\n\n```tsx\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0;\n  for (let i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n```\n\n这个版本的循环实际上会正确地执行求和，因为内循环的 `i` 会对外循环的 `i` 产生阴影。\n\n为了写出更清晰的代码，通常应避免使用投影。虽然在某些情况下，利用它可能是合适的，但你应该使用你的最佳判断。\n\n## 1.7 块级作用域变量捕获\n\n当我们第一次触及用`var`声明捕获变量的想法时，我们简要地讨论了变量一旦被捕获是如何行动的。为了给大家一个更好的直观印象，每次运行一个作用域时，它都会创建一个变量的 \"环境\"。这个环境和它捕获的变量甚至在它的作用域内的所有东西都执行完毕后仍然存在。\n\n```tsx\nfunction theCityThatAlwaysSleeps() {\n  let getCity;\n  if (true) {\n    let city = \"Seattle\";\n    getCity = function () {\n      return city;\n    };\n  }\n  return getCity();\n}\n```\n\n因为我们已经从它的环境中捕获了`city`，所以尽管 `if` 块已经执行完毕，我们仍然能够访问它。\n\n回想一下，在我们之前的`setTimeout`例子中，我们最终需要使用IIFE来捕获`for`循环的每个迭代中的变量状态。实际上，我们所做的是为我们捕获的变量创建一个新的变量环境。这有点麻烦，但幸运的是，在TypeScript中你再也不用这么做了。\n\n当声明为循环的一部分时，`let`声明的行为有很大的不同。这些声明并不只是给循环本身引入一个新的环境，而是在每个迭代中创建一个新的范围。因为这就是我们在IIFE中所做的事情，我们可以改变我们以前的`setTimeout`的例子，只使用`let`声明。\n\n```tsx\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\n和预期的一样，这将打印出：\n\n```shell\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n## 1.8 `const`声明\n\n`const`声明是声明变量的另一种方式。\n\n```tsx\nconst numLivesForCat = 9;\n```\n\n它们就像`let`声明一样，但正如它们的名字所暗示的，一旦它们被绑定，它们的值就不能被改变。换句话说，它们有和`let`一样的范围规则，但你不能重新赋值给它们。\n\n这不应该与它们所指的值是不可改变的想法相混淆。\n\n```tsx\nconst numLivesForCat = 9;\nconst kitty = {\n  name: \"Aurora\",\n  numLives: numLivesForCat,\n}; // 错误\nkitty = {\n  name: \"Danielle\",\n  numLives: numLivesForCat,\n};\n// 以下都正确\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;\n```\n\n除非你采取特定的措施来避免它，否则常量变量的内部状态仍然是可以修改的。幸运的是，TypeScript允许你指定一个对象的成员是 `readonly` 的。\n\n## 1.9 `let`与`const`比较\n\n鉴于我们有两种具有类似范围语义的声明，我们很自然地会问自己应该使用哪一种。像大多数广泛的问题一样，答案是：这取决于。\n\n根据最小特权原则，除了那些你打算修改的声明外，所有的声明都应该使用 const。其理由是，如果一个变量不需要被写入，那么在同一个代码库中工作的其他人就不应该自动能够写入该对象，他们需要考虑是否真的需要重新赋值给该变量。在推理数据流时，使用`const`也会使代码更可预测。\n\n使用你的最佳判断，如果适用的话，请与你的团队其他成员协商此事。\n\n本教程的大部分内容都使用`let`声明。\n\n## 1.10 解构\n\nTypeScript拥有的另一个ECMAScript 2015特性是解构。关于完整的参考资料，请看[Mozilla开发者网络上的文章](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。在本节中，我们将做一个简短的概述。\n\n## 1.11 数组析构\n\n最简单的解构形式是数组解构赋值。\n\n```tsx\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // 输出 1\nconsole.log(second); // 输出 2\n```\n\n这将创建两个新的变量，命名为 `first` 和 `second`。这等同于使用索引，但要方便得多。\n\n```tsx\nfirst = input[0];\nsecond = input[1];\n```\n\n解构也适用于已经声明的变量。\n\n```tsx\n// 交换变量\n[first, second] = [second, first];\n```\n\n而且是带参数的函数：\n\n```tsx\nfunction f([first, second]: [number, number]) {\n  console.log(first);\n  console.log(second);\n}\nf([1, 2]);\n```\n\n你可以使用语法 `...` 为列表中的剩余项目创建一个变量。\n\n```tsx\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // 输出 1\nconsole.log(rest); // 输出 [ 2, 3, 4 ]\n```\n\n当然，由于这是JavaScript，你可以直接忽略你不关心的拖尾元素：\n\n```tsx\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n\n或其他元素：\n\n```tsx\nlet [, second, , fourth] = [1, 2, 3, 4];\nconsole.log(second); // 输出 2\nconsole.log(fourth); // 输出 4\n```\n\n## 1.12 元组解构\n\n元组可以像数组一样被去结构化；去结构化的变量得到相应元组元素的类型：\n\n```tsx\nlet tuple: [number, string, boolean] = [7, \"hello\", true];\nlet [a, b, c] = tuple; // a: number, b: string, c: boolean\n```\n\n对一个元组进行解构，超出其元素的范围是一个错误：\n\n```tsx\nlet [a, b, c, d] = tuple; // 错误，索引3处没有元素\n```\n\n和数组一样，你可以用`...`对元组的其余部分进行解构，以得到一个更短的元组：\n\n```tsx\nlet [a, ...bc] = tuple; // bc: [string, boolean]\nlet [a, b, c, ...d] = tuple; // d: [], 空 tuple\n```\n\n或者忽略尾部元素，或者忽略其他元素：\n\n```tsx\nlet [a] = tuple; // a: number\nlet [, b] = tuple; // b: string\n```\n\n## 1.13 对象解构\n\n你也可以做对象的结构：\n\n```tsx\nlet o = { a: \"foo\", b: 12, c: \"bar\" };\nlet { a, b } = o;\n```\n\n这就从`o.a`和`o.b`中创建了新的变量`a`和`b`。注意，如果你不需要`c`，你可以跳过它。\n\n就像数组去结构化一样，你可以不用声明就进行赋值：\n\n```tsx\n({ a, b } = { a: \"baz\", b: 101 });\n```\n\n请注意，我们必须用圆括号包围这个语句。JavaScript通常将{作为块的开始来解析。\n\n你可以使用语法`...`为对象中的剩余项目创建一个变量：\n\n```tsx\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n\n1. 属性重命名\n\n你也可以给属性起不同的名字：\n\n```tsx\nlet { a: newName1, b: newName2 } = o;\n```\n\n这里的语法开始变得混乱了。你可以把`a: newName1`读作 `\"a as newName1\"`。方向是从左到右，就像你写的一样：\n\n```tsx\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n\n令人困惑的是，这里的冒号并不表示类型。如果你指定了类型，仍然需要写在整个结构解构之后。\n\n```tsx\nlet { a, b }: { a: string; b: number } = o;\n```\n\n1. 默认值\n\n默认值让你指定一个默认值，以防一个属性未被定义。\n\n```tsx\nfunction keepWholeObject(wholeObject: { a: string; b?: number }) {\n  let { a, b = 1001 } = wholeObject;\n}\n```\n\n在这个例子中，`b?` 表示`b`是可选的，所以它可能是未定义的。 `keepWholeObject`现在有一个`wholeObject`的变量，以及属性`a`和`b`，即使`b`是未定义的。\n\n## 1.14 Function 声明\n\n去结构化在函数声明中也起作用。对于简单的情况，这是很直接的。\n\n```tsx\ntype C = { a: string; b?: number };\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n\n但是对于参数来说，指定默认值是比较常见的，而用解构的方式来获得默认值是很棘手的。首先，你需要记住把模式放在默认值之前。\n\n```tsx\nfunction f({ a = \"\", b = 0 } = {}): void {\n  // ...\n}\nf();\n```\n\n然后，你需要记住在`destructured`属性上给可选属性一个默认值，而不是主初始化器。记住，`C`的定义是`b`可选的。\n\n```tsx\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n  // ...\n}\nf({ a: \"yes\" }); // 正确，b = 0\nf(); // 正确, 默认 { a: \"\" }, 然后默认为 b = 0\nf({}); // 错误，如果你提供一个参数，'a'是必须的\n```\n\n小心使用解构。正如前面的例子所展示的，除了最简单的析构表达式之外，任何东西都会令人困惑。这在深度嵌套的结构化中尤其如此，即使不堆积重命名、默认值和类型注释，也会变得非常难以理解。尽量保持结构化表达式的小而简单。你总是可以自己写出解构会产生的赋值。\n\n## 1.15 展开\n\n展开操作符与解构相反。它允许你将一个数组分散到另一个数组中，或者将一个对象分散到另一个对象中。比如说：\n\n```tsx\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n\n这使`bothPlus`的值为`[0, 1, 2, 3, 4, 5]`。展开创建 `first` 和 `second` 的浅层拷贝。它们不会因为展开而改变。\n\n你也可以展开对象。\n\n```tsx\nlet defaults = {\n  food: \"spicy\",\n  price: \"$$\",\n  ambiance: \"noisy\",\n};\nlet search = {\n  ...defaults,\n  food: \"rich\",\n};\n```\n\n现在的 `search` 是 `{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }`。对象展开比数组展开更复杂。像数组展开一样，它从左到右进行，但结果仍然是一个对象。这意味着展开对象中较晚出现的属性会覆盖较早出现的属性。因此，如果我们修改前面的例子，在最后展开：\n\n```tsx\nlet defaults = {\n  food: \"spicy\",\n  price: \"$$\",\n  ambiance: \"noisy\",\n};\nlet search = {\n  food: \"rich\",\n  ...defaults,\n};\n```\n\n然后，`defaults`中的食物属性覆盖了`food: \"rich\"`，这不是我们在这种情况下想要的。\n\n对象传播也有其他一些令人惊讶的限制。首先，它只包括一个对象 [自己的、可列举的属性](https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。基本上，这意味着当你传播一个对象的实例时，你会失去方法。\n\n```tsx\nclass C {\n  p = 12;\n  m() {}\n}\nlet c = new C();\nlet clone = {\n  ...c,\n};\nclone.p; // 正确\nclone.m(); // 错误!\n```\n\nTypeScript编译器不允许从通用函数中展开类型参数。该功能预计将在未来的语言版本中出现。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-1、高级篇：变量声明.md",
        "raw": "---\ntitle: 2-1、高级篇：变量声明\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 48402\ndate: 2024-01-28 19:53:37\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 一、变量声明\n\n`let`和`const`是JavaScript中变量声明的两个相对较新的概念。正如我们前面提到的，`let`在某些方面与`var`相似，但允许用户避免在JavaScript中遇到的一些常见的 \"麻烦\"。\n\n`const`是`let`的一个扩展，它可以防止重新赋值给一个变量。\n\n由于TypeScript是JavaScript的扩展，该语言自然支持`let`和`const`。在这里，我们将进一步阐述这些新的声明，以及为什么它们比`var`更适合。\n\n如果你已经不经意地使用了JavaScript，那么下一节可能是刷新你记忆的一个好方法。如果你对JavaScript中`var`声明的所有怪癖非常熟悉，你可能会发现跳过前面会更容易。\n\n## 1.1 var 变量声明\n\n在JavaScript中声明一个变量，传统上都是用`var`关键字来完成。\n\n```tsx\nvar a = 10;\n```\n\n正如你可能已经发现的，我们刚刚声明了一个名为`a`的变量，其值为`10`。\n\n我们也可以在一个函数中声明一个变量：\n\n```tsx\nfunction f() {\n  var message = \"Hello, world!\";\n  return message;\n}\n```\n\n而我们也可以在其他函数中访问这些相同的变量：\n\n```tsx\nfunction f() {\n  var a = 10;\n  return function g() {\n    var b = a + 1;\n    return b;\n  };\n}\nvar g = f();\ng(); // returns '11'\n```\n\n在上面这个例子中，`g`捕获了`f`中声明的变量`a`。在`g`被调用的任何时候，`a`的值都将与`f`中`a`的值相联系。\n\n```tsx\nfunction f() {\n  var a = 1;\n  a = 2;\n  var b = g();\n  a = 3;\n  return b;\n  function g() {\n    return a;\n  }\n}\nf(); // returns '2'\n```\n\n## 1.2 作用域规则\n\n对于那些习惯于其他语言的人来说，`var`声明有一些奇怪的作用域范围规则。以下面的例子为例：\n\n```tsx\nfunction f(shouldInitialize: boolean) {\n  if (shouldInitialize) {\n    var x = 10;\n  }\n  return x;\n}\nf(true); // 返回 '10'\nf(false); // 返回 'undefined'\n```\n\n有些读者可能会对这个例子产生怀疑。变量`x`是在`if`块中声明的，但我们却能从该块之外访问它。这是因为`var`声明可以在其包含的函数、模块、命名空间或全局范围内的任何地方访问（所有这些我们将在后面讨论），而不考虑包含的块。有些人把这称为`var`作用域或函数作用域。参数也是函数作用域。\n\n这些作用域规则会导致几种类型的错误。它们加剧的一个问题是，多次声明同一个变量并不是一个错误。\n\n```tsx\nfunction sumMatrix(matrix: number[][]) {\n  var sum = 0;\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n```\n\n也许对于一些有经验的JavaScript开发者来说，这很容易被发现，但是内部`for-loop`会意外地覆盖变量`i`，因为`i`指的是同一个函数范围的变量。正如有经验的开发者现在所知道的，类似的各种bug会在代码审查中溜走，并会成为无尽的挫折来源。\n\n## 1.3 变量捕获的怪癖\n\n花点时间猜一猜下面这段话的输出是什么：\n\n```tsx\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\n对于那些不熟悉的人来说，`setTimeout`将尝试在一定数量的毫秒后执行一个函数（尽管要等待其他东西停止运行）。\n\n准备好了吗？看看吧。\n\n```shell\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\n许多JavaScript开发人员对这种行为非常熟悉，但如果你感到惊讶，你肯定不是一个人。大多数人都希望输出的结果是：\n\n```shell\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n还记得我们前面提到的关于变量捕获的问题吗？我们传递给`setTimeout`的每个函数表达式实际上都是指同一范围内的同一个`i`。\n\n让我们花点时间考虑一下这意味着什么。 `setTimeout`将在若干毫秒之后运行一个函数，但只有在`for`循环停止执行之后；当`for`循环停止执行时，`i`的值是`10`。因此，每次给定的函数被调用时，它将打印出`10`!\n\n一个常见的解决方法是使用IIFE--一个立即调用的函数表达式--来捕获每次迭代的`i`。\n\n```tsx\nfor (var i = 0; i < 10; i++) {\n  // 通过调用一个带有其当前值的函数\n  // 捕捉'i'的当前状态\n  (function (i) {\n    setTimeout(function () {\n      console.log(i);\n    }, 100 * i);\n  })(i);\n}\n```\n\n这种看起来很奇怪的模式其实是很常见的。参数列表中的 `i` 实际上是对 `for` 循环中声明的 `i` 的影子，但由于我们对它们的命名相同，所以我们不必对循环体进行过多的修改。\n\n## 1.4 let 变量声明\n\n现在你已经发现`var`有一些问题，这正是`let`语句被引入的原因。除了使用的关键字外，`let`语句的写法与`var`语句相同。\n\n```tsx\nlet hello = \"Hello!\";\n```\n\n关键的区别不在语法上，而在语义上，我们现在要深入研究。\n\n## 1.5 块级作用域\n\n当一个变量使用`let`声明时，它使用了一些人所说的词法范围或块法范围。与用`var`声明的变量不同，`block-scope`变量的作用域会泄露给其包含的函数，而在其最近的包含块或`for-loop`之外是不可见的。\n\n```tsx\nfunction f(input: boolean) {\n  let a = 100;\n  if (input) {\n    // 引用'a'仍然可以\n    let b = a + 1;\n    return b;\n  }\n  // 错误：这里不存在'b'。\n  return b;\n}\n```\n\n在这里，我们有两个局部变量`a`和`b`。`a`的作用域仅限于`f`的主体，而`b`的作用域仅限于包含`if`语句的块。\n\n在`catch`子句中声明的变量也有类似的作用域规则。\n\n```tsx\ntry {\n  throw \"oh no!\";\n} catch (e) {\n  console.log(\"Oh well.\");\n}\n// Error: 这里不存在'e'。\nconsole.log(e);\n```\n\n块级作用域变量的另一个属性是，在它们被实际声明之前，它们不能被读或写到。虽然这些变量在它们的整个作用域中都是 \"存在 \"的，但是直到它们被声明之前的所有点都是它们的时间死角的一部分。这只是一种复杂的说法，你不能在`let`语句之前访问它们，幸运的是TypeScript会让你知道这一点。\n\n```tsx\na++; // 在声明之前使用'a'是非法的。\nlet a;\n```\n\n需要注意的是，你仍然可以在声明之前*捕获*一个块范围的变量。唯一的问题是，在声明之前调用该函数是非法的。如果以ES2015为目标，现代运行时将抛出一个错误；然而，现在TypeScript是允许的，不会将此作为一个错误报告。\n\n```tsx\nfunction foo() {\n  // 可以捕捉到 \"a\"。\n  return a;\n}\n// 在声明'a'之前非法调用'foo'。\n// runtimes应该在这里抛出一个错误\nfoo();\nlet a;\n```\n\nFor more information on temporal dead zones, see relevant content on the [Mozilla Developer Network](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).\n\n关于时空死角的更多信息，请看 [Mozilla开发者网络](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)上的相关内容。\n\n## 1.6 重复声明和投影\n\n对于var声明，我们提到，你声明了多少次变量并不重要，你只是得到了一个。\n\n```tsx\nfunction f(x) {\n  var x;\n  var x;\n  if (true) {\n    var x;\n  }\n}\n```\n\n在上面的例子中，所有关于`x`的声明实际上指的是同一个`x`，这是完全有效的。这往往会成为错误的根源。值得庆幸的是，`let`的声明并不那么宽容。\n\n```tsx\nlet x = 10;\nlet x = 20; // 错误：不能在同一范围内重新声明'x'。\n```\n\n变量不一定要都是块范围的，TypeScript才会告诉我们有一个问题。\n\n```tsx\nfunction f(x) {\n  let x = 100; // 错误：干扰了参数声明\n}\n\nfunction g() {\n  let x = 100;\n  var x = 100; // 错误：不能同时有'x'的声明\n}\n```\n\n这并不是说一个块作用域变量永远不能和一个函数作用域变量一起声明。区块作用域变量只是需要在一个明显不同的区块中声明。\n\n```tsx\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100;\n    return x;\n  }\n  return x;\n}\nf(false, 0); // 返回 '0'\nf(true, 0); // 返回 '100'\n```\n\n在一个更加嵌套的作用域中引入一个新名字的行为被称为投影。这是一把双刃剑，因为它可以在意外影射的情况下自行引入某些错误，同时也可以防止某些错误。例如，想象一下我们之前用`let`变量编写的`sumMatrix函`数：\n\n```tsx\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0;\n  for (let i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n```\n\n这个版本的循环实际上会正确地执行求和，因为内循环的 `i` 会对外循环的 `i` 产生阴影。\n\n为了写出更清晰的代码，通常应避免使用投影。虽然在某些情况下，利用它可能是合适的，但你应该使用你的最佳判断。\n\n## 1.7 块级作用域变量捕获\n\n当我们第一次触及用`var`声明捕获变量的想法时，我们简要地讨论了变量一旦被捕获是如何行动的。为了给大家一个更好的直观印象，每次运行一个作用域时，它都会创建一个变量的 \"环境\"。这个环境和它捕获的变量甚至在它的作用域内的所有东西都执行完毕后仍然存在。\n\n```tsx\nfunction theCityThatAlwaysSleeps() {\n  let getCity;\n  if (true) {\n    let city = \"Seattle\";\n    getCity = function () {\n      return city;\n    };\n  }\n  return getCity();\n}\n```\n\n因为我们已经从它的环境中捕获了`city`，所以尽管 `if` 块已经执行完毕，我们仍然能够访问它。\n\n回想一下，在我们之前的`setTimeout`例子中，我们最终需要使用IIFE来捕获`for`循环的每个迭代中的变量状态。实际上，我们所做的是为我们捕获的变量创建一个新的变量环境。这有点麻烦，但幸运的是，在TypeScript中你再也不用这么做了。\n\n当声明为循环的一部分时，`let`声明的行为有很大的不同。这些声明并不只是给循环本身引入一个新的环境，而是在每个迭代中创建一个新的范围。因为这就是我们在IIFE中所做的事情，我们可以改变我们以前的`setTimeout`的例子，只使用`let`声明。\n\n```tsx\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\n和预期的一样，这将打印出：\n\n```shell\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n## 1.8 `const`声明\n\n`const`声明是声明变量的另一种方式。\n\n```tsx\nconst numLivesForCat = 9;\n```\n\n它们就像`let`声明一样，但正如它们的名字所暗示的，一旦它们被绑定，它们的值就不能被改变。换句话说，它们有和`let`一样的范围规则，但你不能重新赋值给它们。\n\n这不应该与它们所指的值是不可改变的想法相混淆。\n\n```tsx\nconst numLivesForCat = 9;\nconst kitty = {\n  name: \"Aurora\",\n  numLives: numLivesForCat,\n}; // 错误\nkitty = {\n  name: \"Danielle\",\n  numLives: numLivesForCat,\n};\n// 以下都正确\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;\n```\n\n除非你采取特定的措施来避免它，否则常量变量的内部状态仍然是可以修改的。幸运的是，TypeScript允许你指定一个对象的成员是 `readonly` 的。\n\n## 1.9 `let`与`const`比较\n\n鉴于我们有两种具有类似范围语义的声明，我们很自然地会问自己应该使用哪一种。像大多数广泛的问题一样，答案是：这取决于。\n\n根据最小特权原则，除了那些你打算修改的声明外，所有的声明都应该使用 const。其理由是，如果一个变量不需要被写入，那么在同一个代码库中工作的其他人就不应该自动能够写入该对象，他们需要考虑是否真的需要重新赋值给该变量。在推理数据流时，使用`const`也会使代码更可预测。\n\n使用你的最佳判断，如果适用的话，请与你的团队其他成员协商此事。\n\n本教程的大部分内容都使用`let`声明。\n\n## 1.10 解构\n\nTypeScript拥有的另一个ECMAScript 2015特性是解构。关于完整的参考资料，请看[Mozilla开发者网络上的文章](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。在本节中，我们将做一个简短的概述。\n\n## 1.11 数组析构\n\n最简单的解构形式是数组解构赋值。\n\n```tsx\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // 输出 1\nconsole.log(second); // 输出 2\n```\n\n这将创建两个新的变量，命名为 `first` 和 `second`。这等同于使用索引，但要方便得多。\n\n```tsx\nfirst = input[0];\nsecond = input[1];\n```\n\n解构也适用于已经声明的变量。\n\n```tsx\n// 交换变量\n[first, second] = [second, first];\n```\n\n而且是带参数的函数：\n\n```tsx\nfunction f([first, second]: [number, number]) {\n  console.log(first);\n  console.log(second);\n}\nf([1, 2]);\n```\n\n你可以使用语法 `...` 为列表中的剩余项目创建一个变量。\n\n```tsx\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // 输出 1\nconsole.log(rest); // 输出 [ 2, 3, 4 ]\n```\n\n当然，由于这是JavaScript，你可以直接忽略你不关心的拖尾元素：\n\n```tsx\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n\n或其他元素：\n\n```tsx\nlet [, second, , fourth] = [1, 2, 3, 4];\nconsole.log(second); // 输出 2\nconsole.log(fourth); // 输出 4\n```\n\n## 1.12 元组解构\n\n元组可以像数组一样被去结构化；去结构化的变量得到相应元组元素的类型：\n\n```tsx\nlet tuple: [number, string, boolean] = [7, \"hello\", true];\nlet [a, b, c] = tuple; // a: number, b: string, c: boolean\n```\n\n对一个元组进行解构，超出其元素的范围是一个错误：\n\n```tsx\nlet [a, b, c, d] = tuple; // 错误，索引3处没有元素\n```\n\n和数组一样，你可以用`...`对元组的其余部分进行解构，以得到一个更短的元组：\n\n```tsx\nlet [a, ...bc] = tuple; // bc: [string, boolean]\nlet [a, b, c, ...d] = tuple; // d: [], 空 tuple\n```\n\n或者忽略尾部元素，或者忽略其他元素：\n\n```tsx\nlet [a] = tuple; // a: number\nlet [, b] = tuple; // b: string\n```\n\n## 1.13 对象解构\n\n你也可以做对象的结构：\n\n```tsx\nlet o = { a: \"foo\", b: 12, c: \"bar\" };\nlet { a, b } = o;\n```\n\n这就从`o.a`和`o.b`中创建了新的变量`a`和`b`。注意，如果你不需要`c`，你可以跳过它。\n\n就像数组去结构化一样，你可以不用声明就进行赋值：\n\n```tsx\n({ a, b } = { a: \"baz\", b: 101 });\n```\n\n请注意，我们必须用圆括号包围这个语句。JavaScript通常将{作为块的开始来解析。\n\n你可以使用语法`...`为对象中的剩余项目创建一个变量：\n\n```tsx\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n\n1. 属性重命名\n\n你也可以给属性起不同的名字：\n\n```tsx\nlet { a: newName1, b: newName2 } = o;\n```\n\n这里的语法开始变得混乱了。你可以把`a: newName1`读作 `\"a as newName1\"`。方向是从左到右，就像你写的一样：\n\n```tsx\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n\n令人困惑的是，这里的冒号并不表示类型。如果你指定了类型，仍然需要写在整个结构解构之后。\n\n```tsx\nlet { a, b }: { a: string; b: number } = o;\n```\n\n1. 默认值\n\n默认值让你指定一个默认值，以防一个属性未被定义。\n\n```tsx\nfunction keepWholeObject(wholeObject: { a: string; b?: number }) {\n  let { a, b = 1001 } = wholeObject;\n}\n```\n\n在这个例子中，`b?` 表示`b`是可选的，所以它可能是未定义的。 `keepWholeObject`现在有一个`wholeObject`的变量，以及属性`a`和`b`，即使`b`是未定义的。\n\n## 1.14 Function 声明\n\n去结构化在函数声明中也起作用。对于简单的情况，这是很直接的。\n\n```tsx\ntype C = { a: string; b?: number };\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n\n但是对于参数来说，指定默认值是比较常见的，而用解构的方式来获得默认值是很棘手的。首先，你需要记住把模式放在默认值之前。\n\n```tsx\nfunction f({ a = \"\", b = 0 } = {}): void {\n  // ...\n}\nf();\n```\n\n然后，你需要记住在`destructured`属性上给可选属性一个默认值，而不是主初始化器。记住，`C`的定义是`b`可选的。\n\n```tsx\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n  // ...\n}\nf({ a: \"yes\" }); // 正确，b = 0\nf(); // 正确, 默认 { a: \"\" }, 然后默认为 b = 0\nf({}); // 错误，如果你提供一个参数，'a'是必须的\n```\n\n小心使用解构。正如前面的例子所展示的，除了最简单的析构表达式之外，任何东西都会令人困惑。这在深度嵌套的结构化中尤其如此，即使不堆积重命名、默认值和类型注释，也会变得非常难以理解。尽量保持结构化表达式的小而简单。你总是可以自己写出解构会产生的赋值。\n\n## 1.15 展开\n\n展开操作符与解构相反。它允许你将一个数组分散到另一个数组中，或者将一个对象分散到另一个对象中。比如说：\n\n```tsx\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n\n这使`bothPlus`的值为`[0, 1, 2, 3, 4, 5]`。展开创建 `first` 和 `second` 的浅层拷贝。它们不会因为展开而改变。\n\n你也可以展开对象。\n\n```tsx\nlet defaults = {\n  food: \"spicy\",\n  price: \"$$\",\n  ambiance: \"noisy\",\n};\nlet search = {\n  ...defaults,\n  food: \"rich\",\n};\n```\n\n现在的 `search` 是 `{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }`。对象展开比数组展开更复杂。像数组展开一样，它从左到右进行，但结果仍然是一个对象。这意味着展开对象中较晚出现的属性会覆盖较早出现的属性。因此，如果我们修改前面的例子，在最后展开：\n\n```tsx\nlet defaults = {\n  food: \"spicy\",\n  price: \"$$\",\n  ambiance: \"noisy\",\n};\nlet search = {\n  food: \"rich\",\n  ...defaults,\n};\n```\n\n然后，`defaults`中的食物属性覆盖了`food: \"rich\"`，这不是我们在这种情况下想要的。\n\n对象传播也有其他一些令人惊讶的限制。首先，它只包括一个对象 [自己的、可列举的属性](https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。基本上，这意味着当你传播一个对象的实例时，你会失去方法。\n\n```tsx\nclass C {\n  p = 12;\n  m() {}\n}\nlet c = new C();\nlet clone = {\n  ...c,\n};\nclone.p; // 正确\nclone.m(); // 错误!\n```\n\nTypeScript编译器不允许从通用函数中展开类型参数。该功能预计将在未来的语言版本中出现。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-1、高级篇：变量声明",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao6001694v33sws3l2v",
        "content": "<h1 id=\"一、变量声明\"><a href=\"#一、变量声明\" class=\"headerlink\" title=\"一、变量声明\"></a>一、变量声明</h1><p><code>let</code>和<code>const</code>是JavaScript中变量声明的两个相对较新的概念。正如我们前面提到的，<code>let</code>在某些方面与<code>var</code>相似，但允许用户避免在JavaScript中遇到的一些常见的 “麻烦”。</p>\n<p><code>const</code>是<code>let</code>的一个扩展，它可以防止重新赋值给一个变量。</p>\n<p>由于TypeScript是JavaScript的扩展，该语言自然支持<code>let</code>和<code>const</code>。在这里，我们将进一步阐述这些新的声明，以及为什么它们比<code>var</code>更适合。</p>\n<p>如果你已经不经意地使用了JavaScript，那么下一节可能是刷新你记忆的一个好方法。如果你对JavaScript中<code>var</code>声明的所有怪癖非常熟悉，你可能会发现跳过前面会更容易。</p>\n<h2 id=\"1-1-var-变量声明\"><a href=\"#1-1-var-变量声明\" class=\"headerlink\" title=\"1.1 var 变量声明\"></a>1.1 var 变量声明</h2><p>在JavaScript中声明一个变量，传统上都是用<code>var</code>关键字来完成。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<p>正如你可能已经发现的，我们刚刚声明了一个名为<code>a</code>的变量，其值为<code>10</code>。</p>\n<p>我们也可以在一个函数中声明一个变量：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而我们也可以在其他函数中访问这些相同的变量：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">g</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">f</span>();</span><br><span class=\"line\"><span class=\"title function_\">g</span>(); <span class=\"comment\">// returns &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面这个例子中，<code>g</code>捕获了<code>f</code>中声明的变量<code>a</code>。在<code>g</code>被调用的任何时候，<code>a</code>的值都将与<code>f</code>中<code>a</code>的值相联系。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  a = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"title function_\">g</span>();</span><br><span class=\"line\">  a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">g</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(); <span class=\"comment\">// returns &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-作用域规则\"><a href=\"#1-2-作用域规则\" class=\"headerlink\" title=\"1.2 作用域规则\"></a>1.2 作用域规则</h2><p>对于那些习惯于其他语言的人来说，<code>var</code>声明有一些奇怪的作用域范围规则。以下面的例子为例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">shouldInitialize</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// 返回 &#x27;10&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">false</span>); <span class=\"comment\">// 返回 &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>有些读者可能会对这个例子产生怀疑。变量<code>x</code>是在<code>if</code>块中声明的，但我们却能从该块之外访问它。这是因为<code>var</code>声明可以在其包含的函数、模块、命名空间或全局范围内的任何地方访问（所有这些我们将在后面讨论），而不考虑包含的块。有些人把这称为<code>var</code>作用域或函数作用域。参数也是函数作用域。</p>\n<p>这些作用域规则会导致几种类型的错误。它们加剧的一个问题是，多次声明同一个变量并不是一个错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sumMatrix</span>(<span class=\"params\"><span class=\"attr\">matrix</span>: <span class=\"built_in\">number</span>[][]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也许对于一些有经验的JavaScript开发者来说，这很容易被发现，但是内部<code>for-loop</code>会意外地覆盖变量<code>i</code>，因为<code>i</code>指的是同一个函数范围的变量。正如有经验的开发者现在所知道的，类似的各种bug会在代码审查中溜走，并会成为无尽的挫折来源。</p>\n<h2 id=\"1-3-变量捕获的怪癖\"><a href=\"#1-3-变量捕获的怪癖\" class=\"headerlink\" title=\"1.3 变量捕获的怪癖\"></a>1.3 变量捕获的怪癖</h2><p>花点时间猜一猜下面这段话的输出是什么：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于那些不熟悉的人来说，<code>setTimeout</code>将尝试在一定数量的毫秒后执行一个函数（尽管要等待其他东西停止运行）。</p>\n<p>准备好了吗？看看吧。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n\n<p>许多JavaScript开发人员对这种行为非常熟悉，但如果你感到惊讶，你肯定不是一个人。大多数人都希望输出的结果是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td></tr></table></figure>\n\n<p>还记得我们前面提到的关于变量捕获的问题吗？我们传递给<code>setTimeout</code>的每个函数表达式实际上都是指同一范围内的同一个<code>i</code>。</p>\n<p>让我们花点时间考虑一下这意味着什么。 <code>setTimeout</code>将在若干毫秒之后运行一个函数，但只有在<code>for</code>循环停止执行之后；当<code>for</code>循环停止执行时，<code>i</code>的值是<code>10</code>。因此，每次给定的函数被调用时，它将打印出<code>10</code>!</p>\n<p>一个常见的解决方法是使用IIFE–一个立即调用的函数表达式–来捕获每次迭代的<code>i</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过调用一个带有其当前值的函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 捕捉&#x27;i&#x27;的当前状态</span></span><br><span class=\"line\">  (<span class=\"keyword\">function</span> (<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">  &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种看起来很奇怪的模式其实是很常见的。参数列表中的 <code>i</code> 实际上是对 <code>for</code> 循环中声明的 <code>i</code> 的影子，但由于我们对它们的命名相同，所以我们不必对循环体进行过多的修改。</p>\n<h2 id=\"1-4-let-变量声明\"><a href=\"#1-4-let-变量声明\" class=\"headerlink\" title=\"1.4 let 变量声明\"></a>1.4 let 变量声明</h2><p>现在你已经发现<code>var</code>有一些问题，这正是<code>let</code>语句被引入的原因。除了使用的关键字外，<code>let</code>语句的写法与<code>var</code>语句相同。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>关键的区别不在语法上，而在语义上，我们现在要深入研究。</p>\n<h2 id=\"1-5-块级作用域\"><a href=\"#1-5-块级作用域\" class=\"headerlink\" title=\"1.5 块级作用域\"></a>1.5 块级作用域</h2><p>当一个变量使用<code>let</code>声明时，它使用了一些人所说的词法范围或块法范围。与用<code>var</code>声明的变量不同，<code>block-scope</code>变量的作用域会泄露给其包含的函数，而在其最近的包含块或<code>for-loop</code>之外是不可见的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">input</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 引用&#x27;a&#x27;仍然可以</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 错误：这里不存在&#x27;b&#x27;。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们有两个局部变量<code>a</code>和<code>b</code>。<code>a</code>的作用域仅限于<code>f</code>的主体，而<code>b</code>的作用域仅限于包含<code>if</code>语句的块。</p>\n<p>在<code>catch</code>子句中声明的变量也有类似的作用域规则。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">&quot;oh no!&quot;</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Oh well.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Error: 这里不存在&#x27;e&#x27;。</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e);</span><br></pre></td></tr></table></figure>\n\n<p>块级作用域变量的另一个属性是，在它们被实际声明之前，它们不能被读或写到。虽然这些变量在它们的整个作用域中都是 “存在 “的，但是直到它们被声明之前的所有点都是它们的时间死角的一部分。这只是一种复杂的说法，你不能在<code>let</code>语句之前访问它们，幸运的是TypeScript会让你知道这一点。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">a++; <span class=\"comment\">// 在声明之前使用&#x27;a&#x27;是非法的。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，你仍然可以在声明之前<em>捕获</em>一个块范围的变量。唯一的问题是，在声明之前调用该函数是非法的。如果以ES2015为目标，现代运行时将抛出一个错误；然而，现在TypeScript是允许的，不会将此作为一个错误报告。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 可以捕捉到 &quot;a&quot;。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在声明&#x27;a&#x27;之前非法调用&#x27;foo&#x27;。</span></span><br><span class=\"line\"><span class=\"comment\">// runtimes应该在这里抛出一个错误</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n\n<p>For more information on temporal dead zones, see relevant content on the <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\">Mozilla Developer Network</a>.</p>\n<p>关于时空死角的更多信息，请看 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\">Mozilla开发者网络</a>上的相关内容。</p>\n<h2 id=\"1-6-重复声明和投影\"><a href=\"#1-6-重复声明和投影\" class=\"headerlink\" title=\"1.6 重复声明和投影\"></a>1.6 重复声明和投影</h2><p>对于var声明，我们提到，你声明了多少次变量并不重要，你只是得到了一个。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，所有关于<code>x</code>的声明实际上指的是同一个<code>x</code>，这是完全有效的。这往往会成为错误的根源。值得庆幸的是，<code>let</code>的声明并不那么宽容。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span>; <span class=\"comment\">// 错误：不能在同一范围内重新声明&#x27;x&#x27;。</span></span><br></pre></td></tr></table></figure>\n\n<p>变量不一定要都是块范围的，TypeScript才会告诉我们有一个问题。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// 错误：干扰了参数声明</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">g</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// 错误：不能同时有&#x27;x&#x27;的声明</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这并不是说一个块作用域变量永远不能和一个函数作用域变量一起声明。区块作用域变量只是需要在一个明显不同的区块中声明。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">condition, x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">false</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 返回 &#x27;0&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">true</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 返回 &#x27;100&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在一个更加嵌套的作用域中引入一个新名字的行为被称为投影。这是一把双刃剑，因为它可以在意外影射的情况下自行引入某些错误，同时也可以防止某些错误。例如，想象一下我们之前用<code>let</code>变量编写的<code>sumMatrix函</code>数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sumMatrix</span>(<span class=\"params\"><span class=\"attr\">matrix</span>: <span class=\"built_in\">number</span>[][]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个版本的循环实际上会正确地执行求和，因为内循环的 <code>i</code> 会对外循环的 <code>i</code> 产生阴影。</p>\n<p>为了写出更清晰的代码，通常应避免使用投影。虽然在某些情况下，利用它可能是合适的，但你应该使用你的最佳判断。</p>\n<h2 id=\"1-7-块级作用域变量捕获\"><a href=\"#1-7-块级作用域变量捕获\" class=\"headerlink\" title=\"1.7 块级作用域变量捕获\"></a>1.7 块级作用域变量捕获</h2><p>当我们第一次触及用<code>var</code>声明捕获变量的想法时，我们简要地讨论了变量一旦被捕获是如何行动的。为了给大家一个更好的直观印象，每次运行一个作用域时，它都会创建一个变量的 “环境”。这个环境和它捕获的变量甚至在它的作用域内的所有东西都执行完毕后仍然存在。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">theCityThatAlwaysSleeps</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> getCity;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> city = <span class=\"string\">&quot;Seattle&quot;</span>;</span><br><span class=\"line\">    getCity = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getCity</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们已经从它的环境中捕获了<code>city</code>，所以尽管 <code>if</code> 块已经执行完毕，我们仍然能够访问它。</p>\n<p>回想一下，在我们之前的<code>setTimeout</code>例子中，我们最终需要使用IIFE来捕获<code>for</code>循环的每个迭代中的变量状态。实际上，我们所做的是为我们捕获的变量创建一个新的变量环境。这有点麻烦，但幸运的是，在TypeScript中你再也不用这么做了。</p>\n<p>当声明为循环的一部分时，<code>let</code>声明的行为有很大的不同。这些声明并不只是给循环本身引入一个新的环境，而是在每个迭代中创建一个新的范围。因为这就是我们在IIFE中所做的事情，我们可以改变我们以前的<code>setTimeout</code>的例子，只使用<code>let</code>声明。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和预期的一样，这将打印出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-8-const声明\"><a href=\"#1-8-const声明\" class=\"headerlink\" title=\"1.8 const声明\"></a>1.8 <code>const</code>声明</h2><p><code>const</code>声明是声明变量的另一种方式。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<p>它们就像<code>let</code>声明一样，但正如它们的名字所暗示的，一旦它们被绑定，它们的值就不能被改变。换句话说，它们有和<code>let</code>一样的范围规则，但你不能重新赋值给它们。</p>\n<p>这不应该与它们所指的值是不可改变的想法相混淆。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;Aurora&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">numLives</span>: numLivesForCat,</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 错误</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;Danielle&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">numLives</span>: numLivesForCat,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 以下都正确</span></span><br><span class=\"line\">kitty.<span class=\"property\">name</span> = <span class=\"string\">&quot;Rory&quot;</span>;</span><br><span class=\"line\">kitty.<span class=\"property\">name</span> = <span class=\"string\">&quot;Kitty&quot;</span>;</span><br><span class=\"line\">kitty.<span class=\"property\">name</span> = <span class=\"string\">&quot;Cat&quot;</span>;</span><br><span class=\"line\">kitty.<span class=\"property\">numLives</span>--;</span><br></pre></td></tr></table></figure>\n\n<p>除非你采取特定的措施来避免它，否则常量变量的内部状态仍然是可以修改的。幸运的是，TypeScript允许你指定一个对象的成员是 <code>readonly</code> 的。</p>\n<h2 id=\"1-9-let与const比较\"><a href=\"#1-9-let与const比较\" class=\"headerlink\" title=\"1.9 let与const比较\"></a>1.9 <code>let</code>与<code>const</code>比较</h2><p>鉴于我们有两种具有类似范围语义的声明，我们很自然地会问自己应该使用哪一种。像大多数广泛的问题一样，答案是：这取决于。</p>\n<p>根据最小特权原则，除了那些你打算修改的声明外，所有的声明都应该使用 const。其理由是，如果一个变量不需要被写入，那么在同一个代码库中工作的其他人就不应该自动能够写入该对象，他们需要考虑是否真的需要重新赋值给该变量。在推理数据流时，使用<code>const</code>也会使代码更可预测。</p>\n<p>使用你的最佳判断，如果适用的话，请与你的团队其他成员协商此事。</p>\n<p>本教程的大部分内容都使用<code>let</code>声明。</p>\n<h2 id=\"1-10-解构\"><a href=\"#1-10-解构\" class=\"headerlink\" title=\"1.10 解构\"></a>1.10 解构</h2><p>TypeScript拥有的另一个ECMAScript 2015特性是解构。关于完整的参考资料，请看<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">Mozilla开发者网络上的文章</a>。在本节中，我们将做一个简短的概述。</p>\n<h2 id=\"1-11-数组析构\"><a href=\"#1-11-数组析构\" class=\"headerlink\" title=\"1.11 数组析构\"></a>1.11 数组析构</h2><p>最简单的解构形式是数组解构赋值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(second); <span class=\"comment\">// 输出 2</span></span><br></pre></td></tr></table></figure>\n\n<p>这将创建两个新的变量，命名为 <code>first</code> 和 <code>second</code>。这等同于使用索引，但要方便得多。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">first = input[<span class=\"number\">0</span>];</span><br><span class=\"line\">second = input[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<p>解构也适用于已经声明的变量。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 交换变量</span></span><br><span class=\"line\">[first, second] = [second, first];</span><br></pre></td></tr></table></figure>\n\n<p>而且是带参数的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(second);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>你可以使用语法 <code>...</code> 为列表中的剩余项目创建一个变量。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rest); <span class=\"comment\">// 输出 [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>当然，由于这是JavaScript，你可以直接忽略你不关心的拖尾元素：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n\n<p>或其他元素：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(second); <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fourth); <span class=\"comment\">// 输出 4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-12-元组解构\"><a href=\"#1-12-元组解构\" class=\"headerlink\" title=\"1.12 元组解构\"></a>1.12 元组解构</h2><p>元组可以像数组一样被去结构化；去结构化的变量得到相应元组元素的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">tuple</span>: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>, <span class=\"built_in\">boolean</span>] = [<span class=\"number\">7</span>, <span class=\"string\">&quot;hello&quot;</span>, <span class=\"literal\">true</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = tuple; <span class=\"comment\">// a: number, b: string, c: boolean</span></span><br></pre></td></tr></table></figure>\n\n<p>对一个元组进行解构，超出其元素的范围是一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c, d] = tuple; <span class=\"comment\">// 错误，索引3处没有元素</span></span><br></pre></td></tr></table></figure>\n\n<p>和数组一样，你可以用<code>...</code>对元组的其余部分进行解构，以得到一个更短的元组：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, ...bc] = tuple; <span class=\"comment\">// bc: [string, boolean]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c, ...d] = tuple; <span class=\"comment\">// d: [], 空 tuple</span></span><br></pre></td></tr></table></figure>\n\n<p>或者忽略尾部元素，或者忽略其他元素：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a] = tuple; <span class=\"comment\">// a: number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [, b] = tuple; <span class=\"comment\">// b: string</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-13-对象解构\"><a href=\"#1-13-对象解构\" class=\"headerlink\" title=\"1.13 对象解构\"></a>1.13 对象解构</h2><p>你也可以做对象的结构：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;foo&quot;</span>, <span class=\"attr\">b</span>: <span class=\"number\">12</span>, <span class=\"attr\">c</span>: <span class=\"string\">&quot;bar&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<p>这就从<code>o.a</code>和<code>o.b</code>中创建了新的变量<code>a</code>和<code>b</code>。注意，如果你不需要<code>c</code>，你可以跳过它。</p>\n<p>就像数组去结构化一样，你可以不用声明就进行赋值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">(&#123; a, b &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;baz&quot;</span>, <span class=\"attr\">b</span>: <span class=\"number\">101</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，我们必须用圆括号包围这个语句。JavaScript通常将{作为块的开始来解析。</p>\n<p>你可以使用语法<code>...</code>为对象中的剩余项目创建一个变量：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.<span class=\"property\">b</span> + passthrough.<span class=\"property\">c</span>.<span class=\"property\">length</span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>属性重命名</li>\n</ol>\n<p>你也可以给属性起不同的名字：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">a</span>: newName1, <span class=\"attr\">b</span>: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<p>这里的语法开始变得混乱了。你可以把<code>a: newName1</code>读作 <code>&quot;a as newName1&quot;</code>。方向是从左到右，就像你写的一样：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.<span class=\"property\">a</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.<span class=\"property\">b</span>;</span><br></pre></td></tr></table></figure>\n\n<p>令人困惑的是，这里的冒号并不表示类型。如果你指定了类型，仍然需要写在整个结构解构之后。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125;: &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">b</span>: <span class=\"built_in\">number</span> &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>默认值</li>\n</ol>\n<p>默认值让你指定一个默认值，以防一个属性未被定义。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">keepWholeObject</span>(<span class=\"params\"><span class=\"attr\">wholeObject</span>: &#123; a: <span class=\"built_in\">string</span>; b?: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>b?</code> 表示<code>b</code>是可选的，所以它可能是未定义的。 <code>keepWholeObject</code>现在有一个<code>wholeObject</code>的变量，以及属性<code>a</code>和<code>b</code>，即使<code>b</code>是未定义的。</p>\n<h2 id=\"1-14-Function-声明\"><a href=\"#1-14-Function-声明\" class=\"headerlink\" title=\"1.14 Function 声明\"></a>1.14 Function 声明</h2><p>去结构化在函数声明中也起作用。对于简单的情况，这是很直接的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">b</span>?: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是对于参数来说，指定默认值是比较常见的，而用解构的方式来获得默认值是很棘手的。首先，你需要记住把模式放在默认值之前。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">&#123; a = <span class=\"string\">&quot;&quot;</span>, b = <span class=\"number\">0</span> &#125; = &#123;&#125;</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure>\n\n<p>然后，你需要记住在<code>destructured</code>属性上给可选属性一个默认值，而不是主初始化器。记住，<code>C</code>的定义是<code>b</code>可选的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">&#123; a, b = <span class=\"number\">0</span> &#125; = &#123; a: <span class=\"string\">&quot;&quot;</span> &#125;</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(&#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;yes&quot;</span> &#125;); <span class=\"comment\">// 正确，b = 0</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(); <span class=\"comment\">// 正确, 默认 &#123; a: &quot;&quot; &#125;, 然后默认为 b = 0</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(&#123;&#125;); <span class=\"comment\">// 错误，如果你提供一个参数，&#x27;a&#x27;是必须的</span></span><br></pre></td></tr></table></figure>\n\n<p>小心使用解构。正如前面的例子所展示的，除了最简单的析构表达式之外，任何东西都会令人困惑。这在深度嵌套的结构化中尤其如此，即使不堆积重命名、默认值和类型注释，也会变得非常难以理解。尽量保持结构化表达式的小而简单。你总是可以自己写出解构会产生的赋值。</p>\n<h2 id=\"1-15-展开\"><a href=\"#1-15-展开\" class=\"headerlink\" title=\"1.15 展开\"></a>1.15 展开</h2><p>展开操作符与解构相反。它允许你将一个数组分散到另一个数组中，或者将一个对象分散到另一个对象中。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>这使<code>bothPlus</code>的值为<code>[0, 1, 2, 3, 4, 5]</code>。展开创建 <code>first</code> 和 <code>second</code> 的浅层拷贝。它们不会因为展开而改变。</p>\n<p>你也可以展开对象。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123;</span><br><span class=\"line\">  <span class=\"attr\">food</span>: <span class=\"string\">&quot;spicy&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">price</span>: <span class=\"string\">&quot;$$&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">ambiance</span>: <span class=\"string\">&quot;noisy&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123;</span><br><span class=\"line\">  ...defaults,</span><br><span class=\"line\">  <span class=\"attr\">food</span>: <span class=\"string\">&quot;rich&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>现在的 <code>search</code> 是 <code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。对象展开比数组展开更复杂。像数组展开一样，它从左到右进行，但结果仍然是一个对象。这意味着展开对象中较晚出现的属性会覆盖较早出现的属性。因此，如果我们修改前面的例子，在最后展开：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123;</span><br><span class=\"line\">  <span class=\"attr\">food</span>: <span class=\"string\">&quot;spicy&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">price</span>: <span class=\"string\">&quot;$$&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">ambiance</span>: <span class=\"string\">&quot;noisy&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123;</span><br><span class=\"line\">  <span class=\"attr\">food</span>: <span class=\"string\">&quot;rich&quot;</span>,</span><br><span class=\"line\">  ...defaults,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后，<code>defaults</code>中的食物属性覆盖了<code>food: &quot;rich&quot;</code>，这不是我们在这种情况下想要的。</p>\n<p>对象传播也有其他一些令人惊讶的限制。首先，它只包括一个对象 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\">自己的、可列举的属性</a>。基本上，这意味着当你传播一个对象的实例时，你会失去方法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  p = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"title function_\">m</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> <span class=\"title function_\">C</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = &#123;</span><br><span class=\"line\">  ...c,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">clone.<span class=\"property\">p</span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">clone.<span class=\"title function_\">m</span>(); <span class=\"comment\">// 错误!</span></span><br></pre></td></tr></table></figure>\n\n<p>TypeScript编译器不允许从通用函数中展开类型参数。该功能预计将在未来的语言版本中出现。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"一、变量声明\"><a href=\"#一、变量声明\" class=\"headerlink\" title=\"一、变量声明\"></a>一、变量声明</h1><p><code>let</code>和<code>const</code>是JavaScript中变量声明的两个相对较新的概念。正如我们前面提到的，<code>let</code>在某些方面与<code>var</code>相似，但允许用户避免在JavaScript中遇到的一些常见的 “麻烦”。</p>\n<p><code>const</code>是<code>let</code>的一个扩展，它可以防止重新赋值给一个变量。</p>\n<p>由于TypeScript是JavaScript的扩展，该语言自然支持<code>let</code>和<code>const</code>。在这里，我们将进一步阐述这些新的声明，以及为什么它们比<code>var</code>更适合。</p>\n<p>如果你已经不经意地使用了JavaScript，那么下一节可能是刷新你记忆的一个好方法。如果你对JavaScript中<code>var</code>声明的所有怪癖非常熟悉，你可能会发现跳过前面会更容易。</p>\n<h2 id=\"1-1-var-变量声明\"><a href=\"#1-1-var-变量声明\" class=\"headerlink\" title=\"1.1 var 变量声明\"></a>1.1 var 变量声明</h2><p>在JavaScript中声明一个变量，传统上都是用<code>var</code>关键字来完成。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<p>正如你可能已经发现的，我们刚刚声明了一个名为<code>a</code>的变量，其值为<code>10</code>。</p>\n<p>我们也可以在一个函数中声明一个变量：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而我们也可以在其他函数中访问这些相同的变量：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">g</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = <span class=\"title function_\">f</span>();</span><br><span class=\"line\"><span class=\"title function_\">g</span>(); <span class=\"comment\">// returns &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面这个例子中，<code>g</code>捕获了<code>f</code>中声明的变量<code>a</code>。在<code>g</code>被调用的任何时候，<code>a</code>的值都将与<code>f</code>中<code>a</code>的值相联系。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  a = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"title function_\">g</span>();</span><br><span class=\"line\">  a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">g</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(); <span class=\"comment\">// returns &#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-作用域规则\"><a href=\"#1-2-作用域规则\" class=\"headerlink\" title=\"1.2 作用域规则\"></a>1.2 作用域规则</h2><p>对于那些习惯于其他语言的人来说，<code>var</code>声明有一些奇怪的作用域范围规则。以下面的例子为例：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">shouldInitialize</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// 返回 &#x27;10&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">false</span>); <span class=\"comment\">// 返回 &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>有些读者可能会对这个例子产生怀疑。变量<code>x</code>是在<code>if</code>块中声明的，但我们却能从该块之外访问它。这是因为<code>var</code>声明可以在其包含的函数、模块、命名空间或全局范围内的任何地方访问（所有这些我们将在后面讨论），而不考虑包含的块。有些人把这称为<code>var</code>作用域或函数作用域。参数也是函数作用域。</p>\n<p>这些作用域规则会导致几种类型的错误。它们加剧的一个问题是，多次声明同一个变量并不是一个错误。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sumMatrix</span>(<span class=\"params\"><span class=\"attr\">matrix</span>: <span class=\"built_in\">number</span>[][]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也许对于一些有经验的JavaScript开发者来说，这很容易被发现，但是内部<code>for-loop</code>会意外地覆盖变量<code>i</code>，因为<code>i</code>指的是同一个函数范围的变量。正如有经验的开发者现在所知道的，类似的各种bug会在代码审查中溜走，并会成为无尽的挫折来源。</p>\n<h2 id=\"1-3-变量捕获的怪癖\"><a href=\"#1-3-变量捕获的怪癖\" class=\"headerlink\" title=\"1.3 变量捕获的怪癖\"></a>1.3 变量捕获的怪癖</h2><p>花点时间猜一猜下面这段话的输出是什么：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于那些不熟悉的人来说，<code>setTimeout</code>将尝试在一定数量的毫秒后执行一个函数（尽管要等待其他东西停止运行）。</p>\n<p>准备好了吗？看看吧。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n\n<p>许多JavaScript开发人员对这种行为非常熟悉，但如果你感到惊讶，你肯定不是一个人。大多数人都希望输出的结果是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td></tr></table></figure>\n\n<p>还记得我们前面提到的关于变量捕获的问题吗？我们传递给<code>setTimeout</code>的每个函数表达式实际上都是指同一范围内的同一个<code>i</code>。</p>\n<p>让我们花点时间考虑一下这意味着什么。 <code>setTimeout</code>将在若干毫秒之后运行一个函数，但只有在<code>for</code>循环停止执行之后；当<code>for</code>循环停止执行时，<code>i</code>的值是<code>10</code>。因此，每次给定的函数被调用时，它将打印出<code>10</code>!</p>\n<p>一个常见的解决方法是使用IIFE–一个立即调用的函数表达式–来捕获每次迭代的<code>i</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过调用一个带有其当前值的函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 捕捉&#x27;i&#x27;的当前状态</span></span><br><span class=\"line\">  (<span class=\"keyword\">function</span> (<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">  &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种看起来很奇怪的模式其实是很常见的。参数列表中的 <code>i</code> 实际上是对 <code>for</code> 循环中声明的 <code>i</code> 的影子，但由于我们对它们的命名相同，所以我们不必对循环体进行过多的修改。</p>\n<h2 id=\"1-4-let-变量声明\"><a href=\"#1-4-let-变量声明\" class=\"headerlink\" title=\"1.4 let 变量声明\"></a>1.4 let 变量声明</h2><p>现在你已经发现<code>var</code>有一些问题，这正是<code>let</code>语句被引入的原因。除了使用的关键字外，<code>let</code>语句的写法与<code>var</code>语句相同。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>关键的区别不在语法上，而在语义上，我们现在要深入研究。</p>\n<h2 id=\"1-5-块级作用域\"><a href=\"#1-5-块级作用域\" class=\"headerlink\" title=\"1.5 块级作用域\"></a>1.5 块级作用域</h2><p>当一个变量使用<code>let</code>声明时，它使用了一些人所说的词法范围或块法范围。与用<code>var</code>声明的变量不同，<code>block-scope</code>变量的作用域会泄露给其包含的函数，而在其最近的包含块或<code>for-loop</code>之外是不可见的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">input</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 引用&#x27;a&#x27;仍然可以</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 错误：这里不存在&#x27;b&#x27;。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，我们有两个局部变量<code>a</code>和<code>b</code>。<code>a</code>的作用域仅限于<code>f</code>的主体，而<code>b</code>的作用域仅限于包含<code>if</code>语句的块。</p>\n<p>在<code>catch</code>子句中声明的变量也有类似的作用域规则。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">&quot;oh no!&quot;</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Oh well.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Error: 这里不存在&#x27;e&#x27;。</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e);</span><br></pre></td></tr></table></figure>\n\n<p>块级作用域变量的另一个属性是，在它们被实际声明之前，它们不能被读或写到。虽然这些变量在它们的整个作用域中都是 “存在 “的，但是直到它们被声明之前的所有点都是它们的时间死角的一部分。这只是一种复杂的说法，你不能在<code>let</code>语句之前访问它们，幸运的是TypeScript会让你知道这一点。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">a++; <span class=\"comment\">// 在声明之前使用&#x27;a&#x27;是非法的。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，你仍然可以在声明之前<em>捕获</em>一个块范围的变量。唯一的问题是，在声明之前调用该函数是非法的。如果以ES2015为目标，现代运行时将抛出一个错误；然而，现在TypeScript是允许的，不会将此作为一个错误报告。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 可以捕捉到 &quot;a&quot;。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在声明&#x27;a&#x27;之前非法调用&#x27;foo&#x27;。</span></span><br><span class=\"line\"><span class=\"comment\">// runtimes应该在这里抛出一个错误</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n\n<p>For more information on temporal dead zones, see relevant content on the <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\">Mozilla Developer Network</a>.</p>\n<p>关于时空死角的更多信息，请看 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\">Mozilla开发者网络</a>上的相关内容。</p>\n<h2 id=\"1-6-重复声明和投影\"><a href=\"#1-6-重复声明和投影\" class=\"headerlink\" title=\"1.6 重复声明和投影\"></a>1.6 重复声明和投影</h2><p>对于var声明，我们提到，你声明了多少次变量并不重要，你只是得到了一个。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，所有关于<code>x</code>的声明实际上指的是同一个<code>x</code>，这是完全有效的。这往往会成为错误的根源。值得庆幸的是，<code>let</code>的声明并不那么宽容。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span>; <span class=\"comment\">// 错误：不能在同一范围内重新声明&#x27;x&#x27;。</span></span><br></pre></td></tr></table></figure>\n\n<p>变量不一定要都是块范围的，TypeScript才会告诉我们有一个问题。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// 错误：干扰了参数声明</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">g</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// 错误：不能同时有&#x27;x&#x27;的声明</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这并不是说一个块作用域变量永远不能和一个函数作用域变量一起声明。区块作用域变量只是需要在一个明显不同的区块中声明。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">condition, x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">false</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 返回 &#x27;0&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(<span class=\"literal\">true</span>, <span class=\"number\">0</span>); <span class=\"comment\">// 返回 &#x27;100&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在一个更加嵌套的作用域中引入一个新名字的行为被称为投影。这是一把双刃剑，因为它可以在意外影射的情况下自行引入某些错误，同时也可以防止某些错误。例如，想象一下我们之前用<code>let</code>变量编写的<code>sumMatrix函</code>数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sumMatrix</span>(<span class=\"params\"><span class=\"attr\">matrix</span>: <span class=\"built_in\">number</span>[][]</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个版本的循环实际上会正确地执行求和，因为内循环的 <code>i</code> 会对外循环的 <code>i</code> 产生阴影。</p>\n<p>为了写出更清晰的代码，通常应避免使用投影。虽然在某些情况下，利用它可能是合适的，但你应该使用你的最佳判断。</p>\n<h2 id=\"1-7-块级作用域变量捕获\"><a href=\"#1-7-块级作用域变量捕获\" class=\"headerlink\" title=\"1.7 块级作用域变量捕获\"></a>1.7 块级作用域变量捕获</h2><p>当我们第一次触及用<code>var</code>声明捕获变量的想法时，我们简要地讨论了变量一旦被捕获是如何行动的。为了给大家一个更好的直观印象，每次运行一个作用域时，它都会创建一个变量的 “环境”。这个环境和它捕获的变量甚至在它的作用域内的所有东西都执行完毕后仍然存在。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">theCityThatAlwaysSleeps</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> getCity;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> city = <span class=\"string\">&quot;Seattle&quot;</span>;</span><br><span class=\"line\">    getCity = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getCity</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们已经从它的环境中捕获了<code>city</code>，所以尽管 <code>if</code> 块已经执行完毕，我们仍然能够访问它。</p>\n<p>回想一下，在我们之前的<code>setTimeout</code>例子中，我们最终需要使用IIFE来捕获<code>for</code>循环的每个迭代中的变量状态。实际上，我们所做的是为我们捕获的变量创建一个新的变量环境。这有点麻烦，但幸运的是，在TypeScript中你再也不用这么做了。</p>\n<p>当声明为循环的一部分时，<code>let</code>声明的行为有很大的不同。这些声明并不只是给循环本身引入一个新的环境，而是在每个迭代中创建一个新的范围。因为这就是我们在IIFE中所做的事情，我们可以改变我们以前的<code>setTimeout</code>的例子，只使用<code>let</code>声明。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和预期的一样，这将打印出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-8-const声明\"><a href=\"#1-8-const声明\" class=\"headerlink\" title=\"1.8 const声明\"></a>1.8 <code>const</code>声明</h2><p><code>const</code>声明是声明变量的另一种方式。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<p>它们就像<code>let</code>声明一样，但正如它们的名字所暗示的，一旦它们被绑定，它们的值就不能被改变。换句话说，它们有和<code>let</code>一样的范围规则，但你不能重新赋值给它们。</p>\n<p>这不应该与它们所指的值是不可改变的想法相混淆。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;Aurora&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">numLives</span>: numLivesForCat,</span><br><span class=\"line\">&#125;; <span class=\"comment\">// 错误</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;Danielle&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">numLives</span>: numLivesForCat,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 以下都正确</span></span><br><span class=\"line\">kitty.<span class=\"property\">name</span> = <span class=\"string\">&quot;Rory&quot;</span>;</span><br><span class=\"line\">kitty.<span class=\"property\">name</span> = <span class=\"string\">&quot;Kitty&quot;</span>;</span><br><span class=\"line\">kitty.<span class=\"property\">name</span> = <span class=\"string\">&quot;Cat&quot;</span>;</span><br><span class=\"line\">kitty.<span class=\"property\">numLives</span>--;</span><br></pre></td></tr></table></figure>\n\n<p>除非你采取特定的措施来避免它，否则常量变量的内部状态仍然是可以修改的。幸运的是，TypeScript允许你指定一个对象的成员是 <code>readonly</code> 的。</p>\n<h2 id=\"1-9-let与const比较\"><a href=\"#1-9-let与const比较\" class=\"headerlink\" title=\"1.9 let与const比较\"></a>1.9 <code>let</code>与<code>const</code>比较</h2><p>鉴于我们有两种具有类似范围语义的声明，我们很自然地会问自己应该使用哪一种。像大多数广泛的问题一样，答案是：这取决于。</p>\n<p>根据最小特权原则，除了那些你打算修改的声明外，所有的声明都应该使用 const。其理由是，如果一个变量不需要被写入，那么在同一个代码库中工作的其他人就不应该自动能够写入该对象，他们需要考虑是否真的需要重新赋值给该变量。在推理数据流时，使用<code>const</code>也会使代码更可预测。</p>\n<p>使用你的最佳判断，如果适用的话，请与你的团队其他成员协商此事。</p>\n<p>本教程的大部分内容都使用<code>let</code>声明。</p>\n<h2 id=\"1-10-解构\"><a href=\"#1-10-解构\" class=\"headerlink\" title=\"1.10 解构\"></a>1.10 解构</h2><p>TypeScript拥有的另一个ECMAScript 2015特性是解构。关于完整的参考资料，请看<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">Mozilla开发者网络上的文章</a>。在本节中，我们将做一个简短的概述。</p>\n<h2 id=\"1-11-数组析构\"><a href=\"#1-11-数组析构\" class=\"headerlink\" title=\"1.11 数组析构\"></a>1.11 数组析构</h2><p>最简单的解构形式是数组解构赋值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(second); <span class=\"comment\">// 输出 2</span></span><br></pre></td></tr></table></figure>\n\n<p>这将创建两个新的变量，命名为 <code>first</code> 和 <code>second</code>。这等同于使用索引，但要方便得多。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">first = input[<span class=\"number\">0</span>];</span><br><span class=\"line\">second = input[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<p>解构也适用于已经声明的变量。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 交换变量</span></span><br><span class=\"line\">[first, second] = [second, first];</span><br></pre></td></tr></table></figure>\n\n<p>而且是带参数的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(second);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>你可以使用语法 <code>...</code> 为列表中的剩余项目创建一个变量。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rest); <span class=\"comment\">// 输出 [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n\n<p>当然，由于这是JavaScript，你可以直接忽略你不关心的拖尾元素：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n\n<p>或其他元素：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(second); <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fourth); <span class=\"comment\">// 输出 4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-12-元组解构\"><a href=\"#1-12-元组解构\" class=\"headerlink\" title=\"1.12 元组解构\"></a>1.12 元组解构</h2><p>元组可以像数组一样被去结构化；去结构化的变量得到相应元组元素的类型：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">tuple</span>: [<span class=\"built_in\">number</span>, <span class=\"built_in\">string</span>, <span class=\"built_in\">boolean</span>] = [<span class=\"number\">7</span>, <span class=\"string\">&quot;hello&quot;</span>, <span class=\"literal\">true</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = tuple; <span class=\"comment\">// a: number, b: string, c: boolean</span></span><br></pre></td></tr></table></figure>\n\n<p>对一个元组进行解构，超出其元素的范围是一个错误：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c, d] = tuple; <span class=\"comment\">// 错误，索引3处没有元素</span></span><br></pre></td></tr></table></figure>\n\n<p>和数组一样，你可以用<code>...</code>对元组的其余部分进行解构，以得到一个更短的元组：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, ...bc] = tuple; <span class=\"comment\">// bc: [string, boolean]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c, ...d] = tuple; <span class=\"comment\">// d: [], 空 tuple</span></span><br></pre></td></tr></table></figure>\n\n<p>或者忽略尾部元素，或者忽略其他元素：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a] = tuple; <span class=\"comment\">// a: number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [, b] = tuple; <span class=\"comment\">// b: string</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-13-对象解构\"><a href=\"#1-13-对象解构\" class=\"headerlink\" title=\"1.13 对象解构\"></a>1.13 对象解构</h2><p>你也可以做对象的结构：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;foo&quot;</span>, <span class=\"attr\">b</span>: <span class=\"number\">12</span>, <span class=\"attr\">c</span>: <span class=\"string\">&quot;bar&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<p>这就从<code>o.a</code>和<code>o.b</code>中创建了新的变量<code>a</code>和<code>b</code>。注意，如果你不需要<code>c</code>，你可以跳过它。</p>\n<p>就像数组去结构化一样，你可以不用声明就进行赋值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">(&#123; a, b &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;baz&quot;</span>, <span class=\"attr\">b</span>: <span class=\"number\">101</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>请注意，我们必须用圆括号包围这个语句。JavaScript通常将{作为块的开始来解析。</p>\n<p>你可以使用语法<code>...</code>为对象中的剩余项目创建一个变量：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.<span class=\"property\">b</span> + passthrough.<span class=\"property\">c</span>.<span class=\"property\">length</span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>属性重命名</li>\n</ol>\n<p>你也可以给属性起不同的名字：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">a</span>: newName1, <span class=\"attr\">b</span>: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<p>这里的语法开始变得混乱了。你可以把<code>a: newName1</code>读作 <code>&quot;a as newName1&quot;</code>。方向是从左到右，就像你写的一样：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.<span class=\"property\">a</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.<span class=\"property\">b</span>;</span><br></pre></td></tr></table></figure>\n\n<p>令人困惑的是，这里的冒号并不表示类型。如果你指定了类型，仍然需要写在整个结构解构之后。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125;: &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">b</span>: <span class=\"built_in\">number</span> &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>默认值</li>\n</ol>\n<p>默认值让你指定一个默认值，以防一个属性未被定义。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">keepWholeObject</span>(<span class=\"params\"><span class=\"attr\">wholeObject</span>: &#123; a: <span class=\"built_in\">string</span>; b?: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>b?</code> 表示<code>b</code>是可选的，所以它可能是未定义的。 <code>keepWholeObject</code>现在有一个<code>wholeObject</code>的变量，以及属性<code>a</code>和<code>b</code>，即使<code>b</code>是未定义的。</p>\n<h2 id=\"1-14-Function-声明\"><a href=\"#1-14-Function-声明\" class=\"headerlink\" title=\"1.14 Function 声明\"></a>1.14 Function 声明</h2><p>去结构化在函数声明中也起作用。对于简单的情况，这是很直接的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">b</span>?: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是对于参数来说，指定默认值是比较常见的，而用解构的方式来获得默认值是很棘手的。首先，你需要记住把模式放在默认值之前。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">&#123; a = <span class=\"string\">&quot;&quot;</span>, b = <span class=\"number\">0</span> &#125; = &#123;&#125;</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure>\n\n<p>然后，你需要记住在<code>destructured</code>属性上给可选属性一个默认值，而不是主初始化器。记住，<code>C</code>的定义是<code>b</code>可选的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">&#123; a, b = <span class=\"number\">0</span> &#125; = &#123; a: <span class=\"string\">&quot;&quot;</span> &#125;</span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>(&#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;yes&quot;</span> &#125;); <span class=\"comment\">// 正确，b = 0</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(); <span class=\"comment\">// 正确, 默认 &#123; a: &quot;&quot; &#125;, 然后默认为 b = 0</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(&#123;&#125;); <span class=\"comment\">// 错误，如果你提供一个参数，&#x27;a&#x27;是必须的</span></span><br></pre></td></tr></table></figure>\n\n<p>小心使用解构。正如前面的例子所展示的，除了最简单的析构表达式之外，任何东西都会令人困惑。这在深度嵌套的结构化中尤其如此，即使不堆积重命名、默认值和类型注释，也会变得非常难以理解。尽量保持结构化表达式的小而简单。你总是可以自己写出解构会产生的赋值。</p>\n<h2 id=\"1-15-展开\"><a href=\"#1-15-展开\" class=\"headerlink\" title=\"1.15 展开\"></a>1.15 展开</h2><p>展开操作符与解构相反。它允许你将一个数组分散到另一个数组中，或者将一个对象分散到另一个对象中。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>这使<code>bothPlus</code>的值为<code>[0, 1, 2, 3, 4, 5]</code>。展开创建 <code>first</code> 和 <code>second</code> 的浅层拷贝。它们不会因为展开而改变。</p>\n<p>你也可以展开对象。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123;</span><br><span class=\"line\">  <span class=\"attr\">food</span>: <span class=\"string\">&quot;spicy&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">price</span>: <span class=\"string\">&quot;$$&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">ambiance</span>: <span class=\"string\">&quot;noisy&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123;</span><br><span class=\"line\">  ...defaults,</span><br><span class=\"line\">  <span class=\"attr\">food</span>: <span class=\"string\">&quot;rich&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>现在的 <code>search</code> 是 <code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。对象展开比数组展开更复杂。像数组展开一样，它从左到右进行，但结果仍然是一个对象。这意味着展开对象中较晚出现的属性会覆盖较早出现的属性。因此，如果我们修改前面的例子，在最后展开：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123;</span><br><span class=\"line\">  <span class=\"attr\">food</span>: <span class=\"string\">&quot;spicy&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">price</span>: <span class=\"string\">&quot;$$&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">ambiance</span>: <span class=\"string\">&quot;noisy&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123;</span><br><span class=\"line\">  <span class=\"attr\">food</span>: <span class=\"string\">&quot;rich&quot;</span>,</span><br><span class=\"line\">  ...defaults,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后，<code>defaults</code>中的食物属性覆盖了<code>food: &quot;rich&quot;</code>，这不是我们在这种情况下想要的。</p>\n<p>对象传播也有其他一些令人惊讶的限制。首先，它只包括一个对象 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\">自己的、可列举的属性</a>。基本上，这意味着当你传播一个对象的实例时，你会失去方法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  p = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"title function_\">m</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> <span class=\"title function_\">C</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = &#123;</span><br><span class=\"line\">  ...c,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">clone.<span class=\"property\">p</span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">clone.<span class=\"title function_\">m</span>(); <span class=\"comment\">// 错误!</span></span><br></pre></td></tr></table></figure>\n\n<p>TypeScript编译器不允许从通用函数中展开类型参数。该功能预计将在未来的语言版本中出现。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-5、高级篇：Symbols",
        "toc": true,
        "abbrlink": 48835,
        "date": "2024-01-28T13:07:17.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 五、Symbols\n\n从ECMAScript 2015开始，`symbol`是一种原始的数据类型，就像 `number` 和 `string` 一样。\n\n`symbol` 值是通过调用 `Symbol`构造函数创建的。\n\n```tsx\nlet sym1 = Symbol();\nlet sym2 = Symbol(\"key\"); // 可选的字符串 key\n```\n\nSymbols 是不可改变的，而且是独一无二的。\n\n```tsx\nlet sym2 = Symbol(\"key\");\nlet sym3 = Symbol(\"key\");\nsym2 === sym3; // false, symbols 是唯一的\n```\n\n就像字符串一样，Symbols 可以被用作对象属性的键。\n\n```tsx\nconst sym = Symbol();\nlet obj = {\n  [sym]: \"value\",\n};\nconsole.log(obj[sym]); // \"value\"\n```\n\nSymbols 也可以与计算属性声明结合起来，以声明对象属性和类成员。\n\n```tsx\nconst getClassNameSymbol = Symbol();\nclass C {\n  [getClassNameSymbol]() {\n    return \"C\";\n  }\n}\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"\n```\n\n## 5.1 `unique symbol`\n\n为了能够将 symbols 作为唯一的字面符号，我们提供了一个特殊的类型 `unique symbol`。 `unique symbol` 是 `symbol` 的一个子类型，只在调用 `Symbol()` 或 `Symbol.for()` 或明确的类型注释时产生。这种类型只允许在常量声明和只读静态属性中使用，为了引用一个特定的唯一符号，你必须使用 `typeof` 操作符。每个对唯一符号的引用都意味着一个完全独特的身份，它与一个给定的声明相联系。\n\n```tsx\ndeclare const sym1: unique symbol;\n// sym2只能是一个常数参考。\nlet sym2: unique symbol = Symbol();\n// Ⓧ 类型为 \"唯一符号 \"的变量必须是 \"const\"类型。\n\n// 运行正确--指的是一个独特的 symbol，但其身份与'sym1'相联系。\nlet sym3: typeof sym1 = sym1;\n\n// 也是正确的\nclass C {\n  static readonly StaticSymbol: unique symbol = Symbol();\n}\n```\n\n因为每个 `unique symbol` 都有一个完全独立的身份，没有两个 `unique symbol` 类型是可以相互分配或比较的。\n\n```tsx\nconst sym2 = Symbol();\nconst sym3 = Symbol();\n\n// 这个条件将总是返回'false'，因为'typeof sym2'和'typeof sym3'的类型没有重合。\nif (sym2 === sym3) {\n  // ...\n}\n```\n\n## 5.2 知名的 Symbols\n\n除了用户定义的 symbols 外，还有著名的内置 symbols。内置符号被用来表示内部语言行为。\n\n下面是一个著名的 symbols 列表：\n\n### 5.2.1 Symbol.hasInstance\n\n一个确定构造函数对象，是否识别一个对象为构造函数的实例之一的方法。由 `instanceof` 操作符的语义调用。\n\n### 5.2.2 Symbol.isConcatSpreadable\n\n一个布尔值，表示一个对象应该被 `Array.prototype.concat`平铺到其数组元素。\n\n### 5.2.3 Symbol.iterator\n\n返回一个对象的默认迭代器的方法。被 `for-of` 语句的语义所调用。\n\n### 5.2.4 Symbol.match\n\n一个正则表达式方法，与字符串的正则表达式相匹配。由 `String.prototype.match`方法调用。\n\n### 5.2.5 Symbol.replace\n\n一个正则表达式方法，用于替换一个字符串中匹配的子串。由`String.prototype.replace`方法调用。\n\n### 5.2.6 Symbol.search\n\n一个正则表达式方法，返回字符串中符合正则表达式的索引。由`String.prototype.search`方法调用。\n\n### 5.2.7 Symbol.species\n\n一个函数值的属性，是用于创建派生对象的构造函数。\n\n### 5.2.8 Symbol.split\n\n一个正则表达式方法，在符合正则表达式的索引处分割一个字符串。由 `String.prototype.split` 方法调用。\n\n### 5.2.9 Symbol.toPrimitive\n\n将一个对象转换为一个相应的基元值的方法。由 `ToPrimitive` 抽象操作调用。\n\n### 5.2.10 Symbol.toStringTag\n\n一个字符串值，用于创建一个对象的默认字符串描述。由内置方法`Object.prototype.toString`调用。\n\n### 5.2.11 Symbol.unscopables\n\n一个对象，其自身的属性名是被排除在相关对象的 'with' 环境绑定之外的属性名。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-5、高级篇：Symbols.md",
        "raw": "---\ntitle: 2-5、高级篇：Symbols\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 48835\ndate: 2024-01-28 21:07:17\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 五、Symbols\n\n从ECMAScript 2015开始，`symbol`是一种原始的数据类型，就像 `number` 和 `string` 一样。\n\n`symbol` 值是通过调用 `Symbol`构造函数创建的。\n\n```tsx\nlet sym1 = Symbol();\nlet sym2 = Symbol(\"key\"); // 可选的字符串 key\n```\n\nSymbols 是不可改变的，而且是独一无二的。\n\n```tsx\nlet sym2 = Symbol(\"key\");\nlet sym3 = Symbol(\"key\");\nsym2 === sym3; // false, symbols 是唯一的\n```\n\n就像字符串一样，Symbols 可以被用作对象属性的键。\n\n```tsx\nconst sym = Symbol();\nlet obj = {\n  [sym]: \"value\",\n};\nconsole.log(obj[sym]); // \"value\"\n```\n\nSymbols 也可以与计算属性声明结合起来，以声明对象属性和类成员。\n\n```tsx\nconst getClassNameSymbol = Symbol();\nclass C {\n  [getClassNameSymbol]() {\n    return \"C\";\n  }\n}\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"\n```\n\n## 5.1 `unique symbol`\n\n为了能够将 symbols 作为唯一的字面符号，我们提供了一个特殊的类型 `unique symbol`。 `unique symbol` 是 `symbol` 的一个子类型，只在调用 `Symbol()` 或 `Symbol.for()` 或明确的类型注释时产生。这种类型只允许在常量声明和只读静态属性中使用，为了引用一个特定的唯一符号，你必须使用 `typeof` 操作符。每个对唯一符号的引用都意味着一个完全独特的身份，它与一个给定的声明相联系。\n\n```tsx\ndeclare const sym1: unique symbol;\n// sym2只能是一个常数参考。\nlet sym2: unique symbol = Symbol();\n// Ⓧ 类型为 \"唯一符号 \"的变量必须是 \"const\"类型。\n\n// 运行正确--指的是一个独特的 symbol，但其身份与'sym1'相联系。\nlet sym3: typeof sym1 = sym1;\n\n// 也是正确的\nclass C {\n  static readonly StaticSymbol: unique symbol = Symbol();\n}\n```\n\n因为每个 `unique symbol` 都有一个完全独立的身份，没有两个 `unique symbol` 类型是可以相互分配或比较的。\n\n```tsx\nconst sym2 = Symbol();\nconst sym3 = Symbol();\n\n// 这个条件将总是返回'false'，因为'typeof sym2'和'typeof sym3'的类型没有重合。\nif (sym2 === sym3) {\n  // ...\n}\n```\n\n## 5.2 知名的 Symbols\n\n除了用户定义的 symbols 外，还有著名的内置 symbols。内置符号被用来表示内部语言行为。\n\n下面是一个著名的 symbols 列表：\n\n### 5.2.1 Symbol.hasInstance\n\n一个确定构造函数对象，是否识别一个对象为构造函数的实例之一的方法。由 `instanceof` 操作符的语义调用。\n\n### 5.2.2 Symbol.isConcatSpreadable\n\n一个布尔值，表示一个对象应该被 `Array.prototype.concat`平铺到其数组元素。\n\n### 5.2.3 Symbol.iterator\n\n返回一个对象的默认迭代器的方法。被 `for-of` 语句的语义所调用。\n\n### 5.2.4 Symbol.match\n\n一个正则表达式方法，与字符串的正则表达式相匹配。由 `String.prototype.match`方法调用。\n\n### 5.2.5 Symbol.replace\n\n一个正则表达式方法，用于替换一个字符串中匹配的子串。由`String.prototype.replace`方法调用。\n\n### 5.2.6 Symbol.search\n\n一个正则表达式方法，返回字符串中符合正则表达式的索引。由`String.prototype.search`方法调用。\n\n### 5.2.7 Symbol.species\n\n一个函数值的属性，是用于创建派生对象的构造函数。\n\n### 5.2.8 Symbol.split\n\n一个正则表达式方法，在符合正则表达式的索引处分割一个字符串。由 `String.prototype.split` 方法调用。\n\n### 5.2.9 Symbol.toPrimitive\n\n将一个对象转换为一个相应的基元值的方法。由 `ToPrimitive` 抽象操作调用。\n\n### 5.2.10 Symbol.toStringTag\n\n一个字符串值，用于创建一个对象的默认字符串描述。由内置方法`Object.prototype.toString`调用。\n\n### 5.2.11 Symbol.unscopables\n\n一个对象，其自身的属性名是被排除在相关对象的 'with' 环境绑定之外的属性名。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-5、高级篇：Symbols",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao6001b94v3fqbkcj16",
        "content": "<h1 id=\"五、Symbols\"><a href=\"#五、Symbols\" class=\"headerlink\" title=\"五、Symbols\"></a>五、Symbols</h1><p>从ECMAScript 2015开始，<code>symbol</code>是一种原始的数据类型，就像 <code>number</code> 和 <code>string</code> 一样。</p>\n<p><code>symbol</code> 值是通过调用 <code>Symbol</code>构造函数创建的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>); <span class=\"comment\">// 可选的字符串 key</span></span><br></pre></td></tr></table></figure>\n\n<p>Symbols 是不可改变的，而且是独一无二的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym3 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">sym2 === sym3; <span class=\"comment\">// false, symbols 是唯一的</span></span><br></pre></td></tr></table></figure>\n\n<p>就像字符串一样，Symbols 可以被用作对象属性的键。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [sym]: <span class=\"string\">&quot;value&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj[sym]); <span class=\"comment\">// &quot;value&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>Symbols 也可以与计算属性声明结合起来，以声明对象属性和类成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getClassNameSymbol = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  [getClassNameSymbol]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;C&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> <span class=\"title function_\">C</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> className = c[getClassNameSymbol](); <span class=\"comment\">// &quot;C&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-1-unique-symbol\"><a href=\"#5-1-unique-symbol\" class=\"headerlink\" title=\"5.1 unique symbol\"></a>5.1 <code>unique symbol</code></h2><p>为了能够将 symbols 作为唯一的字面符号，我们提供了一个特殊的类型 <code>unique symbol</code>。 <code>unique symbol</code> 是 <code>symbol</code> 的一个子类型，只在调用 <code>Symbol()</code> 或 <code>Symbol.for()</code> 或明确的类型注释时产生。这种类型只允许在常量声明和只读静态属性中使用，为了引用一个特定的唯一符号，你必须使用 <code>typeof</code> 操作符。每个对唯一符号的引用都意味着一个完全独特的身份，它与一个给定的声明相联系。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> <span class=\"attr\">sym1</span>: unique <span class=\"built_in\">symbol</span>;</span><br><span class=\"line\"><span class=\"comment\">// sym2只能是一个常数参考。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">sym2</span>: unique <span class=\"built_in\">symbol</span> = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"comment\">// Ⓧ 类型为 &quot;唯一符号 &quot;的变量必须是 &quot;const&quot;类型。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行正确--指的是一个独特的 symbol，但其身份与&#x27;sym1&#x27;相联系。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">sym3</span>: <span class=\"keyword\">typeof</span> sym1 = sym1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也是正确的</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"title class_\">StaticSymbol</span>: unique <span class=\"built_in\">symbol</span> = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为每个 <code>unique symbol</code> 都有一个完全独立的身份，没有两个 <code>unique symbol</code> 类型是可以相互分配或比较的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym2 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> sym3 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个条件将总是返回&#x27;false&#x27;，因为&#x27;typeof sym2&#x27;和&#x27;typeof sym3&#x27;的类型没有重合。</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (sym2 === sym3) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-知名的-Symbols\"><a href=\"#5-2-知名的-Symbols\" class=\"headerlink\" title=\"5.2 知名的 Symbols\"></a>5.2 知名的 Symbols</h2><p>除了用户定义的 symbols 外，还有著名的内置 symbols。内置符号被用来表示内部语言行为。</p>\n<p>下面是一个著名的 symbols 列表：</p>\n<h3 id=\"5-2-1-Symbol-hasInstance\"><a href=\"#5-2-1-Symbol-hasInstance\" class=\"headerlink\" title=\"5.2.1 Symbol.hasInstance\"></a>5.2.1 Symbol.hasInstance</h3><p>一个确定构造函数对象，是否识别一个对象为构造函数的实例之一的方法。由 <code>instanceof</code> 操作符的语义调用。</p>\n<h3 id=\"5-2-2-Symbol-isConcatSpreadable\"><a href=\"#5-2-2-Symbol-isConcatSpreadable\" class=\"headerlink\" title=\"5.2.2 Symbol.isConcatSpreadable\"></a>5.2.2 Symbol.isConcatSpreadable</h3><p>一个布尔值，表示一个对象应该被 <code>Array.prototype.concat</code>平铺到其数组元素。</p>\n<h3 id=\"5-2-3-Symbol-iterator\"><a href=\"#5-2-3-Symbol-iterator\" class=\"headerlink\" title=\"5.2.3 Symbol.iterator\"></a>5.2.3 Symbol.iterator</h3><p>返回一个对象的默认迭代器的方法。被 <code>for-of</code> 语句的语义所调用。</p>\n<h3 id=\"5-2-4-Symbol-match\"><a href=\"#5-2-4-Symbol-match\" class=\"headerlink\" title=\"5.2.4 Symbol.match\"></a>5.2.4 Symbol.match</h3><p>一个正则表达式方法，与字符串的正则表达式相匹配。由 <code>String.prototype.match</code>方法调用。</p>\n<h3 id=\"5-2-5-Symbol-replace\"><a href=\"#5-2-5-Symbol-replace\" class=\"headerlink\" title=\"5.2.5 Symbol.replace\"></a>5.2.5 Symbol.replace</h3><p>一个正则表达式方法，用于替换一个字符串中匹配的子串。由<code>String.prototype.replace</code>方法调用。</p>\n<h3 id=\"5-2-6-Symbol-search\"><a href=\"#5-2-6-Symbol-search\" class=\"headerlink\" title=\"5.2.6 Symbol.search\"></a>5.2.6 Symbol.search</h3><p>一个正则表达式方法，返回字符串中符合正则表达式的索引。由<code>String.prototype.search</code>方法调用。</p>\n<h3 id=\"5-2-7-Symbol-species\"><a href=\"#5-2-7-Symbol-species\" class=\"headerlink\" title=\"5.2.7 Symbol.species\"></a>5.2.7 Symbol.species</h3><p>一个函数值的属性，是用于创建派生对象的构造函数。</p>\n<h3 id=\"5-2-8-Symbol-split\"><a href=\"#5-2-8-Symbol-split\" class=\"headerlink\" title=\"5.2.8 Symbol.split\"></a>5.2.8 Symbol.split</h3><p>一个正则表达式方法，在符合正则表达式的索引处分割一个字符串。由 <code>String.prototype.split</code> 方法调用。</p>\n<h3 id=\"5-2-9-Symbol-toPrimitive\"><a href=\"#5-2-9-Symbol-toPrimitive\" class=\"headerlink\" title=\"5.2.9 Symbol.toPrimitive\"></a>5.2.9 Symbol.toPrimitive</h3><p>将一个对象转换为一个相应的基元值的方法。由 <code>ToPrimitive</code> 抽象操作调用。</p>\n<h3 id=\"5-2-10-Symbol-toStringTag\"><a href=\"#5-2-10-Symbol-toStringTag\" class=\"headerlink\" title=\"5.2.10 Symbol.toStringTag\"></a>5.2.10 Symbol.toStringTag</h3><p>一个字符串值，用于创建一个对象的默认字符串描述。由内置方法<code>Object.prototype.toString</code>调用。</p>\n<h3 id=\"5-2-11-Symbol-unscopables\"><a href=\"#5-2-11-Symbol-unscopables\" class=\"headerlink\" title=\"5.2.11 Symbol.unscopables\"></a>5.2.11 Symbol.unscopables</h3><p>一个对象，其自身的属性名是被排除在相关对象的 ‘with’ 环境绑定之外的属性名。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"五、Symbols\"><a href=\"#五、Symbols\" class=\"headerlink\" title=\"五、Symbols\"></a>五、Symbols</h1><p>从ECMAScript 2015开始，<code>symbol</code>是一种原始的数据类型，就像 <code>number</code> 和 <code>string</code> 一样。</p>\n<p><code>symbol</code> 值是通过调用 <code>Symbol</code>构造函数创建的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>); <span class=\"comment\">// 可选的字符串 key</span></span><br></pre></td></tr></table></figure>\n\n<p>Symbols 是不可改变的，而且是独一无二的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym3 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">sym2 === sym3; <span class=\"comment\">// false, symbols 是唯一的</span></span><br></pre></td></tr></table></figure>\n\n<p>就像字符串一样，Symbols 可以被用作对象属性的键。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [sym]: <span class=\"string\">&quot;value&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj[sym]); <span class=\"comment\">// &quot;value&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>Symbols 也可以与计算属性声明结合起来，以声明对象属性和类成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getClassNameSymbol = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  [getClassNameSymbol]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;C&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> <span class=\"title function_\">C</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> className = c[getClassNameSymbol](); <span class=\"comment\">// &quot;C&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-1-unique-symbol\"><a href=\"#5-1-unique-symbol\" class=\"headerlink\" title=\"5.1 unique symbol\"></a>5.1 <code>unique symbol</code></h2><p>为了能够将 symbols 作为唯一的字面符号，我们提供了一个特殊的类型 <code>unique symbol</code>。 <code>unique symbol</code> 是 <code>symbol</code> 的一个子类型，只在调用 <code>Symbol()</code> 或 <code>Symbol.for()</code> 或明确的类型注释时产生。这种类型只允许在常量声明和只读静态属性中使用，为了引用一个特定的唯一符号，你必须使用 <code>typeof</code> 操作符。每个对唯一符号的引用都意味着一个完全独特的身份，它与一个给定的声明相联系。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> <span class=\"attr\">sym1</span>: unique <span class=\"built_in\">symbol</span>;</span><br><span class=\"line\"><span class=\"comment\">// sym2只能是一个常数参考。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">sym2</span>: unique <span class=\"built_in\">symbol</span> = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"comment\">// Ⓧ 类型为 &quot;唯一符号 &quot;的变量必须是 &quot;const&quot;类型。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行正确--指的是一个独特的 symbol，但其身份与&#x27;sym1&#x27;相联系。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">sym3</span>: <span class=\"keyword\">typeof</span> sym1 = sym1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也是正确的</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"title class_\">StaticSymbol</span>: unique <span class=\"built_in\">symbol</span> = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为每个 <code>unique symbol</code> 都有一个完全独立的身份，没有两个 <code>unique symbol</code> 类型是可以相互分配或比较的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym2 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> sym3 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个条件将总是返回&#x27;false&#x27;，因为&#x27;typeof sym2&#x27;和&#x27;typeof sym3&#x27;的类型没有重合。</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (sym2 === sym3) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-知名的-Symbols\"><a href=\"#5-2-知名的-Symbols\" class=\"headerlink\" title=\"5.2 知名的 Symbols\"></a>5.2 知名的 Symbols</h2><p>除了用户定义的 symbols 外，还有著名的内置 symbols。内置符号被用来表示内部语言行为。</p>\n<p>下面是一个著名的 symbols 列表：</p>\n<h3 id=\"5-2-1-Symbol-hasInstance\"><a href=\"#5-2-1-Symbol-hasInstance\" class=\"headerlink\" title=\"5.2.1 Symbol.hasInstance\"></a>5.2.1 Symbol.hasInstance</h3><p>一个确定构造函数对象，是否识别一个对象为构造函数的实例之一的方法。由 <code>instanceof</code> 操作符的语义调用。</p>\n<h3 id=\"5-2-2-Symbol-isConcatSpreadable\"><a href=\"#5-2-2-Symbol-isConcatSpreadable\" class=\"headerlink\" title=\"5.2.2 Symbol.isConcatSpreadable\"></a>5.2.2 Symbol.isConcatSpreadable</h3><p>一个布尔值，表示一个对象应该被 <code>Array.prototype.concat</code>平铺到其数组元素。</p>\n<h3 id=\"5-2-3-Symbol-iterator\"><a href=\"#5-2-3-Symbol-iterator\" class=\"headerlink\" title=\"5.2.3 Symbol.iterator\"></a>5.2.3 Symbol.iterator</h3><p>返回一个对象的默认迭代器的方法。被 <code>for-of</code> 语句的语义所调用。</p>\n<h3 id=\"5-2-4-Symbol-match\"><a href=\"#5-2-4-Symbol-match\" class=\"headerlink\" title=\"5.2.4 Symbol.match\"></a>5.2.4 Symbol.match</h3><p>一个正则表达式方法，与字符串的正则表达式相匹配。由 <code>String.prototype.match</code>方法调用。</p>\n<h3 id=\"5-2-5-Symbol-replace\"><a href=\"#5-2-5-Symbol-replace\" class=\"headerlink\" title=\"5.2.5 Symbol.replace\"></a>5.2.5 Symbol.replace</h3><p>一个正则表达式方法，用于替换一个字符串中匹配的子串。由<code>String.prototype.replace</code>方法调用。</p>\n<h3 id=\"5-2-6-Symbol-search\"><a href=\"#5-2-6-Symbol-search\" class=\"headerlink\" title=\"5.2.6 Symbol.search\"></a>5.2.6 Symbol.search</h3><p>一个正则表达式方法，返回字符串中符合正则表达式的索引。由<code>String.prototype.search</code>方法调用。</p>\n<h3 id=\"5-2-7-Symbol-species\"><a href=\"#5-2-7-Symbol-species\" class=\"headerlink\" title=\"5.2.7 Symbol.species\"></a>5.2.7 Symbol.species</h3><p>一个函数值的属性，是用于创建派生对象的构造函数。</p>\n<h3 id=\"5-2-8-Symbol-split\"><a href=\"#5-2-8-Symbol-split\" class=\"headerlink\" title=\"5.2.8 Symbol.split\"></a>5.2.8 Symbol.split</h3><p>一个正则表达式方法，在符合正则表达式的索引处分割一个字符串。由 <code>String.prototype.split</code> 方法调用。</p>\n<h3 id=\"5-2-9-Symbol-toPrimitive\"><a href=\"#5-2-9-Symbol-toPrimitive\" class=\"headerlink\" title=\"5.2.9 Symbol.toPrimitive\"></a>5.2.9 Symbol.toPrimitive</h3><p>将一个对象转换为一个相应的基元值的方法。由 <code>ToPrimitive</code> 抽象操作调用。</p>\n<h3 id=\"5-2-10-Symbol-toStringTag\"><a href=\"#5-2-10-Symbol-toStringTag\" class=\"headerlink\" title=\"5.2.10 Symbol.toStringTag\"></a>5.2.10 Symbol.toStringTag</h3><p>一个字符串值，用于创建一个对象的默认字符串描述。由内置方法<code>Object.prototype.toString</code>调用。</p>\n<h3 id=\"5-2-11-Symbol-unscopables\"><a href=\"#5-2-11-Symbol-unscopables\" class=\"headerlink\" title=\"5.2.11 Symbol.unscopables\"></a>5.2.11 Symbol.unscopables</h3><p>一个对象，其自身的属性名是被排除在相关对象的 ‘with’ 环境绑定之外的属性名。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-4、高级篇：公共类型",
        "toc": true,
        "abbrlink": 13304,
        "date": "2024-01-28T13:06:33.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_01.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 四、 公共类型\n\nTypeScript 提供了几个实用类型，以促进常见的类型转换。这些实用程序在全局范围内可用。\n\n## 4.1 Partial`<Type>`\n\n构建一个类型，将 `Type` 的所有属性设置为可选。这个工具将返回一个表示给定类型的所有子集的类型。\n\n**例子：**\n\n```tsx\ninterface Todo {\n  title: string;\n  description: string;\n}\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n\nconst todo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\",\n};\n\nconst todo2 = updateTodo(todo1, {\n  description: \"throw out trash\",\n});\n```\n\n## 4.2 Required`<Type>`\n\n构建一个由 `Type` 的所有属性组成的类型，设置为必填。与 `Partial` 相反：\n\n```tsx\ninterface Props {\n  a?: number;\n  b?: string;\n}\n\nconst obj: Props = { a: 5 };\n\nconst obj2: Required<Props> = { a: 5 };\n```\n\n<img src=\"/img/TypeScript/11-01.png\" alt=\"image-20211223212409295\" style=\"zoom:50%;\" />\n\n## 4.3 Readonly<Type>\n\n构建一个类型，`Type` 的所有属性设置为 `readonly`，这意味着构建的类型的属性不能被重新设置值。\n\n```tsx\ninterface Todo {\n  title: string;\n}\n\nconst todo: Readonly<Todo> = {\n  title: \"Delete inactive users\",\n};\n\ntodo.title = \"Hello\";\n```\n\n<img src=\"/img/TypeScript/11-02.png\" alt=\"image-20211223212707668\" style=\"zoom: 67%;\" />\n\n这个工具对于表示将在运行时失败的赋值表达式很有用（即当试图重新分配一个 [冻结对象 ](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)的属性时）。\n\n```tsx\nfunction freeze<Type>(obj: Type): Readonly<Type>;\n```\n\n## 4.4 Record<Keys, Type>\n\n构建一个对象类型，其属性键是 `Keys`，其属性值是 `Type`。这个工具可以用来将一个类型的属性映射到另一个类型。\n\n```tsx\ninterface CatInfo {\n  age: number;\n  breed: string;\n}\n\ntype CatName = \"miffy\" | \"boris\" | \"mordred\";\n\nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: \"Persian\" },\n  boris: { age: 5, breed: \"Maine Coon\" },\n  mordred: { age: 16, breed: \"British Shorthair\" },\n};\n\n// const cats: Record<CatName, CatInfo>\ncats.boris;\n```\n\n## 4.5 Pick<Type, Keys>\n\n通过从 `Type `中选取属性集合`Keys`（属性名或属性名的联合）来构造一个类型。\n\n```tsx\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n\nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n\n// const todo: TodoPreview\ntodo;\n```\n\n## 4.6 Omit<Type, Keys>\n\n通过从 `Type` 中选取所有属性，然后删除 `Keys`（属性名或属性名的联合）来构造一个类型。\n\n```tsx\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n}\n\ntype TodoPreview = Omit<Todo, \"description\">;\n\nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n  createdAt: 1615544252770,\n};\n\n// const todo: TodoPreview\ntodo;\n\ntype TodoInfo = Omit<Todo, \"completed\" | \"createdAt\">;\n\nconst todoInfo: TodoInfo = {\n  title: \"Pick up kids\",\n  description: \"Kindergarten closes at 5pm\",\n};\n\n// const todoInfo: TodoInfo\ntodoInfo;\n```\n\n## 4.7 Exclude<Type, ExcludedUnion>\n\n通过从 `Type` 中排除所有可分配给 `ExcludedUnion` 的联盟成员来构造一个类型。\n\n```tsx\n// type T0 = \"b\" | \"c\"\ntype T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;\n\n// type T1 = \"c\"\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">;\n\n// type T2 = string | number\ntype T2 = Exclude<string | number | (() => void), Function>;\n```\n\n## 4.8 Extract<Type, Union>\n\n通过从 `Type` 中提取可分配给 `Union` 的所有 `union` 成员，构造一个类型。\n\n```tsx\n// type T0 = \"a\"\ntype T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;\n\n// type T1 = () => void\ntype T1 = Extract<string | number | (() => void), Function>;\n```\n\n## 4.9 NonNullable<Type>\n\n通过从 `Type` 中排除 `null`和`undefined`来构造一个类型。\n\n```tsx\n// type T0 = string | number\ntype T0 = NonNullable<string | number | undefined>;\n\n// type T1 = string[]\ntype T1 = NonNullable<string[] | null | undefined>;\n```\n\n## 4.10 Parameters<Type>\n\n从一个函数类型 `Type` 的参数中使用的类型构建一个元组类型。\n\n```tsx\ndeclare function f1(arg: { a: number; b: string }): void;\n\n// type T0 = []\ntype T0 = Parameters<() => string>;\n\n// type T1 = [s: string]\ntype T1 = Parameters<(s: string) => void>;\n\n// type T2 = [arg: unknown]\ntype T2 = Parameters<<T>(arg: T) => T>;\n\n/*\ntype T3 = [arg: {\n    a: number;\n    b: string;\n}]\n*/\ntype T3 = Parameters<typeof f1>;\n\n// type T4 = unknown[]\ntype T4 = Parameters<any>;\n\n// type T5 = never\ntype T5 = Parameters<never>;\n\n// type T6 = never\ntype T6 = Parameters<string>;\n\n// type T7 = never\ntype T7 = Parameters<Function>;\n```\n\n<img src=\"/img/TypeScript/11-03.png\" alt=\"image-20211224135715919\" style=\"zoom: 50%;\" />\n\n## 4.11 ConstructorParameters<Type>\n\n从构造函数的类型中构造一个元组或数组类型。它产生一个具有所有参数类型的元组类型（如果 `Type` 不是一个函数，则为 `never` 类型）。\n\n```tsx\n// type T0 = [message?: string]\ntype T0 = ConstructorParameters<ErrorConstructor>;\n\n// type T1 = string[]\ntype T1 = ConstructorParameters<FunctionConstructor>;\n\n// type T2 = [pattern: string | RegExp, flags?: string]\ntype T2 = ConstructorParameters<RegExpConstructor>;\n\n// type T3 = unknown[]\ntype T3 = ConstructorParameters<any>;\n\n// type T4 = never\ntype T4 = ConstructorParameters<Function>;\n```\n\n<img src=\"/img/TypeScript/11-4.png\" alt=\"image-20211224150128771\" style=\"zoom: 50%;\" />\n\n## 4.12 ReturnType<Type>\n\n构建一个由函数 `Type` 的返回类型组成的类型。\n\n```tsx\ndeclare function f1(): { a: number; b: string };\n// type T0 = string\ntype T0 = ReturnType<() => string>;\n\n// type T1 = void\ntype T1 = ReturnType<(s: string) => void>;\n\n// type T2 = unknown\ntype T2 = ReturnType<<T>() => T>;\n\n// type T3 = number[]\ntype T3 = ReturnType<<T extends U, U extends number[]>() => T>;\n\n/*\ntype T4 = {\n  a: number;\n  b: string;\n}\n*/\ntype T4 = ReturnType<typeof f1>;\n\n// type T5 = any\ntype T5 = ReturnType<any>;\n\n// type T6 = never\ntype T6 = ReturnType<never>;\n\n// type T7 = any 报错\ntype T7 = ReturnType<string>;\n\n// type T8 = any 报错\ntype T8 = ReturnType<Function>;\n```\n\n<img src=\"/img/TypeScript/11-05.png\" alt=\"image-20211224164920604\" style=\"zoom: 50%;\" />\n\n## 4.13 InstanceType<Type>\n\n构建一个由 `Type` 中构造函数的实例类型组成的类型。\n\n```tsx\nclass C {\n  x = 0;\n  y = 0;\n}\n\n// type T0 = C\ntype T0 = InstanceType<typeof C>;\n\n// type T1 = any\ntype T1 = InstanceType<any>;\n\n// type T2 = never\ntype T2 = InstanceType<never>;\n\n// type T3 = any\ntype T3 = InstanceType<string>;\n\n// type T4 = any\ntype T4 = InstanceType<Function>;\n```\n\n<img src=\"/img/TypeScript/11-07.png\" alt=\"image-20211224170431379\" style=\"zoom:50%;\" />\n\n## 4.14 ThisParameterType<Type>\n\n提取一个函数类型的`this`参数的类型，如果该函数类型没有 `this`参数，则为 `unknown`。\n\n```tsx\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n\nfunction numberToString(n: ThisParameterType<typeof toHex>) {\n  return toHex.apply(n);\n}\n```\n\n## 4.15 OmitThisParameter<Type>\n\n移除 `Type`的`this`参数。如果`Type`没有明确声明的`this`参数，结果只是`Type`。否则，一个没有`this`参数的新函数类型将从`Type`创建。泛型被擦除，只有最后的重载签名被传播到新的函数类型。\n\n```tsx\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n\nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n\nconsole.log(fiveToHex());\n```\n\n## 4.16 ThisType<Type>\n\n这个工具并不返回一个转换后的类型。相反，它作为一个上下文的 `this` 类型的标记。注意，必须启用`noImplicitThis` 标志才能使用这个工具。\n\n```tsx\ntype ObjectDescriptor<D, M> = {\n  data?: D;\n  methods?: M & ThisType<D & M>; // 方法中的 'this' 类型是 D & M\n};\n\nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n  let data: object = desc.data || {};\n  let methods: object = desc.methods || {};\n  return { ...data, ...methods } as D & M;\n}\n\nlet obj = makeObject({\n  data: { x: 0, y: 0 },\n  methods: {\n    moveBy(dx: number, dy: number) {\n      this.x += dx;\n      this.y += dy;\n    },\n  },\n});\n\nobj.x = 10;\nobj.y = 20;\nobj.moveBy(5, 5);\n```\n\n在上面的例子中，makeObject的参数中的 `methods` 对象有一个包括 `ThisType<D & M>` 的上下文类型，因此方法对象中 `this` 的类型是 `{ x: number, y: number } & { moveBy(dx: number, dy: number): number }`。注意 `methods` 属性的类型如何同时是推理目标和方法中 `this` 类型的来源。\n\n`ThisType<T>`标记接口只是在`lib.d.ts`中声明的一个空接口。除了在对象字面的上下文类型中被识别之外，该接口的行为与任何空接口一样。\n\n## 4.17 字符串操作类型\n\n### `Uppercase<StringType>`\n\n### `Lowercase<StringType>`\n\n### `Capitalize<StringType>`\n\n### `Uncapitalize<StringType>`\n\nTypeScript包括一组类型，可以在类型系统中用于字符串操作。你可以在 [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype) 文档中找到这些工具的用法。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-4、高级篇：公共类型.md",
        "raw": "---\ntitle: 2-4、高级篇：公共类型\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 13304\ndate: 2024-01-28 21:06:33\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 四、 公共类型\n\nTypeScript 提供了几个实用类型，以促进常见的类型转换。这些实用程序在全局范围内可用。\n\n## 4.1 Partial`<Type>`\n\n构建一个类型，将 `Type` 的所有属性设置为可选。这个工具将返回一个表示给定类型的所有子集的类型。\n\n**例子：**\n\n```tsx\ninterface Todo {\n  title: string;\n  description: string;\n}\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n\nconst todo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\",\n};\n\nconst todo2 = updateTodo(todo1, {\n  description: \"throw out trash\",\n});\n```\n\n## 4.2 Required`<Type>`\n\n构建一个由 `Type` 的所有属性组成的类型，设置为必填。与 `Partial` 相反：\n\n```tsx\ninterface Props {\n  a?: number;\n  b?: string;\n}\n\nconst obj: Props = { a: 5 };\n\nconst obj2: Required<Props> = { a: 5 };\n```\n\n<img src=\"/img/TypeScript/11-01.png\" alt=\"image-20211223212409295\" style=\"zoom:50%;\" />\n\n## 4.3 Readonly<Type>\n\n构建一个类型，`Type` 的所有属性设置为 `readonly`，这意味着构建的类型的属性不能被重新设置值。\n\n```tsx\ninterface Todo {\n  title: string;\n}\n\nconst todo: Readonly<Todo> = {\n  title: \"Delete inactive users\",\n};\n\ntodo.title = \"Hello\";\n```\n\n<img src=\"/img/TypeScript/11-02.png\" alt=\"image-20211223212707668\" style=\"zoom: 67%;\" />\n\n这个工具对于表示将在运行时失败的赋值表达式很有用（即当试图重新分配一个 [冻结对象 ](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)的属性时）。\n\n```tsx\nfunction freeze<Type>(obj: Type): Readonly<Type>;\n```\n\n## 4.4 Record<Keys, Type>\n\n构建一个对象类型，其属性键是 `Keys`，其属性值是 `Type`。这个工具可以用来将一个类型的属性映射到另一个类型。\n\n```tsx\ninterface CatInfo {\n  age: number;\n  breed: string;\n}\n\ntype CatName = \"miffy\" | \"boris\" | \"mordred\";\n\nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: \"Persian\" },\n  boris: { age: 5, breed: \"Maine Coon\" },\n  mordred: { age: 16, breed: \"British Shorthair\" },\n};\n\n// const cats: Record<CatName, CatInfo>\ncats.boris;\n```\n\n## 4.5 Pick<Type, Keys>\n\n通过从 `Type `中选取属性集合`Keys`（属性名或属性名的联合）来构造一个类型。\n\n```tsx\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n\nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n\n// const todo: TodoPreview\ntodo;\n```\n\n## 4.6 Omit<Type, Keys>\n\n通过从 `Type` 中选取所有属性，然后删除 `Keys`（属性名或属性名的联合）来构造一个类型。\n\n```tsx\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: number;\n}\n\ntype TodoPreview = Omit<Todo, \"description\">;\n\nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n  createdAt: 1615544252770,\n};\n\n// const todo: TodoPreview\ntodo;\n\ntype TodoInfo = Omit<Todo, \"completed\" | \"createdAt\">;\n\nconst todoInfo: TodoInfo = {\n  title: \"Pick up kids\",\n  description: \"Kindergarten closes at 5pm\",\n};\n\n// const todoInfo: TodoInfo\ntodoInfo;\n```\n\n## 4.7 Exclude<Type, ExcludedUnion>\n\n通过从 `Type` 中排除所有可分配给 `ExcludedUnion` 的联盟成员来构造一个类型。\n\n```tsx\n// type T0 = \"b\" | \"c\"\ntype T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;\n\n// type T1 = \"c\"\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">;\n\n// type T2 = string | number\ntype T2 = Exclude<string | number | (() => void), Function>;\n```\n\n## 4.8 Extract<Type, Union>\n\n通过从 `Type` 中提取可分配给 `Union` 的所有 `union` 成员，构造一个类型。\n\n```tsx\n// type T0 = \"a\"\ntype T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;\n\n// type T1 = () => void\ntype T1 = Extract<string | number | (() => void), Function>;\n```\n\n## 4.9 NonNullable<Type>\n\n通过从 `Type` 中排除 `null`和`undefined`来构造一个类型。\n\n```tsx\n// type T0 = string | number\ntype T0 = NonNullable<string | number | undefined>;\n\n// type T1 = string[]\ntype T1 = NonNullable<string[] | null | undefined>;\n```\n\n## 4.10 Parameters<Type>\n\n从一个函数类型 `Type` 的参数中使用的类型构建一个元组类型。\n\n```tsx\ndeclare function f1(arg: { a: number; b: string }): void;\n\n// type T0 = []\ntype T0 = Parameters<() => string>;\n\n// type T1 = [s: string]\ntype T1 = Parameters<(s: string) => void>;\n\n// type T2 = [arg: unknown]\ntype T2 = Parameters<<T>(arg: T) => T>;\n\n/*\ntype T3 = [arg: {\n    a: number;\n    b: string;\n}]\n*/\ntype T3 = Parameters<typeof f1>;\n\n// type T4 = unknown[]\ntype T4 = Parameters<any>;\n\n// type T5 = never\ntype T5 = Parameters<never>;\n\n// type T6 = never\ntype T6 = Parameters<string>;\n\n// type T7 = never\ntype T7 = Parameters<Function>;\n```\n\n<img src=\"/img/TypeScript/11-03.png\" alt=\"image-20211224135715919\" style=\"zoom: 50%;\" />\n\n## 4.11 ConstructorParameters<Type>\n\n从构造函数的类型中构造一个元组或数组类型。它产生一个具有所有参数类型的元组类型（如果 `Type` 不是一个函数，则为 `never` 类型）。\n\n```tsx\n// type T0 = [message?: string]\ntype T0 = ConstructorParameters<ErrorConstructor>;\n\n// type T1 = string[]\ntype T1 = ConstructorParameters<FunctionConstructor>;\n\n// type T2 = [pattern: string | RegExp, flags?: string]\ntype T2 = ConstructorParameters<RegExpConstructor>;\n\n// type T3 = unknown[]\ntype T3 = ConstructorParameters<any>;\n\n// type T4 = never\ntype T4 = ConstructorParameters<Function>;\n```\n\n<img src=\"/img/TypeScript/11-4.png\" alt=\"image-20211224150128771\" style=\"zoom: 50%;\" />\n\n## 4.12 ReturnType<Type>\n\n构建一个由函数 `Type` 的返回类型组成的类型。\n\n```tsx\ndeclare function f1(): { a: number; b: string };\n// type T0 = string\ntype T0 = ReturnType<() => string>;\n\n// type T1 = void\ntype T1 = ReturnType<(s: string) => void>;\n\n// type T2 = unknown\ntype T2 = ReturnType<<T>() => T>;\n\n// type T3 = number[]\ntype T3 = ReturnType<<T extends U, U extends number[]>() => T>;\n\n/*\ntype T4 = {\n  a: number;\n  b: string;\n}\n*/\ntype T4 = ReturnType<typeof f1>;\n\n// type T5 = any\ntype T5 = ReturnType<any>;\n\n// type T6 = never\ntype T6 = ReturnType<never>;\n\n// type T7 = any 报错\ntype T7 = ReturnType<string>;\n\n// type T8 = any 报错\ntype T8 = ReturnType<Function>;\n```\n\n<img src=\"/img/TypeScript/11-05.png\" alt=\"image-20211224164920604\" style=\"zoom: 50%;\" />\n\n## 4.13 InstanceType<Type>\n\n构建一个由 `Type` 中构造函数的实例类型组成的类型。\n\n```tsx\nclass C {\n  x = 0;\n  y = 0;\n}\n\n// type T0 = C\ntype T0 = InstanceType<typeof C>;\n\n// type T1 = any\ntype T1 = InstanceType<any>;\n\n// type T2 = never\ntype T2 = InstanceType<never>;\n\n// type T3 = any\ntype T3 = InstanceType<string>;\n\n// type T4 = any\ntype T4 = InstanceType<Function>;\n```\n\n<img src=\"/img/TypeScript/11-07.png\" alt=\"image-20211224170431379\" style=\"zoom:50%;\" />\n\n## 4.14 ThisParameterType<Type>\n\n提取一个函数类型的`this`参数的类型，如果该函数类型没有 `this`参数，则为 `unknown`。\n\n```tsx\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n\nfunction numberToString(n: ThisParameterType<typeof toHex>) {\n  return toHex.apply(n);\n}\n```\n\n## 4.15 OmitThisParameter<Type>\n\n移除 `Type`的`this`参数。如果`Type`没有明确声明的`this`参数，结果只是`Type`。否则，一个没有`this`参数的新函数类型将从`Type`创建。泛型被擦除，只有最后的重载签名被传播到新的函数类型。\n\n```tsx\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n\nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n\nconsole.log(fiveToHex());\n```\n\n## 4.16 ThisType<Type>\n\n这个工具并不返回一个转换后的类型。相反，它作为一个上下文的 `this` 类型的标记。注意，必须启用`noImplicitThis` 标志才能使用这个工具。\n\n```tsx\ntype ObjectDescriptor<D, M> = {\n  data?: D;\n  methods?: M & ThisType<D & M>; // 方法中的 'this' 类型是 D & M\n};\n\nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n  let data: object = desc.data || {};\n  let methods: object = desc.methods || {};\n  return { ...data, ...methods } as D & M;\n}\n\nlet obj = makeObject({\n  data: { x: 0, y: 0 },\n  methods: {\n    moveBy(dx: number, dy: number) {\n      this.x += dx;\n      this.y += dy;\n    },\n  },\n});\n\nobj.x = 10;\nobj.y = 20;\nobj.moveBy(5, 5);\n```\n\n在上面的例子中，makeObject的参数中的 `methods` 对象有一个包括 `ThisType<D & M>` 的上下文类型，因此方法对象中 `this` 的类型是 `{ x: number, y: number } & { moveBy(dx: number, dy: number): number }`。注意 `methods` 属性的类型如何同时是推理目标和方法中 `this` 类型的来源。\n\n`ThisType<T>`标记接口只是在`lib.d.ts`中声明的一个空接口。除了在对象字面的上下文类型中被识别之外，该接口的行为与任何空接口一样。\n\n## 4.17 字符串操作类型\n\n### `Uppercase<StringType>`\n\n### `Lowercase<StringType>`\n\n### `Capitalize<StringType>`\n\n### `Uncapitalize<StringType>`\n\nTypeScript包括一组类型，可以在类型系统中用于字符串操作。你可以在 [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype) 文档中找到这些工具的用法。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-4、高级篇：公共类型",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao7001e94v3f2xe2ueb",
        "content": "<h1 id=\"四、-公共类型\"><a href=\"#四、-公共类型\" class=\"headerlink\" title=\"四、 公共类型\"></a>四、 公共类型</h1><p>TypeScript 提供了几个实用类型，以促进常见的类型转换。这些实用程序在全局范围内可用。</p>\n<h2 id=\"4-1-Partial\"><a href=\"#4-1-Partial\" class=\"headerlink\" title=\"4.1 Partial&lt;Type&gt;\"></a>4.1 Partial<code>&lt;Type&gt;</code></h2><p>构建一个类型，将 <code>Type</code> 的所有属性设置为可选。这个工具将返回一个表示给定类型的所有子集的类型。</p>\n<p><strong>例子：</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateTodo</span>(<span class=\"params\"><span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span>, <span class=\"attr\">fieldsToUpdate</span>: <span class=\"title class_\">Partial</span>&lt;<span class=\"title class_\">Todo</span>&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todo1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;organize desk&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">&quot;clear clutter&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todo2 = <span class=\"title function_\">updateTodo</span>(todo1, &#123;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">&quot;throw out trash&quot;</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-Required\"><a href=\"#4-2-Required\" class=\"headerlink\" title=\"4.2 Required&lt;Type&gt;\"></a>4.2 Required<code>&lt;Type&gt;</code></h2><p>构建一个由 <code>Type</code> 的所有属性组成的类型，设置为必填。与 <code>Partial</code> 相反：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Props</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj</span>: <span class=\"title class_\">Props</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj2</span>: <span class=\"title class_\">Required</span>&lt;<span class=\"title class_\">Props</span>&gt; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-01.png\" alt=\"image-20211223212409295\" style=\"zoom:50%;\" />\n\n<h2 id=\"4-3-Readonly\"><a href=\"#4-3-Readonly\" class=\"headerlink\" title=\"4.3 Readonly\"></a>4.3 Readonly<Type></h2><p>构建一个类型，<code>Type</code> 的所有属性设置为 <code>readonly</code>，这意味着构建的类型的属性不能被重新设置值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">Readonly</span>&lt;<span class=\"title class_\">Todo</span>&gt; = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;Delete inactive users&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">todo.<span class=\"property\">title</span> = <span class=\"string\">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-02.png\" alt=\"image-20211223212707668\" style=\"zoom: 67%;\" />\n\n<p>这个工具对于表示将在运行时失败的赋值表达式很有用（即当试图重新分配一个 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">冻结对象 </a>的属性时）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> freeze&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">obj</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Readonly</span>&lt;<span class=\"title class_\">Type</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-4-Record\"><a href=\"#4-4-Record\" class=\"headerlink\" title=\"4.4 Record&lt;Keys, Type&gt;\"></a>4.4 Record&lt;Keys, Type&gt;</h2><p>构建一个对象类型，其属性键是 <code>Keys</code>，其属性值是 <code>Type</code>。这个工具可以用来将一个类型的属性映射到另一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">CatInfo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">breed</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CatName</span> = <span class=\"string\">&quot;miffy&quot;</span> | <span class=\"string\">&quot;boris&quot;</span> | <span class=\"string\">&quot;mordred&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">cats</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"title class_\">CatName</span>, <span class=\"title class_\">CatInfo</span>&gt; = &#123;</span><br><span class=\"line\">  <span class=\"attr\">miffy</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">10</span>, <span class=\"attr\">breed</span>: <span class=\"string\">&quot;Persian&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">boris</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">5</span>, <span class=\"attr\">breed</span>: <span class=\"string\">&quot;Maine Coon&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mordred</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">16</span>, <span class=\"attr\">breed</span>: <span class=\"string\">&quot;British Shorthair&quot;</span> &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const cats: Record&lt;CatName, CatInfo&gt;</span></span><br><span class=\"line\">cats.<span class=\"property\">boris</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-5-Pick\"><a href=\"#4-5-Pick\" class=\"headerlink\" title=\"4.5 Pick&lt;Type, Keys&gt;\"></a>4.5 Pick&lt;Type, Keys&gt;</h2><p>通过从 <code>Type </code>中选取属性集合<code>Keys</code>（属性名或属性名的联合）来构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreview</span> = <span class=\"title class_\">Pick</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">&quot;title&quot;</span> | <span class=\"string\">&quot;completed&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreview</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;Clean room&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const todo: TodoPreview</span></span><br><span class=\"line\">todo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-6-Omit\"><a href=\"#4-6-Omit\" class=\"headerlink\" title=\"4.6 Omit&lt;Type, Keys&gt;\"></a>4.6 Omit&lt;Type, Keys&gt;</h2><p>通过从 <code>Type</code> 中选取所有属性，然后删除 <code>Keys</code>（属性名或属性名的联合）来构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"attr\">createdAt</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreview</span> = <span class=\"title class_\">Omit</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">&quot;description&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreview</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;Clean room&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">createdAt</span>: <span class=\"number\">1615544252770</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const todo: TodoPreview</span></span><br><span class=\"line\">todo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoInfo</span> = <span class=\"title class_\">Omit</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">&quot;completed&quot;</span> | <span class=\"string\">&quot;createdAt&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todoInfo</span>: <span class=\"title class_\">TodoInfo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;Pick up kids&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">&quot;Kindergarten closes at 5pm&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const todoInfo: TodoInfo</span></span><br><span class=\"line\">todoInfo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-7-Exclude\"><a href=\"#4-7-Exclude\" class=\"headerlink\" title=\"4.7 Exclude&lt;Type, ExcludedUnion&gt;\"></a>4.7 Exclude&lt;Type, ExcludedUnion&gt;</h2><p>通过从 <code>Type</code> 中排除所有可分配给 <code>ExcludedUnion</code> 的联盟成员来构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type T0 = &quot;b&quot; | &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">Exclude</span>&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">Exclude</span>&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">Exclude</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-8-Extract\"><a href=\"#4-8-Extract\" class=\"headerlink\" title=\"4.8 Extract&lt;Type, Union&gt;\"></a>4.8 Extract&lt;Type, Union&gt;</h2><p>通过从 <code>Type</code> 中提取可分配给 <code>Union</code> 的所有 <code>union</code> 成员，构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type T0 = &quot;a&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">Extract</span>&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = () =&gt; void</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">Extract</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-9-NonNullable\"><a href=\"#4-9-NonNullable\" class=\"headerlink\" title=\"4.9 NonNullable\"></a>4.9 NonNullable<Type></h2><p>通过从 <code>Type</code> 中排除 <code>null</code>和<code>undefined</code>来构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type T0 = string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">NonNullable</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"literal\">undefined</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = string[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">NonNullable</span>&lt;<span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-10-Parameters\"><a href=\"#4-10-Parameters\" class=\"headerlink\" title=\"4.10 Parameters\"></a>4.10 Parameters<Type></h2><p>从一个函数类型 <code>Type</code> 的参数中使用的类型构建一个元组类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"><span class=\"attr\">arg</span>: &#123; a: <span class=\"built_in\">number</span>; b: <span class=\"built_in\">string</span> &#125;</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T0 = []</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = [s: string]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = [arg: unknown]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">Parameters</span>&lt;&lt;T&gt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: T</span>) =&gt;</span> T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type T3 = [arg: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    a: number;</span></span><br><span class=\"line\"><span class=\"comment\">    b: string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"keyword\">typeof</span> f1&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T4 = unknown[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T4</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T5 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T5</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"built_in\">never</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T6 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T6</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T7 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T7</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-03.png\" alt=\"image-20211224135715919\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-11-ConstructorParameters\"><a href=\"#4-11-ConstructorParameters\" class=\"headerlink\" title=\"4.11 ConstructorParameters\"></a>4.11 ConstructorParameters<Type></h2><p>从构造函数的类型中构造一个元组或数组类型。它产生一个具有所有参数类型的元组类型（如果 <code>Type</code> 不是一个函数，则为 <code>never</code> 类型）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type T0 = [message?: string]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"title class_\">ErrorConstructor</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = string[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"title class_\">FunctionConstructor</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = [pattern: string | RegExp, flags?: string]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"title class_\">RegExpConstructor</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T3 = unknown[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T4 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T4</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-4.png\" alt=\"image-20211224150128771\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-12-ReturnType\"><a href=\"#4-12-ReturnType\" class=\"headerlink\" title=\"4.12 ReturnType\"></a>4.12 ReturnType<Type></h2><p>构建一个由函数 <code>Type</code> 的返回类型组成的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"></span>): &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">b</span>: <span class=\"built_in\">string</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// type T0 = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = void</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = unknown</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">ReturnType</span>&lt;&lt;T&gt;<span class=\"function\">() =&gt;</span> T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T3 = number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"title class_\">ReturnType</span>&lt;&lt;T <span class=\"keyword\">extends</span> U, U <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span>[]&gt;<span class=\"function\">() =&gt;</span> T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type T4 = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  a: number;</span></span><br><span class=\"line\"><span class=\"comment\">  b: string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T4</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"keyword\">typeof</span> f1&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T5 = any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T5</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T6 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T6</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"built_in\">never</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T7 = any 报错</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T7</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T8 = any 报错</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T8</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-05.png\" alt=\"image-20211224164920604\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-13-InstanceType\"><a href=\"#4-13-InstanceType\" class=\"headerlink\" title=\"4.13 InstanceType\"></a>4.13 InstanceType<Type></h2><p>构建一个由 <code>Type</code> 中构造函数的实例类型组成的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T0 = C</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"keyword\">typeof</span> C&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"built_in\">never</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T3 = any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T4 = any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T4</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-07.png\" alt=\"image-20211224170431379\" style=\"zoom:50%;\" />\n\n<h2 id=\"4-14-ThisParameterType\"><a href=\"#4-14-ThisParameterType\" class=\"headerlink\" title=\"4.14 ThisParameterType\"></a>4.14 ThisParameterType<Type></h2><p>提取一个函数类型的<code>this</code>参数的类型，如果该函数类型没有 <code>this</code>参数，则为 <code>unknown</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">toHex</span>(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">Number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">numberToString</span>(<span class=\"params\"><span class=\"attr\">n</span>: <span class=\"title class_\">ThisParameterType</span>&lt;<span class=\"keyword\">typeof</span> toHex&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> toHex.<span class=\"title function_\">apply</span>(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-15-OmitThisParameter\"><a href=\"#4-15-OmitThisParameter\" class=\"headerlink\" title=\"4.15 OmitThisParameter\"></a>4.15 OmitThisParameter<Type></h2><p>移除 <code>Type</code>的<code>this</code>参数。如果<code>Type</code>没有明确声明的<code>this</code>参数，结果只是<code>Type</code>。否则，一个没有<code>this</code>参数的新函数类型将从<code>Type</code>创建。泛型被擦除，只有最后的重载签名被传播到新的函数类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">toHex</span>(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">Number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">fiveToHex</span>: <span class=\"title class_\">OmitThisParameter</span>&lt;<span class=\"keyword\">typeof</span> toHex&gt; = toHex.<span class=\"title function_\">bind</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">fiveToHex</span>());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-16-ThisType\"><a href=\"#4-16-ThisType\" class=\"headerlink\" title=\"4.16 ThisType\"></a>4.16 ThisType<Type></h2><p>这个工具并不返回一个转换后的类型。相反，它作为一个上下文的 <code>this</code> 类型的标记。注意，必须启用<code>noImplicitThis</code> 标志才能使用这个工具。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ObjectDescriptor</span>&lt;D, M&gt; = &#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>?: D;</span><br><span class=\"line\">  <span class=\"attr\">methods</span>?: M &amp; <span class=\"title class_\">ThisType</span>&lt;D &amp; M&gt;; <span class=\"comment\">// 方法中的 &#x27;this&#x27; 类型是 D &amp; M</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> makeObject&lt;D, M&gt;(<span class=\"attr\">desc</span>: <span class=\"title class_\">ObjectDescriptor</span>&lt;D, M&gt;): D &amp; M &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">data</span>: <span class=\"built_in\">object</span> = desc.<span class=\"property\">data</span> || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">methods</span>: <span class=\"built_in\">object</span> = desc.<span class=\"property\">methods</span> || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...data, ...methods &#125; <span class=\"keyword\">as</span> D &amp; M;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"title function_\">makeObject</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">moveBy</span>(<span class=\"params\"><span class=\"attr\">dx</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">dy</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">x</span> += dx;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">y</span> += dy;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">x</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">obj.<span class=\"property\">y</span> = <span class=\"number\">20</span>;</span><br><span class=\"line\">obj.<span class=\"title function_\">moveBy</span>(<span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，makeObject的参数中的 <code>methods</code> 对象有一个包括 <code>ThisType&lt;D &amp; M&gt;</code> 的上下文类型，因此方法对象中 <code>this</code> 的类型是 <code>&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;</code>。注意 <code>methods</code> 属性的类型如何同时是推理目标和方法中 <code>this</code> 类型的来源。</p>\n<p><code>ThisType&lt;T&gt;</code>标记接口只是在<code>lib.d.ts</code>中声明的一个空接口。除了在对象字面的上下文类型中被识别之外，该接口的行为与任何空接口一样。</p>\n<h2 id=\"4-17-字符串操作类型\"><a href=\"#4-17-字符串操作类型\" class=\"headerlink\" title=\"4.17 字符串操作类型\"></a>4.17 字符串操作类型</h2><h3 id=\"Uppercase\"><a href=\"#Uppercase\" class=\"headerlink\" title=\"Uppercase&lt;StringType&gt;\"></a><code>Uppercase&lt;StringType&gt;</code></h3><h3 id=\"Lowercase\"><a href=\"#Lowercase\" class=\"headerlink\" title=\"Lowercase&lt;StringType&gt;\"></a><code>Lowercase&lt;StringType&gt;</code></h3><h3 id=\"Capitalize\"><a href=\"#Capitalize\" class=\"headerlink\" title=\"Capitalize&lt;StringType&gt;\"></a><code>Capitalize&lt;StringType&gt;</code></h3><h3 id=\"Uncapitalize\"><a href=\"#Uncapitalize\" class=\"headerlink\" title=\"Uncapitalize&lt;StringType&gt;\"></a><code>Uncapitalize&lt;StringType&gt;</code></h3><p>TypeScript包括一组类型，可以在类型系统中用于字符串操作。你可以在 <a href=\"https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype\">Template Literal Types</a> 文档中找到这些工具的用法。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"四、-公共类型\"><a href=\"#四、-公共类型\" class=\"headerlink\" title=\"四、 公共类型\"></a>四、 公共类型</h1><p>TypeScript 提供了几个实用类型，以促进常见的类型转换。这些实用程序在全局范围内可用。</p>\n<h2 id=\"4-1-Partial\"><a href=\"#4-1-Partial\" class=\"headerlink\" title=\"4.1 Partial&lt;Type&gt;\"></a>4.1 Partial<code>&lt;Type&gt;</code></h2><p>构建一个类型，将 <code>Type</code> 的所有属性设置为可选。这个工具将返回一个表示给定类型的所有子集的类型。</p>\n<p><strong>例子：</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateTodo</span>(<span class=\"params\"><span class=\"attr\">todo</span>: <span class=\"title class_\">Todo</span>, <span class=\"attr\">fieldsToUpdate</span>: <span class=\"title class_\">Partial</span>&lt;<span class=\"title class_\">Todo</span>&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todo1 = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;organize desk&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">&quot;clear clutter&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todo2 = <span class=\"title function_\">updateTodo</span>(todo1, &#123;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">&quot;throw out trash&quot;</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-Required\"><a href=\"#4-2-Required\" class=\"headerlink\" title=\"4.2 Required&lt;Type&gt;\"></a>4.2 Required<code>&lt;Type&gt;</code></h2><p>构建一个由 <code>Type</code> 的所有属性组成的类型，设置为必填。与 <code>Partial</code> 相反：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Props</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">b</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj</span>: <span class=\"title class_\">Props</span> = &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">obj2</span>: <span class=\"title class_\">Required</span>&lt;<span class=\"title class_\">Props</span>&gt; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-01.png\" alt=\"image-20211223212409295\" style=\"zoom:50%;\" />\n\n<h2 id=\"4-3-Readonly\"><a href=\"#4-3-Readonly\" class=\"headerlink\" title=\"4.3 Readonly\"></a>4.3 Readonly<Type></h2><p>构建一个类型，<code>Type</code> 的所有属性设置为 <code>readonly</code>，这意味着构建的类型的属性不能被重新设置值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">Readonly</span>&lt;<span class=\"title class_\">Todo</span>&gt; = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;Delete inactive users&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">todo.<span class=\"property\">title</span> = <span class=\"string\">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-02.png\" alt=\"image-20211223212707668\" style=\"zoom: 67%;\" />\n\n<p>这个工具对于表示将在运行时失败的赋值表达式很有用（即当试图重新分配一个 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">冻结对象 </a>的属性时）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> freeze&lt;<span class=\"title class_\">Type</span>&gt;(<span class=\"attr\">obj</span>: <span class=\"title class_\">Type</span>): <span class=\"title class_\">Readonly</span>&lt;<span class=\"title class_\">Type</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-4-Record\"><a href=\"#4-4-Record\" class=\"headerlink\" title=\"4.4 Record&lt;Keys, Type&gt;\"></a>4.4 Record&lt;Keys, Type&gt;</h2><p>构建一个对象类型，其属性键是 <code>Keys</code>，其属性值是 <code>Type</code>。这个工具可以用来将一个类型的属性映射到另一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">CatInfo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">breed</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">CatName</span> = <span class=\"string\">&quot;miffy&quot;</span> | <span class=\"string\">&quot;boris&quot;</span> | <span class=\"string\">&quot;mordred&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">cats</span>: <span class=\"title class_\">Record</span>&lt;<span class=\"title class_\">CatName</span>, <span class=\"title class_\">CatInfo</span>&gt; = &#123;</span><br><span class=\"line\">  <span class=\"attr\">miffy</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">10</span>, <span class=\"attr\">breed</span>: <span class=\"string\">&quot;Persian&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">boris</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">5</span>, <span class=\"attr\">breed</span>: <span class=\"string\">&quot;Maine Coon&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">mordred</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">16</span>, <span class=\"attr\">breed</span>: <span class=\"string\">&quot;British Shorthair&quot;</span> &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const cats: Record&lt;CatName, CatInfo&gt;</span></span><br><span class=\"line\">cats.<span class=\"property\">boris</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-5-Pick\"><a href=\"#4-5-Pick\" class=\"headerlink\" title=\"4.5 Pick&lt;Type, Keys&gt;\"></a>4.5 Pick&lt;Type, Keys&gt;</h2><p>通过从 <code>Type </code>中选取属性集合<code>Keys</code>（属性名或属性名的联合）来构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreview</span> = <span class=\"title class_\">Pick</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">&quot;title&quot;</span> | <span class=\"string\">&quot;completed&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreview</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;Clean room&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const todo: TodoPreview</span></span><br><span class=\"line\">todo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-6-Omit\"><a href=\"#4-6-Omit\" class=\"headerlink\" title=\"4.6 Omit&lt;Type, Keys&gt;\"></a>4.6 Omit&lt;Type, Keys&gt;</h2><p>通过从 <code>Type</code> 中选取所有属性，然后删除 <code>Keys</code>（属性名或属性名的联合）来构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"attr\">createdAt</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreview</span> = <span class=\"title class_\">Omit</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">&quot;description&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreview</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;Clean room&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">createdAt</span>: <span class=\"number\">1615544252770</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const todo: TodoPreview</span></span><br><span class=\"line\">todo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoInfo</span> = <span class=\"title class_\">Omit</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">&quot;completed&quot;</span> | <span class=\"string\">&quot;createdAt&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todoInfo</span>: <span class=\"title class_\">TodoInfo</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">&quot;Pick up kids&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">&quot;Kindergarten closes at 5pm&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const todoInfo: TodoInfo</span></span><br><span class=\"line\">todoInfo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-7-Exclude\"><a href=\"#4-7-Exclude\" class=\"headerlink\" title=\"4.7 Exclude&lt;Type, ExcludedUnion&gt;\"></a>4.7 Exclude&lt;Type, ExcludedUnion&gt;</h2><p>通过从 <code>Type</code> 中排除所有可分配给 <code>ExcludedUnion</code> 的联盟成员来构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type T0 = &quot;b&quot; | &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">Exclude</span>&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">Exclude</span>&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">Exclude</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-8-Extract\"><a href=\"#4-8-Extract\" class=\"headerlink\" title=\"4.8 Extract&lt;Type, Union&gt;\"></a>4.8 Extract&lt;Type, Union&gt;</h2><p>通过从 <code>Type</code> 中提取可分配给 <code>Union</code> 的所有 <code>union</code> 成员，构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type T0 = &quot;a&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">Extract</span>&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = () =&gt; void</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">Extract</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-9-NonNullable\"><a href=\"#4-9-NonNullable\" class=\"headerlink\" title=\"4.9 NonNullable\"></a>4.9 NonNullable<Type></h2><p>通过从 <code>Type</code> 中排除 <code>null</code>和<code>undefined</code>来构造一个类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type T0 = string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">NonNullable</span>&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"literal\">undefined</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = string[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">NonNullable</span>&lt;<span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-10-Parameters\"><a href=\"#4-10-Parameters\" class=\"headerlink\" title=\"4.10 Parameters\"></a>4.10 Parameters<Type></h2><p>从一个函数类型 <code>Type</code> 的参数中使用的类型构建一个元组类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"><span class=\"attr\">arg</span>: &#123; a: <span class=\"built_in\">number</span>; b: <span class=\"built_in\">string</span> &#125;</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T0 = []</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = [s: string]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = [arg: unknown]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">Parameters</span>&lt;&lt;T&gt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">arg</span>: T</span>) =&gt;</span> T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type T3 = [arg: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    a: number;</span></span><br><span class=\"line\"><span class=\"comment\">    b: string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"keyword\">typeof</span> f1&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T4 = unknown[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T4</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T5 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T5</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"built_in\">never</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T6 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T6</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T7 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T7</span> = <span class=\"title class_\">Parameters</span>&lt;<span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-03.png\" alt=\"image-20211224135715919\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-11-ConstructorParameters\"><a href=\"#4-11-ConstructorParameters\" class=\"headerlink\" title=\"4.11 ConstructorParameters\"></a>4.11 ConstructorParameters<Type></h2><p>从构造函数的类型中构造一个元组或数组类型。它产生一个具有所有参数类型的元组类型（如果 <code>Type</code> 不是一个函数，则为 <code>never</code> 类型）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type T0 = [message?: string]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"title class_\">ErrorConstructor</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = string[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"title class_\">FunctionConstructor</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = [pattern: string | RegExp, flags?: string]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"title class_\">RegExpConstructor</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T3 = unknown[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T4 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T4</span> = <span class=\"title class_\">ConstructorParameters</span>&lt;<span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-4.png\" alt=\"image-20211224150128771\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-12-ReturnType\"><a href=\"#4-12-ReturnType\" class=\"headerlink\" title=\"4.12 ReturnType\"></a>4.12 ReturnType<Type></h2><p>构建一个由函数 <code>Type</code> 的返回类型组成的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"></span>): &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">number</span>; <span class=\"attr\">b</span>: <span class=\"built_in\">string</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// type T0 = string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = void</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"function\">(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = unknown</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">ReturnType</span>&lt;&lt;T&gt;<span class=\"function\">() =&gt;</span> T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T3 = number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"title class_\">ReturnType</span>&lt;&lt;T <span class=\"keyword\">extends</span> U, U <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span>[]&gt;<span class=\"function\">() =&gt;</span> T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">type T4 = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  a: number;</span></span><br><span class=\"line\"><span class=\"comment\">  b: string;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T4</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"keyword\">typeof</span> f1&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T5 = any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T5</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T6 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T6</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"built_in\">never</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T7 = any 报错</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T7</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T8 = any 报错</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T8</span> = <span class=\"title class_\">ReturnType</span>&lt;<span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-05.png\" alt=\"image-20211224164920604\" style=\"zoom: 50%;\" />\n\n<h2 id=\"4-13-InstanceType\"><a href=\"#4-13-InstanceType\" class=\"headerlink\" title=\"4.13 InstanceType\"></a>4.13 InstanceType<Type></h2><p>构建一个由 <code>Type</code> 中构造函数的实例类型组成的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T0 = C</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T0</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"keyword\">typeof</span> C&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T1 = any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T1</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"built_in\">any</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T2 = never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T2</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"built_in\">never</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T3 = any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T3</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// type T4 = any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"variable constant_\">T4</span> = <span class=\"title class_\">InstanceType</span>&lt;<span class=\"title class_\">Function</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-07.png\" alt=\"image-20211224170431379\" style=\"zoom:50%;\" />\n\n<h2 id=\"4-14-ThisParameterType\"><a href=\"#4-14-ThisParameterType\" class=\"headerlink\" title=\"4.14 ThisParameterType\"></a>4.14 ThisParameterType<Type></h2><p>提取一个函数类型的<code>this</code>参数的类型，如果该函数类型没有 <code>this</code>参数，则为 <code>unknown</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">toHex</span>(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">Number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">numberToString</span>(<span class=\"params\"><span class=\"attr\">n</span>: <span class=\"title class_\">ThisParameterType</span>&lt;<span class=\"keyword\">typeof</span> toHex&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> toHex.<span class=\"title function_\">apply</span>(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-15-OmitThisParameter\"><a href=\"#4-15-OmitThisParameter\" class=\"headerlink\" title=\"4.15 OmitThisParameter\"></a>4.15 OmitThisParameter<Type></h2><p>移除 <code>Type</code>的<code>this</code>参数。如果<code>Type</code>没有明确声明的<code>this</code>参数，结果只是<code>Type</code>。否则，一个没有<code>this</code>参数的新函数类型将从<code>Type</code>创建。泛型被擦除，只有最后的重载签名被传播到新的函数类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">toHex</span>(<span class=\"params\"><span class=\"attr\">this</span>: <span class=\"title class_\">Number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">fiveToHex</span>: <span class=\"title class_\">OmitThisParameter</span>&lt;<span class=\"keyword\">typeof</span> toHex&gt; = toHex.<span class=\"title function_\">bind</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">fiveToHex</span>());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-16-ThisType\"><a href=\"#4-16-ThisType\" class=\"headerlink\" title=\"4.16 ThisType\"></a>4.16 ThisType<Type></h2><p>这个工具并不返回一个转换后的类型。相反，它作为一个上下文的 <code>this</code> 类型的标记。注意，必须启用<code>noImplicitThis</code> 标志才能使用这个工具。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ObjectDescriptor</span>&lt;D, M&gt; = &#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>?: D;</span><br><span class=\"line\">  <span class=\"attr\">methods</span>?: M &amp; <span class=\"title class_\">ThisType</span>&lt;D &amp; M&gt;; <span class=\"comment\">// 方法中的 &#x27;this&#x27; 类型是 D &amp; M</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> makeObject&lt;D, M&gt;(<span class=\"attr\">desc</span>: <span class=\"title class_\">ObjectDescriptor</span>&lt;D, M&gt;): D &amp; M &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">data</span>: <span class=\"built_in\">object</span> = desc.<span class=\"property\">data</span> || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">methods</span>: <span class=\"built_in\">object</span> = desc.<span class=\"property\">methods</span> || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...data, ...methods &#125; <span class=\"keyword\">as</span> D &amp; M;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"title function_\">makeObject</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"title function_\">moveBy</span>(<span class=\"params\"><span class=\"attr\">dx</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">dy</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">x</span> += dx;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">y</span> += dy;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">x</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">obj.<span class=\"property\">y</span> = <span class=\"number\">20</span>;</span><br><span class=\"line\">obj.<span class=\"title function_\">moveBy</span>(<span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，makeObject的参数中的 <code>methods</code> 对象有一个包括 <code>ThisType&lt;D &amp; M&gt;</code> 的上下文类型，因此方法对象中 <code>this</code> 的类型是 <code>&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;</code>。注意 <code>methods</code> 属性的类型如何同时是推理目标和方法中 <code>this</code> 类型的来源。</p>\n<p><code>ThisType&lt;T&gt;</code>标记接口只是在<code>lib.d.ts</code>中声明的一个空接口。除了在对象字面的上下文类型中被识别之外，该接口的行为与任何空接口一样。</p>\n<h2 id=\"4-17-字符串操作类型\"><a href=\"#4-17-字符串操作类型\" class=\"headerlink\" title=\"4.17 字符串操作类型\"></a>4.17 字符串操作类型</h2><h3 id=\"Uppercase\"><a href=\"#Uppercase\" class=\"headerlink\" title=\"Uppercase&lt;StringType&gt;\"></a><code>Uppercase&lt;StringType&gt;</code></h3><h3 id=\"Lowercase\"><a href=\"#Lowercase\" class=\"headerlink\" title=\"Lowercase&lt;StringType&gt;\"></a><code>Lowercase&lt;StringType&gt;</code></h3><h3 id=\"Capitalize\"><a href=\"#Capitalize\" class=\"headerlink\" title=\"Capitalize&lt;StringType&gt;\"></a><code>Capitalize&lt;StringType&gt;</code></h3><h3 id=\"Uncapitalize\"><a href=\"#Uncapitalize\" class=\"headerlink\" title=\"Uncapitalize&lt;StringType&gt;\"></a><code>Uncapitalize&lt;StringType&gt;</code></h3><p>TypeScript包括一组类型，可以在类型系统中用于字符串操作。你可以在 <a href=\"https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#uppercasestringtype\">Template Literal Types</a> 文档中找到这些工具的用法。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-7、高级篇：迭代器和生成器",
        "toc": true,
        "abbrlink": 9376,
        "date": "2024-01-28T13:08:17.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_01.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 七、迭代器和生成器\n\n## 7.1 遍历\n\n如果一个对象有 `Symbol.iterator` 属性的实现，它就被认为是可迭代的。一些内置类型，如`Array`、`Map`、`Set`、`String`、`Int32Array`、`Uint32Array`等，已经实现了它们的`Symbol.iterator`属性。对象上的`Symbol.iterator`函数负责返回要迭代的值的列表。\n\n### 7.1.1 `Iterable`接口\n\n`Iterable`是一个我们可以使用的类型，如果我们想接收上面列出的可迭代的类型。下面是一个例子：\n\n```tsx\nfunction toArray<X>(xs: Iterable<X>): X[] {\n  return [...xs];\n}\n```\n\n### 7.1.2 `for..of` 声明\n\n`for...of`在一个可迭代对象上循环，调用对象上的`Symbol.iterator`属性。下面是一个关于数组的简单`for.of`循环。\n\n```tsx\nlet someArray = [1, \"string\", false];\nfor (let entry of someArray) {\n  console.log(entry); // 1, \"string\", false\n}\n```\n\n### 7.1.3 `for..of`与`for..in`声明\n\n`for...of`和`for...in`语句都是在列表上进行迭代；但迭代的值是不同的，`for...in`返回被迭代对象的键值列表，而`for...of`返回被迭代对象的数字属性值列表。\n\n这里有一个例子可以证明这种区别：\n\n```tsx\nlet list = [4, 5, 6];\nfor (let i in list) {\n  console.log(i); // \"0\", \"1\", \"2\",\n}\nfor (let i of list) {\n  console.log(i); // 4, 5, 6\n}\n```\n\n另一个区别是`for...in`对任何对象进行操作；它作为一种检查该对象上的属性的方法。另一方面，`for...of`主要对可迭代对象的值感兴趣。像`Map`和`Set`这样的内置对象实现了`Symbol.iterator`属性，允许访问存储的值。\n\n```tsx\nlet pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\nfor (let pet in pets) {\n  console.log(pet); // \"species\"\n}\nfor (let pet of pets) {\n  console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}\n```\n\n## 7.2 代码生成\n\n### 7.2.1 生成目标 ES5 和 ES3\n\n当针对ES5或ES3兼容的引擎时，迭代器只允许在 `Array` 类型的值上使用。在非数组值上使用 `for...of` 循环是一个错误，即使这些非数组值实现了 `Symbol.iterator` 属性。\n\n例如，编译器将为`for...`的循环生成一个简单的`for`循环。\n\n```tsx\nlet numbers = [1, 2, 3];\nfor (let num of numbers) {\n  console.log(num);\n}\n```\n\n将被生成为：\n\n```tsx\nvar numbers = [1, 2, 3];\nfor (var _i = 0; _i < numbers.length; _i++) {\n  var num = numbers[_i];\n  console.log(num);\n}\n```\n\n### 7.2.2 ECMAScript 2015 和 更高版本\n\n当针对ECMAScipt 2015兼容的引擎时，编译器将生成 `for...of` 循环，以针对引擎中的内置迭代器实现。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-7、高级篇：迭代器和生成器.md",
        "raw": "---\ntitle: 2-7、高级篇：迭代器和生成器\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 9376\ndate: 2024-01-28 21:08:17\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 七、迭代器和生成器\n\n## 7.1 遍历\n\n如果一个对象有 `Symbol.iterator` 属性的实现，它就被认为是可迭代的。一些内置类型，如`Array`、`Map`、`Set`、`String`、`Int32Array`、`Uint32Array`等，已经实现了它们的`Symbol.iterator`属性。对象上的`Symbol.iterator`函数负责返回要迭代的值的列表。\n\n### 7.1.1 `Iterable`接口\n\n`Iterable`是一个我们可以使用的类型，如果我们想接收上面列出的可迭代的类型。下面是一个例子：\n\n```tsx\nfunction toArray<X>(xs: Iterable<X>): X[] {\n  return [...xs];\n}\n```\n\n### 7.1.2 `for..of` 声明\n\n`for...of`在一个可迭代对象上循环，调用对象上的`Symbol.iterator`属性。下面是一个关于数组的简单`for.of`循环。\n\n```tsx\nlet someArray = [1, \"string\", false];\nfor (let entry of someArray) {\n  console.log(entry); // 1, \"string\", false\n}\n```\n\n### 7.1.3 `for..of`与`for..in`声明\n\n`for...of`和`for...in`语句都是在列表上进行迭代；但迭代的值是不同的，`for...in`返回被迭代对象的键值列表，而`for...of`返回被迭代对象的数字属性值列表。\n\n这里有一个例子可以证明这种区别：\n\n```tsx\nlet list = [4, 5, 6];\nfor (let i in list) {\n  console.log(i); // \"0\", \"1\", \"2\",\n}\nfor (let i of list) {\n  console.log(i); // 4, 5, 6\n}\n```\n\n另一个区别是`for...in`对任何对象进行操作；它作为一种检查该对象上的属性的方法。另一方面，`for...of`主要对可迭代对象的值感兴趣。像`Map`和`Set`这样的内置对象实现了`Symbol.iterator`属性，允许访问存储的值。\n\n```tsx\nlet pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\nfor (let pet in pets) {\n  console.log(pet); // \"species\"\n}\nfor (let pet of pets) {\n  console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}\n```\n\n## 7.2 代码生成\n\n### 7.2.1 生成目标 ES5 和 ES3\n\n当针对ES5或ES3兼容的引擎时，迭代器只允许在 `Array` 类型的值上使用。在非数组值上使用 `for...of` 循环是一个错误，即使这些非数组值实现了 `Symbol.iterator` 属性。\n\n例如，编译器将为`for...`的循环生成一个简单的`for`循环。\n\n```tsx\nlet numbers = [1, 2, 3];\nfor (let num of numbers) {\n  console.log(num);\n}\n```\n\n将被生成为：\n\n```tsx\nvar numbers = [1, 2, 3];\nfor (var _i = 0; _i < numbers.length; _i++) {\n  var num = numbers[_i];\n  console.log(num);\n}\n```\n\n### 7.2.2 ECMAScript 2015 和 更高版本\n\n当针对ECMAScipt 2015兼容的引擎时，编译器将生成 `for...of` 循环，以针对引擎中的内置迭代器实现。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-7、高级篇：迭代器和生成器",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao7001i94v375br1p4u",
        "content": "<h1 id=\"七、迭代器和生成器\"><a href=\"#七、迭代器和生成器\" class=\"headerlink\" title=\"七、迭代器和生成器\"></a>七、迭代器和生成器</h1><h2 id=\"7-1-遍历\"><a href=\"#7-1-遍历\" class=\"headerlink\" title=\"7.1 遍历\"></a>7.1 遍历</h2><p>如果一个对象有 <code>Symbol.iterator</code> 属性的实现，它就被认为是可迭代的。一些内置类型，如<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>String</code>、<code>Int32Array</code>、<code>Uint32Array</code>等，已经实现了它们的<code>Symbol.iterator</code>属性。对象上的<code>Symbol.iterator</code>函数负责返回要迭代的值的列表。</p>\n<h3 id=\"7-1-1-Iterable接口\"><a href=\"#7-1-1-Iterable接口\" class=\"headerlink\" title=\"7.1.1 Iterable接口\"></a>7.1.1 <code>Iterable</code>接口</h3><p><code>Iterable</code>是一个我们可以使用的类型，如果我们想接收上面列出的可迭代的类型。下面是一个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> toArray&lt;X&gt;(<span class=\"attr\">xs</span>: <span class=\"title class_\">Iterable</span>&lt;X&gt;): X[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [...xs];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-2-for-of-声明\"><a href=\"#7-1-2-for-of-声明\" class=\"headerlink\" title=\"7.1.2 for..of 声明\"></a>7.1.2 <code>for..of</code> 声明</h3><p><code>for...of</code>在一个可迭代对象上循环，调用对象上的<code>Symbol.iterator</code>属性。下面是一个关于数组的简单<code>for.of</code>循环。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someArray = [<span class=\"number\">1</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"literal\">false</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> someArray) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(entry); <span class=\"comment\">// 1, &quot;string&quot;, false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-3-for-of与for-in声明\"><a href=\"#7-1-3-for-of与for-in声明\" class=\"headerlink\" title=\"7.1.3 for..of与for..in声明\"></a>7.1.3 <code>for..of</code>与<code>for..in</code>声明</h3><p><code>for...of</code>和<code>for...in</code>语句都是在列表上进行迭代；但迭代的值是不同的，<code>for...in</code>返回被迭代对象的键值列表，而<code>for...of</code>返回被迭代对象的数字属性值列表。</p>\n<p>这里有一个例子可以证明这种区别：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> list) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;,</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> list) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 4, 5, 6</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一个区别是<code>for...in</code>对任何对象进行操作；它作为一种检查该对象上的属性的方法。另一方面，<code>for...of</code>主要对可迭代对象的值感兴趣。像<code>Map</code>和<code>Set</code>这样的内置对象实现了<code>Symbol.iterator</code>属性，允许访问存储的值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pets = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"string\">&quot;Cat&quot;</span>, <span class=\"string\">&quot;Dog&quot;</span>, <span class=\"string\">&quot;Hamster&quot;</span>]);</span><br><span class=\"line\">pets[<span class=\"string\">&quot;species&quot;</span>] = <span class=\"string\">&quot;mammals&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">in</span> pets) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pet); <span class=\"comment\">// &quot;species&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">of</span> pets) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pet); <span class=\"comment\">// &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-2-代码生成\"><a href=\"#7-2-代码生成\" class=\"headerlink\" title=\"7.2 代码生成\"></a>7.2 代码生成</h2><h3 id=\"7-2-1-生成目标-ES5-和-ES3\"><a href=\"#7-2-1-生成目标-ES5-和-ES3\" class=\"headerlink\" title=\"7.2.1 生成目标 ES5 和 ES3\"></a>7.2.1 生成目标 ES5 和 ES3</h3><p>当针对ES5或ES3兼容的引擎时，迭代器只允许在 <code>Array</code> 类型的值上使用。在非数组值上使用 <code>for...of</code> 循环是一个错误，即使这些非数组值实现了 <code>Symbol.iterator</code> 属性。</p>\n<p>例如，编译器将为<code>for...</code>的循环生成一个简单的<code>for</code>循环。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将被生成为：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> _i = <span class=\"number\">0</span>; _i &lt; numbers.<span class=\"property\">length</span>; _i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> num = numbers[_i];</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-2-ECMAScript-2015-和-更高版本\"><a href=\"#7-2-2-ECMAScript-2015-和-更高版本\" class=\"headerlink\" title=\"7.2.2 ECMAScript 2015 和 更高版本\"></a>7.2.2 ECMAScript 2015 和 更高版本</h3><p>当针对ECMAScipt 2015兼容的引擎时，编译器将生成 <code>for...of</code> 循环，以针对引擎中的内置迭代器实现。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"七、迭代器和生成器\"><a href=\"#七、迭代器和生成器\" class=\"headerlink\" title=\"七、迭代器和生成器\"></a>七、迭代器和生成器</h1><h2 id=\"7-1-遍历\"><a href=\"#7-1-遍历\" class=\"headerlink\" title=\"7.1 遍历\"></a>7.1 遍历</h2><p>如果一个对象有 <code>Symbol.iterator</code> 属性的实现，它就被认为是可迭代的。一些内置类型，如<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>String</code>、<code>Int32Array</code>、<code>Uint32Array</code>等，已经实现了它们的<code>Symbol.iterator</code>属性。对象上的<code>Symbol.iterator</code>函数负责返回要迭代的值的列表。</p>\n<h3 id=\"7-1-1-Iterable接口\"><a href=\"#7-1-1-Iterable接口\" class=\"headerlink\" title=\"7.1.1 Iterable接口\"></a>7.1.1 <code>Iterable</code>接口</h3><p><code>Iterable</code>是一个我们可以使用的类型，如果我们想接收上面列出的可迭代的类型。下面是一个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> toArray&lt;X&gt;(<span class=\"attr\">xs</span>: <span class=\"title class_\">Iterable</span>&lt;X&gt;): X[] &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [...xs];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-2-for-of-声明\"><a href=\"#7-1-2-for-of-声明\" class=\"headerlink\" title=\"7.1.2 for..of 声明\"></a>7.1.2 <code>for..of</code> 声明</h3><p><code>for...of</code>在一个可迭代对象上循环，调用对象上的<code>Symbol.iterator</code>属性。下面是一个关于数组的简单<code>for.of</code>循环。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someArray = [<span class=\"number\">1</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"literal\">false</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> someArray) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(entry); <span class=\"comment\">// 1, &quot;string&quot;, false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-3-for-of与for-in声明\"><a href=\"#7-1-3-for-of与for-in声明\" class=\"headerlink\" title=\"7.1.3 for..of与for..in声明\"></a>7.1.3 <code>for..of</code>与<code>for..in</code>声明</h3><p><code>for...of</code>和<code>for...in</code>语句都是在列表上进行迭代；但迭代的值是不同的，<code>for...in</code>返回被迭代对象的键值列表，而<code>for...of</code>返回被迭代对象的数字属性值列表。</p>\n<p>这里有一个例子可以证明这种区别：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> list) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;,</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> list) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 4, 5, 6</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一个区别是<code>for...in</code>对任何对象进行操作；它作为一种检查该对象上的属性的方法。另一方面，<code>for...of</code>主要对可迭代对象的值感兴趣。像<code>Map</code>和<code>Set</code>这样的内置对象实现了<code>Symbol.iterator</code>属性，允许访问存储的值。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pets = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"string\">&quot;Cat&quot;</span>, <span class=\"string\">&quot;Dog&quot;</span>, <span class=\"string\">&quot;Hamster&quot;</span>]);</span><br><span class=\"line\">pets[<span class=\"string\">&quot;species&quot;</span>] = <span class=\"string\">&quot;mammals&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">in</span> pets) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pet); <span class=\"comment\">// &quot;species&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">of</span> pets) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pet); <span class=\"comment\">// &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-2-代码生成\"><a href=\"#7-2-代码生成\" class=\"headerlink\" title=\"7.2 代码生成\"></a>7.2 代码生成</h2><h3 id=\"7-2-1-生成目标-ES5-和-ES3\"><a href=\"#7-2-1-生成目标-ES5-和-ES3\" class=\"headerlink\" title=\"7.2.1 生成目标 ES5 和 ES3\"></a>7.2.1 生成目标 ES5 和 ES3</h3><p>当针对ES5或ES3兼容的引擎时，迭代器只允许在 <code>Array</code> 类型的值上使用。在非数组值上使用 <code>for...of</code> 循环是一个错误，即使这些非数组值实现了 <code>Symbol.iterator</code> 属性。</p>\n<p>例如，编译器将为<code>for...</code>的循环生成一个简单的<code>for</code>循环。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将被生成为：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> _i = <span class=\"number\">0</span>; _i &lt; numbers.<span class=\"property\">length</span>; _i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> num = numbers[_i];</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-2-ECMAScript-2015-和-更高版本\"><a href=\"#7-2-2-ECMAScript-2015-和-更高版本\" class=\"headerlink\" title=\"7.2.2 ECMAScript 2015 和 更高版本\"></a>7.2.2 ECMAScript 2015 和 更高版本</h3><p>当针对ECMAScipt 2015兼容的引擎时，编译器将生成 <code>for...of</code> 循环，以针对引擎中的内置迭代器实现。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-3、高级篇：枚举",
        "toc": true,
        "abbrlink": 43807,
        "date": "2024-01-28T11:58:16.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_02.jpeg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 三、枚举\n\n`Enums`是TypeScript的少数功能之一，它不是JavaScript的类型级扩展。\n\n枚举允许开发者定义一组命名的常量。使用枚举可以使其更容易记录意图，或创建一组不同的情况。TypeScript提供了基于数字和字符串的枚举。\n\n## 3.1 数值型枚举\n\n我们首先从数字枚举开始，如果你来自其他语言，可能会更熟悉它。一个枚举可以用 `enum` 关键字来定义。\n\n```tsx\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\n```\n\n上面，我们有一个数字枚举，其中 `Up` 被初始化为 `1` ，所有下面的成员从这一点开始自动递增。换句话说，`Direction.Up`的值是 `1` ，`Down` 是 `2`，`Left`是`3`，`Right`是`4`。\n\n如果我们愿意，我们可以完全不使用初始化器：\n\n```tsx\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n```\n\n这里，Up的值是0，Down是1，依次类推。这种自动递增的行为对于我们可能不关心成员值本身，但关心每个值与同一枚举中的其他值不同的情况很有用。\n\n使用枚举很简单：只需将任何成员作为枚举本身的一个属性来访问，并使用枚举的名称来声明类型:\n\n```tsx\nenum UserResponse {\n  No = 0,\n  Yes = 1,\n}\n\nfunction respond(recipient: string, message: UserResponse): void {\n  // ...\n}\nrespond(\"Princess Caroline\", UserResponse.Yes);\n```\n\n数字枚举可以混合在计算和常量成员中（见下文）。简而言之，没有初始化器的枚举要么需要放在第一位，要么必须放在用数字常量或其他常量枚举成员初始化的数字枚举之后。换句话说，下面的情况是不允许的：\n\n```tsx\nenum E {\n  A = getSomeValue(),\n  B,\n  // Ⓧ Enum成员必须有初始化器。\n}\n```\n\n## 3.2 字符串枚举\n\n字符串枚举是一个类似的概念，但有一些细微的运行时差异，如下文所述。在一个字符串枚举中，每个成员都必须用一个字符串字头或另一个字符串枚举成员进行常量初始化。\n\n```tsx\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}\n```\n\n虽然字符串枚举没有自动递增的行为，但字符串枚举有一个好处，那就是它们可以很好地 \"序列化\"。换句话说，如果你在调试时不得不读取一个数字枚举的运行时值，这个值往往是不透明的--它本身并不传达任何有用的意义（尽管 [反向映射](https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings)往往可以帮助你），字符串枚举允许你在代码运行时给出一个有意义的、可读的值，与枚举成员本身的名称无关。\n\n## 3.3 异构枚举\n\n从技术上讲，枚举可以与字符串和数字成员混合，但不清楚为什么你会想这样做：\n\n```\nenum BooleanLikeHeterogeneousEnum {\n  No = 0,\n  Yes = \"YES\",\n}\n```\n\n除非你真的想以一种巧妙的方式利用JavaScript的运行时行为，否则建议你不要这样做。\n\n## 3.4 计算型和常量型成员\n\n每个枚举成员都有一个与之相关的值，可以是常量，也可以是计算值。一个枚举成员被认为是常数，如果：\n\n- 它是枚举中的第一个成员，它没有初始化器，在这种情况下，它被赋值为 `0`：\n\n```tsx\n// E.X is constant:\nenum E {\n  X,\n}\n```\n\n- 它没有一个初始化器，而且前面的枚举成员是一个数字常数。在这种情况下，当前枚举成员的值将是前一个枚举成员的值加 `1`：\n\n```tsx\n// 'E1'和'E2'中的所有枚举成员都是常数。\nenum E1 {\n  X,\n  Y,\n  Z,\n}\nenum E2 {\n  A = 1,\n  B,\n  C,\n}\n```\n\n枚举成员用一个常量枚举表达式进行初始化。常量枚举表达式是TypeScript表达式的一个子集，可以在编译时进行完全评估。一个表达式是一个常量枚举表达式，如果它是：\n\n1. 枚举表达式的字面意思（基本上是一个字符串字面量或一个数字字面量）\n2. 对先前定义的常量枚举成员的引用（可以来自不同的枚举）。\n3. 一个括号内的常量枚举表达式\n4. 应用于常量枚举表达式的 `+`,` -`,` ~`单项运算符之一\n5. `+`,` -`,` *`,` /`,` %`, `<<`, `>>`, `>>`, `&`, `|`, `^` 以常量枚举表达式为操作数的二元运算符\n\n如果常量枚举表达式被评估为`NaN`或`Infinity`，这是一个编译时错误。\n\n在所有其他情况下，枚举成员被认为是计算出来的。\n\n```tsx\nenum FileAccess {\n  // 常量成员\n  None,\n  Read = 1 << 1,\n  Write = 1 << 2,\n  ReadWrite = Read | Write,\n  // 计算成员\n  G = \"123\".length,\n}\n```\n\n## 3.5 联合枚举和枚举成员类型\n\n有一个特殊的常量枚举成员的子集没有被计算：字面枚举成员。字面枚举成员是一个没有初始化值的常量枚举成员，或者其值被初始化为：\n\n- 任何字符串（例如：`\"foo\"`, `\"bar\"`, `\"baz\"`）。\n\n- 任何数字字头（例如：`1`，`100`）\n- 应用于任何数字字面的单数减号（例如：`-1`，`-100`）\n\n当一个枚举中的所有成员都有枚举的字面价值时，一些特殊的语义就会发挥作用。\n\n首先，枚举成员也成为了类型。例如，我们可以说某些成员只能有一个枚举成员的值：\n\n```tsx\nenum ShapeKind {\n  Circle,\n  Square,\n}\ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\ninterface Square {\n  kind: ShapeKind.Square;\n  sideLength: number;\n}\nlet c: Circle = {\n  kind: ShapeKind.Square,\n  // Ⓧ 类型 'ShapeKind.Square' 不能被分配给类型 'ShapeKind.Circle'\n  radius: 100,\n};\n```\n\n另一个变化是枚举类型本身有效地成为每个枚举成员的联盟。通过联合枚举，类型系统能够利用这一事实，即它知道存在于枚举本身的精确的值集。正因为如此，TypeScript可以捕捉到我们可能错误地比较数值的错误。比如说：\n\n```tsx\nenum E {\n  Foo,\n  Bar,\n}\n\nfunction f(x: E) {\n  if (x !== E.Foo || x !== E.Bar) {\n    // Ⓧ 这个条件将总是返回'true'，因为'E.Foo'和'E.Bar'的类型没有重合。\n    //...\n  }\n}\n```\n\n在这个例子中，我们首先检查了`x`是否不是`E.Foo`。如果这个检查成功了，那么我们的 `||` 就会短路，`'if'`的主体就会运行。然而，如果检查没有成功，那么 `x` 就只能是 `E.Foo`，所以看它是否等于 `E.Bar` 就没有意义了。\n\n## 3.6 运行时的枚举\n\n枚举是在运行时存在的真实对象。例如，下面这个枚举：\n\n```tsx\nenum E {\n  X,\n  Y,\n  Z,\n}\n```\n\n实际上可以被传递给函数：\n\n```tsx\nenum E {\n  X,\n  Y,\n  Z,\n}\n\nfunction f(obj: { X: number }) {\n  return obj.X;\n}\n\n// 可以正常工作，因为'E'有一个名为'X'的属性，是一个数字。\nf(E);\n```\n\n## 3.7 编译时的枚举\n\n尽管Enum是在运行时存在的真实对象，`keyof`关键字的工作方式与你对典型对象的预期不同。相反，使用`keyof typeof`来获得一个将所有Enum键表示为字符串的类型。\n\n```tsx\nenum LogLevel {\n  ERROR,\n  WARN,\n  INFO,\n  DEBUG,\n}\n/**\n * 这相当于:\n * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\n */\ntype LogLevelStrings = keyof typeof LogLevel;\n\nfunction printImportant(key: LogLevelStrings, message: string) {\n  const num = LogLevel[key];\n  if (num <= LogLevel.WARN) {\n    console.log(\"Log level key is:\", key);\n    console.log(\"Log level value is:\", num);\n    console.log(\"Log level message is:\", message);\n  }\n}\nprintImportant(\"ERROR\", \"This is a message\");\n```\n\n- **反向映射**\n\n除了为成员创建一个带有属性名称的对象外，数字枚举的成员还可以得到从枚举值到枚举名称的反向映射。例如，在这个例子中：\n\n```tsx\nenum Enum {\n  A,\n}\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n```\n\nTypeScript将其编译为以下的JavaScript：\n\n```js\n\"use strict\";\nvar Enum;\n(function (Enum) {\n  Enum[(Enum[\"A\"] = 0)] = \"A\";\n})(Enum || (Enum = {}));\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n```\n\n在这段生成的代码中，一个枚举被编译成一个对象，它同时存储了正向 (`name` -> `value`)和反向 (`value` -> `name`) 的映射关系。对其他枚举成员的引用总是以属性访问的方式发出，而且从不内联。\n\n请记住，字符串枚举成员根本不会被生成反向映射。\n\n- **`const`枚举**\n\n在大多数情况下，枚举是一个完全有效的解决方案。然而有时要求比较严格。为了避免在访问枚举值时支付额外的生成代码和额外的间接性的代价，可以使用`const`枚举。常量枚举是使用我们枚举上的 `const` 修饰符来定义的。\n\n```tsx\nconst enum Enum {\n  A = 1,\n  B = A * 2,\n}\n```\n\n常量枚举只能使用常量枚举表达式，与普通枚举不同，它们在编译过程中被完全删除。常量枚举成员在使用地点被内联。这是可能的，因为常量枚举不能有计算的成员。\n\n```tsx\nconst enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\nlet directions = [\n  Direction.Up,\n  Direction.Down,\n  Direction.Left,\n  Direction.Right,\n];\n```\n\n在生成的代码中，将变成：\n\n```js\n\"use strict\";\nlet directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n```\n\n## 3.8 环境枚举\n\n环境枚举是用来描述已经存在的枚举类型的形状。\n\n```tsx\ndeclare enum Enum {\n  A = 1,\n  B,\n  C = 2,\n}\n```\n\n环境枚举和非环境枚举之间的一个重要区别是，在常规枚举中，如果其前面的枚举成员被认为是常量，那么没有初始化器的成员将被认为是常量。相反，一个没有初始化器的环境（和非常量）枚举成员总是被认为是计算的。\n\n## 3.9 对象与枚举\n\n在现代TypeScript中，你可能不需要一个枚举，因为一个对象的常量就足够了：\n\n```tsx\nconst enum EDirection {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nconst ODirection = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: 3,\n} as const;\n\n// (enum member) EDirection.Up = 0\nEDirection.Up;\n\n// (property) Up: 0\nODirection.Up;\n\n// 将枚举作为一个参数\nfunction walk(dir: EDirection) {}\n\n// 它需要一个额外的行来拉出数值\ntype Direction = (typeof ODirection)[keyof typeof ODirection];\nfunction run(dir: Direction) {}\n\nwalk(EDirection.Left);\nrun(ODirection.Right);\n```\n\n与TypeScript的枚举相比，支持这种格式的最大理由是，它使你的代码库与JavaScript的状态保持一致，`when/if`枚举被添加到JavaScript中，那么你可以转移到额外的语法。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-3、高级篇：枚举.md",
        "raw": "---\ntitle: 2-3、高级篇：枚举\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 43807\ndate: 2024-01-28 19:58:16\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 三、枚举\n\n`Enums`是TypeScript的少数功能之一，它不是JavaScript的类型级扩展。\n\n枚举允许开发者定义一组命名的常量。使用枚举可以使其更容易记录意图，或创建一组不同的情况。TypeScript提供了基于数字和字符串的枚举。\n\n## 3.1 数值型枚举\n\n我们首先从数字枚举开始，如果你来自其他语言，可能会更熟悉它。一个枚举可以用 `enum` 关键字来定义。\n\n```tsx\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\n```\n\n上面，我们有一个数字枚举，其中 `Up` 被初始化为 `1` ，所有下面的成员从这一点开始自动递增。换句话说，`Direction.Up`的值是 `1` ，`Down` 是 `2`，`Left`是`3`，`Right`是`4`。\n\n如果我们愿意，我们可以完全不使用初始化器：\n\n```tsx\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n```\n\n这里，Up的值是0，Down是1，依次类推。这种自动递增的行为对于我们可能不关心成员值本身，但关心每个值与同一枚举中的其他值不同的情况很有用。\n\n使用枚举很简单：只需将任何成员作为枚举本身的一个属性来访问，并使用枚举的名称来声明类型:\n\n```tsx\nenum UserResponse {\n  No = 0,\n  Yes = 1,\n}\n\nfunction respond(recipient: string, message: UserResponse): void {\n  // ...\n}\nrespond(\"Princess Caroline\", UserResponse.Yes);\n```\n\n数字枚举可以混合在计算和常量成员中（见下文）。简而言之，没有初始化器的枚举要么需要放在第一位，要么必须放在用数字常量或其他常量枚举成员初始化的数字枚举之后。换句话说，下面的情况是不允许的：\n\n```tsx\nenum E {\n  A = getSomeValue(),\n  B,\n  // Ⓧ Enum成员必须有初始化器。\n}\n```\n\n## 3.2 字符串枚举\n\n字符串枚举是一个类似的概念，但有一些细微的运行时差异，如下文所述。在一个字符串枚举中，每个成员都必须用一个字符串字头或另一个字符串枚举成员进行常量初始化。\n\n```tsx\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}\n```\n\n虽然字符串枚举没有自动递增的行为，但字符串枚举有一个好处，那就是它们可以很好地 \"序列化\"。换句话说，如果你在调试时不得不读取一个数字枚举的运行时值，这个值往往是不透明的--它本身并不传达任何有用的意义（尽管 [反向映射](https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings)往往可以帮助你），字符串枚举允许你在代码运行时给出一个有意义的、可读的值，与枚举成员本身的名称无关。\n\n## 3.3 异构枚举\n\n从技术上讲，枚举可以与字符串和数字成员混合，但不清楚为什么你会想这样做：\n\n```\nenum BooleanLikeHeterogeneousEnum {\n  No = 0,\n  Yes = \"YES\",\n}\n```\n\n除非你真的想以一种巧妙的方式利用JavaScript的运行时行为，否则建议你不要这样做。\n\n## 3.4 计算型和常量型成员\n\n每个枚举成员都有一个与之相关的值，可以是常量，也可以是计算值。一个枚举成员被认为是常数，如果：\n\n- 它是枚举中的第一个成员，它没有初始化器，在这种情况下，它被赋值为 `0`：\n\n```tsx\n// E.X is constant:\nenum E {\n  X,\n}\n```\n\n- 它没有一个初始化器，而且前面的枚举成员是一个数字常数。在这种情况下，当前枚举成员的值将是前一个枚举成员的值加 `1`：\n\n```tsx\n// 'E1'和'E2'中的所有枚举成员都是常数。\nenum E1 {\n  X,\n  Y,\n  Z,\n}\nenum E2 {\n  A = 1,\n  B,\n  C,\n}\n```\n\n枚举成员用一个常量枚举表达式进行初始化。常量枚举表达式是TypeScript表达式的一个子集，可以在编译时进行完全评估。一个表达式是一个常量枚举表达式，如果它是：\n\n1. 枚举表达式的字面意思（基本上是一个字符串字面量或一个数字字面量）\n2. 对先前定义的常量枚举成员的引用（可以来自不同的枚举）。\n3. 一个括号内的常量枚举表达式\n4. 应用于常量枚举表达式的 `+`,` -`,` ~`单项运算符之一\n5. `+`,` -`,` *`,` /`,` %`, `<<`, `>>`, `>>`, `&`, `|`, `^` 以常量枚举表达式为操作数的二元运算符\n\n如果常量枚举表达式被评估为`NaN`或`Infinity`，这是一个编译时错误。\n\n在所有其他情况下，枚举成员被认为是计算出来的。\n\n```tsx\nenum FileAccess {\n  // 常量成员\n  None,\n  Read = 1 << 1,\n  Write = 1 << 2,\n  ReadWrite = Read | Write,\n  // 计算成员\n  G = \"123\".length,\n}\n```\n\n## 3.5 联合枚举和枚举成员类型\n\n有一个特殊的常量枚举成员的子集没有被计算：字面枚举成员。字面枚举成员是一个没有初始化值的常量枚举成员，或者其值被初始化为：\n\n- 任何字符串（例如：`\"foo\"`, `\"bar\"`, `\"baz\"`）。\n\n- 任何数字字头（例如：`1`，`100`）\n- 应用于任何数字字面的单数减号（例如：`-1`，`-100`）\n\n当一个枚举中的所有成员都有枚举的字面价值时，一些特殊的语义就会发挥作用。\n\n首先，枚举成员也成为了类型。例如，我们可以说某些成员只能有一个枚举成员的值：\n\n```tsx\nenum ShapeKind {\n  Circle,\n  Square,\n}\ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\ninterface Square {\n  kind: ShapeKind.Square;\n  sideLength: number;\n}\nlet c: Circle = {\n  kind: ShapeKind.Square,\n  // Ⓧ 类型 'ShapeKind.Square' 不能被分配给类型 'ShapeKind.Circle'\n  radius: 100,\n};\n```\n\n另一个变化是枚举类型本身有效地成为每个枚举成员的联盟。通过联合枚举，类型系统能够利用这一事实，即它知道存在于枚举本身的精确的值集。正因为如此，TypeScript可以捕捉到我们可能错误地比较数值的错误。比如说：\n\n```tsx\nenum E {\n  Foo,\n  Bar,\n}\n\nfunction f(x: E) {\n  if (x !== E.Foo || x !== E.Bar) {\n    // Ⓧ 这个条件将总是返回'true'，因为'E.Foo'和'E.Bar'的类型没有重合。\n    //...\n  }\n}\n```\n\n在这个例子中，我们首先检查了`x`是否不是`E.Foo`。如果这个检查成功了，那么我们的 `||` 就会短路，`'if'`的主体就会运行。然而，如果检查没有成功，那么 `x` 就只能是 `E.Foo`，所以看它是否等于 `E.Bar` 就没有意义了。\n\n## 3.6 运行时的枚举\n\n枚举是在运行时存在的真实对象。例如，下面这个枚举：\n\n```tsx\nenum E {\n  X,\n  Y,\n  Z,\n}\n```\n\n实际上可以被传递给函数：\n\n```tsx\nenum E {\n  X,\n  Y,\n  Z,\n}\n\nfunction f(obj: { X: number }) {\n  return obj.X;\n}\n\n// 可以正常工作，因为'E'有一个名为'X'的属性，是一个数字。\nf(E);\n```\n\n## 3.7 编译时的枚举\n\n尽管Enum是在运行时存在的真实对象，`keyof`关键字的工作方式与你对典型对象的预期不同。相反，使用`keyof typeof`来获得一个将所有Enum键表示为字符串的类型。\n\n```tsx\nenum LogLevel {\n  ERROR,\n  WARN,\n  INFO,\n  DEBUG,\n}\n/**\n * 这相当于:\n * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\n */\ntype LogLevelStrings = keyof typeof LogLevel;\n\nfunction printImportant(key: LogLevelStrings, message: string) {\n  const num = LogLevel[key];\n  if (num <= LogLevel.WARN) {\n    console.log(\"Log level key is:\", key);\n    console.log(\"Log level value is:\", num);\n    console.log(\"Log level message is:\", message);\n  }\n}\nprintImportant(\"ERROR\", \"This is a message\");\n```\n\n- **反向映射**\n\n除了为成员创建一个带有属性名称的对象外，数字枚举的成员还可以得到从枚举值到枚举名称的反向映射。例如，在这个例子中：\n\n```tsx\nenum Enum {\n  A,\n}\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n```\n\nTypeScript将其编译为以下的JavaScript：\n\n```js\n\"use strict\";\nvar Enum;\n(function (Enum) {\n  Enum[(Enum[\"A\"] = 0)] = \"A\";\n})(Enum || (Enum = {}));\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n```\n\n在这段生成的代码中，一个枚举被编译成一个对象，它同时存储了正向 (`name` -> `value`)和反向 (`value` -> `name`) 的映射关系。对其他枚举成员的引用总是以属性访问的方式发出，而且从不内联。\n\n请记住，字符串枚举成员根本不会被生成反向映射。\n\n- **`const`枚举**\n\n在大多数情况下，枚举是一个完全有效的解决方案。然而有时要求比较严格。为了避免在访问枚举值时支付额外的生成代码和额外的间接性的代价，可以使用`const`枚举。常量枚举是使用我们枚举上的 `const` 修饰符来定义的。\n\n```tsx\nconst enum Enum {\n  A = 1,\n  B = A * 2,\n}\n```\n\n常量枚举只能使用常量枚举表达式，与普通枚举不同，它们在编译过程中被完全删除。常量枚举成员在使用地点被内联。这是可能的，因为常量枚举不能有计算的成员。\n\n```tsx\nconst enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\nlet directions = [\n  Direction.Up,\n  Direction.Down,\n  Direction.Left,\n  Direction.Right,\n];\n```\n\n在生成的代码中，将变成：\n\n```js\n\"use strict\";\nlet directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n```\n\n## 3.8 环境枚举\n\n环境枚举是用来描述已经存在的枚举类型的形状。\n\n```tsx\ndeclare enum Enum {\n  A = 1,\n  B,\n  C = 2,\n}\n```\n\n环境枚举和非环境枚举之间的一个重要区别是，在常规枚举中，如果其前面的枚举成员被认为是常量，那么没有初始化器的成员将被认为是常量。相反，一个没有初始化器的环境（和非常量）枚举成员总是被认为是计算的。\n\n## 3.9 对象与枚举\n\n在现代TypeScript中，你可能不需要一个枚举，因为一个对象的常量就足够了：\n\n```tsx\nconst enum EDirection {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nconst ODirection = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: 3,\n} as const;\n\n// (enum member) EDirection.Up = 0\nEDirection.Up;\n\n// (property) Up: 0\nODirection.Up;\n\n// 将枚举作为一个参数\nfunction walk(dir: EDirection) {}\n\n// 它需要一个额外的行来拉出数值\ntype Direction = (typeof ODirection)[keyof typeof ODirection];\nfunction run(dir: Direction) {}\n\nwalk(EDirection.Left);\nrun(ODirection.Right);\n```\n\n与TypeScript的枚举相比，支持这种格式的最大理由是，它使你的代码库与JavaScript的状态保持一致，`when/if`枚举被添加到JavaScript中，那么你可以转移到额外的语法。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-3、高级篇：枚举",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao8001k94v3ef8rbu5l",
        "content": "<h1 id=\"三、枚举\"><a href=\"#三、枚举\" class=\"headerlink\" title=\"三、枚举\"></a>三、枚举</h1><p><code>Enums</code>是TypeScript的少数功能之一，它不是JavaScript的类型级扩展。</p>\n<p>枚举允许开发者定义一组命名的常量。使用枚举可以使其更容易记录意图，或创建一组不同的情况。TypeScript提供了基于数字和字符串的枚举。</p>\n<h2 id=\"3-1-数值型枚举\"><a href=\"#3-1-数值型枚举\" class=\"headerlink\" title=\"3.1 数值型枚举\"></a>3.1 数值型枚举</h2><p>我们首先从数字枚举开始，如果你来自其他语言，可能会更熟悉它。一个枚举可以用 <code>enum</code> 关键字来定义。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面，我们有一个数字枚举，其中 <code>Up</code> 被初始化为 <code>1</code> ，所有下面的成员从这一点开始自动递增。换句话说，<code>Direction.Up</code>的值是 <code>1</code> ，<code>Down</code> 是 <code>2</code>，<code>Left</code>是<code>3</code>，<code>Right</code>是<code>4</code>。</p>\n<p>如果我们愿意，我们可以完全不使用初始化器：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，Up的值是0，Down是1，依次类推。这种自动递增的行为对于我们可能不关心成员值本身，但关心每个值与同一枚举中的其他值不同的情况很有用。</p>\n<p>使用枚举很简单：只需将任何成员作为枚举本身的一个属性来访问，并使用枚举的名称来声明类型:</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">UserResponse</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">respond</span>(<span class=\"params\"><span class=\"attr\">recipient</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">message</span>: <span class=\"title class_\">UserResponse</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">respond</span>(<span class=\"string\">&quot;Princess Caroline&quot;</span>, <span class=\"title class_\">UserResponse</span>.<span class=\"property\">Yes</span>);</span><br></pre></td></tr></table></figure>\n\n<p>数字枚举可以混合在计算和常量成员中（见下文）。简而言之，没有初始化器的枚举要么需要放在第一位，要么必须放在用数字常量或其他常量枚举成员初始化的数字枚举之后。换句话说，下面的情况是不允许的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  A = <span class=\"title function_\">getSomeValue</span>(),</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  <span class=\"comment\">// Ⓧ Enum成员必须有初始化器。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-字符串枚举\"><a href=\"#3-2-字符串枚举\" class=\"headerlink\" title=\"3.2 字符串枚举\"></a>3.2 字符串枚举</h2><p>字符串枚举是一个类似的概念，但有一些细微的运行时差异，如下文所述。在一个字符串枚举中，每个成员都必须用一个字符串字头或另一个字符串枚举成员进行常量初始化。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span> = <span class=\"string\">&quot;UP&quot;</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span> = <span class=\"string\">&quot;DOWN&quot;</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span> = <span class=\"string\">&quot;LEFT&quot;</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span> = <span class=\"string\">&quot;RIGHT&quot;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然字符串枚举没有自动递增的行为，但字符串枚举有一个好处，那就是它们可以很好地 “序列化”。换句话说，如果你在调试时不得不读取一个数字枚举的运行时值，这个值往往是不透明的–它本身并不传达任何有用的意义（尽管 <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\">反向映射</a>往往可以帮助你），字符串枚举允许你在代码运行时给出一个有意义的、可读的值，与枚举成员本身的名称无关。</p>\n<h2 id=\"3-3-异构枚举\"><a href=\"#3-3-异构枚举\" class=\"headerlink\" title=\"3.3 异构枚举\"></a>3.3 异构枚举</h2><p>从技术上讲，枚举可以与字符串和数字成员混合，但不清楚为什么你会想这样做：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum BooleanLikeHeterogeneousEnum &#123;</span><br><span class=\"line\">  No = 0,</span><br><span class=\"line\">  Yes = &quot;YES&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除非你真的想以一种巧妙的方式利用JavaScript的运行时行为，否则建议你不要这样做。</p>\n<h2 id=\"3-4-计算型和常量型成员\"><a href=\"#3-4-计算型和常量型成员\" class=\"headerlink\" title=\"3.4 计算型和常量型成员\"></a>3.4 计算型和常量型成员</h2><p>每个枚举成员都有一个与之相关的值，可以是常量，也可以是计算值。一个枚举成员被认为是常数，如果：</p>\n<ul>\n<li>它是枚举中的第一个成员，它没有初始化器，在这种情况下，它被赋值为 <code>0</code>：</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// E.X is constant:</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>它没有一个初始化器，而且前面的枚举成员是一个数字常数。在这种情况下，当前枚举成员的值将是前一个枚举成员的值加 <code>1</code>：</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#x27;E1&#x27;和&#x27;E2&#x27;中的所有枚举成员都是常数。</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"variable constant_\">E1</span> &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"variable constant_\">E2</span> &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举成员用一个常量枚举表达式进行初始化。常量枚举表达式是TypeScript表达式的一个子集，可以在编译时进行完全评估。一个表达式是一个常量枚举表达式，如果它是：</p>\n<ol>\n<li>枚举表达式的字面意思（基本上是一个字符串字面量或一个数字字面量）</li>\n<li>对先前定义的常量枚举成员的引用（可以来自不同的枚举）。</li>\n<li>一个括号内的常量枚举表达式</li>\n<li>应用于常量枚举表达式的 <code>+</code>,<code> -</code>,<code> ~</code>单项运算符之一</li>\n<li><code>+</code>,<code> -</code>,<code> *</code>,<code> /</code>,<code> %</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 以常量枚举表达式为操作数的二元运算符</li>\n</ol>\n<p>如果常量枚举表达式被评估为<code>NaN</code>或<code>Infinity</code>，这是一个编译时错误。</p>\n<p>在所有其他情况下，枚举成员被认为是计算出来的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">FileAccess</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 常量成员</span></span><br><span class=\"line\">  <span class=\"title class_\">None</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Read</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Write</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"title class_\">ReadWrite</span> = <span class=\"title class_\">Read</span> | <span class=\"title class_\">Write</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 计算成员</span></span><br><span class=\"line\">  G = <span class=\"string\">&quot;123&quot;</span>.<span class=\"property\">length</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-联合枚举和枚举成员类型\"><a href=\"#3-5-联合枚举和枚举成员类型\" class=\"headerlink\" title=\"3.5 联合枚举和枚举成员类型\"></a>3.5 联合枚举和枚举成员类型</h2><p>有一个特殊的常量枚举成员的子集没有被计算：字面枚举成员。字面枚举成员是一个没有初始化值的常量枚举成员，或者其值被初始化为：</p>\n<ul>\n<li><p>任何字符串（例如：<code>&quot;foo&quot;</code>, <code>&quot;bar&quot;</code>, <code>&quot;baz&quot;</code>）。</p>\n</li>\n<li><p>任何数字字头（例如：<code>1</code>，<code>100</code>）</p>\n</li>\n<li><p>应用于任何数字字面的单数减号（例如：<code>-1</code>，<code>-100</code>）</p>\n</li>\n</ul>\n<p>当一个枚举中的所有成员都有枚举的字面价值时，一些特殊的语义就会发挥作用。</p>\n<p>首先，枚举成员也成为了类型。例如，我们可以说某些成员只能有一个枚举成员的值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">ShapeKind</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Circle</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Square</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"title class_\">ShapeKind</span>.<span class=\"property\">Circle</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"title class_\">ShapeKind</span>.<span class=\"property\">Square</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">c</span>: <span class=\"title class_\">Circle</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"title class_\">ShapeKind</span>.<span class=\"property\">Square</span>,</span><br><span class=\"line\">  <span class=\"comment\">// Ⓧ 类型 &#x27;ShapeKind.Square&#x27; 不能被分配给类型 &#x27;ShapeKind.Circle&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>另一个变化是枚举类型本身有效地成为每个枚举成员的联盟。通过联合枚举，类型系统能够利用这一事实，即它知道存在于枚举本身的精确的值集。正因为如此，TypeScript可以捕捉到我们可能错误地比较数值的错误。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Foo</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Bar</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">x</span>: E</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== E.<span class=\"property\">Foo</span> || x !== E.<span class=\"property\">Bar</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Ⓧ 这个条件将总是返回&#x27;true&#x27;，因为&#x27;E.Foo&#x27;和&#x27;E.Bar&#x27;的类型没有重合。</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们首先检查了<code>x</code>是否不是<code>E.Foo</code>。如果这个检查成功了，那么我们的 <code>||</code> 就会短路，<code>&#39;if&#39;</code>的主体就会运行。然而，如果检查没有成功，那么 <code>x</code> 就只能是 <code>E.Foo</code>，所以看它是否等于 <code>E.Bar</code> 就没有意义了。</p>\n<h2 id=\"3-6-运行时的枚举\"><a href=\"#3-6-运行时的枚举\" class=\"headerlink\" title=\"3.6 运行时的枚举\"></a>3.6 运行时的枚举</h2><p>枚举是在运行时存在的真实对象。例如，下面这个枚举：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上可以被传递给函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; X: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj.<span class=\"property\">X</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以正常工作，因为&#x27;E&#x27;有一个名为&#x27;X&#x27;的属性，是一个数字。</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(E);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7-编译时的枚举\"><a href=\"#3-7-编译时的枚举\" class=\"headerlink\" title=\"3.7 编译时的枚举\"></a>3.7 编译时的枚举</h2><p>尽管Enum是在运行时存在的真实对象，<code>keyof</code>关键字的工作方式与你对典型对象的预期不同。相反，使用<code>keyof typeof</code>来获得一个将所有Enum键表示为字符串的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">LogLevel</span> &#123;</span><br><span class=\"line\">  <span class=\"variable constant_\">ERROR</span>,</span><br><span class=\"line\">  <span class=\"variable constant_\">WARN</span>,</span><br><span class=\"line\">  <span class=\"variable constant_\">INFO</span>,</span><br><span class=\"line\">  <span class=\"variable constant_\">DEBUG</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这相当于:</span></span><br><span class=\"line\"><span class=\"comment\"> * type LogLevelStrings = &#x27;ERROR&#x27; | &#x27;WARN&#x27; | &#x27;INFO&#x27; | &#x27;DEBUG&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">LogLevelStrings</span> = keyof <span class=\"keyword\">typeof</span> <span class=\"title class_\">LogLevel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printImportant</span>(<span class=\"params\"><span class=\"attr\">key</span>: <span class=\"title class_\">LogLevelStrings</span>, <span class=\"attr\">message</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = <span class=\"title class_\">LogLevel</span>[key];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= <span class=\"title class_\">LogLevel</span>.<span class=\"property\">WARN</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Log level key is:&quot;</span>, key);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Log level value is:&quot;</span>, num);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Log level message is:&quot;</span>, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printImportant</span>(<span class=\"string\">&quot;ERROR&quot;</span>, <span class=\"string\">&quot;This is a message&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>反向映射</strong></li>\n</ul>\n<p>除了为成员创建一个带有属性名称的对象外，数字枚举的成员还可以得到从枚举值到枚举名称的反向映射。例如，在这个例子中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Enum</span> &#123;</span><br><span class=\"line\">  A,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"title class_\">Enum</span>.<span class=\"property\">A</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> nameOfA = <span class=\"title class_\">Enum</span>[a]; <span class=\"comment\">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>TypeScript将其编译为以下的JavaScript：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Enum</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\">Enum</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Enum</span>[(<span class=\"title class_\">Enum</span>[<span class=\"string\">&quot;A&quot;</span>] = <span class=\"number\">0</span>)] = <span class=\"string\">&quot;A&quot;</span>;</span><br><span class=\"line\">&#125;)(<span class=\"title class_\">Enum</span> || (<span class=\"title class_\">Enum</span> = &#123;&#125;));</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"title class_\">Enum</span>.<span class=\"property\">A</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> nameOfA = <span class=\"title class_\">Enum</span>[a]; <span class=\"comment\">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这段生成的代码中，一个枚举被编译成一个对象，它同时存储了正向 (<code>name</code> -&gt; <code>value</code>)和反向 (<code>value</code> -&gt; <code>name</code>) 的映射关系。对其他枚举成员的引用总是以属性访问的方式发出，而且从不内联。</p>\n<p>请记住，字符串枚举成员根本不会被生成反向映射。</p>\n<ul>\n<li><strong><code>const</code>枚举</strong></li>\n</ul>\n<p>在大多数情况下，枚举是一个完全有效的解决方案。然而有时要求比较严格。为了避免在访问枚举值时支付额外的生成代码和额外的间接性的代价，可以使用<code>const</code>枚举。常量枚举是使用我们枚举上的 <code>const</code> 修饰符来定义的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Enum</span> &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B = A * <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常量枚举只能使用常量枚举表达式，与普通枚举不同，它们在编译过程中被完全删除。常量枚举成员在使用地点被内联。这是可能的，因为常量枚举不能有计算的成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> directions = [</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>.<span class=\"property\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>.<span class=\"property\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>.<span class=\"property\">Right</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>在生成的代码中，将变成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> directions = [<span class=\"number\">0</span> <span class=\"comment\">/* Up */</span>, <span class=\"number\">1</span> <span class=\"comment\">/* Down */</span>, <span class=\"number\">2</span> <span class=\"comment\">/* Left */</span>, <span class=\"number\">3</span> <span class=\"comment\">/* Right */</span>];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-8-环境枚举\"><a href=\"#3-8-环境枚举\" class=\"headerlink\" title=\"3.8 环境枚举\"></a>3.8 环境枚举</h2><p>环境枚举是用来描述已经存在的枚举类型的形状。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Enum</span> &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C = <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>环境枚举和非环境枚举之间的一个重要区别是，在常规枚举中，如果其前面的枚举成员被认为是常量，那么没有初始化器的成员将被认为是常量。相反，一个没有初始化器的环境（和非常量）枚举成员总是被认为是计算的。</p>\n<h2 id=\"3-9-对象与枚举\"><a href=\"#3-9-对象与枚举\" class=\"headerlink\" title=\"3.9 对象与枚举\"></a>3.9 对象与枚举</h2><p>在现代TypeScript中，你可能不需要一个枚举，因为一个对象的常量就足够了：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">EDirection</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ODirection</span> = &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (enum member) EDirection.Up = 0</span></span><br><span class=\"line\"><span class=\"title class_\">EDirection</span>.<span class=\"property\">Up</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (property) Up: 0</span></span><br><span class=\"line\"><span class=\"title class_\">ODirection</span>.<span class=\"property\">Up</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将枚举作为一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">walk</span>(<span class=\"params\"><span class=\"attr\">dir</span>: <span class=\"title class_\">EDirection</span></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 它需要一个额外的行来拉出数值</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Direction</span> = (<span class=\"keyword\">typeof</span> <span class=\"title class_\">ODirection</span>)[keyof <span class=\"keyword\">typeof</span> <span class=\"title class_\">ODirection</span>];</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">run</span>(<span class=\"params\"><span class=\"attr\">dir</span>: <span class=\"title class_\">Direction</span></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">walk</span>(<span class=\"title class_\">EDirection</span>.<span class=\"property\">Left</span>);</span><br><span class=\"line\"><span class=\"title function_\">run</span>(<span class=\"title class_\">ODirection</span>.<span class=\"property\">Right</span>);</span><br></pre></td></tr></table></figure>\n\n<p>与TypeScript的枚举相比，支持这种格式的最大理由是，它使你的代码库与JavaScript的状态保持一致，<code>when/if</code>枚举被添加到JavaScript中，那么你可以转移到额外的语法。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"三、枚举\"><a href=\"#三、枚举\" class=\"headerlink\" title=\"三、枚举\"></a>三、枚举</h1><p><code>Enums</code>是TypeScript的少数功能之一，它不是JavaScript的类型级扩展。</p>\n<p>枚举允许开发者定义一组命名的常量。使用枚举可以使其更容易记录意图，或创建一组不同的情况。TypeScript提供了基于数字和字符串的枚举。</p>\n<h2 id=\"3-1-数值型枚举\"><a href=\"#3-1-数值型枚举\" class=\"headerlink\" title=\"3.1 数值型枚举\"></a>3.1 数值型枚举</h2><p>我们首先从数字枚举开始，如果你来自其他语言，可能会更熟悉它。一个枚举可以用 <code>enum</code> 关键字来定义。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面，我们有一个数字枚举，其中 <code>Up</code> 被初始化为 <code>1</code> ，所有下面的成员从这一点开始自动递增。换句话说，<code>Direction.Up</code>的值是 <code>1</code> ，<code>Down</code> 是 <code>2</code>，<code>Left</code>是<code>3</code>，<code>Right</code>是<code>4</code>。</p>\n<p>如果我们愿意，我们可以完全不使用初始化器：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，Up的值是0，Down是1，依次类推。这种自动递增的行为对于我们可能不关心成员值本身，但关心每个值与同一枚举中的其他值不同的情况很有用。</p>\n<p>使用枚举很简单：只需将任何成员作为枚举本身的一个属性来访问，并使用枚举的名称来声明类型:</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">UserResponse</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">No</span> = <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Yes</span> = <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">respond</span>(<span class=\"params\"><span class=\"attr\">recipient</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">message</span>: <span class=\"title class_\">UserResponse</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">respond</span>(<span class=\"string\">&quot;Princess Caroline&quot;</span>, <span class=\"title class_\">UserResponse</span>.<span class=\"property\">Yes</span>);</span><br></pre></td></tr></table></figure>\n\n<p>数字枚举可以混合在计算和常量成员中（见下文）。简而言之，没有初始化器的枚举要么需要放在第一位，要么必须放在用数字常量或其他常量枚举成员初始化的数字枚举之后。换句话说，下面的情况是不允许的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  A = <span class=\"title function_\">getSomeValue</span>(),</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  <span class=\"comment\">// Ⓧ Enum成员必须有初始化器。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-字符串枚举\"><a href=\"#3-2-字符串枚举\" class=\"headerlink\" title=\"3.2 字符串枚举\"></a>3.2 字符串枚举</h2><p>字符串枚举是一个类似的概念，但有一些细微的运行时差异，如下文所述。在一个字符串枚举中，每个成员都必须用一个字符串字头或另一个字符串枚举成员进行常量初始化。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span> = <span class=\"string\">&quot;UP&quot;</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span> = <span class=\"string\">&quot;DOWN&quot;</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span> = <span class=\"string\">&quot;LEFT&quot;</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span> = <span class=\"string\">&quot;RIGHT&quot;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然字符串枚举没有自动递增的行为，但字符串枚举有一个好处，那就是它们可以很好地 “序列化”。换句话说，如果你在调试时不得不读取一个数字枚举的运行时值，这个值往往是不透明的–它本身并不传达任何有用的意义（尽管 <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\">反向映射</a>往往可以帮助你），字符串枚举允许你在代码运行时给出一个有意义的、可读的值，与枚举成员本身的名称无关。</p>\n<h2 id=\"3-3-异构枚举\"><a href=\"#3-3-异构枚举\" class=\"headerlink\" title=\"3.3 异构枚举\"></a>3.3 异构枚举</h2><p>从技术上讲，枚举可以与字符串和数字成员混合，但不清楚为什么你会想这样做：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum BooleanLikeHeterogeneousEnum &#123;</span><br><span class=\"line\">  No = 0,</span><br><span class=\"line\">  Yes = &quot;YES&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除非你真的想以一种巧妙的方式利用JavaScript的运行时行为，否则建议你不要这样做。</p>\n<h2 id=\"3-4-计算型和常量型成员\"><a href=\"#3-4-计算型和常量型成员\" class=\"headerlink\" title=\"3.4 计算型和常量型成员\"></a>3.4 计算型和常量型成员</h2><p>每个枚举成员都有一个与之相关的值，可以是常量，也可以是计算值。一个枚举成员被认为是常数，如果：</p>\n<ul>\n<li>它是枚举中的第一个成员，它没有初始化器，在这种情况下，它被赋值为 <code>0</code>：</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// E.X is constant:</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>它没有一个初始化器，而且前面的枚举成员是一个数字常数。在这种情况下，当前枚举成员的值将是前一个枚举成员的值加 <code>1</code>：</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#x27;E1&#x27;和&#x27;E2&#x27;中的所有枚举成员都是常数。</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"variable constant_\">E1</span> &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"variable constant_\">E2</span> &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举成员用一个常量枚举表达式进行初始化。常量枚举表达式是TypeScript表达式的一个子集，可以在编译时进行完全评估。一个表达式是一个常量枚举表达式，如果它是：</p>\n<ol>\n<li>枚举表达式的字面意思（基本上是一个字符串字面量或一个数字字面量）</li>\n<li>对先前定义的常量枚举成员的引用（可以来自不同的枚举）。</li>\n<li>一个括号内的常量枚举表达式</li>\n<li>应用于常量枚举表达式的 <code>+</code>,<code> -</code>,<code> ~</code>单项运算符之一</li>\n<li><code>+</code>,<code> -</code>,<code> *</code>,<code> /</code>,<code> %</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 以常量枚举表达式为操作数的二元运算符</li>\n</ol>\n<p>如果常量枚举表达式被评估为<code>NaN</code>或<code>Infinity</code>，这是一个编译时错误。</p>\n<p>在所有其他情况下，枚举成员被认为是计算出来的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">FileAccess</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 常量成员</span></span><br><span class=\"line\">  <span class=\"title class_\">None</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Read</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Write</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"title class_\">ReadWrite</span> = <span class=\"title class_\">Read</span> | <span class=\"title class_\">Write</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 计算成员</span></span><br><span class=\"line\">  G = <span class=\"string\">&quot;123&quot;</span>.<span class=\"property\">length</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-联合枚举和枚举成员类型\"><a href=\"#3-5-联合枚举和枚举成员类型\" class=\"headerlink\" title=\"3.5 联合枚举和枚举成员类型\"></a>3.5 联合枚举和枚举成员类型</h2><p>有一个特殊的常量枚举成员的子集没有被计算：字面枚举成员。字面枚举成员是一个没有初始化值的常量枚举成员，或者其值被初始化为：</p>\n<ul>\n<li><p>任何字符串（例如：<code>&quot;foo&quot;</code>, <code>&quot;bar&quot;</code>, <code>&quot;baz&quot;</code>）。</p>\n</li>\n<li><p>任何数字字头（例如：<code>1</code>，<code>100</code>）</p>\n</li>\n<li><p>应用于任何数字字面的单数减号（例如：<code>-1</code>，<code>-100</code>）</p>\n</li>\n</ul>\n<p>当一个枚举中的所有成员都有枚举的字面价值时，一些特殊的语义就会发挥作用。</p>\n<p>首先，枚举成员也成为了类型。例如，我们可以说某些成员只能有一个枚举成员的值：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">ShapeKind</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Circle</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Square</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"title class_\">ShapeKind</span>.<span class=\"property\">Circle</span>;</span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"title class_\">ShapeKind</span>.<span class=\"property\">Square</span>;</span><br><span class=\"line\">  <span class=\"attr\">sideLength</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">c</span>: <span class=\"title class_\">Circle</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">kind</span>: <span class=\"title class_\">ShapeKind</span>.<span class=\"property\">Square</span>,</span><br><span class=\"line\">  <span class=\"comment\">// Ⓧ 类型 &#x27;ShapeKind.Square&#x27; 不能被分配给类型 &#x27;ShapeKind.Circle&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">radius</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>另一个变化是枚举类型本身有效地成为每个枚举成员的联盟。通过联合枚举，类型系统能够利用这一事实，即它知道存在于枚举本身的精确的值集。正因为如此，TypeScript可以捕捉到我们可能错误地比较数值的错误。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Foo</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Bar</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">x</span>: E</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== E.<span class=\"property\">Foo</span> || x !== E.<span class=\"property\">Bar</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Ⓧ 这个条件将总是返回&#x27;true&#x27;，因为&#x27;E.Foo&#x27;和&#x27;E.Bar&#x27;的类型没有重合。</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们首先检查了<code>x</code>是否不是<code>E.Foo</code>。如果这个检查成功了，那么我们的 <code>||</code> 就会短路，<code>&#39;if&#39;</code>的主体就会运行。然而，如果检查没有成功，那么 <code>x</code> 就只能是 <code>E.Foo</code>，所以看它是否等于 <code>E.Bar</code> 就没有意义了。</p>\n<h2 id=\"3-6-运行时的枚举\"><a href=\"#3-6-运行时的枚举\" class=\"headerlink\" title=\"3.6 运行时的枚举\"></a>3.6 运行时的枚举</h2><p>枚举是在运行时存在的真实对象。例如，下面这个枚举：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上可以被传递给函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> E &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"><span class=\"attr\">obj</span>: &#123; X: <span class=\"built_in\">number</span> &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj.<span class=\"property\">X</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以正常工作，因为&#x27;E&#x27;有一个名为&#x27;X&#x27;的属性，是一个数字。</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>(E);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7-编译时的枚举\"><a href=\"#3-7-编译时的枚举\" class=\"headerlink\" title=\"3.7 编译时的枚举\"></a>3.7 编译时的枚举</h2><p>尽管Enum是在运行时存在的真实对象，<code>keyof</code>关键字的工作方式与你对典型对象的预期不同。相反，使用<code>keyof typeof</code>来获得一个将所有Enum键表示为字符串的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">LogLevel</span> &#123;</span><br><span class=\"line\">  <span class=\"variable constant_\">ERROR</span>,</span><br><span class=\"line\">  <span class=\"variable constant_\">WARN</span>,</span><br><span class=\"line\">  <span class=\"variable constant_\">INFO</span>,</span><br><span class=\"line\">  <span class=\"variable constant_\">DEBUG</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这相当于:</span></span><br><span class=\"line\"><span class=\"comment\"> * type LogLevelStrings = &#x27;ERROR&#x27; | &#x27;WARN&#x27; | &#x27;INFO&#x27; | &#x27;DEBUG&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">LogLevelStrings</span> = keyof <span class=\"keyword\">typeof</span> <span class=\"title class_\">LogLevel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printImportant</span>(<span class=\"params\"><span class=\"attr\">key</span>: <span class=\"title class_\">LogLevelStrings</span>, <span class=\"attr\">message</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = <span class=\"title class_\">LogLevel</span>[key];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= <span class=\"title class_\">LogLevel</span>.<span class=\"property\">WARN</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Log level key is:&quot;</span>, key);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Log level value is:&quot;</span>, num);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Log level message is:&quot;</span>, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">printImportant</span>(<span class=\"string\">&quot;ERROR&quot;</span>, <span class=\"string\">&quot;This is a message&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>反向映射</strong></li>\n</ul>\n<p>除了为成员创建一个带有属性名称的对象外，数字枚举的成员还可以得到从枚举值到枚举名称的反向映射。例如，在这个例子中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Enum</span> &#123;</span><br><span class=\"line\">  A,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"title class_\">Enum</span>.<span class=\"property\">A</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> nameOfA = <span class=\"title class_\">Enum</span>[a]; <span class=\"comment\">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>TypeScript将其编译为以下的JavaScript：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Enum</span>;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\">Enum</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Enum</span>[(<span class=\"title class_\">Enum</span>[<span class=\"string\">&quot;A&quot;</span>] = <span class=\"number\">0</span>)] = <span class=\"string\">&quot;A&quot;</span>;</span><br><span class=\"line\">&#125;)(<span class=\"title class_\">Enum</span> || (<span class=\"title class_\">Enum</span> = &#123;&#125;));</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"title class_\">Enum</span>.<span class=\"property\">A</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> nameOfA = <span class=\"title class_\">Enum</span>[a]; <span class=\"comment\">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这段生成的代码中，一个枚举被编译成一个对象，它同时存储了正向 (<code>name</code> -&gt; <code>value</code>)和反向 (<code>value</code> -&gt; <code>name</code>) 的映射关系。对其他枚举成员的引用总是以属性访问的方式发出，而且从不内联。</p>\n<p>请记住，字符串枚举成员根本不会被生成反向映射。</p>\n<ul>\n<li><strong><code>const</code>枚举</strong></li>\n</ul>\n<p>在大多数情况下，枚举是一个完全有效的解决方案。然而有时要求比较严格。为了避免在访问枚举值时支付额外的生成代码和额外的间接性的代价，可以使用<code>const</code>枚举。常量枚举是使用我们枚举上的 <code>const</code> 修饰符来定义的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Enum</span> &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B = A * <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常量枚举只能使用常量枚举表达式，与普通枚举不同，它们在编译过程中被完全删除。常量枚举成员在使用地点被内联。这是可能的，因为常量枚举不能有计算的成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Direction</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> directions = [</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>.<span class=\"property\">Up</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>.<span class=\"property\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>.<span class=\"property\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Direction</span>.<span class=\"property\">Right</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>在生成的代码中，将变成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> directions = [<span class=\"number\">0</span> <span class=\"comment\">/* Up */</span>, <span class=\"number\">1</span> <span class=\"comment\">/* Down */</span>, <span class=\"number\">2</span> <span class=\"comment\">/* Left */</span>, <span class=\"number\">3</span> <span class=\"comment\">/* Right */</span>];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-8-环境枚举\"><a href=\"#3-8-环境枚举\" class=\"headerlink\" title=\"3.8 环境枚举\"></a>3.8 环境枚举</h2><p>环境枚举是用来描述已经存在的枚举类型的形状。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Enum</span> &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C = <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>环境枚举和非环境枚举之间的一个重要区别是，在常规枚举中，如果其前面的枚举成员被认为是常量，那么没有初始化器的成员将被认为是常量。相反，一个没有初始化器的环境（和非常量）枚举成员总是被认为是计算的。</p>\n<h2 id=\"3-9-对象与枚举\"><a href=\"#3-9-对象与枚举\" class=\"headerlink\" title=\"3.9 对象与枚举\"></a>3.9 对象与枚举</h2><p>在现代TypeScript中，你可能不需要一个枚举，因为一个对象的常量就足够了：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">EDirection</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ODirection</span> = &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Up</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Down</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Left</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Right</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125; <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (enum member) EDirection.Up = 0</span></span><br><span class=\"line\"><span class=\"title class_\">EDirection</span>.<span class=\"property\">Up</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (property) Up: 0</span></span><br><span class=\"line\"><span class=\"title class_\">ODirection</span>.<span class=\"property\">Up</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将枚举作为一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">walk</span>(<span class=\"params\"><span class=\"attr\">dir</span>: <span class=\"title class_\">EDirection</span></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 它需要一个额外的行来拉出数值</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Direction</span> = (<span class=\"keyword\">typeof</span> <span class=\"title class_\">ODirection</span>)[keyof <span class=\"keyword\">typeof</span> <span class=\"title class_\">ODirection</span>];</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">run</span>(<span class=\"params\"><span class=\"attr\">dir</span>: <span class=\"title class_\">Direction</span></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">walk</span>(<span class=\"title class_\">EDirection</span>.<span class=\"property\">Left</span>);</span><br><span class=\"line\"><span class=\"title function_\">run</span>(<span class=\"title class_\">ODirection</span>.<span class=\"property\">Right</span>);</span><br></pre></td></tr></table></figure>\n\n<p>与TypeScript的枚举相比，支持这种格式的最大理由是，它使你的代码库与JavaScript的状态保持一致，<code>when/if</code>枚举被添加到JavaScript中，那么你可以转移到额外的语法。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-6、高级篇：类型兼容性",
        "toc": true,
        "abbrlink": 44933,
        "date": "2024-01-28T13:07:47.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 六、类型兼容性\n\nTypeScript中的类型兼容性是基于结构子类型的。结构分型是一种完全基于其成员的类型关系的方式。这与名义类型不同。考虑一下下面的代码：\n\n```tsx\ninterface Pet {\n  name: string;\n}\nclass Dog {\n  name: string;\n}\nlet pet: Pet;\n// 正确，因为结构化类型\npet = new Dog();\n```\n\n在像 `C#`或`Java`这样的名义类型语言中，相应的代码将是一个错误，因为 `Dog` 类没有明确地描述自己是 `Pet` 接口的实现者。\n\nTypeScript的结构类型系统是根据JavaScript代码的典型写法设计的。因为JavaScript广泛使用匿名对象，如函数表达式和对象字面量，用结构类型系统而不是命名类型系统来表示JavaScript库中的各种关系要自然得多。\n\n## 6.1 关于健全性的说明\n\nTypeScript 的类型系统允许某些在编译时无法知道的操作是安全的。当一个类型系统具有这种属性时，它被称为不 \"健全\"。我们仔细考虑了 TypeScript 允许不健全行为的地方，在这篇文档中，我们将解释这些发生的地方以及它们背后的动机情景。\n\n## 6.2 起步\n\nTypeScript的结构类型系统的基本规则是，如果 `y` 至少有与 `x` 相同的成员，那么 `x` 与 `y` 是兼容的。\n\n```tsx\ninterface Pet {\n  name: string;\n}\nlet pet: Pet;\n// dog's 推断类型是 { name: string; owner: string; }\nlet dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };\npet = dog;\n```\n\n为了检查 `dog` 是否可以被分配给 `pet`，编译器检查 `pet` 的每个属性，以找到 `dog` 中相应的兼容属性。在这种情况下，`dog` 必须有一个名为 `name` 的成员，它是一个字符串。它有，所以赋值是允许的。\n\n在检查函数调用参数时，也使用了同样的赋值规则。\n\n```tsx\ninterface Pet {\n  name: string;\n}\nlet dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };\nfunction greet(pet: Pet) {\n  console.log(\"Hello, \" + pet.name);\n}\ngreet(dog); // 正确\n```\n\n请注意，`dog` 有一个额外的 `owner` 属性，但这并不产生错误。在检查兼容性时，只考虑目标类型（本例中为 `Pet`）的成员。\n\n这个比较过程是递归进行的，探索每个成员和子成员的类型。\n\n## 6.3 对比两个函数\n\n虽然比较原始类型和对象类型是相对直接的，但什么样的函数应该被认为是兼容的，这个问题就有点复杂了。让我们从两个函数的基本例子开始，这两个函数只在参数列表上有所不同：\n\n```tsx\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\ny = x; // 正确\nx = y; // 错误\n```\n\n为了检查 `x` 是否可以分配给 `y`，我们首先看一下参数列表。`x` 中的每个参数在 `y` 中都必须有一个类型兼容的对应参数。注意，参数的名称不被考虑，只考虑它们的类型。在这种情况下，`x` 中的每个参数在 `y` 中都有一个对应的兼容参数，所以这个赋值是允许的。\n\n第二个赋值是一个错误，因为 `y` 有一个 `x` 没有的必要的第二个参数，所以这个赋值是不允许的。\n\n你可能想知道为什么我们允许像例子中的 `y = x` 那样 \"丢弃 \"参数。这个赋值被允许的原因是，忽略额外的函数参数在JavaScript中其实很常见。例如，`Array#forEach`为回调函数提供了三个参数：数组元素、其索引和包含数组。尽管如此，提供一个只使用第一个参数的回调是非常有用的：\n\n```tsx\nlet items = [1, 2, 3];\n// 不要强迫这些额外参数\nitems.forEach((item, index, array) => console.log(item));\n// 应该没有问题!\nitems.forEach((item) => console.log(item));\n```\n\n现在让我们看看如何处理返回类型，使用两个只因返回类型不同的函数：\n\n```tsx\nlet x = () => ({ name: \"Alice\" });\nlet y = () => ({ name: \"Alice\", location: \"Seattle\" });\nx = y; // 正确\ny = x; // 错误，因为x()缺少一个location属性\n```\n\n类型系统强制要求源函数的返回类型是目标类型的返回类型的一个子类型。\n\n## 6.4 函数参数的双差性\n\n```tsx\nenum EventType {\n  Mouse,\n  Keyboard,\n}\ninterface Event {\n  timestamp: number;\n}\ninterface MyMouseEvent extends Event {\n  x: number;\n  y: number;\n}\ninterface MyKeyEvent extends Event {\n  keyCode: number;\n}\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n  /* ... */\n}\n// 不健全，但有用且常见\nlistenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + \",\" + e.y));\n// 在健全性存在的情况下，不可取的选择\nlistenEvent(EventType.Mouse, (e: Event) =>\n  console.log((e as MyMouseEvent).x + \",\" + (e as MyMouseEvent).y),\n);\nlistenEvent(EventType.Mouse, ((e: MyMouseEvent) =>\n  console.log(e.x + \",\" + e.y)) as (e: Event) => void);\n// 仍然不允许（明确的错误）。对于完全不兼容的类型强制执行类型安全\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\n当这种情况发生时，你可以让TypeScript通过编译器标志 [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes)引发错误。\n\n## 6.5 可选参数和其余参数\n\n在比较函数的兼容性时，可选参数和必需参数是可以互换的。源类型的额外可选参数不是错误，而目标类型的可选参数在源类型中没有对应的参数也不是错误。\n\n当一个函数有一个剩余参数时，它被当作是一个无限的可选参数系列。\n\n从类型系统的角度来看，这是不健全的，但从运行时的角度来看，可选参数的概念一般不会得到很好的加强，因为在这个位置传递 `undefined` 的参数对大多数函数来说是等价的。\n\n激励性的例子是一个函数的常见模式，它接受一个回调，并用一些可预测的（对程序员）但未知的（对类型系统）参数数量来调用它。\n\n```tsx\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n  /* ... 用'args'调用回调 ... */\n}\n// 不健全 - invokeLater \"可能 \"提供任何数量的参数\ninvokeLater([1, 2], (x, y) => console.log(x + \", \" + y));\n// 令人困惑的是（x和y实际上是需要的），而且是无法发现的\ninvokeLater([1, 2], (x?, y?) => console.log(x + \", \" + y));\n```\n\n## 6.6 带有重载的函数\n\n当一个函数有重载时，源类型中的每个重载必须由目标类型上的兼容签名来匹配。这保证了目标函数可以在所有与源函数相同的情况下被调用。\n\n## 6.7 枚举\n\n枚举与数字兼容，而数字与枚举兼容。来自不同枚举类型的枚举值被认为是不兼容的。比如说：\n\n```tsx\nenum Status {\n  Ready,\n  Waiting,\n}\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\nlet status = Status.Ready;\nstatus = Color.Green; // 错误\n```\n\n## 6.8 类\n\n类的工作方式与对象字面类型和接口类似，但有一个例外：它们同时具有静态和实例类型。当比较一个类类型的两个对象时，只有实例的成员被比较。静态成员和构造函数不影响兼容性。\n\n```tsx\nclass Animal {\n  feet: number;\n  constructor(name: string, numFeet: number) {}\n}\nclass Size {\n  feet: number;\n  constructor(numFeet: number) {}\n}\nlet a: Animal;\nlet s: Size;\na = s; // 正确\ns = a; // 正确\n```\n\n## 6.9 类中的私有和受保护成员\n\n一个类中的私有成员和保护成员会影响其兼容性。当一个类的实例被检查兼容性时，如果目标类型包含一个私有成员，那么源类型也必须包含一个源自同一类的私有成员。同样地，这也适用于有保护成员的实例。这允许一个类与它的超类进行赋值兼容，但不允许与来自不同继承层次的类进行赋值兼容，否则就会有相同的形状。\n\n## 6.10 泛型\n\n因为TypeScript是一个结构化的类型系统，类型参数只在作为成员类型的一部分被消耗时影响到结果类型。比如说：\n\n```tsx\ninterface Empty<T> {}\nlet x: Empty<number>;\nlet y: Empty<string>;\nx = y; // 正确，因为y符合x的结构\n```\n\n在上面，`x`和`y`是兼容的，因为它们的结构没有以区分的方式使用类型参数。通过给`Empty<T>`增加一个成员来改变这个例子，显示了这是如何工作的。\n\n```tsx\ninterface NotEmpty<T> {\n  data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\nx = y; // 错误，因为x和y不兼容\n```\n\n这样一来，一个指定了类型参数的泛型类型就像一个非泛型类型一样。\n\n对于没有指定类型参数的泛型，兼容性的检查是通过指定任何来代替所有未指定的类型参数。然后产生的类型被检查是否兼容，就像在非泛型的情况下一样。\n\n比如说：\n\n```tsx\nlet identity = function <T>(x: T): T {\n  // ...\n};\nlet reverse = function <U>(y: U): U {\n  // ...\n};\nidentity = reverse; // 正确, 因为 (x: any) => any 匹配 (y: any) => any\n```\n\n## 6.11 子类型与赋值\n\n到目前为止，我们已经使用了 \"兼容\"，这并不是语言规范中定义的一个术语。在TypeScript中，有两种兼容性：子类型和赋值。这些不同之处只在于，赋值扩展了子类型的兼容性，允许赋值到 `any`，以及赋值到具有相应数值的`enum`。\n\n语言中不同的地方使用这两种兼容性机制中的一种，取决于情况。在实际应用中，类型兼容性是由赋值兼容性决定的，即使是在 `implements` 和 `extends` 子句中。\n\n## 6.12 `any`,`unknown`,`object`,`void`,`undefined`,`null`, 和`never`可分配性\n\n下表总结了一些抽象类型之间的可分配性。行表示每个类型可被分配到什么，列表示什么可被分配到它们。\"✓\"表示只有在关闭[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) 时才是兼容的组合。\n\n|             |  any  | unknown | object | void  | undefined | null  | never |\n| :---------: | :---: | :-----: | :----: | :---: | :-------: | :---: | :---: |\n|    any →    |       |  **✓**  | **✓**  | **✓** |   **✓**   | **✓** |   ✕   |\n|  unknown →  | **✓** |         |   ✕    |   ✕   |     ✕     |   ✕   |   ✕   |\n|  object →   | **✓** |  **✓**  |        |   ✕   |     ✕     |   ✕   |   ✕   |\n|   void →    | **✓** |  **✓**  |   ✕    |       |     ✕     |   ✕   |   ✕   |\n| undefined → | **✓** |  **✓**  |   ✓    | **✓** |           |   ✓   |   ✕   |\n|   null →    | **✓** |  **✓**  |   ✓    |   ✓   |     ✓     |       |   ✕   |\n|   never →   | **✓** |  **✓**  | **✓**  | **✓** |   **✓**   | **✓** |       |\n\n- 所有的东西都是可以分配给自己的。\n\n- `any`和`unknown`在可分配的内容方面是相同的，不同的是`unknown`不能分配给任何东西，除了any。\n- `unknown`和`never`就像是彼此的反义词。一切都可以分配给`unknown`, `never`就可以分配给一切。没有任何东西可以分配给`never`，`unknown`不能分配给任何东西（除了`any`）。\n- `void`不能赋值给任何东西，以下是例外情况：`any`、`unknown`、`never`、`undefined`和`null`（如果`strictNullChecks`是关闭的，详见表）。\n- 当`strictNullChecks`关闭时，`null`和`undefined`与`never`类似：可赋值给大多数类型，大多数类型不可赋值给它们。它们可以互相赋值。\n- 当`strictNullChecks`打开时，`null`和`undefined`的行为更像`void`：除了`any`、`unknown`、`never`和`void`之外，不能赋值给任何东西（`undefined`总是可以赋值给`void`）。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-6、高级篇：类型兼容性.md",
        "raw": "---\ntitle: 2-6、高级篇：类型兼容性\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 44933\ndate: 2024-01-28 21:07:47\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 六、类型兼容性\n\nTypeScript中的类型兼容性是基于结构子类型的。结构分型是一种完全基于其成员的类型关系的方式。这与名义类型不同。考虑一下下面的代码：\n\n```tsx\ninterface Pet {\n  name: string;\n}\nclass Dog {\n  name: string;\n}\nlet pet: Pet;\n// 正确，因为结构化类型\npet = new Dog();\n```\n\n在像 `C#`或`Java`这样的名义类型语言中，相应的代码将是一个错误，因为 `Dog` 类没有明确地描述自己是 `Pet` 接口的实现者。\n\nTypeScript的结构类型系统是根据JavaScript代码的典型写法设计的。因为JavaScript广泛使用匿名对象，如函数表达式和对象字面量，用结构类型系统而不是命名类型系统来表示JavaScript库中的各种关系要自然得多。\n\n## 6.1 关于健全性的说明\n\nTypeScript 的类型系统允许某些在编译时无法知道的操作是安全的。当一个类型系统具有这种属性时，它被称为不 \"健全\"。我们仔细考虑了 TypeScript 允许不健全行为的地方，在这篇文档中，我们将解释这些发生的地方以及它们背后的动机情景。\n\n## 6.2 起步\n\nTypeScript的结构类型系统的基本规则是，如果 `y` 至少有与 `x` 相同的成员，那么 `x` 与 `y` 是兼容的。\n\n```tsx\ninterface Pet {\n  name: string;\n}\nlet pet: Pet;\n// dog's 推断类型是 { name: string; owner: string; }\nlet dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };\npet = dog;\n```\n\n为了检查 `dog` 是否可以被分配给 `pet`，编译器检查 `pet` 的每个属性，以找到 `dog` 中相应的兼容属性。在这种情况下，`dog` 必须有一个名为 `name` 的成员，它是一个字符串。它有，所以赋值是允许的。\n\n在检查函数调用参数时，也使用了同样的赋值规则。\n\n```tsx\ninterface Pet {\n  name: string;\n}\nlet dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };\nfunction greet(pet: Pet) {\n  console.log(\"Hello, \" + pet.name);\n}\ngreet(dog); // 正确\n```\n\n请注意，`dog` 有一个额外的 `owner` 属性，但这并不产生错误。在检查兼容性时，只考虑目标类型（本例中为 `Pet`）的成员。\n\n这个比较过程是递归进行的，探索每个成员和子成员的类型。\n\n## 6.3 对比两个函数\n\n虽然比较原始类型和对象类型是相对直接的，但什么样的函数应该被认为是兼容的，这个问题就有点复杂了。让我们从两个函数的基本例子开始，这两个函数只在参数列表上有所不同：\n\n```tsx\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\ny = x; // 正确\nx = y; // 错误\n```\n\n为了检查 `x` 是否可以分配给 `y`，我们首先看一下参数列表。`x` 中的每个参数在 `y` 中都必须有一个类型兼容的对应参数。注意，参数的名称不被考虑，只考虑它们的类型。在这种情况下，`x` 中的每个参数在 `y` 中都有一个对应的兼容参数，所以这个赋值是允许的。\n\n第二个赋值是一个错误，因为 `y` 有一个 `x` 没有的必要的第二个参数，所以这个赋值是不允许的。\n\n你可能想知道为什么我们允许像例子中的 `y = x` 那样 \"丢弃 \"参数。这个赋值被允许的原因是，忽略额外的函数参数在JavaScript中其实很常见。例如，`Array#forEach`为回调函数提供了三个参数：数组元素、其索引和包含数组。尽管如此，提供一个只使用第一个参数的回调是非常有用的：\n\n```tsx\nlet items = [1, 2, 3];\n// 不要强迫这些额外参数\nitems.forEach((item, index, array) => console.log(item));\n// 应该没有问题!\nitems.forEach((item) => console.log(item));\n```\n\n现在让我们看看如何处理返回类型，使用两个只因返回类型不同的函数：\n\n```tsx\nlet x = () => ({ name: \"Alice\" });\nlet y = () => ({ name: \"Alice\", location: \"Seattle\" });\nx = y; // 正确\ny = x; // 错误，因为x()缺少一个location属性\n```\n\n类型系统强制要求源函数的返回类型是目标类型的返回类型的一个子类型。\n\n## 6.4 函数参数的双差性\n\n```tsx\nenum EventType {\n  Mouse,\n  Keyboard,\n}\ninterface Event {\n  timestamp: number;\n}\ninterface MyMouseEvent extends Event {\n  x: number;\n  y: number;\n}\ninterface MyKeyEvent extends Event {\n  keyCode: number;\n}\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n  /* ... */\n}\n// 不健全，但有用且常见\nlistenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + \",\" + e.y));\n// 在健全性存在的情况下，不可取的选择\nlistenEvent(EventType.Mouse, (e: Event) =>\n  console.log((e as MyMouseEvent).x + \",\" + (e as MyMouseEvent).y),\n);\nlistenEvent(EventType.Mouse, ((e: MyMouseEvent) =>\n  console.log(e.x + \",\" + e.y)) as (e: Event) => void);\n// 仍然不允许（明确的错误）。对于完全不兼容的类型强制执行类型安全\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\n当这种情况发生时，你可以让TypeScript通过编译器标志 [`strictFunctionTypes`](https://www.typescriptlang.org/tsconfig#strictFunctionTypes)引发错误。\n\n## 6.5 可选参数和其余参数\n\n在比较函数的兼容性时，可选参数和必需参数是可以互换的。源类型的额外可选参数不是错误，而目标类型的可选参数在源类型中没有对应的参数也不是错误。\n\n当一个函数有一个剩余参数时，它被当作是一个无限的可选参数系列。\n\n从类型系统的角度来看，这是不健全的，但从运行时的角度来看，可选参数的概念一般不会得到很好的加强，因为在这个位置传递 `undefined` 的参数对大多数函数来说是等价的。\n\n激励性的例子是一个函数的常见模式，它接受一个回调，并用一些可预测的（对程序员）但未知的（对类型系统）参数数量来调用它。\n\n```tsx\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n  /* ... 用'args'调用回调 ... */\n}\n// 不健全 - invokeLater \"可能 \"提供任何数量的参数\ninvokeLater([1, 2], (x, y) => console.log(x + \", \" + y));\n// 令人困惑的是（x和y实际上是需要的），而且是无法发现的\ninvokeLater([1, 2], (x?, y?) => console.log(x + \", \" + y));\n```\n\n## 6.6 带有重载的函数\n\n当一个函数有重载时，源类型中的每个重载必须由目标类型上的兼容签名来匹配。这保证了目标函数可以在所有与源函数相同的情况下被调用。\n\n## 6.7 枚举\n\n枚举与数字兼容，而数字与枚举兼容。来自不同枚举类型的枚举值被认为是不兼容的。比如说：\n\n```tsx\nenum Status {\n  Ready,\n  Waiting,\n}\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\nlet status = Status.Ready;\nstatus = Color.Green; // 错误\n```\n\n## 6.8 类\n\n类的工作方式与对象字面类型和接口类似，但有一个例外：它们同时具有静态和实例类型。当比较一个类类型的两个对象时，只有实例的成员被比较。静态成员和构造函数不影响兼容性。\n\n```tsx\nclass Animal {\n  feet: number;\n  constructor(name: string, numFeet: number) {}\n}\nclass Size {\n  feet: number;\n  constructor(numFeet: number) {}\n}\nlet a: Animal;\nlet s: Size;\na = s; // 正确\ns = a; // 正确\n```\n\n## 6.9 类中的私有和受保护成员\n\n一个类中的私有成员和保护成员会影响其兼容性。当一个类的实例被检查兼容性时，如果目标类型包含一个私有成员，那么源类型也必须包含一个源自同一类的私有成员。同样地，这也适用于有保护成员的实例。这允许一个类与它的超类进行赋值兼容，但不允许与来自不同继承层次的类进行赋值兼容，否则就会有相同的形状。\n\n## 6.10 泛型\n\n因为TypeScript是一个结构化的类型系统，类型参数只在作为成员类型的一部分被消耗时影响到结果类型。比如说：\n\n```tsx\ninterface Empty<T> {}\nlet x: Empty<number>;\nlet y: Empty<string>;\nx = y; // 正确，因为y符合x的结构\n```\n\n在上面，`x`和`y`是兼容的，因为它们的结构没有以区分的方式使用类型参数。通过给`Empty<T>`增加一个成员来改变这个例子，显示了这是如何工作的。\n\n```tsx\ninterface NotEmpty<T> {\n  data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\nx = y; // 错误，因为x和y不兼容\n```\n\n这样一来，一个指定了类型参数的泛型类型就像一个非泛型类型一样。\n\n对于没有指定类型参数的泛型，兼容性的检查是通过指定任何来代替所有未指定的类型参数。然后产生的类型被检查是否兼容，就像在非泛型的情况下一样。\n\n比如说：\n\n```tsx\nlet identity = function <T>(x: T): T {\n  // ...\n};\nlet reverse = function <U>(y: U): U {\n  // ...\n};\nidentity = reverse; // 正确, 因为 (x: any) => any 匹配 (y: any) => any\n```\n\n## 6.11 子类型与赋值\n\n到目前为止，我们已经使用了 \"兼容\"，这并不是语言规范中定义的一个术语。在TypeScript中，有两种兼容性：子类型和赋值。这些不同之处只在于，赋值扩展了子类型的兼容性，允许赋值到 `any`，以及赋值到具有相应数值的`enum`。\n\n语言中不同的地方使用这两种兼容性机制中的一种，取决于情况。在实际应用中，类型兼容性是由赋值兼容性决定的，即使是在 `implements` 和 `extends` 子句中。\n\n## 6.12 `any`,`unknown`,`object`,`void`,`undefined`,`null`, 和`never`可分配性\n\n下表总结了一些抽象类型之间的可分配性。行表示每个类型可被分配到什么，列表示什么可被分配到它们。\"✓\"表示只有在关闭[`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) 时才是兼容的组合。\n\n|             |  any  | unknown | object | void  | undefined | null  | never |\n| :---------: | :---: | :-----: | :----: | :---: | :-------: | :---: | :---: |\n|    any →    |       |  **✓**  | **✓**  | **✓** |   **✓**   | **✓** |   ✕   |\n|  unknown →  | **✓** |         |   ✕    |   ✕   |     ✕     |   ✕   |   ✕   |\n|  object →   | **✓** |  **✓**  |        |   ✕   |     ✕     |   ✕   |   ✕   |\n|   void →    | **✓** |  **✓**  |   ✕    |       |     ✕     |   ✕   |   ✕   |\n| undefined → | **✓** |  **✓**  |   ✓    | **✓** |           |   ✓   |   ✕   |\n|   null →    | **✓** |  **✓**  |   ✓    |   ✓   |     ✓     |       |   ✕   |\n|   never →   | **✓** |  **✓**  | **✓**  | **✓** |   **✓**   | **✓** |       |\n\n- 所有的东西都是可以分配给自己的。\n\n- `any`和`unknown`在可分配的内容方面是相同的，不同的是`unknown`不能分配给任何东西，除了any。\n- `unknown`和`never`就像是彼此的反义词。一切都可以分配给`unknown`, `never`就可以分配给一切。没有任何东西可以分配给`never`，`unknown`不能分配给任何东西（除了`any`）。\n- `void`不能赋值给任何东西，以下是例外情况：`any`、`unknown`、`never`、`undefined`和`null`（如果`strictNullChecks`是关闭的，详见表）。\n- 当`strictNullChecks`关闭时，`null`和`undefined`与`never`类似：可赋值给大多数类型，大多数类型不可赋值给它们。它们可以互相赋值。\n- 当`strictNullChecks`打开时，`null`和`undefined`的行为更像`void`：除了`any`、`unknown`、`never`和`void`之外，不能赋值给任何东西（`undefined`总是可以赋值给`void`）。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-6、高级篇：类型兼容性",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao8001p94v3cyyz8uyf",
        "content": "<h1 id=\"六、类型兼容性\"><a href=\"#六、类型兼容性\" class=\"headerlink\" title=\"六、类型兼容性\"></a>六、类型兼容性</h1><p>TypeScript中的类型兼容性是基于结构子类型的。结构分型是一种完全基于其成员的类型关系的方式。这与名义类型不同。考虑一下下面的代码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Pet</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">pet</span>: <span class=\"title class_\">Pet</span>;</span><br><span class=\"line\"><span class=\"comment\">// 正确，因为结构化类型</span></span><br><span class=\"line\">pet = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br></pre></td></tr></table></figure>\n\n<p>在像 <code>C#</code>或<code>Java</code>这样的名义类型语言中，相应的代码将是一个错误，因为 <code>Dog</code> 类没有明确地描述自己是 <code>Pet</code> 接口的实现者。</p>\n<p>TypeScript的结构类型系统是根据JavaScript代码的典型写法设计的。因为JavaScript广泛使用匿名对象，如函数表达式和对象字面量，用结构类型系统而不是命名类型系统来表示JavaScript库中的各种关系要自然得多。</p>\n<h2 id=\"6-1-关于健全性的说明\"><a href=\"#6-1-关于健全性的说明\" class=\"headerlink\" title=\"6.1 关于健全性的说明\"></a>6.1 关于健全性的说明</h2><p>TypeScript 的类型系统允许某些在编译时无法知道的操作是安全的。当一个类型系统具有这种属性时，它被称为不 “健全”。我们仔细考虑了 TypeScript 允许不健全行为的地方，在这篇文档中，我们将解释这些发生的地方以及它们背后的动机情景。</p>\n<h2 id=\"6-2-起步\"><a href=\"#6-2-起步\" class=\"headerlink\" title=\"6.2 起步\"></a>6.2 起步</h2><p>TypeScript的结构类型系统的基本规则是，如果 <code>y</code> 至少有与 <code>x</code> 相同的成员，那么 <code>x</code> 与 <code>y</code> 是兼容的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Pet</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">pet</span>: <span class=\"title class_\">Pet</span>;</span><br><span class=\"line\"><span class=\"comment\">// dog&#x27;s 推断类型是 &#123; name: string; owner: string; &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Lassie&quot;</span>, <span class=\"attr\">owner</span>: <span class=\"string\">&quot;Rudd Weatherwax&quot;</span> &#125;;</span><br><span class=\"line\">pet = dog;</span><br></pre></td></tr></table></figure>\n\n<p>为了检查 <code>dog</code> 是否可以被分配给 <code>pet</code>，编译器检查 <code>pet</code> 的每个属性，以找到 <code>dog</code> 中相应的兼容属性。在这种情况下，<code>dog</code> 必须有一个名为 <code>name</code> 的成员，它是一个字符串。它有，所以赋值是允许的。</p>\n<p>在检查函数调用参数时，也使用了同样的赋值规则。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Pet</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Lassie&quot;</span>, <span class=\"attr\">owner</span>: <span class=\"string\">&quot;Rudd Weatherwax&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">pet</span>: <span class=\"title class_\">Pet</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + pet.<span class=\"property\">name</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(dog); <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，<code>dog</code> 有一个额外的 <code>owner</code> 属性，但这并不产生错误。在检查兼容性时，只考虑目标类型（本例中为 <code>Pet</code>）的成员。</p>\n<p>这个比较过程是递归进行的，探索每个成员和子成员的类型。</p>\n<h2 id=\"6-3-对比两个函数\"><a href=\"#6-3-对比两个函数\" class=\"headerlink\" title=\"6.3 对比两个函数\"></a>6.3 对比两个函数</h2><p>虽然比较原始类型和对象类型是相对直接的，但什么样的函数应该被认为是兼容的，这个问题就有点复杂了。让我们从两个函数的基本例子开始，这两个函数只在参数列表上有所不同：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">x</span> = (<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">number</span></span>) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">y</span> = (<span class=\"params\"><span class=\"attr\">b</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">y = x; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">x = y; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<p>为了检查 <code>x</code> 是否可以分配给 <code>y</code>，我们首先看一下参数列表。<code>x</code> 中的每个参数在 <code>y</code> 中都必须有一个类型兼容的对应参数。注意，参数的名称不被考虑，只考虑它们的类型。在这种情况下，<code>x</code> 中的每个参数在 <code>y</code> 中都有一个对应的兼容参数，所以这个赋值是允许的。</p>\n<p>第二个赋值是一个错误，因为 <code>y</code> 有一个 <code>x</code> 没有的必要的第二个参数，所以这个赋值是不允许的。</p>\n<p>你可能想知道为什么我们允许像例子中的 <code>y = x</code> 那样 “丢弃 “参数。这个赋值被允许的原因是，忽略额外的函数参数在JavaScript中其实很常见。例如，<code>Array#forEach</code>为回调函数提供了三个参数：数组元素、其索引和包含数组。尽管如此，提供一个只使用第一个参数的回调是非常有用的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> items = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">// 不要强迫这些额外参数</span></span><br><span class=\"line\">items.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item));</span><br><span class=\"line\"><span class=\"comment\">// 应该没有问题!</span></span><br><span class=\"line\">items.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item));</span><br></pre></td></tr></table></figure>\n\n<p>现在让我们看看如何处理返回类型，使用两个只因返回类型不同的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">x</span> = (<span class=\"params\"></span>) =&gt; (&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">y</span> = (<span class=\"params\"></span>) =&gt; (&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">location</span>: <span class=\"string\">&quot;Seattle&quot;</span> &#125;);</span><br><span class=\"line\">x = y; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">y = x; <span class=\"comment\">// 错误，因为x()缺少一个location属性</span></span><br></pre></td></tr></table></figure>\n\n<p>类型系统强制要求源函数的返回类型是目标类型的返回类型的一个子类型。</p>\n<h2 id=\"6-4-函数参数的双差性\"><a href=\"#6-4-函数参数的双差性\" class=\"headerlink\" title=\"6.4 函数参数的双差性\"></a>6.4 函数参数的双差性</h2><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">EventType</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Mouse</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Keyboard</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Event</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">timestamp</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyMouseEvent</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Event</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyKeyEvent</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Event</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">keyCode</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">listenEvent</span>(<span class=\"params\"><span class=\"attr\">eventType</span>: <span class=\"title class_\">EventType</span>, <span class=\"attr\">handler</span>: (n: Event) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 不健全，但有用且常见</span></span><br><span class=\"line\"><span class=\"title function_\">listenEvent</span>(<span class=\"title class_\">EventType</span>.<span class=\"property\">Mouse</span>, <span class=\"function\">(<span class=\"params\"><span class=\"attr\">e</span>: <span class=\"title class_\">MyMouseEvent</span></span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e.<span class=\"property\">x</span> + <span class=\"string\">&quot;,&quot;</span> + e.<span class=\"property\">y</span>));</span><br><span class=\"line\"><span class=\"comment\">// 在健全性存在的情况下，不可取的选择</span></span><br><span class=\"line\"><span class=\"title function_\">listenEvent</span>(<span class=\"title class_\">EventType</span>.<span class=\"property\">Mouse</span>, <span class=\"function\">(<span class=\"params\"><span class=\"attr\">e</span>: <span class=\"title class_\">Event</span></span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>((e <span class=\"keyword\">as</span> <span class=\"title class_\">MyMouseEvent</span>).<span class=\"property\">x</span> + <span class=\"string\">&quot;,&quot;</span> + (e <span class=\"keyword\">as</span> <span class=\"title class_\">MyMouseEvent</span>).<span class=\"property\">y</span>),</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"title function_\">listenEvent</span>(<span class=\"title class_\">EventType</span>.<span class=\"property\">Mouse</span>, (<span class=\"function\">(<span class=\"params\"><span class=\"attr\">e</span>: <span class=\"title class_\">MyMouseEvent</span></span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e.<span class=\"property\">x</span> + <span class=\"string\">&quot;,&quot;</span> + e.<span class=\"property\">y</span>)) <span class=\"title function_\">as</span> (<span class=\"attr\">e</span>: <span class=\"title class_\">Event</span>) =&gt; <span class=\"built_in\">void</span>);</span><br><span class=\"line\"><span class=\"comment\">// 仍然不允许（明确的错误）。对于完全不兼容的类型强制执行类型安全</span></span><br><span class=\"line\"><span class=\"title function_\">listenEvent</span>(<span class=\"title class_\">EventType</span>.<span class=\"property\">Mouse</span>, <span class=\"function\">(<span class=\"params\"><span class=\"attr\">e</span>: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e));</span><br></pre></td></tr></table></figure>\n\n<p>当这种情况发生时，你可以让TypeScript通过编译器标志 <a href=\"https://www.typescriptlang.org/tsconfig#strictFunctionTypes\"><code>strictFunctionTypes</code></a>引发错误。</p>\n<h2 id=\"6-5-可选参数和其余参数\"><a href=\"#6-5-可选参数和其余参数\" class=\"headerlink\" title=\"6.5 可选参数和其余参数\"></a>6.5 可选参数和其余参数</h2><p>在比较函数的兼容性时，可选参数和必需参数是可以互换的。源类型的额外可选参数不是错误，而目标类型的可选参数在源类型中没有对应的参数也不是错误。</p>\n<p>当一个函数有一个剩余参数时，它被当作是一个无限的可选参数系列。</p>\n<p>从类型系统的角度来看，这是不健全的，但从运行时的角度来看，可选参数的概念一般不会得到很好的加强，因为在这个位置传递 <code>undefined</code> 的参数对大多数函数来说是等价的。</p>\n<p>激励性的例子是一个函数的常见模式，它接受一个回调，并用一些可预测的（对程序员）但未知的（对类型系统）参数数量来调用它。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">invokeLater</span>(<span class=\"params\"><span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[], <span class=\"attr\">callback</span>: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... 用&#x27;args&#x27;调用回调 ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 不健全 - invokeLater &quot;可能 &quot;提供任何数量的参数</span></span><br><span class=\"line\"><span class=\"title function_\">invokeLater</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x + <span class=\"string\">&quot;, &quot;</span> + y));</span><br><span class=\"line\"><span class=\"comment\">// 令人困惑的是（x和y实际上是需要的），而且是无法发现的</span></span><br><span class=\"line\"><span class=\"title function_\">invokeLater</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x?, y?</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x + <span class=\"string\">&quot;, &quot;</span> + y));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-6-带有重载的函数\"><a href=\"#6-6-带有重载的函数\" class=\"headerlink\" title=\"6.6 带有重载的函数\"></a>6.6 带有重载的函数</h2><p>当一个函数有重载时，源类型中的每个重载必须由目标类型上的兼容签名来匹配。这保证了目标函数可以在所有与源函数相同的情况下被调用。</p>\n<h2 id=\"6-7-枚举\"><a href=\"#6-7-枚举\" class=\"headerlink\" title=\"6.7 枚举\"></a>6.7 枚举</h2><p>枚举与数字兼容，而数字与枚举兼容。来自不同枚举类型的枚举值被认为是不兼容的。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Status</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Ready</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Waiting</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Red</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Blue</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Green</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> status = <span class=\"title class_\">Status</span>.<span class=\"property\">Ready</span>;</span><br><span class=\"line\">status = <span class=\"title class_\">Color</span>.<span class=\"property\">Green</span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-8-类\"><a href=\"#6-8-类\" class=\"headerlink\" title=\"6.8 类\"></a>6.8 类</h2><p>类的工作方式与对象字面类型和接口类似，但有一个例外：它们同时具有静态和实例类型。当比较一个类类型的两个对象时，只有实例的成员被比较。静态成员和构造函数不影响兼容性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">feet</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">numFeet</span>: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Size</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">feet</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">numFeet</span>: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>: <span class=\"title class_\">Animal</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">s</span>: <span class=\"title class_\">Size</span>;</span><br><span class=\"line\">a = s; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">s = a; <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-9-类中的私有和受保护成员\"><a href=\"#6-9-类中的私有和受保护成员\" class=\"headerlink\" title=\"6.9 类中的私有和受保护成员\"></a>6.9 类中的私有和受保护成员</h2><p>一个类中的私有成员和保护成员会影响其兼容性。当一个类的实例被检查兼容性时，如果目标类型包含一个私有成员，那么源类型也必须包含一个源自同一类的私有成员。同样地，这也适用于有保护成员的实例。这允许一个类与它的超类进行赋值兼容，但不允许与来自不同继承层次的类进行赋值兼容，否则就会有相同的形状。</p>\n<h2 id=\"6-10-泛型\"><a href=\"#6-10-泛型\" class=\"headerlink\" title=\"6.10 泛型\"></a>6.10 泛型</h2><p>因为TypeScript是一个结构化的类型系统，类型参数只在作为成员类型的一部分被消耗时影响到结果类型。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Empty</span>&lt;T&gt; &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"title class_\">Empty</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">y</span>: <span class=\"title class_\">Empty</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\">x = y; <span class=\"comment\">// 正确，因为y符合x的结构</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面，<code>x</code>和<code>y</code>是兼容的，因为它们的结构没有以区分的方式使用类型参数。通过给<code>Empty&lt;T&gt;</code>增加一个成员来改变这个例子，显示了这是如何工作的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NotEmpty</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"title class_\">NotEmpty</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">y</span>: <span class=\"title class_\">NotEmpty</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\">x = y; <span class=\"comment\">// 错误，因为x和y不兼容</span></span><br></pre></td></tr></table></figure>\n\n<p>这样一来，一个指定了类型参数的泛型类型就像一个非泛型类型一样。</p>\n<p>对于没有指定类型参数的泛型，兼容性的检查是通过指定任何来代替所有未指定的类型参数。然后产生的类型被检查是否兼容，就像在非泛型的情况下一样。</p>\n<p>比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identity = <span class=\"keyword\">function</span> &lt;T&gt;(<span class=\"attr\">x</span>: T): T &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> reverse = <span class=\"keyword\">function</span> &lt;U&gt;(<span class=\"attr\">y</span>: U): U &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">identity = reverse; <span class=\"comment\">// 正确, 因为 (x: any) =&gt; any 匹配 (y: any) =&gt; any</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-11-子类型与赋值\"><a href=\"#6-11-子类型与赋值\" class=\"headerlink\" title=\"6.11 子类型与赋值\"></a>6.11 子类型与赋值</h2><p>到目前为止，我们已经使用了 “兼容”，这并不是语言规范中定义的一个术语。在TypeScript中，有两种兼容性：子类型和赋值。这些不同之处只在于，赋值扩展了子类型的兼容性，允许赋值到 <code>any</code>，以及赋值到具有相应数值的<code>enum</code>。</p>\n<p>语言中不同的地方使用这两种兼容性机制中的一种，取决于情况。在实际应用中，类型兼容性是由赋值兼容性决定的，即使是在 <code>implements</code> 和 <code>extends</code> 子句中。</p>\n<h2 id=\"6-12-any-unknown-object-void-undefined-null-和never可分配性\"><a href=\"#6-12-any-unknown-object-void-undefined-null-和never可分配性\" class=\"headerlink\" title=\"6.12 any,unknown,object,void,undefined,null, 和never可分配性\"></a>6.12 <code>any</code>,<code>unknown</code>,<code>object</code>,<code>void</code>,<code>undefined</code>,<code>null</code>, 和<code>never</code>可分配性</h2><p>下表总结了一些抽象类型之间的可分配性。行表示每个类型可被分配到什么，列表示什么可被分配到它们。”✓”表示只有在关闭<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a> 时才是兼容的组合。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">any</th>\n<th align=\"center\">unknown</th>\n<th align=\"center\">object</th>\n<th align=\"center\">void</th>\n<th align=\"center\">undefined</th>\n<th align=\"center\">null</th>\n<th align=\"center\">never</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">any →</td>\n<td align=\"center\"></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">unknown →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"></td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">object →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"></td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">void →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\">✕</td>\n<td align=\"center\"></td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">undefined →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\">✓</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"></td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">null →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n<td align=\"center\"></td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">never →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>所有的东西都是可以分配给自己的。</p>\n</li>\n<li><p><code>any</code>和<code>unknown</code>在可分配的内容方面是相同的，不同的是<code>unknown</code>不能分配给任何东西，除了any。</p>\n</li>\n<li><p><code>unknown</code>和<code>never</code>就像是彼此的反义词。一切都可以分配给<code>unknown</code>, <code>never</code>就可以分配给一切。没有任何东西可以分配给<code>never</code>，<code>unknown</code>不能分配给任何东西（除了<code>any</code>）。</p>\n</li>\n<li><p><code>void</code>不能赋值给任何东西，以下是例外情况：<code>any</code>、<code>unknown</code>、<code>never</code>、<code>undefined</code>和<code>null</code>（如果<code>strictNullChecks</code>是关闭的，详见表）。</p>\n</li>\n<li><p>当<code>strictNullChecks</code>关闭时，<code>null</code>和<code>undefined</code>与<code>never</code>类似：可赋值给大多数类型，大多数类型不可赋值给它们。它们可以互相赋值。</p>\n</li>\n<li><p>当<code>strictNullChecks</code>打开时，<code>null</code>和<code>undefined</code>的行为更像<code>void</code>：除了<code>any</code>、<code>unknown</code>、<code>never</code>和<code>void</code>之外，不能赋值给任何东西（<code>undefined</code>总是可以赋值给<code>void</code>）。</p>\n</li>\n</ul>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"六、类型兼容性\"><a href=\"#六、类型兼容性\" class=\"headerlink\" title=\"六、类型兼容性\"></a>六、类型兼容性</h1><p>TypeScript中的类型兼容性是基于结构子类型的。结构分型是一种完全基于其成员的类型关系的方式。这与名义类型不同。考虑一下下面的代码：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Pet</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">pet</span>: <span class=\"title class_\">Pet</span>;</span><br><span class=\"line\"><span class=\"comment\">// 正确，因为结构化类型</span></span><br><span class=\"line\">pet = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br></pre></td></tr></table></figure>\n\n<p>在像 <code>C#</code>或<code>Java</code>这样的名义类型语言中，相应的代码将是一个错误，因为 <code>Dog</code> 类没有明确地描述自己是 <code>Pet</code> 接口的实现者。</p>\n<p>TypeScript的结构类型系统是根据JavaScript代码的典型写法设计的。因为JavaScript广泛使用匿名对象，如函数表达式和对象字面量，用结构类型系统而不是命名类型系统来表示JavaScript库中的各种关系要自然得多。</p>\n<h2 id=\"6-1-关于健全性的说明\"><a href=\"#6-1-关于健全性的说明\" class=\"headerlink\" title=\"6.1 关于健全性的说明\"></a>6.1 关于健全性的说明</h2><p>TypeScript 的类型系统允许某些在编译时无法知道的操作是安全的。当一个类型系统具有这种属性时，它被称为不 “健全”。我们仔细考虑了 TypeScript 允许不健全行为的地方，在这篇文档中，我们将解释这些发生的地方以及它们背后的动机情景。</p>\n<h2 id=\"6-2-起步\"><a href=\"#6-2-起步\" class=\"headerlink\" title=\"6.2 起步\"></a>6.2 起步</h2><p>TypeScript的结构类型系统的基本规则是，如果 <code>y</code> 至少有与 <code>x</code> 相同的成员，那么 <code>x</code> 与 <code>y</code> 是兼容的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Pet</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">pet</span>: <span class=\"title class_\">Pet</span>;</span><br><span class=\"line\"><span class=\"comment\">// dog&#x27;s 推断类型是 &#123; name: string; owner: string; &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Lassie&quot;</span>, <span class=\"attr\">owner</span>: <span class=\"string\">&quot;Rudd Weatherwax&quot;</span> &#125;;</span><br><span class=\"line\">pet = dog;</span><br></pre></td></tr></table></figure>\n\n<p>为了检查 <code>dog</code> 是否可以被分配给 <code>pet</code>，编译器检查 <code>pet</code> 的每个属性，以找到 <code>dog</code> 中相应的兼容属性。在这种情况下，<code>dog</code> 必须有一个名为 <code>name</code> 的成员，它是一个字符串。它有，所以赋值是允许的。</p>\n<p>在检查函数调用参数时，也使用了同样的赋值规则。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Pet</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Lassie&quot;</span>, <span class=\"attr\">owner</span>: <span class=\"string\">&quot;Rudd Weatherwax&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\"><span class=\"attr\">pet</span>: <span class=\"title class_\">Pet</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello, &quot;</span> + pet.<span class=\"property\">name</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(dog); <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，<code>dog</code> 有一个额外的 <code>owner</code> 属性，但这并不产生错误。在检查兼容性时，只考虑目标类型（本例中为 <code>Pet</code>）的成员。</p>\n<p>这个比较过程是递归进行的，探索每个成员和子成员的类型。</p>\n<h2 id=\"6-3-对比两个函数\"><a href=\"#6-3-对比两个函数\" class=\"headerlink\" title=\"6.3 对比两个函数\"></a>6.3 对比两个函数</h2><p>虽然比较原始类型和对象类型是相对直接的，但什么样的函数应该被认为是兼容的，这个问题就有点复杂了。让我们从两个函数的基本例子开始，这两个函数只在参数列表上有所不同：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">x</span> = (<span class=\"params\"><span class=\"attr\">a</span>: <span class=\"built_in\">number</span></span>) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">y</span> = (<span class=\"params\"><span class=\"attr\">b</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">y = x; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">x = y; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<p>为了检查 <code>x</code> 是否可以分配给 <code>y</code>，我们首先看一下参数列表。<code>x</code> 中的每个参数在 <code>y</code> 中都必须有一个类型兼容的对应参数。注意，参数的名称不被考虑，只考虑它们的类型。在这种情况下，<code>x</code> 中的每个参数在 <code>y</code> 中都有一个对应的兼容参数，所以这个赋值是允许的。</p>\n<p>第二个赋值是一个错误，因为 <code>y</code> 有一个 <code>x</code> 没有的必要的第二个参数，所以这个赋值是不允许的。</p>\n<p>你可能想知道为什么我们允许像例子中的 <code>y = x</code> 那样 “丢弃 “参数。这个赋值被允许的原因是，忽略额外的函数参数在JavaScript中其实很常见。例如，<code>Array#forEach</code>为回调函数提供了三个参数：数组元素、其索引和包含数组。尽管如此，提供一个只使用第一个参数的回调是非常有用的：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> items = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">// 不要强迫这些额外参数</span></span><br><span class=\"line\">items.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item));</span><br><span class=\"line\"><span class=\"comment\">// 应该没有问题!</span></span><br><span class=\"line\">items.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item));</span><br></pre></td></tr></table></figure>\n\n<p>现在让我们看看如何处理返回类型，使用两个只因返回类型不同的函数：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">x</span> = (<span class=\"params\"></span>) =&gt; (&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">y</span> = (<span class=\"params\"></span>) =&gt; (&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">location</span>: <span class=\"string\">&quot;Seattle&quot;</span> &#125;);</span><br><span class=\"line\">x = y; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">y = x; <span class=\"comment\">// 错误，因为x()缺少一个location属性</span></span><br></pre></td></tr></table></figure>\n\n<p>类型系统强制要求源函数的返回类型是目标类型的返回类型的一个子类型。</p>\n<h2 id=\"6-4-函数参数的双差性\"><a href=\"#6-4-函数参数的双差性\" class=\"headerlink\" title=\"6.4 函数参数的双差性\"></a>6.4 函数参数的双差性</h2><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">EventType</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Mouse</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Keyboard</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Event</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">timestamp</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyMouseEvent</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Event</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyKeyEvent</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Event</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">keyCode</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">listenEvent</span>(<span class=\"params\"><span class=\"attr\">eventType</span>: <span class=\"title class_\">EventType</span>, <span class=\"attr\">handler</span>: (n: Event) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 不健全，但有用且常见</span></span><br><span class=\"line\"><span class=\"title function_\">listenEvent</span>(<span class=\"title class_\">EventType</span>.<span class=\"property\">Mouse</span>, <span class=\"function\">(<span class=\"params\"><span class=\"attr\">e</span>: <span class=\"title class_\">MyMouseEvent</span></span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e.<span class=\"property\">x</span> + <span class=\"string\">&quot;,&quot;</span> + e.<span class=\"property\">y</span>));</span><br><span class=\"line\"><span class=\"comment\">// 在健全性存在的情况下，不可取的选择</span></span><br><span class=\"line\"><span class=\"title function_\">listenEvent</span>(<span class=\"title class_\">EventType</span>.<span class=\"property\">Mouse</span>, <span class=\"function\">(<span class=\"params\"><span class=\"attr\">e</span>: <span class=\"title class_\">Event</span></span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>((e <span class=\"keyword\">as</span> <span class=\"title class_\">MyMouseEvent</span>).<span class=\"property\">x</span> + <span class=\"string\">&quot;,&quot;</span> + (e <span class=\"keyword\">as</span> <span class=\"title class_\">MyMouseEvent</span>).<span class=\"property\">y</span>),</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"title function_\">listenEvent</span>(<span class=\"title class_\">EventType</span>.<span class=\"property\">Mouse</span>, (<span class=\"function\">(<span class=\"params\"><span class=\"attr\">e</span>: <span class=\"title class_\">MyMouseEvent</span></span>) =&gt;</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e.<span class=\"property\">x</span> + <span class=\"string\">&quot;,&quot;</span> + e.<span class=\"property\">y</span>)) <span class=\"title function_\">as</span> (<span class=\"attr\">e</span>: <span class=\"title class_\">Event</span>) =&gt; <span class=\"built_in\">void</span>);</span><br><span class=\"line\"><span class=\"comment\">// 仍然不允许（明确的错误）。对于完全不兼容的类型强制执行类型安全</span></span><br><span class=\"line\"><span class=\"title function_\">listenEvent</span>(<span class=\"title class_\">EventType</span>.<span class=\"property\">Mouse</span>, <span class=\"function\">(<span class=\"params\"><span class=\"attr\">e</span>: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e));</span><br></pre></td></tr></table></figure>\n\n<p>当这种情况发生时，你可以让TypeScript通过编译器标志 <a href=\"https://www.typescriptlang.org/tsconfig#strictFunctionTypes\"><code>strictFunctionTypes</code></a>引发错误。</p>\n<h2 id=\"6-5-可选参数和其余参数\"><a href=\"#6-5-可选参数和其余参数\" class=\"headerlink\" title=\"6.5 可选参数和其余参数\"></a>6.5 可选参数和其余参数</h2><p>在比较函数的兼容性时，可选参数和必需参数是可以互换的。源类型的额外可选参数不是错误，而目标类型的可选参数在源类型中没有对应的参数也不是错误。</p>\n<p>当一个函数有一个剩余参数时，它被当作是一个无限的可选参数系列。</p>\n<p>从类型系统的角度来看，这是不健全的，但从运行时的角度来看，可选参数的概念一般不会得到很好的加强，因为在这个位置传递 <code>undefined</code> 的参数对大多数函数来说是等价的。</p>\n<p>激励性的例子是一个函数的常见模式，它接受一个回调，并用一些可预测的（对程序员）但未知的（对类型系统）参数数量来调用它。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">invokeLater</span>(<span class=\"params\"><span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[], <span class=\"attr\">callback</span>: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... 用&#x27;args&#x27;调用回调 ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 不健全 - invokeLater &quot;可能 &quot;提供任何数量的参数</span></span><br><span class=\"line\"><span class=\"title function_\">invokeLater</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x + <span class=\"string\">&quot;, &quot;</span> + y));</span><br><span class=\"line\"><span class=\"comment\">// 令人困惑的是（x和y实际上是需要的），而且是无法发现的</span></span><br><span class=\"line\"><span class=\"title function_\">invokeLater</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x?, y?</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x + <span class=\"string\">&quot;, &quot;</span> + y));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-6-带有重载的函数\"><a href=\"#6-6-带有重载的函数\" class=\"headerlink\" title=\"6.6 带有重载的函数\"></a>6.6 带有重载的函数</h2><p>当一个函数有重载时，源类型中的每个重载必须由目标类型上的兼容签名来匹配。这保证了目标函数可以在所有与源函数相同的情况下被调用。</p>\n<h2 id=\"6-7-枚举\"><a href=\"#6-7-枚举\" class=\"headerlink\" title=\"6.7 枚举\"></a>6.7 枚举</h2><p>枚举与数字兼容，而数字与枚举兼容。来自不同枚举类型的枚举值被认为是不兼容的。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Status</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Ready</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Waiting</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Red</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Blue</span>,</span><br><span class=\"line\">  <span class=\"title class_\">Green</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> status = <span class=\"title class_\">Status</span>.<span class=\"property\">Ready</span>;</span><br><span class=\"line\">status = <span class=\"title class_\">Color</span>.<span class=\"property\">Green</span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-8-类\"><a href=\"#6-8-类\" class=\"headerlink\" title=\"6.8 类\"></a>6.8 类</h2><p>类的工作方式与对象字面类型和接口类似，但有一个例外：它们同时具有静态和实例类型。当比较一个类类型的两个对象时，只有实例的成员被比较。静态成员和构造函数不影响兼容性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">feet</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">numFeet</span>: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Size</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">feet</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">numFeet</span>: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>: <span class=\"title class_\">Animal</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">s</span>: <span class=\"title class_\">Size</span>;</span><br><span class=\"line\">a = s; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">s = a; <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-9-类中的私有和受保护成员\"><a href=\"#6-9-类中的私有和受保护成员\" class=\"headerlink\" title=\"6.9 类中的私有和受保护成员\"></a>6.9 类中的私有和受保护成员</h2><p>一个类中的私有成员和保护成员会影响其兼容性。当一个类的实例被检查兼容性时，如果目标类型包含一个私有成员，那么源类型也必须包含一个源自同一类的私有成员。同样地，这也适用于有保护成员的实例。这允许一个类与它的超类进行赋值兼容，但不允许与来自不同继承层次的类进行赋值兼容，否则就会有相同的形状。</p>\n<h2 id=\"6-10-泛型\"><a href=\"#6-10-泛型\" class=\"headerlink\" title=\"6.10 泛型\"></a>6.10 泛型</h2><p>因为TypeScript是一个结构化的类型系统，类型参数只在作为成员类型的一部分被消耗时影响到结果类型。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Empty</span>&lt;T&gt; &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"title class_\">Empty</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">y</span>: <span class=\"title class_\">Empty</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\">x = y; <span class=\"comment\">// 正确，因为y符合x的结构</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面，<code>x</code>和<code>y</code>是兼容的，因为它们的结构没有以区分的方式使用类型参数。通过给<code>Empty&lt;T&gt;</code>增加一个成员来改变这个例子，显示了这是如何工作的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">NotEmpty</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">x</span>: <span class=\"title class_\">NotEmpty</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">y</span>: <span class=\"title class_\">NotEmpty</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\">x = y; <span class=\"comment\">// 错误，因为x和y不兼容</span></span><br></pre></td></tr></table></figure>\n\n<p>这样一来，一个指定了类型参数的泛型类型就像一个非泛型类型一样。</p>\n<p>对于没有指定类型参数的泛型，兼容性的检查是通过指定任何来代替所有未指定的类型参数。然后产生的类型被检查是否兼容，就像在非泛型的情况下一样。</p>\n<p>比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identity = <span class=\"keyword\">function</span> &lt;T&gt;(<span class=\"attr\">x</span>: T): T &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> reverse = <span class=\"keyword\">function</span> &lt;U&gt;(<span class=\"attr\">y</span>: U): U &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">identity = reverse; <span class=\"comment\">// 正确, 因为 (x: any) =&gt; any 匹配 (y: any) =&gt; any</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-11-子类型与赋值\"><a href=\"#6-11-子类型与赋值\" class=\"headerlink\" title=\"6.11 子类型与赋值\"></a>6.11 子类型与赋值</h2><p>到目前为止，我们已经使用了 “兼容”，这并不是语言规范中定义的一个术语。在TypeScript中，有两种兼容性：子类型和赋值。这些不同之处只在于，赋值扩展了子类型的兼容性，允许赋值到 <code>any</code>，以及赋值到具有相应数值的<code>enum</code>。</p>\n<p>语言中不同的地方使用这两种兼容性机制中的一种，取决于情况。在实际应用中，类型兼容性是由赋值兼容性决定的，即使是在 <code>implements</code> 和 <code>extends</code> 子句中。</p>\n<h2 id=\"6-12-any-unknown-object-void-undefined-null-和never可分配性\"><a href=\"#6-12-any-unknown-object-void-undefined-null-和never可分配性\" class=\"headerlink\" title=\"6.12 any,unknown,object,void,undefined,null, 和never可分配性\"></a>6.12 <code>any</code>,<code>unknown</code>,<code>object</code>,<code>void</code>,<code>undefined</code>,<code>null</code>, 和<code>never</code>可分配性</h2><p>下表总结了一些抽象类型之间的可分配性。行表示每个类型可被分配到什么，列表示什么可被分配到它们。”✓”表示只有在关闭<a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a> 时才是兼容的组合。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">any</th>\n<th align=\"center\">unknown</th>\n<th align=\"center\">object</th>\n<th align=\"center\">void</th>\n<th align=\"center\">undefined</th>\n<th align=\"center\">null</th>\n<th align=\"center\">never</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">any →</td>\n<td align=\"center\"></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">unknown →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"></td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">object →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"></td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">void →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\">✕</td>\n<td align=\"center\"></td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">undefined →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\">✓</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"></td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">null →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n<td align=\"center\">✓</td>\n<td align=\"center\"></td>\n<td align=\"center\">✕</td>\n</tr>\n<tr>\n<td align=\"center\">never →</td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"><strong>✓</strong></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>所有的东西都是可以分配给自己的。</p>\n</li>\n<li><p><code>any</code>和<code>unknown</code>在可分配的内容方面是相同的，不同的是<code>unknown</code>不能分配给任何东西，除了any。</p>\n</li>\n<li><p><code>unknown</code>和<code>never</code>就像是彼此的反义词。一切都可以分配给<code>unknown</code>, <code>never</code>就可以分配给一切。没有任何东西可以分配给<code>never</code>，<code>unknown</code>不能分配给任何东西（除了<code>any</code>）。</p>\n</li>\n<li><p><code>void</code>不能赋值给任何东西，以下是例外情况：<code>any</code>、<code>unknown</code>、<code>never</code>、<code>undefined</code>和<code>null</code>（如果<code>strictNullChecks</code>是关闭的，详见表）。</p>\n</li>\n<li><p>当<code>strictNullChecks</code>关闭时，<code>null</code>和<code>undefined</code>与<code>never</code>类似：可赋值给大多数类型，大多数类型不可赋值给它们。它们可以互相赋值。</p>\n</li>\n<li><p>当<code>strictNullChecks</code>打开时，<code>null</code>和<code>undefined</code>的行为更像<code>void</code>：除了<code>any</code>、<code>unknown</code>、<code>never</code>和<code>void</code>之外，不能赋值给任何东西（<code>undefined</code>总是可以赋值给<code>void</code>）。</p>\n</li>\n</ul>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-9、高级篇：JSX",
        "toc": true,
        "abbrlink": 22247,
        "date": "2024-01-28T13:09:29.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 九、JSX\n\n[JSX](https://facebook.github.io/jsx/) 是一种可嵌入的类似XML的语法。它旨在被转换为有效的JavaScript，尽管这种转换的语义是具体实施的。JSX随着[React](https://reactjs.org/) 框架的流行而兴起，但后来也有了其他的实现。TypeScript支持嵌入、类型检查，以及直接将JSX编译为JavaScript。\n\n## 9. 1 基本用法\n\n为了使用JSX，你必须做两件事。\n\n1. 用 `.tsx` 扩展名来命名你的文件\n2. 启用 `jsx` 选项\n\nTypeScript有三种JSX模式：`preserve`, `react`和 `react-native`。这些模式只影响生成阶段 - 类型检查不受影响。 `preserve` 模式将保留 JSX 作为输出的一部分，以便被另一个转换步骤（例如 [Babel](https://babeljs.io/)）进一步消耗。此外，输出将有一个 `.jsx` 文件扩展名。`react`模式将发出 `React.createElement`，在使用前不需要经过JSX转换，而且输出将有一个 `.js` 文件扩展名。`react-native` 模式相当于保留模式，它保留了所有的JSX，但输出将有一个 `.js` 文件扩展名。\n\n| Mode           | Input     | Output                                            | Output File Extension |\n| :------------- | :-------- | :------------------------------------------------ | :-------------------- |\n| `preserve`     | `<div />` | `<div />`                                         | `.jsx`                |\n| `react`        | `<div />` | `React.createElement(\"div\")`                      | `.js`                 |\n| `react-native` | `<div />` | `<div />`                                         | `.js`                 |\n| `react-jsx`    | `<div />` | `_jsx(\"div\", {}, void 0);`                        | `.js`                 |\n| `react-jsxdev` | `<div />` | `_jsxDEV(\"div\", {}, void 0, false, {...}, this);` | `.js`                 |\n\nYou can specify this mode using either the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) command line flag or the corresponding option [`jsx` in your tsconfig.json](https://www.typescriptlang.org/tsconfig#jsx) file.\n\n你可以使用 `jsx` 命令行标志或你的 [ tsconfig.json](https://www.typescriptlang.org/tsconfig#jsx) 文件中的相应选项 `jsx` 指定这种模式。\n\n> \\*注意：你可以用 [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory) 选项指定针对 react JSX 生成 JS 时使用的JSX工厂函数（默认为`React.createElement`）。\n\n## 9.2 `as`操作符\n\n回忆一下如何编写类型断言。\n\n```tsx\nconst foo = <foo>bar;\n```\n\n这断言变量 `bar`具有`foo`类型。由于TypeScript也使用角括号进行类型断言，将其与JSX的语法相结合会带来某些解析困难。因此，TypeScript不允许在 `.tsx` 文件中使用角括号类型断言。\n\n由于上述语法不能在 `.tsx` 文件中使用，应该使用一个替代的类型断言操作符：`as`。这个例子可以很容易地用 `as` 操作符重写。\n\n```tsx\nconst foo = bar as foo;\n```\n\n`as` 操作符在 `.ts` 和 `.tsx` 文件中都可用，并且在行为上与角括号式断言风格相同。\n\n## 9.3 类型检查\n\n为了理解JSX的类型检查，你必须首先理解内在元素和基于值的元素之间的区别。给定一个JSX表达式 `<expr />`，`expr`既可以指环境中固有的东西（例如DOM环境中的`div`或`span`），也可以指你创建的自定义组件。这很重要，有两个原因。\n\n- 对于React来说，内在元素是以字符串的形式发出的（`React.createElement(\"div\")`），而你创建的组件则不是（`React.createElement(MyComponent)`）。\n- 在JSX元素中传递的属性类型应该被不同地查找。元素的内在属性应该是已知的，而组件可能想要指定他们自己的属性集。\n\nTypeScript使用[与React相同的约定](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components) 来区分这些。一个内在的元素总是以小写字母开始，而一个基于价值的元素总是以大写字母开始。\n\n## 9.4 内在元素\n\n内在元素在特殊接口 `JSX.IntrinsicElements` 上被查询到。默认情况下，如果没有指定这个接口，那么什么都可以，内在元素将不会被类型检查。然而，如果这个接口存在，那么内在元素的名称将作为`JSX.IntrinsicElements`接口上的一个属性被查询。比如说。\n\n```tsx\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: any;\n  }\n}\n<foo />; // 正确\n<bar />; // 错误\n```\n\n在上面的例子中，`<foo />`可以正常工作，但`<bar />`会导致一个错误，因为它没有被指定在`JSX.IntrinsicElements`上。\n\n注意：你也可以在`JWX.IntrinsicElements`上指定一个全面的字符串索引器，如下所示：\n\n```tsx\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    [elemName: string]: any;\n  }\n}\n```\n\n## 9.5 基于值的元素\n\n基于值的元素只是通过范围内的标识符进行查询。\n\n```tsx\nimport MyComponent from \"./myComponent\";\n<MyComponent />; // 正确\n<SomeOtherComponent />; // 错误\n```\n\n有两种方法来定义基于值的元素：\n\n1. 函数组件（FC）\n2. 类组件\n\n因为这两类基于值的元素在JSX表达式中是无法区分的，首先TS尝试使用重载解析将表达式解析为一个函数组件。如果这个过程成功了，那么TS就完成了将表达式解析为它的声明。如果该值不能被解析为一个函数组件，那么TS将尝试将其解析为一个类组件。如果失败了，TS将报告一个错误。\n\n### 9.5.1 函数组件\n\n顾名思义，该组件被定义为一个JavaScript函数，其第一个参数是一个 `props` 对象。TS强制要求它的返回类型必须是可分配给 `JSX.Element`的。\n\n```tsx\ninterface FooProp {\n  name: string;\n  X: number;\n  Y: number;\n}\ndeclare function AnotherComponent(prop: { name: string });\nfunction ComponentFoo(prop: FooProp) {\n  return <AnotherComponent name={prop.name} />;\n}\nconst Button = (prop: { value: string }, context: { color: string }) => (\n  <button />\n);\n```\n\n因为函数组件只是一个JavaScript函数，这里也可以使用函数重载。\n\n```tsx\ninterface ClickableProps {\n  children: JSX.Element[] | JSX.Element;\n}\n\ninterface HomeProps extends ClickableProps {\n  home: JSX.Element;\n}\n\ninterface SideProps extends ClickableProps {\n  side: JSX.Element | string;\n}\n\nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SideProps): JSX.Element;\nfunction MainButton(prop: ClickableProps): JSX.Element {\n  // ...\n}\n```\n\n> 注意：函数组件以前被称为无状态函数组件（SFC）。由于Function Components在最近的react版本中不再被认为是无状态的，`SFC`类型和它的别名`StatelessComponent`被废弃了。\n\n### 9.5.2 类组件\n\n定义一个类组件的类型是可能的。然而，要做到这一点，最好理解两个新术语：元素类类型和元素实例类型。\n\n给定`<Expr />`，元素类的类型就是`Expr`的类型。所以在上面的例子中，如果`MyComponent`是一个ES6类，那么类的类型就是该类的构造函数和状态。如果`MyComponent`是一个工厂函数，类的类型将是该函数。\n\n一旦类的类型被确定，实例的类型就由该类的构造或调用签名（无论哪一个）的返回类型的联合决定。因此，在ES6类的情况下，实例类型将是该类实例的类型，而在工厂函数的情况下，它将是该函数返回值的类型。\n\n```tsx\nclass MyComponent {\n  render() {}\n}\n// 使用构造签名\nconst myComponent = new MyComponent();\n// 元素类类型 => MyComponent\n// 元素实例类型 => { render: () => void }\n\nfunction MyFactoryFunction() {\n  return {\n    render: () => {},\n  };\n}\n// 使用调用签名\nconst myComponent = MyFactoryFunction();\n// 元素类类型 => MyFactoryFunction\n// 元素实例类型 => { render: () => void }\n```\n\n元素实例类型很有趣，因为它必须可以分配给 `JSX.ElementClass`，否则会导致错误。默认情况下，`JSX.ElementClass` 是 `{}`，但它可以被增强，以限制JSX的使用，使其只适用于那些符合适当接口的类型。\n\n```tsx\ndeclare namespace JSX {\n  interface ElementClass {\n    render: any;\n  }\n}\nclass MyComponent {\n  render() {}\n}\nfunction MyFactoryFunction() {\n  return { render: () => {} };\n}\n<MyComponent />; // 正确\n<MyFactoryFunction />; // 正确\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n  return {};\n}\n<NotAValidComponent />; // 错误\n<NotAValidFactoryFunction />; // 错误\n```\n\n## 9.6 属性类型检查\n\n类型检查属性的第一步是确定元素属性类型。这在内在元素和基于值的元素之间略有不同。\n\n对于内在元素，它是 `JSX.IntrinsicElements` 上的属性类型。\n\n```tsx\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { bar?: boolean };\n  }\n}\n// 'foo'的元素属性类型是'{bar?: boolean}'\n<foo bar />;\n```\n\n元素属性类型是用来对JSX中的属性进行类型检查的。支持可选和必需的属性。\n\n```tsx\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { requiredProp: string; optionalProp?: number };\n  }\n}\n<foo requiredProp=\"bar\" />; // 正确\n<foo requiredProp=\"bar\" optionalProp={0} />; // 正确\n<foo />; // 错误, requiredProp 缺失\n<foo requiredProp={0} />; // 错误, requiredProp 应该为 string 类型\n<foo requiredProp=\"bar\" unknownProp />; // 错误, unknownProp 属性不存在\n<foo requiredProp=\"bar\" some-unknown-prop />; // 正确, 因为 'some-unknown-prop' 不是一个有效的属性标识\n```\n\n> 注意：如果一个属性名称不是一个有效的JS标识符（如data-\\*属性），如果在元素属性类型中找不到它，则不被认为是一个错误。\n\n此外，`JSX.IntrinsicAttributes`接口可以用来指定JSX框架使用的额外属性，这些属性一般不会被组件的道具或参数使用--例如React中的key。进一步专门化，通用的 `JSX.IntrinsicClassAttributes<T>`类型也可以用来为类组件（而不是函数组件）指定同种额外属性。在这种类型中，通用参数与类的实例类型相对应。在React中，这被用来允许`Ref<T>`类型的`ref`属性。一般来说，这些接口上的所有属性都应该是可选的，除非你打算让你的JSX框架的用户需要在每个标签上提供一些属性。\n\n展开运算符也能正常工作：\n\n```tsx\nconst props = { requiredProp: \"bar\" };\n<foo {...props} />; // 正确\nconst badProps = {};\n<foo {...badProps} />; // 错误\n```\n\n## 9.7 子类型检查\n\n在TypeScript 2.3中，TS引入了*children*的类型检查。*children*是元素属性类型中的一个特殊属性，子的*JSXExpressions*被采取插入属性中。类似于TS使用`JSX.ElementAttributesProperty`来确定 _props_ 的名称，TS使用`JSX.ElementChildrenAttribute`来确定这些 _props_ 中的 _children_ 的名称。`JSX.ElementChildrenAttribute`应该用一个单一的属性来声明。\n\n```tsx\ndeclare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {}; // 指定要使用的 children 名称\n  }\n}\n```\n\n```tsx\n<div>\n  <h1>Hello</h1>\n</div>;\n<div>\n  <h1>Hello</h1>\n  World\n</div>;\nconst CustomComp = (props) => <div>{props.children}</div>\n<CustomComp>\n  <div>Hello World</div>\n  {\"This is just a JS expression...\" + 1000}\n</CustomComp>\n```\n\n你可以像其他属性一样指定 _children_ 的类型。这将覆盖默认的类型，例如，如果你使用React类型的话：\n\n```tsx\ninterface PropsType {\n  children: JSX.Element\n  name: string\n}\nclass Component extends React.Component<PropsType, {}> {\n  render() {\n    return (\n      <h2>\n        {this.props.children}\n      </h2>\n    )\n  }\n}\n\n// 正确\n<Component name=\"foo\">\n  <h1>Hello World</h1>\n</Component>\n\n// 错误: children是JSX.Element的类型，而不是JSX.Element的数组\n<Component name=\"bar\">\n  <h1>Hello World</h1>\n  <h2>Hello World</h2>\n</Component>\n\n// 错误: children是JSX.Element的类型，而不是JSX.Element的数组或字符串。\n<Component name=\"baz\">\n  <h1>Hello</h1>\n  World\n</Component>\n```\n\n## 9.8 JSX的结果类型\n\n默认情况下，JSX表达式的结果被打造成 `any` 类型。你可以通过指定 `JSX.Element` 接口来定制类型。然而，不可能从这个接口中检索到关于JSX的元素、属性或孩子的类型信息。它是一个黑盒子。\n\n## 9.9 嵌入表达式\n\nJSX允许你通过用大括号（`{ }`）包围表达式，在标签之间嵌入表达式。\n\n```tsx\nconst a = (\n  <div>\n    {[\"foo\", \"bar\"].map((i) => (\n      <span>{i / 2}</span>\n    ))}\n  </div>\n);\n```\n\n上面的代码将导致一个错误，因为你不能用一个字符串除以一个数字。当使用 `preserve` 选项时，输出结果看起来像：\n\n```tsx\nconst a = (\n  <div>\n    {[\"foo\", \"bar\"].map(function (i) {\n      return <span>{i / 2}</span>;\n    })}\n  </div>\n);\n```\n\n## 9.10 React 集成\n\n要在React中使用JSX，你应该使用 [React 类型](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)。这些类型化定义了 `JSX` 的命名空间，以便与React一起使用。\n\n```tsx\n/// <reference path=\"react.d.ts\" />\ninterface Props {\n  foo: string;\n}\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n<MyComponent foo=\"bar\" />; // 正确\n<MyComponent foo={0} />; // 错误\n```\n\n### 9.10.1 配置JSX\n\n有多个编译器标志可以用来定制你的JSX，它们既可以作为编译器标志，也可以通过内联的每个文件实用程序发挥作用。要了解更多信息，请看他们的tsconfig参考页：\n\n- [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n- [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n- [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-9、高级篇：JSX.md",
        "raw": "---\ntitle: 2-9、高级篇：JSX\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 22247\ndate: 2024-01-28 21:09:29\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 九、JSX\n\n[JSX](https://facebook.github.io/jsx/) 是一种可嵌入的类似XML的语法。它旨在被转换为有效的JavaScript，尽管这种转换的语义是具体实施的。JSX随着[React](https://reactjs.org/) 框架的流行而兴起，但后来也有了其他的实现。TypeScript支持嵌入、类型检查，以及直接将JSX编译为JavaScript。\n\n## 9. 1 基本用法\n\n为了使用JSX，你必须做两件事。\n\n1. 用 `.tsx` 扩展名来命名你的文件\n2. 启用 `jsx` 选项\n\nTypeScript有三种JSX模式：`preserve`, `react`和 `react-native`。这些模式只影响生成阶段 - 类型检查不受影响。 `preserve` 模式将保留 JSX 作为输出的一部分，以便被另一个转换步骤（例如 [Babel](https://babeljs.io/)）进一步消耗。此外，输出将有一个 `.jsx` 文件扩展名。`react`模式将发出 `React.createElement`，在使用前不需要经过JSX转换，而且输出将有一个 `.js` 文件扩展名。`react-native` 模式相当于保留模式，它保留了所有的JSX，但输出将有一个 `.js` 文件扩展名。\n\n| Mode           | Input     | Output                                            | Output File Extension |\n| :------------- | :-------- | :------------------------------------------------ | :-------------------- |\n| `preserve`     | `<div />` | `<div />`                                         | `.jsx`                |\n| `react`        | `<div />` | `React.createElement(\"div\")`                      | `.js`                 |\n| `react-native` | `<div />` | `<div />`                                         | `.js`                 |\n| `react-jsx`    | `<div />` | `_jsx(\"div\", {}, void 0);`                        | `.js`                 |\n| `react-jsxdev` | `<div />` | `_jsxDEV(\"div\", {}, void 0, false, {...}, this);` | `.js`                 |\n\nYou can specify this mode using either the [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) command line flag or the corresponding option [`jsx` in your tsconfig.json](https://www.typescriptlang.org/tsconfig#jsx) file.\n\n你可以使用 `jsx` 命令行标志或你的 [ tsconfig.json](https://www.typescriptlang.org/tsconfig#jsx) 文件中的相应选项 `jsx` 指定这种模式。\n\n> \\*注意：你可以用 [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory) 选项指定针对 react JSX 生成 JS 时使用的JSX工厂函数（默认为`React.createElement`）。\n\n## 9.2 `as`操作符\n\n回忆一下如何编写类型断言。\n\n```tsx\nconst foo = <foo>bar;\n```\n\n这断言变量 `bar`具有`foo`类型。由于TypeScript也使用角括号进行类型断言，将其与JSX的语法相结合会带来某些解析困难。因此，TypeScript不允许在 `.tsx` 文件中使用角括号类型断言。\n\n由于上述语法不能在 `.tsx` 文件中使用，应该使用一个替代的类型断言操作符：`as`。这个例子可以很容易地用 `as` 操作符重写。\n\n```tsx\nconst foo = bar as foo;\n```\n\n`as` 操作符在 `.ts` 和 `.tsx` 文件中都可用，并且在行为上与角括号式断言风格相同。\n\n## 9.3 类型检查\n\n为了理解JSX的类型检查，你必须首先理解内在元素和基于值的元素之间的区别。给定一个JSX表达式 `<expr />`，`expr`既可以指环境中固有的东西（例如DOM环境中的`div`或`span`），也可以指你创建的自定义组件。这很重要，有两个原因。\n\n- 对于React来说，内在元素是以字符串的形式发出的（`React.createElement(\"div\")`），而你创建的组件则不是（`React.createElement(MyComponent)`）。\n- 在JSX元素中传递的属性类型应该被不同地查找。元素的内在属性应该是已知的，而组件可能想要指定他们自己的属性集。\n\nTypeScript使用[与React相同的约定](http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components) 来区分这些。一个内在的元素总是以小写字母开始，而一个基于价值的元素总是以大写字母开始。\n\n## 9.4 内在元素\n\n内在元素在特殊接口 `JSX.IntrinsicElements` 上被查询到。默认情况下，如果没有指定这个接口，那么什么都可以，内在元素将不会被类型检查。然而，如果这个接口存在，那么内在元素的名称将作为`JSX.IntrinsicElements`接口上的一个属性被查询。比如说。\n\n```tsx\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: any;\n  }\n}\n<foo />; // 正确\n<bar />; // 错误\n```\n\n在上面的例子中，`<foo />`可以正常工作，但`<bar />`会导致一个错误，因为它没有被指定在`JSX.IntrinsicElements`上。\n\n注意：你也可以在`JWX.IntrinsicElements`上指定一个全面的字符串索引器，如下所示：\n\n```tsx\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    [elemName: string]: any;\n  }\n}\n```\n\n## 9.5 基于值的元素\n\n基于值的元素只是通过范围内的标识符进行查询。\n\n```tsx\nimport MyComponent from \"./myComponent\";\n<MyComponent />; // 正确\n<SomeOtherComponent />; // 错误\n```\n\n有两种方法来定义基于值的元素：\n\n1. 函数组件（FC）\n2. 类组件\n\n因为这两类基于值的元素在JSX表达式中是无法区分的，首先TS尝试使用重载解析将表达式解析为一个函数组件。如果这个过程成功了，那么TS就完成了将表达式解析为它的声明。如果该值不能被解析为一个函数组件，那么TS将尝试将其解析为一个类组件。如果失败了，TS将报告一个错误。\n\n### 9.5.1 函数组件\n\n顾名思义，该组件被定义为一个JavaScript函数，其第一个参数是一个 `props` 对象。TS强制要求它的返回类型必须是可分配给 `JSX.Element`的。\n\n```tsx\ninterface FooProp {\n  name: string;\n  X: number;\n  Y: number;\n}\ndeclare function AnotherComponent(prop: { name: string });\nfunction ComponentFoo(prop: FooProp) {\n  return <AnotherComponent name={prop.name} />;\n}\nconst Button = (prop: { value: string }, context: { color: string }) => (\n  <button />\n);\n```\n\n因为函数组件只是一个JavaScript函数，这里也可以使用函数重载。\n\n```tsx\ninterface ClickableProps {\n  children: JSX.Element[] | JSX.Element;\n}\n\ninterface HomeProps extends ClickableProps {\n  home: JSX.Element;\n}\n\ninterface SideProps extends ClickableProps {\n  side: JSX.Element | string;\n}\n\nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SideProps): JSX.Element;\nfunction MainButton(prop: ClickableProps): JSX.Element {\n  // ...\n}\n```\n\n> 注意：函数组件以前被称为无状态函数组件（SFC）。由于Function Components在最近的react版本中不再被认为是无状态的，`SFC`类型和它的别名`StatelessComponent`被废弃了。\n\n### 9.5.2 类组件\n\n定义一个类组件的类型是可能的。然而，要做到这一点，最好理解两个新术语：元素类类型和元素实例类型。\n\n给定`<Expr />`，元素类的类型就是`Expr`的类型。所以在上面的例子中，如果`MyComponent`是一个ES6类，那么类的类型就是该类的构造函数和状态。如果`MyComponent`是一个工厂函数，类的类型将是该函数。\n\n一旦类的类型被确定，实例的类型就由该类的构造或调用签名（无论哪一个）的返回类型的联合决定。因此，在ES6类的情况下，实例类型将是该类实例的类型，而在工厂函数的情况下，它将是该函数返回值的类型。\n\n```tsx\nclass MyComponent {\n  render() {}\n}\n// 使用构造签名\nconst myComponent = new MyComponent();\n// 元素类类型 => MyComponent\n// 元素实例类型 => { render: () => void }\n\nfunction MyFactoryFunction() {\n  return {\n    render: () => {},\n  };\n}\n// 使用调用签名\nconst myComponent = MyFactoryFunction();\n// 元素类类型 => MyFactoryFunction\n// 元素实例类型 => { render: () => void }\n```\n\n元素实例类型很有趣，因为它必须可以分配给 `JSX.ElementClass`，否则会导致错误。默认情况下，`JSX.ElementClass` 是 `{}`，但它可以被增强，以限制JSX的使用，使其只适用于那些符合适当接口的类型。\n\n```tsx\ndeclare namespace JSX {\n  interface ElementClass {\n    render: any;\n  }\n}\nclass MyComponent {\n  render() {}\n}\nfunction MyFactoryFunction() {\n  return { render: () => {} };\n}\n<MyComponent />; // 正确\n<MyFactoryFunction />; // 正确\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n  return {};\n}\n<NotAValidComponent />; // 错误\n<NotAValidFactoryFunction />; // 错误\n```\n\n## 9.6 属性类型检查\n\n类型检查属性的第一步是确定元素属性类型。这在内在元素和基于值的元素之间略有不同。\n\n对于内在元素，它是 `JSX.IntrinsicElements` 上的属性类型。\n\n```tsx\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { bar?: boolean };\n  }\n}\n// 'foo'的元素属性类型是'{bar?: boolean}'\n<foo bar />;\n```\n\n元素属性类型是用来对JSX中的属性进行类型检查的。支持可选和必需的属性。\n\n```tsx\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { requiredProp: string; optionalProp?: number };\n  }\n}\n<foo requiredProp=\"bar\" />; // 正确\n<foo requiredProp=\"bar\" optionalProp={0} />; // 正确\n<foo />; // 错误, requiredProp 缺失\n<foo requiredProp={0} />; // 错误, requiredProp 应该为 string 类型\n<foo requiredProp=\"bar\" unknownProp />; // 错误, unknownProp 属性不存在\n<foo requiredProp=\"bar\" some-unknown-prop />; // 正确, 因为 'some-unknown-prop' 不是一个有效的属性标识\n```\n\n> 注意：如果一个属性名称不是一个有效的JS标识符（如data-\\*属性），如果在元素属性类型中找不到它，则不被认为是一个错误。\n\n此外，`JSX.IntrinsicAttributes`接口可以用来指定JSX框架使用的额外属性，这些属性一般不会被组件的道具或参数使用--例如React中的key。进一步专门化，通用的 `JSX.IntrinsicClassAttributes<T>`类型也可以用来为类组件（而不是函数组件）指定同种额外属性。在这种类型中，通用参数与类的实例类型相对应。在React中，这被用来允许`Ref<T>`类型的`ref`属性。一般来说，这些接口上的所有属性都应该是可选的，除非你打算让你的JSX框架的用户需要在每个标签上提供一些属性。\n\n展开运算符也能正常工作：\n\n```tsx\nconst props = { requiredProp: \"bar\" };\n<foo {...props} />; // 正确\nconst badProps = {};\n<foo {...badProps} />; // 错误\n```\n\n## 9.7 子类型检查\n\n在TypeScript 2.3中，TS引入了*children*的类型检查。*children*是元素属性类型中的一个特殊属性，子的*JSXExpressions*被采取插入属性中。类似于TS使用`JSX.ElementAttributesProperty`来确定 _props_ 的名称，TS使用`JSX.ElementChildrenAttribute`来确定这些 _props_ 中的 _children_ 的名称。`JSX.ElementChildrenAttribute`应该用一个单一的属性来声明。\n\n```tsx\ndeclare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {}; // 指定要使用的 children 名称\n  }\n}\n```\n\n```tsx\n<div>\n  <h1>Hello</h1>\n</div>;\n<div>\n  <h1>Hello</h1>\n  World\n</div>;\nconst CustomComp = (props) => <div>{props.children}</div>\n<CustomComp>\n  <div>Hello World</div>\n  {\"This is just a JS expression...\" + 1000}\n</CustomComp>\n```\n\n你可以像其他属性一样指定 _children_ 的类型。这将覆盖默认的类型，例如，如果你使用React类型的话：\n\n```tsx\ninterface PropsType {\n  children: JSX.Element\n  name: string\n}\nclass Component extends React.Component<PropsType, {}> {\n  render() {\n    return (\n      <h2>\n        {this.props.children}\n      </h2>\n    )\n  }\n}\n\n// 正确\n<Component name=\"foo\">\n  <h1>Hello World</h1>\n</Component>\n\n// 错误: children是JSX.Element的类型，而不是JSX.Element的数组\n<Component name=\"bar\">\n  <h1>Hello World</h1>\n  <h2>Hello World</h2>\n</Component>\n\n// 错误: children是JSX.Element的类型，而不是JSX.Element的数组或字符串。\n<Component name=\"baz\">\n  <h1>Hello</h1>\n  World\n</Component>\n```\n\n## 9.8 JSX的结果类型\n\n默认情况下，JSX表达式的结果被打造成 `any` 类型。你可以通过指定 `JSX.Element` 接口来定制类型。然而，不可能从这个接口中检索到关于JSX的元素、属性或孩子的类型信息。它是一个黑盒子。\n\n## 9.9 嵌入表达式\n\nJSX允许你通过用大括号（`{ }`）包围表达式，在标签之间嵌入表达式。\n\n```tsx\nconst a = (\n  <div>\n    {[\"foo\", \"bar\"].map((i) => (\n      <span>{i / 2}</span>\n    ))}\n  </div>\n);\n```\n\n上面的代码将导致一个错误，因为你不能用一个字符串除以一个数字。当使用 `preserve` 选项时，输出结果看起来像：\n\n```tsx\nconst a = (\n  <div>\n    {[\"foo\", \"bar\"].map(function (i) {\n      return <span>{i / 2}</span>;\n    })}\n  </div>\n);\n```\n\n## 9.10 React 集成\n\n要在React中使用JSX，你应该使用 [React 类型](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react)。这些类型化定义了 `JSX` 的命名空间，以便与React一起使用。\n\n```tsx\n/// <reference path=\"react.d.ts\" />\ninterface Props {\n  foo: string;\n}\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n<MyComponent foo=\"bar\" />; // 正确\n<MyComponent foo={0} />; // 错误\n```\n\n### 9.10.1 配置JSX\n\n有多个编译器标志可以用来定制你的JSX，它们既可以作为编译器标志，也可以通过内联的每个文件实用程序发挥作用。要了解更多信息，请看他们的tsconfig参考页：\n\n- [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n- [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n- [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-9、高级篇：JSX",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao9001s94v345t85zx6",
        "content": "<h1 id=\"九、JSX\"><a href=\"#九、JSX\" class=\"headerlink\" title=\"九、JSX\"></a>九、JSX</h1><p><a href=\"https://facebook.github.io/jsx/\">JSX</a> 是一种可嵌入的类似XML的语法。它旨在被转换为有效的JavaScript，尽管这种转换的语义是具体实施的。JSX随着<a href=\"https://reactjs.org/\">React</a> 框架的流行而兴起，但后来也有了其他的实现。TypeScript支持嵌入、类型检查，以及直接将JSX编译为JavaScript。</p>\n<h2 id=\"9-1-基本用法\"><a href=\"#9-1-基本用法\" class=\"headerlink\" title=\"9. 1 基本用法\"></a>9. 1 基本用法</h2><p>为了使用JSX，你必须做两件事。</p>\n<ol>\n<li>用 <code>.tsx</code> 扩展名来命名你的文件</li>\n<li>启用 <code>jsx</code> 选项</li>\n</ol>\n<p>TypeScript有三种JSX模式：<code>preserve</code>, <code>react</code>和 <code>react-native</code>。这些模式只影响生成阶段 - 类型检查不受影响。 <code>preserve</code> 模式将保留 JSX 作为输出的一部分，以便被另一个转换步骤（例如 <a href=\"https://babeljs.io/\">Babel</a>）进一步消耗。此外，输出将有一个 <code>.jsx</code> 文件扩展名。<code>react</code>模式将发出 <code>React.createElement</code>，在使用前不需要经过JSX转换，而且输出将有一个 <code>.js</code> 文件扩展名。<code>react-native</code> 模式相当于保留模式，它保留了所有的JSX，但输出将有一个 <code>.js</code> 文件扩展名。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Mode</th>\n<th align=\"left\">Input</th>\n<th align=\"left\">Output</th>\n<th align=\"left\">Output File Extension</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>preserve</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>.jsx</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>react</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>React.createElement(&quot;div&quot;)</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>react-native</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>react-jsx</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>_jsx(&quot;div&quot;, &#123;&#125;, void 0);</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>react-jsxdev</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>_jsxDEV(&quot;div&quot;, &#123;&#125;, void 0, false, &#123;...&#125;, this);</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n</tbody></table>\n<p>You can specify this mode using either the <a href=\"https://www.typescriptlang.org/tsconfig#jsx\"><code>jsx</code></a> command line flag or the corresponding option <a href=\"https://www.typescriptlang.org/tsconfig#jsx\"><code>jsx</code> in your tsconfig.json</a> file.</p>\n<p>你可以使用 <code>jsx</code> 命令行标志或你的 <a href=\"https://www.typescriptlang.org/tsconfig#jsx\"> tsconfig.json</a> 文件中的相应选项 <code>jsx</code> 指定这种模式。</p>\n<blockquote>\n<p>*注意：你可以用 <a href=\"https://www.typescriptlang.org/tsconfig#jsxFactory\"><code>jsxFactory</code></a> 选项指定针对 react JSX 生成 JS 时使用的JSX工厂函数（默认为<code>React.createElement</code>）。</p>\n</blockquote>\n<h2 id=\"9-2-as操作符\"><a href=\"#9-2-as操作符\" class=\"headerlink\" title=\"9.2 as操作符\"></a>9.2 <code>as</code>操作符</h2><p>回忆一下如何编写类型断言。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &lt;foo&gt;bar;</span><br></pre></td></tr></table></figure>\n\n<p>这断言变量 <code>bar</code>具有<code>foo</code>类型。由于TypeScript也使用角括号进行类型断言，将其与JSX的语法相结合会带来某些解析困难。因此，TypeScript不允许在 <code>.tsx</code> 文件中使用角括号类型断言。</p>\n<p>由于上述语法不能在 <code>.tsx</code> 文件中使用，应该使用一个替代的类型断言操作符：<code>as</code>。这个例子可以很容易地用 <code>as</code> 操作符重写。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = bar <span class=\"keyword\">as</span> foo;</span><br></pre></td></tr></table></figure>\n\n<p><code>as</code> 操作符在 <code>.ts</code> 和 <code>.tsx</code> 文件中都可用，并且在行为上与角括号式断言风格相同。</p>\n<h2 id=\"9-3-类型检查\"><a href=\"#9-3-类型检查\" class=\"headerlink\" title=\"9.3 类型检查\"></a>9.3 类型检查</h2><p>为了理解JSX的类型检查，你必须首先理解内在元素和基于值的元素之间的区别。给定一个JSX表达式 <code>&lt;expr /&gt;</code>，<code>expr</code>既可以指环境中固有的东西（例如DOM环境中的<code>div</code>或<code>span</code>），也可以指你创建的自定义组件。这很重要，有两个原因。</p>\n<ul>\n<li>对于React来说，内在元素是以字符串的形式发出的（<code>React.createElement(&quot;div&quot;)</code>），而你创建的组件则不是（<code>React.createElement(MyComponent)</code>）。</li>\n<li>在JSX元素中传递的属性类型应该被不同地查找。元素的内在属性应该是已知的，而组件可能想要指定他们自己的属性集。</li>\n</ul>\n<p>TypeScript使用<a href=\"http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components\">与React相同的约定</a> 来区分这些。一个内在的元素总是以小写字母开始，而一个基于价值的元素总是以大写字母开始。</p>\n<h2 id=\"9-4-内在元素\"><a href=\"#9-4-内在元素\" class=\"headerlink\" title=\"9.4 内在元素\"></a>9.4 内在元素</h2><p>内在元素在特殊接口 <code>JSX.IntrinsicElements</code> 上被查询到。默认情况下，如果没有指定这个接口，那么什么都可以，内在元素将不会被类型检查。然而，如果这个接口存在，那么内在元素的名称将作为<code>JSX.IntrinsicElements</code>接口上的一个属性被查询。比如说。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">IntrinsicElements</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;foo /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">bar</span> /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，<code>&lt;foo /&gt;</code>可以正常工作，但<code>&lt;bar /&gt;</code>会导致一个错误，因为它没有被指定在<code>JSX.IntrinsicElements</code>上。</p>\n<p>注意：你也可以在<code>JWX.IntrinsicElements</code>上指定一个全面的字符串索引器，如下所示：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">IntrinsicElements</span> &#123;</span><br><span class=\"line\">    [<span class=\"attr\">elemName</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-5-基于值的元素\"><a href=\"#9-5-基于值的元素\" class=\"headerlink\" title=\"9.5 基于值的元素\"></a>9.5 基于值的元素</h2><p>基于值的元素只是通过范围内的标识符进行查询。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">MyComponent</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./myComponent&quot;</span>;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span> /&gt;</span></span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">SomeOtherComponent</span> /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<p>有两种方法来定义基于值的元素：</p>\n<ol>\n<li>函数组件（FC）</li>\n<li>类组件</li>\n</ol>\n<p>因为这两类基于值的元素在JSX表达式中是无法区分的，首先TS尝试使用重载解析将表达式解析为一个函数组件。如果这个过程成功了，那么TS就完成了将表达式解析为它的声明。如果该值不能被解析为一个函数组件，那么TS将尝试将其解析为一个类组件。如果失败了，TS将报告一个错误。</p>\n<h3 id=\"9-5-1-函数组件\"><a href=\"#9-5-1-函数组件\" class=\"headerlink\" title=\"9.5.1 函数组件\"></a>9.5.1 函数组件</h3><p>顾名思义，该组件被定义为一个JavaScript函数，其第一个参数是一个 <code>props</code> 对象。TS强制要求它的返回类型必须是可分配给 <code>JSX.Element</code>的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">FooProp</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">X</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">Y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">AnotherComponent</span>(<span class=\"params\"><span class=\"attr\">prop</span>: &#123; name: <span class=\"built_in\">string</span> &#125;</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ComponentFoo</span>(<span class=\"params\"><span class=\"attr\">prop</span>: <span class=\"title class_\">FooProp</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">AnotherComponent</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;prop.name&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Button</span> = (<span class=\"params\"><span class=\"attr\">prop</span>: &#123; value: <span class=\"built_in\">string</span> &#125;, <span class=\"attr\">context</span>: &#123; color: <span class=\"built_in\">string</span> &#125;</span>) =&gt; (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> /&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>因为函数组件只是一个JavaScript函数，这里也可以使用函数重载。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ClickableProps</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">children</span>: <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>[] | <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">HomeProps</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClickableProps</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">home</span>: <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">SideProps</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClickableProps</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">side</span>: <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span> | <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MainButton</span>(<span class=\"params\"><span class=\"attr\">prop</span>: <span class=\"title class_\">HomeProps</span></span>): <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MainButton</span>(<span class=\"params\"><span class=\"attr\">prop</span>: <span class=\"title class_\">SideProps</span></span>): <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MainButton</span>(<span class=\"params\"><span class=\"attr\">prop</span>: <span class=\"title class_\">ClickableProps</span></span>): <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：函数组件以前被称为无状态函数组件（SFC）。由于Function Components在最近的react版本中不再被认为是无状态的，<code>SFC</code>类型和它的别名<code>StatelessComponent</code>被废弃了。</p>\n</blockquote>\n<h3 id=\"9-5-2-类组件\"><a href=\"#9-5-2-类组件\" class=\"headerlink\" title=\"9.5.2 类组件\"></a>9.5.2 类组件</h3><p>定义一个类组件的类型是可能的。然而，要做到这一点，最好理解两个新术语：元素类类型和元素实例类型。</p>\n<p>给定<code>&lt;Expr /&gt;</code>，元素类的类型就是<code>Expr</code>的类型。所以在上面的例子中，如果<code>MyComponent</code>是一个ES6类，那么类的类型就是该类的构造函数和状态。如果<code>MyComponent</code>是一个工厂函数，类的类型将是该函数。</p>\n<p>一旦类的类型被确定，实例的类型就由该类的构造或调用签名（无论哪一个）的返回类型的联合决定。因此，在ES6类的情况下，实例类型将是该类实例的类型，而在工厂函数的情况下，它将是该函数返回值的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用构造签名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myComponent = <span class=\"keyword\">new</span> <span class=\"title class_\">MyComponent</span>();</span><br><span class=\"line\"><span class=\"comment\">// 元素类类型 =&gt; MyComponent</span></span><br><span class=\"line\"><span class=\"comment\">// 元素实例类型 =&gt; &#123; render: () =&gt; void &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MyFactoryFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">render</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用调用签名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myComponent = <span class=\"title class_\">MyFactoryFunction</span>();</span><br><span class=\"line\"><span class=\"comment\">// 元素类类型 =&gt; MyFactoryFunction</span></span><br><span class=\"line\"><span class=\"comment\">// 元素实例类型 =&gt; &#123; render: () =&gt; void &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>元素实例类型很有趣，因为它必须可以分配给 <code>JSX.ElementClass</code>，否则会导致错误。默认情况下，<code>JSX.ElementClass</code> 是 <code>&#123;&#125;</code>，但它可以被增强，以限制JSX的使用，使其只适用于那些符合适当接口的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">ElementClass</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">render</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MyFactoryFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">render</span>: <span class=\"function\">() =&gt;</span> &#123;&#125; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"title class_\">MyComponent</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">MyFactoryFunction</span> /&gt;</span></span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NotAValidComponent</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">NotAValidFactoryFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"title class_\">NotAValidComponent</span> /&gt;; <span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">NotAValidFactoryFunction</span> /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-6-属性类型检查\"><a href=\"#9-6-属性类型检查\" class=\"headerlink\" title=\"9.6 属性类型检查\"></a>9.6 属性类型检查</h2><p>类型检查属性的第一步是确定元素属性类型。这在内在元素和基于值的元素之间略有不同。</p>\n<p>对于内在元素，它是 <code>JSX.IntrinsicElements</code> 上的属性类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">IntrinsicElements</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: &#123; <span class=\"attr\">bar</span>?: <span class=\"built_in\">boolean</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#x27;foo&#x27;的元素属性类型是&#x27;&#123;bar?: boolean&#125;&#x27;</span></span><br><span class=\"line\">&lt;foo bar /&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>元素属性类型是用来对JSX中的属性进行类型检查的。支持可选和必需的属性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">IntrinsicElements</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: &#123; <span class=\"attr\">requiredProp</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">optionalProp</span>?: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">requiredProp</span>=<span class=\"string\">&quot;bar&quot;</span> <span class=\"attr\">optionalProp</span>=<span class=\"string\">&#123;0&#125;</span> /&gt;</span></span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> /&gt;</span></span>; <span class=\"comment\">// 错误, requiredProp 缺失</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">requiredProp</span>=<span class=\"string\">&#123;0&#125;</span> /&gt;</span></span>; <span class=\"comment\">// 错误, requiredProp 应该为 string 类型</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">requiredProp</span>=<span class=\"string\">&quot;bar&quot;</span> <span class=\"attr\">unknownProp</span> /&gt;</span></span>; <span class=\"comment\">// 错误, unknownProp 属性不存在</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">requiredProp</span>=<span class=\"string\">&quot;bar&quot;</span> <span class=\"attr\">some-unknown-prop</span> /&gt;</span></span>; <span class=\"comment\">// 正确, 因为 &#x27;some-unknown-prop&#x27; 不是一个有效的属性标识</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果一个属性名称不是一个有效的JS标识符（如data-*属性），如果在元素属性类型中找不到它，则不被认为是一个错误。</p>\n</blockquote>\n<p>此外，<code>JSX.IntrinsicAttributes</code>接口可以用来指定JSX框架使用的额外属性，这些属性一般不会被组件的道具或参数使用–例如React中的key。进一步专门化，通用的 <code>JSX.IntrinsicClassAttributes&lt;T&gt;</code>类型也可以用来为类组件（而不是函数组件）指定同种额外属性。在这种类型中，通用参数与类的实例类型相对应。在React中，这被用来允许<code>Ref&lt;T&gt;</code>类型的<code>ref</code>属性。一般来说，这些接口上的所有属性都应该是可选的，除非你打算让你的JSX框架的用户需要在每个标签上提供一些属性。</p>\n<p>展开运算符也能正常工作：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> props = &#123; <span class=\"attr\">requiredProp</span>: <span class=\"string\">&quot;bar&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> &#123;<span class=\"attr\">...props</span>&#125; /&gt;</span></span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> badProps = &#123;&#125;;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> &#123;<span class=\"attr\">...badProps</span>&#125; /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-7-子类型检查\"><a href=\"#9-7-子类型检查\" class=\"headerlink\" title=\"9.7 子类型检查\"></a>9.7 子类型检查</h2><p>在TypeScript 2.3中，TS引入了<em>children</em>的类型检查。<em>children</em>是元素属性类型中的一个特殊属性，子的<em>JSXExpressions</em>被采取插入属性中。类似于TS使用<code>JSX.ElementAttributesProperty</code>来确定 <em>props</em> 的名称，TS使用<code>JSX.ElementChildrenAttribute</code>来确定这些 <em>props</em> 中的 <em>children</em> 的名称。<code>JSX.ElementChildrenAttribute</code>应该用一个单一的属性来声明。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">ElementChildrenAttribute</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">children</span>: &#123;&#125;; <span class=\"comment\">// 指定要使用的 children 名称</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  World</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">CustomComp</span> = (<span class=\"params\">props</span>) =&gt; <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;props.children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">CustomComp</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  &#123;&quot;This is just a JS expression...&quot; + 1000&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">CustomComp</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>你可以像其他属性一样指定 <em>children</em> 的类型。这将覆盖默认的类型，例如，如果你使用React类型的话：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">PropsType</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">children</span>: <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span></span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Component</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span>&lt;<span class=\"title class_\">PropsType</span>, &#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;this.props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;<span class=\"title class_\">Component</span> name=<span class=\"string\">&quot;foo&quot;</span>&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&lt;/<span class=\"title class_\">Component</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误: children是JSX.Element的类型，而不是JSX.Element的数组</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;bar&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">Component</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误: children是JSX.Element的类型，而不是JSX.Element的数组或字符串。</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;baz&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  World</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">Component</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-8-JSX的结果类型\"><a href=\"#9-8-JSX的结果类型\" class=\"headerlink\" title=\"9.8 JSX的结果类型\"></a>9.8 JSX的结果类型</h2><p>默认情况下，JSX表达式的结果被打造成 <code>any</code> 类型。你可以通过指定 <code>JSX.Element</code> 接口来定制类型。然而，不可能从这个接口中检索到关于JSX的元素、属性或孩子的类型信息。它是一个黑盒子。</p>\n<h2 id=\"9-9-嵌入表达式\"><a href=\"#9-9-嵌入表达式\" class=\"headerlink\" title=\"9.9 嵌入表达式\"></a>9.9 嵌入表达式</h2><p>JSX允许你通过用大括号（<code>&#123; &#125;</code>）包围表达式，在标签之间嵌入表达式。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map((i) =&gt; (</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;i / 2&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    ))&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码将导致一个错误，因为你不能用一个字符串除以一个数字。当使用 <code>preserve</code> 选项时，输出结果看起来像：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map(function (i) &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">      return <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;i / 2&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>;</span></span><br><span class=\"line\"><span class=\"language-xml\">    &#125;)&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-10-React-集成\"><a href=\"#9-10-React-集成\" class=\"headerlink\" title=\"9.10 React 集成\"></a>9.10 React 集成</h2><p>要在React中使用JSX，你应该使用 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react\">React 类型</a>。这些类型化定义了 <code>JSX</code> 的命名空间，以便与React一起使用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;react.d.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Props</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span>&lt;<span class=\"title class_\">Props</span>, &#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"title class_\">MyComponent</span> foo=<span class=\"string\">&quot;bar&quot;</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span> <span class=\"attr\">foo</span>=<span class=\"string\">&#123;0&#125;</span> /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-10-1-配置JSX\"><a href=\"#9-10-1-配置JSX\" class=\"headerlink\" title=\"9.10.1 配置JSX\"></a>9.10.1 配置JSX</h3><p>有多个编译器标志可以用来定制你的JSX，它们既可以作为编译器标志，也可以通过内联的每个文件实用程序发挥作用。要了解更多信息，请看他们的tsconfig参考页：</p>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxFactory\"><code>jsxFactory</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxFragmentFactory\"><code>jsxFragmentFactory</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxImportSource\"><code>jsxImportSource</code></a></li>\n</ul>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"九、JSX\"><a href=\"#九、JSX\" class=\"headerlink\" title=\"九、JSX\"></a>九、JSX</h1><p><a href=\"https://facebook.github.io/jsx/\">JSX</a> 是一种可嵌入的类似XML的语法。它旨在被转换为有效的JavaScript，尽管这种转换的语义是具体实施的。JSX随着<a href=\"https://reactjs.org/\">React</a> 框架的流行而兴起，但后来也有了其他的实现。TypeScript支持嵌入、类型检查，以及直接将JSX编译为JavaScript。</p>\n<h2 id=\"9-1-基本用法\"><a href=\"#9-1-基本用法\" class=\"headerlink\" title=\"9. 1 基本用法\"></a>9. 1 基本用法</h2><p>为了使用JSX，你必须做两件事。</p>\n<ol>\n<li>用 <code>.tsx</code> 扩展名来命名你的文件</li>\n<li>启用 <code>jsx</code> 选项</li>\n</ol>\n<p>TypeScript有三种JSX模式：<code>preserve</code>, <code>react</code>和 <code>react-native</code>。这些模式只影响生成阶段 - 类型检查不受影响。 <code>preserve</code> 模式将保留 JSX 作为输出的一部分，以便被另一个转换步骤（例如 <a href=\"https://babeljs.io/\">Babel</a>）进一步消耗。此外，输出将有一个 <code>.jsx</code> 文件扩展名。<code>react</code>模式将发出 <code>React.createElement</code>，在使用前不需要经过JSX转换，而且输出将有一个 <code>.js</code> 文件扩展名。<code>react-native</code> 模式相当于保留模式，它保留了所有的JSX，但输出将有一个 <code>.js</code> 文件扩展名。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Mode</th>\n<th align=\"left\">Input</th>\n<th align=\"left\">Output</th>\n<th align=\"left\">Output File Extension</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>preserve</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>.jsx</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>react</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>React.createElement(&quot;div&quot;)</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>react-native</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>react-jsx</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>_jsx(&quot;div&quot;, &#123;&#125;, void 0);</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>react-jsxdev</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>_jsxDEV(&quot;div&quot;, &#123;&#125;, void 0, false, &#123;...&#125;, this);</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n</tbody></table>\n<p>You can specify this mode using either the <a href=\"https://www.typescriptlang.org/tsconfig#jsx\"><code>jsx</code></a> command line flag or the corresponding option <a href=\"https://www.typescriptlang.org/tsconfig#jsx\"><code>jsx</code> in your tsconfig.json</a> file.</p>\n<p>你可以使用 <code>jsx</code> 命令行标志或你的 <a href=\"https://www.typescriptlang.org/tsconfig#jsx\"> tsconfig.json</a> 文件中的相应选项 <code>jsx</code> 指定这种模式。</p>\n<blockquote>\n<p>*注意：你可以用 <a href=\"https://www.typescriptlang.org/tsconfig#jsxFactory\"><code>jsxFactory</code></a> 选项指定针对 react JSX 生成 JS 时使用的JSX工厂函数（默认为<code>React.createElement</code>）。</p>\n</blockquote>\n<h2 id=\"9-2-as操作符\"><a href=\"#9-2-as操作符\" class=\"headerlink\" title=\"9.2 as操作符\"></a>9.2 <code>as</code>操作符</h2><p>回忆一下如何编写类型断言。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &lt;foo&gt;bar;</span><br></pre></td></tr></table></figure>\n\n<p>这断言变量 <code>bar</code>具有<code>foo</code>类型。由于TypeScript也使用角括号进行类型断言，将其与JSX的语法相结合会带来某些解析困难。因此，TypeScript不允许在 <code>.tsx</code> 文件中使用角括号类型断言。</p>\n<p>由于上述语法不能在 <code>.tsx</code> 文件中使用，应该使用一个替代的类型断言操作符：<code>as</code>。这个例子可以很容易地用 <code>as</code> 操作符重写。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = bar <span class=\"keyword\">as</span> foo;</span><br></pre></td></tr></table></figure>\n\n<p><code>as</code> 操作符在 <code>.ts</code> 和 <code>.tsx</code> 文件中都可用，并且在行为上与角括号式断言风格相同。</p>\n<h2 id=\"9-3-类型检查\"><a href=\"#9-3-类型检查\" class=\"headerlink\" title=\"9.3 类型检查\"></a>9.3 类型检查</h2><p>为了理解JSX的类型检查，你必须首先理解内在元素和基于值的元素之间的区别。给定一个JSX表达式 <code>&lt;expr /&gt;</code>，<code>expr</code>既可以指环境中固有的东西（例如DOM环境中的<code>div</code>或<code>span</code>），也可以指你创建的自定义组件。这很重要，有两个原因。</p>\n<ul>\n<li>对于React来说，内在元素是以字符串的形式发出的（<code>React.createElement(&quot;div&quot;)</code>），而你创建的组件则不是（<code>React.createElement(MyComponent)</code>）。</li>\n<li>在JSX元素中传递的属性类型应该被不同地查找。元素的内在属性应该是已知的，而组件可能想要指定他们自己的属性集。</li>\n</ul>\n<p>TypeScript使用<a href=\"http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components\">与React相同的约定</a> 来区分这些。一个内在的元素总是以小写字母开始，而一个基于价值的元素总是以大写字母开始。</p>\n<h2 id=\"9-4-内在元素\"><a href=\"#9-4-内在元素\" class=\"headerlink\" title=\"9.4 内在元素\"></a>9.4 内在元素</h2><p>内在元素在特殊接口 <code>JSX.IntrinsicElements</code> 上被查询到。默认情况下，如果没有指定这个接口，那么什么都可以，内在元素将不会被类型检查。然而，如果这个接口存在，那么内在元素的名称将作为<code>JSX.IntrinsicElements</code>接口上的一个属性被查询。比如说。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">IntrinsicElements</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;foo /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">bar</span> /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中，<code>&lt;foo /&gt;</code>可以正常工作，但<code>&lt;bar /&gt;</code>会导致一个错误，因为它没有被指定在<code>JSX.IntrinsicElements</code>上。</p>\n<p>注意：你也可以在<code>JWX.IntrinsicElements</code>上指定一个全面的字符串索引器，如下所示：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">IntrinsicElements</span> &#123;</span><br><span class=\"line\">    [<span class=\"attr\">elemName</span>: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-5-基于值的元素\"><a href=\"#9-5-基于值的元素\" class=\"headerlink\" title=\"9.5 基于值的元素\"></a>9.5 基于值的元素</h2><p>基于值的元素只是通过范围内的标识符进行查询。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">MyComponent</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./myComponent&quot;</span>;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span> /&gt;</span></span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">SomeOtherComponent</span> /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<p>有两种方法来定义基于值的元素：</p>\n<ol>\n<li>函数组件（FC）</li>\n<li>类组件</li>\n</ol>\n<p>因为这两类基于值的元素在JSX表达式中是无法区分的，首先TS尝试使用重载解析将表达式解析为一个函数组件。如果这个过程成功了，那么TS就完成了将表达式解析为它的声明。如果该值不能被解析为一个函数组件，那么TS将尝试将其解析为一个类组件。如果失败了，TS将报告一个错误。</p>\n<h3 id=\"9-5-1-函数组件\"><a href=\"#9-5-1-函数组件\" class=\"headerlink\" title=\"9.5.1 函数组件\"></a>9.5.1 函数组件</h3><p>顾名思义，该组件被定义为一个JavaScript函数，其第一个参数是一个 <code>props</code> 对象。TS强制要求它的返回类型必须是可分配给 <code>JSX.Element</code>的。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">FooProp</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">X</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">Y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">AnotherComponent</span>(<span class=\"params\"><span class=\"attr\">prop</span>: &#123; name: <span class=\"built_in\">string</span> &#125;</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ComponentFoo</span>(<span class=\"params\"><span class=\"attr\">prop</span>: <span class=\"title class_\">FooProp</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">AnotherComponent</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;prop.name&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Button</span> = (<span class=\"params\"><span class=\"attr\">prop</span>: &#123; value: <span class=\"built_in\">string</span> &#125;, <span class=\"attr\">context</span>: &#123; color: <span class=\"built_in\">string</span> &#125;</span>) =&gt; (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> /&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>因为函数组件只是一个JavaScript函数，这里也可以使用函数重载。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">ClickableProps</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">children</span>: <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>[] | <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">HomeProps</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClickableProps</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">home</span>: <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">SideProps</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClickableProps</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">side</span>: <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span> | <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MainButton</span>(<span class=\"params\"><span class=\"attr\">prop</span>: <span class=\"title class_\">HomeProps</span></span>): <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MainButton</span>(<span class=\"params\"><span class=\"attr\">prop</span>: <span class=\"title class_\">SideProps</span></span>): <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MainButton</span>(<span class=\"params\"><span class=\"attr\">prop</span>: <span class=\"title class_\">ClickableProps</span></span>): <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：函数组件以前被称为无状态函数组件（SFC）。由于Function Components在最近的react版本中不再被认为是无状态的，<code>SFC</code>类型和它的别名<code>StatelessComponent</code>被废弃了。</p>\n</blockquote>\n<h3 id=\"9-5-2-类组件\"><a href=\"#9-5-2-类组件\" class=\"headerlink\" title=\"9.5.2 类组件\"></a>9.5.2 类组件</h3><p>定义一个类组件的类型是可能的。然而，要做到这一点，最好理解两个新术语：元素类类型和元素实例类型。</p>\n<p>给定<code>&lt;Expr /&gt;</code>，元素类的类型就是<code>Expr</code>的类型。所以在上面的例子中，如果<code>MyComponent</code>是一个ES6类，那么类的类型就是该类的构造函数和状态。如果<code>MyComponent</code>是一个工厂函数，类的类型将是该函数。</p>\n<p>一旦类的类型被确定，实例的类型就由该类的构造或调用签名（无论哪一个）的返回类型的联合决定。因此，在ES6类的情况下，实例类型将是该类实例的类型，而在工厂函数的情况下，它将是该函数返回值的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用构造签名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myComponent = <span class=\"keyword\">new</span> <span class=\"title class_\">MyComponent</span>();</span><br><span class=\"line\"><span class=\"comment\">// 元素类类型 =&gt; MyComponent</span></span><br><span class=\"line\"><span class=\"comment\">// 元素实例类型 =&gt; &#123; render: () =&gt; void &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MyFactoryFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">render</span>: <span class=\"function\">() =&gt;</span> &#123;&#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用调用签名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myComponent = <span class=\"title class_\">MyFactoryFunction</span>();</span><br><span class=\"line\"><span class=\"comment\">// 元素类类型 =&gt; MyFactoryFunction</span></span><br><span class=\"line\"><span class=\"comment\">// 元素实例类型 =&gt; &#123; render: () =&gt; void &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>元素实例类型很有趣，因为它必须可以分配给 <code>JSX.ElementClass</code>，否则会导致错误。默认情况下，<code>JSX.ElementClass</code> 是 <code>&#123;&#125;</code>，但它可以被增强，以限制JSX的使用，使其只适用于那些符合适当接口的类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">ElementClass</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">render</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">MyFactoryFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">render</span>: <span class=\"function\">() =&gt;</span> &#123;&#125; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"title class_\">MyComponent</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">MyFactoryFunction</span> /&gt;</span></span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NotAValidComponent</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">NotAValidFactoryFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"title class_\">NotAValidComponent</span> /&gt;; <span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">NotAValidFactoryFunction</span> /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-6-属性类型检查\"><a href=\"#9-6-属性类型检查\" class=\"headerlink\" title=\"9.6 属性类型检查\"></a>9.6 属性类型检查</h2><p>类型检查属性的第一步是确定元素属性类型。这在内在元素和基于值的元素之间略有不同。</p>\n<p>对于内在元素，它是 <code>JSX.IntrinsicElements</code> 上的属性类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">IntrinsicElements</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: &#123; <span class=\"attr\">bar</span>?: <span class=\"built_in\">boolean</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#x27;foo&#x27;的元素属性类型是&#x27;&#123;bar?: boolean&#125;&#x27;</span></span><br><span class=\"line\">&lt;foo bar /&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>元素属性类型是用来对JSX中的属性进行类型检查的。支持可选和必需的属性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">IntrinsicElements</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: &#123; <span class=\"attr\">requiredProp</span>: <span class=\"built_in\">string</span>; <span class=\"attr\">optionalProp</span>?: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">requiredProp</span>=<span class=\"string\">&quot;bar&quot;</span> <span class=\"attr\">optionalProp</span>=<span class=\"string\">&#123;0&#125;</span> /&gt;</span></span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> /&gt;</span></span>; <span class=\"comment\">// 错误, requiredProp 缺失</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">requiredProp</span>=<span class=\"string\">&#123;0&#125;</span> /&gt;</span></span>; <span class=\"comment\">// 错误, requiredProp 应该为 string 类型</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">requiredProp</span>=<span class=\"string\">&quot;bar&quot;</span> <span class=\"attr\">unknownProp</span> /&gt;</span></span>; <span class=\"comment\">// 错误, unknownProp 属性不存在</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> <span class=\"attr\">requiredProp</span>=<span class=\"string\">&quot;bar&quot;</span> <span class=\"attr\">some-unknown-prop</span> /&gt;</span></span>; <span class=\"comment\">// 正确, 因为 &#x27;some-unknown-prop&#x27; 不是一个有效的属性标识</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果一个属性名称不是一个有效的JS标识符（如data-*属性），如果在元素属性类型中找不到它，则不被认为是一个错误。</p>\n</blockquote>\n<p>此外，<code>JSX.IntrinsicAttributes</code>接口可以用来指定JSX框架使用的额外属性，这些属性一般不会被组件的道具或参数使用–例如React中的key。进一步专门化，通用的 <code>JSX.IntrinsicClassAttributes&lt;T&gt;</code>类型也可以用来为类组件（而不是函数组件）指定同种额外属性。在这种类型中，通用参数与类的实例类型相对应。在React中，这被用来允许<code>Ref&lt;T&gt;</code>类型的<code>ref</code>属性。一般来说，这些接口上的所有属性都应该是可选的，除非你打算让你的JSX框架的用户需要在每个标签上提供一些属性。</p>\n<p>展开运算符也能正常工作：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> props = &#123; <span class=\"attr\">requiredProp</span>: <span class=\"string\">&quot;bar&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> &#123;<span class=\"attr\">...props</span>&#125; /&gt;</span></span>; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> badProps = &#123;&#125;;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">foo</span> &#123;<span class=\"attr\">...badProps</span>&#125; /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-7-子类型检查\"><a href=\"#9-7-子类型检查\" class=\"headerlink\" title=\"9.7 子类型检查\"></a>9.7 子类型检查</h2><p>在TypeScript 2.3中，TS引入了<em>children</em>的类型检查。<em>children</em>是元素属性类型中的一个特殊属性，子的<em>JSXExpressions</em>被采取插入属性中。类似于TS使用<code>JSX.ElementAttributesProperty</code>来确定 <em>props</em> 的名称，TS使用<code>JSX.ElementChildrenAttribute</code>来确定这些 <em>props</em> 中的 <em>children</em> 的名称。<code>JSX.ElementChildrenAttribute</code>应该用一个单一的属性来声明。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">JSX</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">ElementChildrenAttribute</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">children</span>: &#123;&#125;; <span class=\"comment\">// 指定要使用的 children 名称</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  World</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">CustomComp</span> = (<span class=\"params\">props</span>) =&gt; <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;props.children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">CustomComp</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  &#123;&quot;This is just a JS expression...&quot; + 1000&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">CustomComp</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>你可以像其他属性一样指定 <em>children</em> 的类型。这将覆盖默认的类型，例如，如果你使用React类型的话：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">PropsType</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">children</span>: <span class=\"variable constant_\">JSX</span>.<span class=\"property\">Element</span></span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Component</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span>&lt;<span class=\"title class_\">PropsType</span>, &#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;this.props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;<span class=\"title class_\">Component</span> name=<span class=\"string\">&quot;foo&quot;</span>&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&lt;/<span class=\"title class_\">Component</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误: children是JSX.Element的类型，而不是JSX.Element的数组</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;bar&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">Component</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误: children是JSX.Element的类型，而不是JSX.Element的数组或字符串。</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;baz&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  World</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">Component</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-8-JSX的结果类型\"><a href=\"#9-8-JSX的结果类型\" class=\"headerlink\" title=\"9.8 JSX的结果类型\"></a>9.8 JSX的结果类型</h2><p>默认情况下，JSX表达式的结果被打造成 <code>any</code> 类型。你可以通过指定 <code>JSX.Element</code> 接口来定制类型。然而，不可能从这个接口中检索到关于JSX的元素、属性或孩子的类型信息。它是一个黑盒子。</p>\n<h2 id=\"9-9-嵌入表达式\"><a href=\"#9-9-嵌入表达式\" class=\"headerlink\" title=\"9.9 嵌入表达式\"></a>9.9 嵌入表达式</h2><p>JSX允许你通过用大括号（<code>&#123; &#125;</code>）包围表达式，在标签之间嵌入表达式。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map((i) =&gt; (</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;i / 2&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    ))&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码将导致一个错误，因为你不能用一个字符串除以一个数字。当使用 <code>preserve</code> 选项时，输出结果看起来像：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map(function (i) &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">      return <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;i / 2&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>;</span></span><br><span class=\"line\"><span class=\"language-xml\">    &#125;)&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-10-React-集成\"><a href=\"#9-10-React-集成\" class=\"headerlink\" title=\"9.10 React 集成\"></a>9.10 React 集成</h2><p>要在React中使用JSX，你应该使用 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react\">React 类型</a>。这些类型化定义了 <code>JSX</code> 的命名空间，以便与React一起使用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;react.d.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Props</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">foo</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span>&lt;<span class=\"title class_\">Props</span>, &#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"title class_\">MyComponent</span> foo=<span class=\"string\">&quot;bar&quot;</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span> <span class=\"attr\">foo</span>=<span class=\"string\">&#123;0&#125;</span> /&gt;</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-10-1-配置JSX\"><a href=\"#9-10-1-配置JSX\" class=\"headerlink\" title=\"9.10.1 配置JSX\"></a>9.10.1 配置JSX</h3><p>有多个编译器标志可以用来定制你的JSX，它们既可以作为编译器标志，也可以通过内联的每个文件实用程序发挥作用。要了解更多信息，请看他们的tsconfig参考页：</p>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxFactory\"><code>jsxFactory</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxFragmentFactory\"><code>jsxFragmentFactory</code></a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig#jsxImportSource\"><code>jsxImportSource</code></a></li>\n</ul>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "3-2、高级篇：三斜线指令",
        "toc": true,
        "abbrlink": 9557,
        "date": "2024-01-28T13:10:26.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 十一、三斜线指令\n\n三斜线指令是包含单个XML标签的单行注释。注释的内容被作为编译器指令使用。\n\n三斜线指令只在其包含文件的顶部有效。三斜线指令的前面只能有单行或多行注释，包括其他三斜线指令。如果它们出现在语句或声明之后，则被视为普通的单行注释，没有任何特殊意义。\n\n## 11.1 `/// <reference path=\"...\" />`\n\n- **预处理输入文件**\n\n编译器对输入文件进行预处理，以解决所有三斜线参考指令。在这个过程中，额外的文件被添加到编译中。\n\n这个过程从一组 _根文件_ 开始；这些文件是在命令行或在 `tsconfig.json` 文件的[`文件列表 `](https://www.typescriptlang.org/tsconfig#files)中指定的文件名。这些根文件按照它们被指定的顺序进行预处理。在一个文件被添加到列表中之前，其中所有的三斜线引用都会被处理，并包括它们的目标。三斜线引用是以深度优先的方式解决的，按照它们在文件中出现的顺序。\n\n如果使用的是相对路径，那么三斜线引用的路径是相对于包含的文件进行解析的。\n\n- **错误**\n\n引用一个不存在的文件是一个错误。一个文件对自己有三重斜线引用是一个错误。\n\n- **使用 `--noResolve`**\n\n如果指定了编译器标志noResolve，三斜线引用将被忽略；它们既不会导致添加新的文件，也不会改变所提供文件的顺序。\n\n## 11.2 `/// <reference types=\"...\" />`\n\n与作为依赖关系声明的 `/// <reference path=\"...\" />` 指令类似，`/// <reference types=\"...\" />`指令声明对包的依赖关系。\n\n解析这些包名的过程与解析 `import` 语句中的模块名的过程类似。一个简单的方法是将三重斜线*引用*类型指令看作是声明包的 `import`。\n\n例如，在一个声明文件中包括 `/// <reference types=\"node\" />` 声明这个文件使用 `@types/node/index.d.ts` 中声明的名字；因此，这个包需要和声明文件一起包含在编译中。\n\n只有在你手工编写 `d.ts` 文件的时候才使用这些指令。\n\n对于在编译过程中生成的声明文件，编译器会自动为你添加 `/// <reference types=\"...\" />；`在生成的声明文件中，*当且仅当*生成的文件使用了被引用包的任何声明时，会添加 `/// <reference types=\"...\" />`。\n\n对于在 `.ts` 文件中声明对 `@types` s包的依赖，在命令行或你的 `tsconfig.json` 中使用 `types` 来代替。参见 [在 `tsconfig.json` 文件里应用 `@types`, `typeRoots` 和 `types` ](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types)以了解更多细节。\n\n## 11.3 `/// <reference lib=\"...\" />`\n\n这个指令允许一个文件明确地包含一个现有的内置 _lib_ 文件。\n\n内置 _lib_ 文件的引用方式与 `tsconfig.json` 中的[`lib`](https://www.typescriptlang.org/tsconfig#lib) 编译器选项相同（例如，使用`lib=\"es2015 \"`而不是`lib=\"lib.es2015.d.ts\"`，等等）。\n\n对于依赖内置类型的声明文件作者，例如DOM APIs或内置的JS运行时构造器，如 `Symbol`或`Iterable`，建议使用三重斜线引用的lib指令。以前这些 .d.ts 文件不得不添加此类类型的前向/重复声明。\n\n例如，在编译中的一个文件中添加`/// <reference lib=\"es2017.string\" />`，相当于用 `--lib es2017.string` 进行编译。\n\n```tsx\n/// <reference lib=\"es2017.string\" />\n\"foo\".padStart(4);\n```\n\n## 11.4 `/// <reference no-default-lib=\"true\"/>`\n\n这个指令将一个文件标记为 _默认库_。你会在 `lib.d.ts` 和它的不同变体的顶部看到这个注释。\n\n这个指令指示编译器在编译时不包括默认库（即 `lib.d.ts`）。这里的影响类似于在命令行中传递 [`noLib`](https://www.typescriptlang.org/tsconfig#noLib) 。\n\n还要注意的是，当传递 [`skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig#skipDefaultLibCheck)时，编译器将只跳过检查带有 `/// <reference no-default-lib=\"true\"/>` 的文件。\n\n## 14.5 `/// <amd-module />`\n\n默认情况下，AMD模块是以匿名方式生成的。当其他工具被用来处理生成的模块时，这可能会导致问题，例如捆绑器（如 `r.js` ）。\n\n`amd-module`指令允许向编译器传递一个可选的模块名称。\n\n- ##### amdModule.ts\n\n```tsx\n///<amd-module name=\"NamedModule\"/>\nexport class C {}\n```\n\n将导致在调用AMD `define`的过程中，将`NamedModule`这个名字分配给模块。\n\n- ##### amdModule.js\n\n```tsx\ndefine(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\n  var C = (function () {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});\n```\n\n## 14.6 `/// <amd-dependency />`\n\n> 注意：这个指令已被废弃。使用`import \"moduleName\";`语句代替。\n\n`/// <amd-dependency path=\"x\" />` 通知编译器一个需要在生成的模块的 require 调用中注入的非 TS 模块的依赖关系。\n\n`amd-dependency`指令也可以有一个可选的`name`属性；这允许为`amd-dependency`传递一个可选的名字。\n\n```tsx\n/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>\ndeclare var moduleA: MyType;\nmoduleA.callStuff();\n```\n\n生成的 JS 代码:\n\n```tsx\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (\n  require,\n  exports,\n  moduleA,\n) {\n  moduleA.callStuff();\n});\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/3-2、高级篇：三斜线指令.md",
        "raw": "---\ntitle: 3-2、高级篇：三斜线指令\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 9557\ndate: 2024-01-28 21:10:26\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 十一、三斜线指令\n\n三斜线指令是包含单个XML标签的单行注释。注释的内容被作为编译器指令使用。\n\n三斜线指令只在其包含文件的顶部有效。三斜线指令的前面只能有单行或多行注释，包括其他三斜线指令。如果它们出现在语句或声明之后，则被视为普通的单行注释，没有任何特殊意义。\n\n## 11.1 `/// <reference path=\"...\" />`\n\n- **预处理输入文件**\n\n编译器对输入文件进行预处理，以解决所有三斜线参考指令。在这个过程中，额外的文件被添加到编译中。\n\n这个过程从一组 _根文件_ 开始；这些文件是在命令行或在 `tsconfig.json` 文件的[`文件列表 `](https://www.typescriptlang.org/tsconfig#files)中指定的文件名。这些根文件按照它们被指定的顺序进行预处理。在一个文件被添加到列表中之前，其中所有的三斜线引用都会被处理，并包括它们的目标。三斜线引用是以深度优先的方式解决的，按照它们在文件中出现的顺序。\n\n如果使用的是相对路径，那么三斜线引用的路径是相对于包含的文件进行解析的。\n\n- **错误**\n\n引用一个不存在的文件是一个错误。一个文件对自己有三重斜线引用是一个错误。\n\n- **使用 `--noResolve`**\n\n如果指定了编译器标志noResolve，三斜线引用将被忽略；它们既不会导致添加新的文件，也不会改变所提供文件的顺序。\n\n## 11.2 `/// <reference types=\"...\" />`\n\n与作为依赖关系声明的 `/// <reference path=\"...\" />` 指令类似，`/// <reference types=\"...\" />`指令声明对包的依赖关系。\n\n解析这些包名的过程与解析 `import` 语句中的模块名的过程类似。一个简单的方法是将三重斜线*引用*类型指令看作是声明包的 `import`。\n\n例如，在一个声明文件中包括 `/// <reference types=\"node\" />` 声明这个文件使用 `@types/node/index.d.ts` 中声明的名字；因此，这个包需要和声明文件一起包含在编译中。\n\n只有在你手工编写 `d.ts` 文件的时候才使用这些指令。\n\n对于在编译过程中生成的声明文件，编译器会自动为你添加 `/// <reference types=\"...\" />；`在生成的声明文件中，*当且仅当*生成的文件使用了被引用包的任何声明时，会添加 `/// <reference types=\"...\" />`。\n\n对于在 `.ts` 文件中声明对 `@types` s包的依赖，在命令行或你的 `tsconfig.json` 中使用 `types` 来代替。参见 [在 `tsconfig.json` 文件里应用 `@types`, `typeRoots` 和 `types` ](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types)以了解更多细节。\n\n## 11.3 `/// <reference lib=\"...\" />`\n\n这个指令允许一个文件明确地包含一个现有的内置 _lib_ 文件。\n\n内置 _lib_ 文件的引用方式与 `tsconfig.json` 中的[`lib`](https://www.typescriptlang.org/tsconfig#lib) 编译器选项相同（例如，使用`lib=\"es2015 \"`而不是`lib=\"lib.es2015.d.ts\"`，等等）。\n\n对于依赖内置类型的声明文件作者，例如DOM APIs或内置的JS运行时构造器，如 `Symbol`或`Iterable`，建议使用三重斜线引用的lib指令。以前这些 .d.ts 文件不得不添加此类类型的前向/重复声明。\n\n例如，在编译中的一个文件中添加`/// <reference lib=\"es2017.string\" />`，相当于用 `--lib es2017.string` 进行编译。\n\n```tsx\n/// <reference lib=\"es2017.string\" />\n\"foo\".padStart(4);\n```\n\n## 11.4 `/// <reference no-default-lib=\"true\"/>`\n\n这个指令将一个文件标记为 _默认库_。你会在 `lib.d.ts` 和它的不同变体的顶部看到这个注释。\n\n这个指令指示编译器在编译时不包括默认库（即 `lib.d.ts`）。这里的影响类似于在命令行中传递 [`noLib`](https://www.typescriptlang.org/tsconfig#noLib) 。\n\n还要注意的是，当传递 [`skipDefaultLibCheck`](https://www.typescriptlang.org/tsconfig#skipDefaultLibCheck)时，编译器将只跳过检查带有 `/// <reference no-default-lib=\"true\"/>` 的文件。\n\n## 14.5 `/// <amd-module />`\n\n默认情况下，AMD模块是以匿名方式生成的。当其他工具被用来处理生成的模块时，这可能会导致问题，例如捆绑器（如 `r.js` ）。\n\n`amd-module`指令允许向编译器传递一个可选的模块名称。\n\n- ##### amdModule.ts\n\n```tsx\n///<amd-module name=\"NamedModule\"/>\nexport class C {}\n```\n\n将导致在调用AMD `define`的过程中，将`NamedModule`这个名字分配给模块。\n\n- ##### amdModule.js\n\n```tsx\ndefine(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\n  var C = (function () {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});\n```\n\n## 14.6 `/// <amd-dependency />`\n\n> 注意：这个指令已被废弃。使用`import \"moduleName\";`语句代替。\n\n`/// <amd-dependency path=\"x\" />` 通知编译器一个需要在生成的模块的 require 调用中注入的非 TS 模块的依赖关系。\n\n`amd-dependency`指令也可以有一个可选的`name`属性；这允许为`amd-dependency`传递一个可选的名字。\n\n```tsx\n/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>\ndeclare var moduleA: MyType;\nmoduleA.callStuff();\n```\n\n生成的 JS 代码:\n\n```tsx\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (\n  require,\n  exports,\n  moduleA,\n) {\n  moduleA.callStuff();\n});\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/3-2、高级篇：三斜线指令",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjao9001w94v35dngd4vo",
        "content": "<h1 id=\"十一、三斜线指令\"><a href=\"#十一、三斜线指令\" class=\"headerlink\" title=\"十一、三斜线指令\"></a>十一、三斜线指令</h1><p>三斜线指令是包含单个XML标签的单行注释。注释的内容被作为编译器指令使用。</p>\n<p>三斜线指令只在其包含文件的顶部有效。三斜线指令的前面只能有单行或多行注释，包括其他三斜线指令。如果它们出现在语句或声明之后，则被视为普通的单行注释，没有任何特殊意义。</p>\n<h2 id=\"11-1\"><a href=\"#11-1\" class=\"headerlink\" title=\"11.1 /// &lt;reference path=&quot;...&quot; /&gt;\"></a>11.1 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code></h2><ul>\n<li><strong>预处理输入文件</strong></li>\n</ul>\n<p>编译器对输入文件进行预处理，以解决所有三斜线参考指令。在这个过程中，额外的文件被添加到编译中。</p>\n<p>这个过程从一组 <em>根文件</em> 开始；这些文件是在命令行或在 <code>tsconfig.json</code> 文件的<a href=\"https://www.typescriptlang.org/tsconfig#files\"><code>文件列表 </code></a>中指定的文件名。这些根文件按照它们被指定的顺序进行预处理。在一个文件被添加到列表中之前，其中所有的三斜线引用都会被处理，并包括它们的目标。三斜线引用是以深度优先的方式解决的，按照它们在文件中出现的顺序。</p>\n<p>如果使用的是相对路径，那么三斜线引用的路径是相对于包含的文件进行解析的。</p>\n<ul>\n<li><strong>错误</strong></li>\n</ul>\n<p>引用一个不存在的文件是一个错误。一个文件对自己有三重斜线引用是一个错误。</p>\n<ul>\n<li><strong>使用 <code>--noResolve</code></strong></li>\n</ul>\n<p>如果指定了编译器标志noResolve，三斜线引用将被忽略；它们既不会导致添加新的文件，也不会改变所提供文件的顺序。</p>\n<h2 id=\"11-2\"><a href=\"#11-2\" class=\"headerlink\" title=\"11.2 /// &lt;reference types=&quot;...&quot; /&gt;\"></a>11.2 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code></h2><p>与作为依赖关系声明的 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令类似，<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>指令声明对包的依赖关系。</p>\n<p>解析这些包名的过程与解析 <code>import</code> 语句中的模块名的过程类似。一个简单的方法是将三重斜线<em>引用</em>类型指令看作是声明包的 <code>import</code>。</p>\n<p>例如，在一个声明文件中包括 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code> 声明这个文件使用 <code>@types/node/index.d.ts</code> 中声明的名字；因此，这个包需要和声明文件一起包含在编译中。</p>\n<p>只有在你手工编写 <code>d.ts</code> 文件的时候才使用这些指令。</p>\n<p>对于在编译过程中生成的声明文件，编译器会自动为你添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;；</code>在生成的声明文件中，<em>当且仅当</em>生成的文件使用了被引用包的任何声明时，会添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>。</p>\n<p>对于在 <code>.ts</code> 文件中声明对 <code>@types</code> s包的依赖，在命令行或你的 <code>tsconfig.json</code> 中使用 <code>types</code> 来代替。参见 <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types\">在 <code>tsconfig.json</code> 文件里应用 <code>@types</code>, <code>typeRoots</code> 和 <code>types</code> </a>以了解更多细节。</p>\n<h2 id=\"11-3\"><a href=\"#11-3\" class=\"headerlink\" title=\"11.3 /// &lt;reference lib=&quot;...&quot; /&gt;\"></a>11.3 <code>/// &lt;reference lib=&quot;...&quot; /&gt;</code></h2><p>这个指令允许一个文件明确地包含一个现有的内置 <em>lib</em> 文件。</p>\n<p>内置 <em>lib</em> 文件的引用方式与 <code>tsconfig.json</code> 中的<a href=\"https://www.typescriptlang.org/tsconfig#lib\"><code>lib</code></a> 编译器选项相同（例如，使用<code>lib=&quot;es2015 &quot;</code>而不是<code>lib=&quot;lib.es2015.d.ts&quot;</code>，等等）。</p>\n<p>对于依赖内置类型的声明文件作者，例如DOM APIs或内置的JS运行时构造器，如 <code>Symbol</code>或<code>Iterable</code>，建议使用三重斜线引用的lib指令。以前这些 .d.ts 文件不得不添加此类类型的前向&#x2F;重复声明。</p>\n<p>例如，在编译中的一个文件中添加<code>/// &lt;reference lib=&quot;es2017.string&quot; /&gt;</code>，相当于用 <code>--lib es2017.string</code> 进行编译。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference lib=&quot;es2017.string&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">&quot;foo&quot;</span>.<span class=\"title function_\">padStart</span>(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-4\"><a href=\"#11-4\" class=\"headerlink\" title=\"11.4 /// &lt;reference no-default-lib=&quot;true&quot;/&gt;\"></a>11.4 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code></h2><p>这个指令将一个文件标记为 _默认库_。你会在 <code>lib.d.ts</code> 和它的不同变体的顶部看到这个注释。</p>\n<p>这个指令指示编译器在编译时不包括默认库（即 <code>lib.d.ts</code>）。这里的影响类似于在命令行中传递 <a href=\"https://www.typescriptlang.org/tsconfig#noLib\"><code>noLib</code></a> 。</p>\n<p>还要注意的是，当传递 <a href=\"https://www.typescriptlang.org/tsconfig#skipDefaultLibCheck\"><code>skipDefaultLibCheck</code></a>时，编译器将只跳过检查带有 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 的文件。</p>\n<h2 id=\"14-5\"><a href=\"#14-5\" class=\"headerlink\" title=\"14.5 /// &lt;amd-module /&gt;\"></a>14.5 <code>/// &lt;amd-module /&gt;</code></h2><p>默认情况下，AMD模块是以匿名方式生成的。当其他工具被用来处理生成的模块时，这可能会导致问题，例如捆绑器（如 <code>r.js</code> ）。</p>\n<p><code>amd-module</code>指令允许向编译器传递一个可选的模块名称。</p>\n<ul>\n<li><h5 id=\"amdModule-ts\"><a href=\"#amdModule-ts\" class=\"headerlink\" title=\"amdModule.ts\"></a>amdModule.ts</h5></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///&lt;amd-module name=&quot;NamedModule&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将导致在调用AMD <code>define</code>的过程中，将<code>NamedModule</code>这个名字分配给模块。</p>\n<ul>\n<li><h5 id=\"amdModule-js\"><a href=\"#amdModule-js\" class=\"headerlink\" title=\"amdModule.js\"></a>amdModule.js</h5></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>(<span class=\"string\">&quot;NamedModule&quot;</span>, [<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>], <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> C = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">C</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> C;</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">C</span> = C;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-6\"><a href=\"#14-6\" class=\"headerlink\" title=\"14.6 /// &lt;amd-dependency /&gt;\"></a>14.6 <code>/// &lt;amd-dependency /&gt;</code></h2><blockquote>\n<p>注意：这个指令已被废弃。使用<code>import &quot;moduleName&quot;;</code>语句代替。</p>\n</blockquote>\n<p><code>/// &lt;amd-dependency path=&quot;x&quot; /&gt;</code> 通知编译器一个需要在生成的模块的 require 调用中注入的非 TS 模块的依赖关系。</p>\n<p><code>amd-dependency</code>指令也可以有一个可选的<code>name</code>属性；这允许为<code>amd-dependency</code>传递一个可选的名字。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;amd-dependency path=&quot;legacy/moduleA&quot; name=&quot;moduleA&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"attr\">moduleA</span>: <span class=\"title class_\">MyType</span>;</span><br><span class=\"line\">moduleA.<span class=\"title function_\">callStuff</span>();</span><br></pre></td></tr></table></figure>\n\n<p>生成的 JS 代码:</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;legacy/moduleA&quot;</span>], <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"built_in\">require</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"built_in\">exports</span>,</span></span><br><span class=\"line\"><span class=\"params\">  moduleA,</span></span><br><span class=\"line\"><span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  moduleA.<span class=\"title function_\">callStuff</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"十一、三斜线指令\"><a href=\"#十一、三斜线指令\" class=\"headerlink\" title=\"十一、三斜线指令\"></a>十一、三斜线指令</h1><p>三斜线指令是包含单个XML标签的单行注释。注释的内容被作为编译器指令使用。</p>\n<p>三斜线指令只在其包含文件的顶部有效。三斜线指令的前面只能有单行或多行注释，包括其他三斜线指令。如果它们出现在语句或声明之后，则被视为普通的单行注释，没有任何特殊意义。</p>\n<h2 id=\"11-1\"><a href=\"#11-1\" class=\"headerlink\" title=\"11.1 /// &lt;reference path=&quot;...&quot; /&gt;\"></a>11.1 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code></h2><ul>\n<li><strong>预处理输入文件</strong></li>\n</ul>\n<p>编译器对输入文件进行预处理，以解决所有三斜线参考指令。在这个过程中，额外的文件被添加到编译中。</p>\n<p>这个过程从一组 <em>根文件</em> 开始；这些文件是在命令行或在 <code>tsconfig.json</code> 文件的<a href=\"https://www.typescriptlang.org/tsconfig#files\"><code>文件列表 </code></a>中指定的文件名。这些根文件按照它们被指定的顺序进行预处理。在一个文件被添加到列表中之前，其中所有的三斜线引用都会被处理，并包括它们的目标。三斜线引用是以深度优先的方式解决的，按照它们在文件中出现的顺序。</p>\n<p>如果使用的是相对路径，那么三斜线引用的路径是相对于包含的文件进行解析的。</p>\n<ul>\n<li><strong>错误</strong></li>\n</ul>\n<p>引用一个不存在的文件是一个错误。一个文件对自己有三重斜线引用是一个错误。</p>\n<ul>\n<li><strong>使用 <code>--noResolve</code></strong></li>\n</ul>\n<p>如果指定了编译器标志noResolve，三斜线引用将被忽略；它们既不会导致添加新的文件，也不会改变所提供文件的顺序。</p>\n<h2 id=\"11-2\"><a href=\"#11-2\" class=\"headerlink\" title=\"11.2 /// &lt;reference types=&quot;...&quot; /&gt;\"></a>11.2 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code></h2><p>与作为依赖关系声明的 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令类似，<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>指令声明对包的依赖关系。</p>\n<p>解析这些包名的过程与解析 <code>import</code> 语句中的模块名的过程类似。一个简单的方法是将三重斜线<em>引用</em>类型指令看作是声明包的 <code>import</code>。</p>\n<p>例如，在一个声明文件中包括 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code> 声明这个文件使用 <code>@types/node/index.d.ts</code> 中声明的名字；因此，这个包需要和声明文件一起包含在编译中。</p>\n<p>只有在你手工编写 <code>d.ts</code> 文件的时候才使用这些指令。</p>\n<p>对于在编译过程中生成的声明文件，编译器会自动为你添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;；</code>在生成的声明文件中，<em>当且仅当</em>生成的文件使用了被引用包的任何声明时，会添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>。</p>\n<p>对于在 <code>.ts</code> 文件中声明对 <code>@types</code> s包的依赖，在命令行或你的 <code>tsconfig.json</code> 中使用 <code>types</code> 来代替。参见 <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types\">在 <code>tsconfig.json</code> 文件里应用 <code>@types</code>, <code>typeRoots</code> 和 <code>types</code> </a>以了解更多细节。</p>\n<h2 id=\"11-3\"><a href=\"#11-3\" class=\"headerlink\" title=\"11.3 /// &lt;reference lib=&quot;...&quot; /&gt;\"></a>11.3 <code>/// &lt;reference lib=&quot;...&quot; /&gt;</code></h2><p>这个指令允许一个文件明确地包含一个现有的内置 <em>lib</em> 文件。</p>\n<p>内置 <em>lib</em> 文件的引用方式与 <code>tsconfig.json</code> 中的<a href=\"https://www.typescriptlang.org/tsconfig#lib\"><code>lib</code></a> 编译器选项相同（例如，使用<code>lib=&quot;es2015 &quot;</code>而不是<code>lib=&quot;lib.es2015.d.ts&quot;</code>，等等）。</p>\n<p>对于依赖内置类型的声明文件作者，例如DOM APIs或内置的JS运行时构造器，如 <code>Symbol</code>或<code>Iterable</code>，建议使用三重斜线引用的lib指令。以前这些 .d.ts 文件不得不添加此类类型的前向&#x2F;重复声明。</p>\n<p>例如，在编译中的一个文件中添加<code>/// &lt;reference lib=&quot;es2017.string&quot; /&gt;</code>，相当于用 <code>--lib es2017.string</code> 进行编译。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference lib=&quot;es2017.string&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"string\">&quot;foo&quot;</span>.<span class=\"title function_\">padStart</span>(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-4\"><a href=\"#11-4\" class=\"headerlink\" title=\"11.4 /// &lt;reference no-default-lib=&quot;true&quot;/&gt;\"></a>11.4 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code></h2><p>这个指令将一个文件标记为 _默认库_。你会在 <code>lib.d.ts</code> 和它的不同变体的顶部看到这个注释。</p>\n<p>这个指令指示编译器在编译时不包括默认库（即 <code>lib.d.ts</code>）。这里的影响类似于在命令行中传递 <a href=\"https://www.typescriptlang.org/tsconfig#noLib\"><code>noLib</code></a> 。</p>\n<p>还要注意的是，当传递 <a href=\"https://www.typescriptlang.org/tsconfig#skipDefaultLibCheck\"><code>skipDefaultLibCheck</code></a>时，编译器将只跳过检查带有 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 的文件。</p>\n<h2 id=\"14-5\"><a href=\"#14-5\" class=\"headerlink\" title=\"14.5 /// &lt;amd-module /&gt;\"></a>14.5 <code>/// &lt;amd-module /&gt;</code></h2><p>默认情况下，AMD模块是以匿名方式生成的。当其他工具被用来处理生成的模块时，这可能会导致问题，例如捆绑器（如 <code>r.js</code> ）。</p>\n<p><code>amd-module</code>指令允许向编译器传递一个可选的模块名称。</p>\n<ul>\n<li><h5 id=\"amdModule-ts\"><a href=\"#amdModule-ts\" class=\"headerlink\" title=\"amdModule.ts\"></a>amdModule.ts</h5></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///&lt;amd-module name=&quot;NamedModule&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将导致在调用AMD <code>define</code>的过程中，将<code>NamedModule</code>这个名字分配给模块。</p>\n<ul>\n<li><h5 id=\"amdModule-js\"><a href=\"#amdModule-js\" class=\"headerlink\" title=\"amdModule.js\"></a>amdModule.js</h5></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>(<span class=\"string\">&quot;NamedModule&quot;</span>, [<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>], <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> C = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">C</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> C;</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">C</span> = C;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-6\"><a href=\"#14-6\" class=\"headerlink\" title=\"14.6 /// &lt;amd-dependency /&gt;\"></a>14.6 <code>/// &lt;amd-dependency /&gt;</code></h2><blockquote>\n<p>注意：这个指令已被废弃。使用<code>import &quot;moduleName&quot;;</code>语句代替。</p>\n</blockquote>\n<p><code>/// &lt;amd-dependency path=&quot;x&quot; /&gt;</code> 通知编译器一个需要在生成的模块的 require 调用中注入的非 TS 模块的依赖关系。</p>\n<p><code>amd-dependency</code>指令也可以有一个可选的<code>name</code>属性；这允许为<code>amd-dependency</code>传递一个可选的名字。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;amd-dependency path=&quot;legacy/moduleA&quot; name=&quot;moduleA&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"attr\">moduleA</span>: <span class=\"title class_\">MyType</span>;</span><br><span class=\"line\">moduleA.<span class=\"title function_\">callStuff</span>();</span><br></pre></td></tr></table></figure>\n\n<p>生成的 JS 代码:</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;legacy/moduleA&quot;</span>], <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"built_in\">require</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"built_in\">exports</span>,</span></span><br><span class=\"line\"><span class=\"params\">  moduleA,</span></span><br><span class=\"line\"><span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  moduleA.<span class=\"title function_\">callStuff</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "2-8、高级篇：装饰器（Decorators）",
        "toc": true,
        "abbrlink": 32666,
        "date": "2024-01-28T13:08:50.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 八、装饰器（Decorators）\n\n## 8.1 简介\n\n随着TypeScript和ES6中类的引入，现在存在某些场景需要额外的功能，来支持注释或修改类和类成员。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的 [第二阶段](https://github.com/tc39/proposal-decorators)建议，并作为TypeScript的一个实验性功能提供。\n\n> 注意：装饰器是一个实验性的功能，在未来的版本中可能会改变。\n\n要启用对装饰器的实验性支持，你必须在命令行或在 `tsconfig.json` 中启用 `experimentalDecorators` 编译器选项。\n\n- **命令行**\n\n```tsx\ntsc --target ES5 --experimentalDecorators\n```\n\n- **tssconfig.json**\n\n```tsx\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n## 8.2 装饰器\n\n装饰器是一种特殊的声明，可以附加到类声明、方法、访问器、属性或参数上。装饰器使用 `@expression`的形式，其中`expression`必须评估为一个函数，该函数将在运行时被调用，并带有关于被装饰的声明的信息。\n\n例如，对于装饰器 `@sealed`，我们可以将 `sealed` 的函数写成如下:\n\n```tsx\nfunction sealed(target) {\n  // 对 \"target\"做一些事情 ...\n}\n```\n\n## 8.3 装饰器工厂\n\n如果我们想自定义装饰器如何应用于声明，我们可以写一个装饰器工厂。装饰器工厂是一个简单的函数，它返回将在运行时被装饰器调用的表达式。\n\n我们可以用以下方式写一个装饰器工厂：\n\n```tsx\nfunction color(value: string) {\n  // 这是装饰器工厂，它设置了\n  // 返回的装饰器函数\n  return function (target) {\n    // 这就是装饰器\n    // 用 \"target\" 和 \"value\"做一些事情...\n  };\n}\n```\n\n## 8.4 装饰器构成\n\n多个装饰器可以应用于一个声明，例如在一行中：\n\n```tsx\n@f @g x\n```\n\n多行的语法：\n\n```tsx\n@f\n@g\nx\n```\n\n当多个装饰器适用于一个声明时，它们的评估类似于数学中的 [函数组合](https://wikipedia.org/wiki/Function_composition)。在这种模式下，当组合函数 f 和 g 时，所产生的组合`(f∘g)(x)` 等同于 `f(g(x))`。\n\n因此，在TypeScript中对一个声明的多个装饰器进行评估时，会执行以下步骤：\n\n1. 每个装饰器的表达式都是自上而下地进行评估的。\n\n2. 然后将结果作为函数从下往上调用。\n\n如果我们使用[装饰器工厂](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)，可以通过下面的例子观察这个评估顺序：\n\n```tsx\nfunction first() {\n  console.log(\"first(): factory evaluated\");\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    console.log(\"first(): called\");\n  };\n}\n\nfunction second() {\n  console.log(\"second(): factory evaluated\");\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    console.log(\"second(): called\");\n  };\n}\n\nclass ExampleClass {\n  @first()\n  @second()\n  method() {}\n}\n```\n\n这将把这个输出打印到控制台：\n\n```sh\nfirst(): factory evaluated\nsecond(): factory evaluated\nsecond(): called\nfirst(): called\n```\n\n## 8.5 装饰器评估\n\n对于应用于类内各种声明的装饰器，有一个明确的顺序：\n\n1. 对于每个实例成员，首先是*参数装饰器*，然后是*方法*、*访问器*或*属性装饰器*。\n2. 对于每个静态成员，先是*参数装饰器*，然后是*方法*、*存取器*或*属性装饰器*。\n3. *参数装饰器被*应用于构造函数。\n4. *类装饰器*适用于类。\n\n## 8.6 类装饰器\n\n*类装饰器*就在类声明之前被声明。类装饰器被应用于类的构造函数，可以用来观察、修改或替换类定义。类装饰器不能在声明文件中使用，也不能在任何其他环境下使用（比如在 `declare` 类上）。\n\n类装饰器的表达式在运行时将作为一个函数被调用，被装饰的类的构造器是它唯一的参数。\n\n如果类装饰器返回一个值，它将用提供的构造函数替换类声明。\n\n> 注意：如果你选择返回一个新的构造函数，必须注意维护原始原型。在运行时应用装饰器的逻辑不会为你这样做。\n\n下面是一个应用于`BugReport`类的类装饰器（`@sealed`）的例子。\n\n```tsx\n@sealed\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n```\n\n我们可以用下面的函数声明来定义`@sealed`装饰器。\n\n```tsx\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n```\n\n当`@sealed`被执行时，它将同时封闭构造函数和它的原型，因此将阻止在运行时通过访问`BugReport.prototype`或通过定义`BugReport`本身的属性来向该类添加或删除任何进一步的功能（注意ES2015类实际上只是基于原型的构造函数的语法糖）。这个装饰器并不能阻止类对`BugReport`进行子类化。\n\n接下来我们有一个如何覆盖构造函数以设置新的默认值的例子：\n\n```tsx\nfunction reportableClassDecorator<T extends { new (...args: any[]): {} }>(\n  constructor: T,\n) {\n  return class extends constructor {\n    reportingURL = \"http://www...\";\n  };\n}\n\n@reportableClassDecorator\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n\nconst bug = new BugReport(\"Needs dark mode\");\nconsole.log(bug.title); // 打印 \"Needs dark mode\"\nconsole.log(bug.type); // 打印 \"report\"\n\n// 注意，装饰器不会改变TypeScript的类型\n// 因此，类型系统对新的属性`reportingURL`是不可知的。\nbug.reportingURL;\n```\n\n<img src=\"/img/TypeScript/11-08.png\" alt=\"image-20211224200305351\" style=\"zoom:50%;\" />\n\n## 8.7 方法装饰器\n\n方法装饰器就在方法声明之前被声明。该装饰器被应用于方法的属性描述符，可以用来观察、修改或替换方法定义。方法装饰器不能在声明文件中使用，不能在重载上使用，也不能在任何其他环境下使用（比如在 `declare`类中）。\n\n方法装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：\n\n1. 静态成员的类的构造函数，或者实例成员的类的原型。\n2. 成员的名称。\n3. 该成员的属性描述符。\n\n> 注意：如果你的脚本目标小于ES5，*属性描述符*将无法定义。\n\n如果方法装饰器返回一个值，它将被用作方法的*属性描述符*。\n\n> 注意：如果你的脚本目标小于ES5，返回值会被忽略。\n\n下面是一个方法装饰器（`@enumerable`）应用于`Greeter`类的一个方法的例子：\n\n```tsx\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n```\n\n我们可以用下面的函数声明来定义`@enumerable`装饰器：\n\n```tsx\nfunction enumerable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    descriptor.enumerable = value;\n  };\n}\n```\n\n这里的`@enumerable(false)`装饰器是一个 [装饰器工厂](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)。当`@enumerable(false)`装饰器被调用时，它修改了属性描述符的`enumerable`属性。\n\n## 8.8 访问器装饰器\n\n一个访问器装饰器就在访问器声明之前被声明。访问器装饰器被应用于访问器的属性描述符，可以用来观察、修改或替换访问器的定义。一个访问器装饰器不能在声明文件中使用，也不能在任何其他环境中使用（比如在`declare`类中）。\n\n> 注意：TypeScript不允许装饰单个成员的 `get`和`set`访问器。相反，该成员的所有装饰器必须应用于文件顺序中指定的第一个访问器。这是因为装饰器适用于一个*属性描述符*，它结合了获取和设置访问器，而不是每个声明单独。\n\n访问器装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：\n\n1. 静态成员的类的构造函数，或者实例成员的类的原型。\n2. 成员的名称。\n3. 该成员的属性描述符。\n\n> 注意：如果你的脚本目标小于ES5，*属性描述符*将无法定义。\n\n如果访问器装饰器返回一个值，它将被用作该成员的*属性描述符*。\n\n> 注意：如果你的脚本目标小于ES5，返回值会被忽略。\n\n下面是一个访问器装饰器（`@configurable`）的例子，它应用于`Point`类的一个成员。\n\n```tsx\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n\n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\n```\n\n我们可以用下面的函数声明来定义`@configurable`装饰器：\n\n```tsx\nfunction configurable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    descriptor.configurable = value;\n  };\n}\n```\n\n## 8.9 属性装饰器\n\n一个*属性装饰器*就在一个属性声明之前被声明。一个属性装饰器不能在声明文件中使用，也不能在任何其他环境下使用（比如在 `declare` 类中）。\n\n属性装饰器的表达式将在运行时作为一个函数被调用，有以下两个参数：\n\n1. 静态成员的类的构造函数，或者实例成员的类的原型。\n2. 成员的名称。\n\n> 注意：由于*属性装饰器*在TypeScript中的初始化方式，属性描述符不会作为参数提供给属性装饰器。这是因为目前没有机制在定义原型成员时描述一个实例属性，也没有办法观察或修改一个属性的初始化器。返回值也被忽略了。因此，一个属性装饰器只能用来观察一个类的特定名称的属性已经被声明。\n\n我们可以使用这些信息来记录关于该属性的元数据，如下面的例子：\n\n```tsx\nclass Greeter {\n  @format(\"Hello, %s\")\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    let formatString = getFormat(this, \"greeting\");\n    return formatString.replace(\"%s\", this.greeting);\n  }\n}\n```\n\n然后我们可以使用以下函数声明来定义`@format`装饰器和`getFormat`函数。\n\n```tsx\nimport \"reflect-metadata\";\nconst formatMetadataKey = Symbol(\"format\");\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\n这里的`@format(\"Hello, %s\") `装饰器是一个[装饰器工厂](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)。当`@format(\"Hello, %s\")`被调用时，它使用`reflect-metadata`库中的`Reflect.metadata`函数为该属性添加一个元数据条目。当`getFormat`被调用时，它读取该格式的元数据值。\n\n> 注意：这个例子需要`reflect-metadata`库。关于`reflect-metadata`库的更多信息，请参见[Metadata](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata)。\n\n## 8.10 参数装饰器\n\n*参数装饰器*就在参数声明之前被声明。参数装饰器被应用于类构造器或方法声明的函数。一个参数装饰器不能在声明文件、重载或任何其他环境中使用（比如在 `declare` 类中）。\n\n参数装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：\n\n1. 对于静态成员，可以是该类的构造函数，对于实例成员，可以是该类的原型。\n2. 该成员的名称。\n3. 参数在函数的参数列表中的序数索引。\n\n> 注意：一个参数装饰器只能用来观察一个方法上已经声明了一个参数。\n\n参数装饰器的返回值被忽略了。\n\n下面是一个参数装饰器（`@required`）应用于`BugReport`类的一个成员的参数的例子：\n\n```tsx\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n\n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    } else {\n      return this.title;\n    }\n  }\n}\n```\n\n然后我们可以使用以下函数声明来定义`@required`和`@validate`装饰器。\n\n```tsx\nimport \"reflect-metadata\";\nconst requiredMetadataKey = Symbol(\"required\");\n\nfunction required(\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex: number,\n) {\n  let existingRequiredParameters: number[] =\n    Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata(\n    requiredMetadataKey,\n    existingRequiredParameters,\n    target,\n    propertyKey,\n  );\n}\n\nfunction validate(\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<Function>,\n) {\n  let method = descriptor.value!;\n\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(\n      requiredMetadataKey,\n      target,\n      propertyName,\n    );\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (\n          parameterIndex >= arguments.length ||\n          arguments[parameterIndex] === undefined\n        ) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n```\n\n`@required`装饰器添加了一个元数据条目，将参数标记为必填。然后，`@validate`装饰器将现有的`greet`方法包装在一个函数中，在调用原始方法之前验证参数。\n\n> 注意：这个例子需要`reflect-metadata`库。关于`reflect-metadata`库的更多信息，请参见[Metadata](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata) 。\n\n## 8.11 Metadata\n\n一些例子使用了`reflect-metadata`库，它为一个[实验性的元数据API](https://github.com/rbuckton/ReflectDecorators). 添加了一个`polyfill`。这个库还不是ECMAScript（JavaScript）标准的一部分。然而，一旦装饰器被正式采纳为ECMAScript标准的一部分，这些扩展将被提议采纳。\n\n你可以通过npm来安装这个库：\n\n```shell\nnpm i reflect-metadata --save\n```\n\nTypeScript包括试验性的支持，为具有装饰器的声明排放某些类型的元数据。要启用这个实验性支持，你必须在命令行或在你的`tsconfig.json`中设置`emitDecoratorMetadata`编译器选项。\n\n- **Command Line**\n\n```shell\ntsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n```\n\n- **tsconfig.json**\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\n启用后，只要导入了`reflect-metadata`库，额外的设计时类型信息就会在运行时暴露。\n\n我们可以在下面的例子中看到这个作用：\n\n```tsx\nimport \"reflect-metadata\";\n\nclass Point {\n  constructor(\n    public x: number,\n    public y: number,\n  ) {}\n}\n\nclass Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  set start(value: Point) {\n    this._start = value;\n  }\n\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  set end(value: Point) {\n    this._end = value;\n  }\n\n  get end() {\n    return this._end;\n  }\n}\n\nfunction validate<T>(\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<T>,\n) {\n  let set = descriptor.set!;\n\n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n\n    if (!(value instanceof type)) {\n      throw new TypeError(\n        `Invalid type, got ${typeof value} not ${type.name}.`,\n      );\n    }\n\n    set.call(this, value);\n  };\n}\n\nconst line = new Line();\nline.start = new Point(0, 0);\n\n// @ts-ignore\n// line.end = {}\n\n// 运行时会失败:\n// > Invalid type, got object not Point\n```\n\nTypeScript编译器将使用`@Reflect.metadata`装饰器注入设计时类型信息。你可以认为它相当于下面的TypeScript：\n\n```tsx\nclass Line {\n  private _start: Point;\n  private _end: Point;\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set start(value: Point) {\n    this._start = value;\n  }\n  get start() {\n    return this._start;\n  }\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set end(value: Point) {\n    this._end = value;\n  }\n  get end() {\n    return this._end;\n  }\n}\n```\n\n> 注意：装饰器元数据是一个实验性的功能，在未来的版本中可能会引入破坏性的变化。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/2-8、高级篇：装饰器（Decorators）.md",
        "raw": "---\ntitle: 2-8、高级篇：装饰器（Decorators）\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 32666\ndate: 2024-01-28 21:08:50\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 八、装饰器（Decorators）\n\n## 8.1 简介\n\n随着TypeScript和ES6中类的引入，现在存在某些场景需要额外的功能，来支持注释或修改类和类成员。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的 [第二阶段](https://github.com/tc39/proposal-decorators)建议，并作为TypeScript的一个实验性功能提供。\n\n> 注意：装饰器是一个实验性的功能，在未来的版本中可能会改变。\n\n要启用对装饰器的实验性支持，你必须在命令行或在 `tsconfig.json` 中启用 `experimentalDecorators` 编译器选项。\n\n- **命令行**\n\n```tsx\ntsc --target ES5 --experimentalDecorators\n```\n\n- **tssconfig.json**\n\n```tsx\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n## 8.2 装饰器\n\n装饰器是一种特殊的声明，可以附加到类声明、方法、访问器、属性或参数上。装饰器使用 `@expression`的形式，其中`expression`必须评估为一个函数，该函数将在运行时被调用，并带有关于被装饰的声明的信息。\n\n例如，对于装饰器 `@sealed`，我们可以将 `sealed` 的函数写成如下:\n\n```tsx\nfunction sealed(target) {\n  // 对 \"target\"做一些事情 ...\n}\n```\n\n## 8.3 装饰器工厂\n\n如果我们想自定义装饰器如何应用于声明，我们可以写一个装饰器工厂。装饰器工厂是一个简单的函数，它返回将在运行时被装饰器调用的表达式。\n\n我们可以用以下方式写一个装饰器工厂：\n\n```tsx\nfunction color(value: string) {\n  // 这是装饰器工厂，它设置了\n  // 返回的装饰器函数\n  return function (target) {\n    // 这就是装饰器\n    // 用 \"target\" 和 \"value\"做一些事情...\n  };\n}\n```\n\n## 8.4 装饰器构成\n\n多个装饰器可以应用于一个声明，例如在一行中：\n\n```tsx\n@f @g x\n```\n\n多行的语法：\n\n```tsx\n@f\n@g\nx\n```\n\n当多个装饰器适用于一个声明时，它们的评估类似于数学中的 [函数组合](https://wikipedia.org/wiki/Function_composition)。在这种模式下，当组合函数 f 和 g 时，所产生的组合`(f∘g)(x)` 等同于 `f(g(x))`。\n\n因此，在TypeScript中对一个声明的多个装饰器进行评估时，会执行以下步骤：\n\n1. 每个装饰器的表达式都是自上而下地进行评估的。\n\n2. 然后将结果作为函数从下往上调用。\n\n如果我们使用[装饰器工厂](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)，可以通过下面的例子观察这个评估顺序：\n\n```tsx\nfunction first() {\n  console.log(\"first(): factory evaluated\");\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    console.log(\"first(): called\");\n  };\n}\n\nfunction second() {\n  console.log(\"second(): factory evaluated\");\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    console.log(\"second(): called\");\n  };\n}\n\nclass ExampleClass {\n  @first()\n  @second()\n  method() {}\n}\n```\n\n这将把这个输出打印到控制台：\n\n```sh\nfirst(): factory evaluated\nsecond(): factory evaluated\nsecond(): called\nfirst(): called\n```\n\n## 8.5 装饰器评估\n\n对于应用于类内各种声明的装饰器，有一个明确的顺序：\n\n1. 对于每个实例成员，首先是*参数装饰器*，然后是*方法*、*访问器*或*属性装饰器*。\n2. 对于每个静态成员，先是*参数装饰器*，然后是*方法*、*存取器*或*属性装饰器*。\n3. *参数装饰器被*应用于构造函数。\n4. *类装饰器*适用于类。\n\n## 8.6 类装饰器\n\n*类装饰器*就在类声明之前被声明。类装饰器被应用于类的构造函数，可以用来观察、修改或替换类定义。类装饰器不能在声明文件中使用，也不能在任何其他环境下使用（比如在 `declare` 类上）。\n\n类装饰器的表达式在运行时将作为一个函数被调用，被装饰的类的构造器是它唯一的参数。\n\n如果类装饰器返回一个值，它将用提供的构造函数替换类声明。\n\n> 注意：如果你选择返回一个新的构造函数，必须注意维护原始原型。在运行时应用装饰器的逻辑不会为你这样做。\n\n下面是一个应用于`BugReport`类的类装饰器（`@sealed`）的例子。\n\n```tsx\n@sealed\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n```\n\n我们可以用下面的函数声明来定义`@sealed`装饰器。\n\n```tsx\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n```\n\n当`@sealed`被执行时，它将同时封闭构造函数和它的原型，因此将阻止在运行时通过访问`BugReport.prototype`或通过定义`BugReport`本身的属性来向该类添加或删除任何进一步的功能（注意ES2015类实际上只是基于原型的构造函数的语法糖）。这个装饰器并不能阻止类对`BugReport`进行子类化。\n\n接下来我们有一个如何覆盖构造函数以设置新的默认值的例子：\n\n```tsx\nfunction reportableClassDecorator<T extends { new (...args: any[]): {} }>(\n  constructor: T,\n) {\n  return class extends constructor {\n    reportingURL = \"http://www...\";\n  };\n}\n\n@reportableClassDecorator\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n\nconst bug = new BugReport(\"Needs dark mode\");\nconsole.log(bug.title); // 打印 \"Needs dark mode\"\nconsole.log(bug.type); // 打印 \"report\"\n\n// 注意，装饰器不会改变TypeScript的类型\n// 因此，类型系统对新的属性`reportingURL`是不可知的。\nbug.reportingURL;\n```\n\n<img src=\"/img/TypeScript/11-08.png\" alt=\"image-20211224200305351\" style=\"zoom:50%;\" />\n\n## 8.7 方法装饰器\n\n方法装饰器就在方法声明之前被声明。该装饰器被应用于方法的属性描述符，可以用来观察、修改或替换方法定义。方法装饰器不能在声明文件中使用，不能在重载上使用，也不能在任何其他环境下使用（比如在 `declare`类中）。\n\n方法装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：\n\n1. 静态成员的类的构造函数，或者实例成员的类的原型。\n2. 成员的名称。\n3. 该成员的属性描述符。\n\n> 注意：如果你的脚本目标小于ES5，*属性描述符*将无法定义。\n\n如果方法装饰器返回一个值，它将被用作方法的*属性描述符*。\n\n> 注意：如果你的脚本目标小于ES5，返回值会被忽略。\n\n下面是一个方法装饰器（`@enumerable`）应用于`Greeter`类的一个方法的例子：\n\n```tsx\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n```\n\n我们可以用下面的函数声明来定义`@enumerable`装饰器：\n\n```tsx\nfunction enumerable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    descriptor.enumerable = value;\n  };\n}\n```\n\n这里的`@enumerable(false)`装饰器是一个 [装饰器工厂](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)。当`@enumerable(false)`装饰器被调用时，它修改了属性描述符的`enumerable`属性。\n\n## 8.8 访问器装饰器\n\n一个访问器装饰器就在访问器声明之前被声明。访问器装饰器被应用于访问器的属性描述符，可以用来观察、修改或替换访问器的定义。一个访问器装饰器不能在声明文件中使用，也不能在任何其他环境中使用（比如在`declare`类中）。\n\n> 注意：TypeScript不允许装饰单个成员的 `get`和`set`访问器。相反，该成员的所有装饰器必须应用于文件顺序中指定的第一个访问器。这是因为装饰器适用于一个*属性描述符*，它结合了获取和设置访问器，而不是每个声明单独。\n\n访问器装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：\n\n1. 静态成员的类的构造函数，或者实例成员的类的原型。\n2. 成员的名称。\n3. 该成员的属性描述符。\n\n> 注意：如果你的脚本目标小于ES5，*属性描述符*将无法定义。\n\n如果访问器装饰器返回一个值，它将被用作该成员的*属性描述符*。\n\n> 注意：如果你的脚本目标小于ES5，返回值会被忽略。\n\n下面是一个访问器装饰器（`@configurable`）的例子，它应用于`Point`类的一个成员。\n\n```tsx\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n\n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\n```\n\n我们可以用下面的函数声明来定义`@configurable`装饰器：\n\n```tsx\nfunction configurable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    descriptor.configurable = value;\n  };\n}\n```\n\n## 8.9 属性装饰器\n\n一个*属性装饰器*就在一个属性声明之前被声明。一个属性装饰器不能在声明文件中使用，也不能在任何其他环境下使用（比如在 `declare` 类中）。\n\n属性装饰器的表达式将在运行时作为一个函数被调用，有以下两个参数：\n\n1. 静态成员的类的构造函数，或者实例成员的类的原型。\n2. 成员的名称。\n\n> 注意：由于*属性装饰器*在TypeScript中的初始化方式，属性描述符不会作为参数提供给属性装饰器。这是因为目前没有机制在定义原型成员时描述一个实例属性，也没有办法观察或修改一个属性的初始化器。返回值也被忽略了。因此，一个属性装饰器只能用来观察一个类的特定名称的属性已经被声明。\n\n我们可以使用这些信息来记录关于该属性的元数据，如下面的例子：\n\n```tsx\nclass Greeter {\n  @format(\"Hello, %s\")\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    let formatString = getFormat(this, \"greeting\");\n    return formatString.replace(\"%s\", this.greeting);\n  }\n}\n```\n\n然后我们可以使用以下函数声明来定义`@format`装饰器和`getFormat`函数。\n\n```tsx\nimport \"reflect-metadata\";\nconst formatMetadataKey = Symbol(\"format\");\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\n这里的`@format(\"Hello, %s\") `装饰器是一个[装饰器工厂](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories)。当`@format(\"Hello, %s\")`被调用时，它使用`reflect-metadata`库中的`Reflect.metadata`函数为该属性添加一个元数据条目。当`getFormat`被调用时，它读取该格式的元数据值。\n\n> 注意：这个例子需要`reflect-metadata`库。关于`reflect-metadata`库的更多信息，请参见[Metadata](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata)。\n\n## 8.10 参数装饰器\n\n*参数装饰器*就在参数声明之前被声明。参数装饰器被应用于类构造器或方法声明的函数。一个参数装饰器不能在声明文件、重载或任何其他环境中使用（比如在 `declare` 类中）。\n\n参数装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：\n\n1. 对于静态成员，可以是该类的构造函数，对于实例成员，可以是该类的原型。\n2. 该成员的名称。\n3. 参数在函数的参数列表中的序数索引。\n\n> 注意：一个参数装饰器只能用来观察一个方法上已经声明了一个参数。\n\n参数装饰器的返回值被忽略了。\n\n下面是一个参数装饰器（`@required`）应用于`BugReport`类的一个成员的参数的例子：\n\n```tsx\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n\n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    } else {\n      return this.title;\n    }\n  }\n}\n```\n\n然后我们可以使用以下函数声明来定义`@required`和`@validate`装饰器。\n\n```tsx\nimport \"reflect-metadata\";\nconst requiredMetadataKey = Symbol(\"required\");\n\nfunction required(\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex: number,\n) {\n  let existingRequiredParameters: number[] =\n    Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata(\n    requiredMetadataKey,\n    existingRequiredParameters,\n    target,\n    propertyKey,\n  );\n}\n\nfunction validate(\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<Function>,\n) {\n  let method = descriptor.value!;\n\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(\n      requiredMetadataKey,\n      target,\n      propertyName,\n    );\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (\n          parameterIndex >= arguments.length ||\n          arguments[parameterIndex] === undefined\n        ) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n```\n\n`@required`装饰器添加了一个元数据条目，将参数标记为必填。然后，`@validate`装饰器将现有的`greet`方法包装在一个函数中，在调用原始方法之前验证参数。\n\n> 注意：这个例子需要`reflect-metadata`库。关于`reflect-metadata`库的更多信息，请参见[Metadata](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata) 。\n\n## 8.11 Metadata\n\n一些例子使用了`reflect-metadata`库，它为一个[实验性的元数据API](https://github.com/rbuckton/ReflectDecorators). 添加了一个`polyfill`。这个库还不是ECMAScript（JavaScript）标准的一部分。然而，一旦装饰器被正式采纳为ECMAScript标准的一部分，这些扩展将被提议采纳。\n\n你可以通过npm来安装这个库：\n\n```shell\nnpm i reflect-metadata --save\n```\n\nTypeScript包括试验性的支持，为具有装饰器的声明排放某些类型的元数据。要启用这个实验性支持，你必须在命令行或在你的`tsconfig.json`中设置`emitDecoratorMetadata`编译器选项。\n\n- **Command Line**\n\n```shell\ntsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n```\n\n- **tsconfig.json**\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\n启用后，只要导入了`reflect-metadata`库，额外的设计时类型信息就会在运行时暴露。\n\n我们可以在下面的例子中看到这个作用：\n\n```tsx\nimport \"reflect-metadata\";\n\nclass Point {\n  constructor(\n    public x: number,\n    public y: number,\n  ) {}\n}\n\nclass Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  set start(value: Point) {\n    this._start = value;\n  }\n\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  set end(value: Point) {\n    this._end = value;\n  }\n\n  get end() {\n    return this._end;\n  }\n}\n\nfunction validate<T>(\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor<T>,\n) {\n  let set = descriptor.set!;\n\n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n\n    if (!(value instanceof type)) {\n      throw new TypeError(\n        `Invalid type, got ${typeof value} not ${type.name}.`,\n      );\n    }\n\n    set.call(this, value);\n  };\n}\n\nconst line = new Line();\nline.start = new Point(0, 0);\n\n// @ts-ignore\n// line.end = {}\n\n// 运行时会失败:\n// > Invalid type, got object not Point\n```\n\nTypeScript编译器将使用`@Reflect.metadata`装饰器注入设计时类型信息。你可以认为它相当于下面的TypeScript：\n\n```tsx\nclass Line {\n  private _start: Point;\n  private _end: Point;\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set start(value: Point) {\n    this._start = value;\n  }\n  get start() {\n    return this._start;\n  }\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set end(value: Point) {\n    this._end = value;\n  }\n  get end() {\n    return this._end;\n  }\n}\n```\n\n> 注意：装饰器元数据是一个实验性的功能，在未来的版本中可能会引入破坏性的变化。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/2-8、高级篇：装饰器（Decorators）",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjaoa001y94v35arw9as9",
        "content": "<h1 id=\"八、装饰器（Decorators）\"><a href=\"#八、装饰器（Decorators）\" class=\"headerlink\" title=\"八、装饰器（Decorators）\"></a>八、装饰器（Decorators）</h1><h2 id=\"8-1-简介\"><a href=\"#8-1-简介\" class=\"headerlink\" title=\"8.1 简介\"></a>8.1 简介</h2><p>随着TypeScript和ES6中类的引入，现在存在某些场景需要额外的功能，来支持注释或修改类和类成员。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的 <a href=\"https://github.com/tc39/proposal-decorators\">第二阶段</a>建议，并作为TypeScript的一个实验性功能提供。</p>\n<blockquote>\n<p>注意：装饰器是一个实验性的功能，在未来的版本中可能会改变。</p>\n</blockquote>\n<p>要启用对装饰器的实验性支持，你必须在命令行或在 <code>tsconfig.json</code> 中启用 <code>experimentalDecorators</code> 编译器选项。</p>\n<ul>\n<li><strong>命令行</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --target <span class=\"title class_\">ES5</span> --experimentalDecorators</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>tssconfig.json</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;target&quot;</span>: <span class=\"string\">&quot;ES5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;experimentalDecorators&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-2-装饰器\"><a href=\"#8-2-装饰器\" class=\"headerlink\" title=\"8.2 装饰器\"></a>8.2 装饰器</h2><p>装饰器是一种特殊的声明，可以附加到类声明、方法、访问器、属性或参数上。装饰器使用 <code>@expression</code>的形式，其中<code>expression</code>必须评估为一个函数，该函数将在运行时被调用，并带有关于被装饰的声明的信息。</p>\n<p>例如，对于装饰器 <code>@sealed</code>，我们可以将 <code>sealed</code> 的函数写成如下:</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sealed</span>(<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对 &quot;target&quot;做一些事情 ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-3-装饰器工厂\"><a href=\"#8-3-装饰器工厂\" class=\"headerlink\" title=\"8.3 装饰器工厂\"></a>8.3 装饰器工厂</h2><p>如果我们想自定义装饰器如何应用于声明，我们可以写一个装饰器工厂。装饰器工厂是一个简单的函数，它返回将在运行时被装饰器调用的表达式。</p>\n<p>我们可以用以下方式写一个装饰器工厂：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">color</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这是装饰器工厂，它设置了</span></span><br><span class=\"line\">  <span class=\"comment\">// 返回的装饰器函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这就是装饰器</span></span><br><span class=\"line\">    <span class=\"comment\">// 用 &quot;target&quot; 和 &quot;value&quot;做一些事情...</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-4-装饰器构成\"><a href=\"#8-4-装饰器构成\" class=\"headerlink\" title=\"8.4 装饰器构成\"></a>8.4 装饰器构成</h2><p>多个装饰器可以应用于一个声明，例如在一行中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@f</span> <span class=\"meta\">@g</span> x</span><br></pre></td></tr></table></figure>\n\n<p>多行的语法：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@f</span></span><br><span class=\"line\"><span class=\"meta\">@g</span></span><br><span class=\"line\">x</span><br></pre></td></tr></table></figure>\n\n<p>当多个装饰器适用于一个声明时，它们的评估类似于数学中的 <a href=\"https://wikipedia.org/wiki/Function_composition\">函数组合</a>。在这种模式下，当组合函数 f 和 g 时，所产生的组合<code>(f∘g)(x)</code> 等同于 <code>f(g(x))</code>。</p>\n<p>因此，在TypeScript中对一个声明的多个装饰器进行评估时，会执行以下步骤：</p>\n<ol>\n<li><p>每个装饰器的表达式都是自上而下地进行评估的。</p>\n</li>\n<li><p>然后将结果作为函数从下往上调用。</p>\n</li>\n</ol>\n<p>如果我们使用<a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories\">装饰器工厂</a>，可以通过下面的例子观察这个评估顺序：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">first</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;first(): factory evaluated&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">descriptor</span>: <span class=\"title class_\">PropertyDescriptor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;first(): called&quot;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">second</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;second(): factory evaluated&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">descriptor</span>: <span class=\"title class_\">PropertyDescriptor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;second(): called&quot;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleClass</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@first</span>()</span><br><span class=\"line\">  <span class=\"meta\">@second</span>()</span><br><span class=\"line\">  <span class=\"title function_\">method</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这将把这个输出打印到控制台：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">first(): factory evaluated</span><br><span class=\"line\">second(): factory evaluated</span><br><span class=\"line\">second(): called</span><br><span class=\"line\">first(): called</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-5-装饰器评估\"><a href=\"#8-5-装饰器评估\" class=\"headerlink\" title=\"8.5 装饰器评估\"></a>8.5 装饰器评估</h2><p>对于应用于类内各种声明的装饰器，有一个明确的顺序：</p>\n<ol>\n<li>对于每个实例成员，首先是<em>参数装饰器</em>，然后是<em>方法</em>、<em>访问器</em>或<em>属性装饰器</em>。</li>\n<li>对于每个静态成员，先是<em>参数装饰器</em>，然后是<em>方法</em>、<em>存取器</em>或<em>属性装饰器</em>。</li>\n<li><em>参数装饰器被</em>应用于构造函数。</li>\n<li><em>类装饰器</em>适用于类。</li>\n</ol>\n<h2 id=\"8-6-类装饰器\"><a href=\"#8-6-类装饰器\" class=\"headerlink\" title=\"8.6 类装饰器\"></a>8.6 类装饰器</h2><p><em>类装饰器</em>就在类声明之前被声明。类装饰器被应用于类的构造函数，可以用来观察、修改或替换类定义。类装饰器不能在声明文件中使用，也不能在任何其他环境下使用（比如在 <code>declare</code> 类上）。</p>\n<p>类装饰器的表达式在运行时将作为一个函数被调用，被装饰的类的构造器是它唯一的参数。</p>\n<p>如果类装饰器返回一个值，它将用提供的构造函数替换类声明。</p>\n<blockquote>\n<p>注意：如果你选择返回一个新的构造函数，必须注意维护原始原型。在运行时应用装饰器的逻辑不会为你这样做。</p>\n</blockquote>\n<p>下面是一个应用于<code>BugReport</code>类的类装饰器（<code>@sealed</code>）的例子。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@sealed</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BugReport</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span> = <span class=\"string\">&quot;report&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">t</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用下面的函数声明来定义<code>@sealed</code>装饰器。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sealed</span>(<span class=\"params\"><span class=\"attr\">constructor</span>: <span class=\"title class_\">Function</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">seal</span>(constructor);</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">seal</span>(constructor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>@sealed</code>被执行时，它将同时封闭构造函数和它的原型，因此将阻止在运行时通过访问<code>BugReport.prototype</code>或通过定义<code>BugReport</code>本身的属性来向该类添加或删除任何进一步的功能（注意ES2015类实际上只是基于原型的构造函数的语法糖）。这个装饰器并不能阻止类对<code>BugReport</code>进行子类化。</p>\n<p>接下来我们有一个如何覆盖构造函数以设置新的默认值的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> reportableClassDecorator&lt;T <span class=\"keyword\">extends</span> &#123; <span class=\"title function_\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]): &#123;&#125; &#125;&gt;(</span><br><span class=\"line\">  <span class=\"attr\">constructor</span>: T,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> constructor &#123;</span><br><span class=\"line\">    reportingURL = <span class=\"string\">&quot;http://www...&quot;</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@reportableClassDecorator</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BugReport</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span> = <span class=\"string\">&quot;report&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">t</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> bug = <span class=\"keyword\">new</span> <span class=\"title class_\">BugReport</span>(<span class=\"string\">&quot;Needs dark mode&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bug.<span class=\"property\">title</span>); <span class=\"comment\">// 打印 &quot;Needs dark mode&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bug.<span class=\"property\">type</span>); <span class=\"comment\">// 打印 &quot;report&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，装饰器不会改变TypeScript的类型</span></span><br><span class=\"line\"><span class=\"comment\">// 因此，类型系统对新的属性`reportingURL`是不可知的。</span></span><br><span class=\"line\">bug.<span class=\"property\">reportingURL</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-08.png\" alt=\"image-20211224200305351\" style=\"zoom:50%;\" />\n\n<h2 id=\"8-7-方法装饰器\"><a href=\"#8-7-方法装饰器\" class=\"headerlink\" title=\"8.7 方法装饰器\"></a>8.7 方法装饰器</h2><p>方法装饰器就在方法声明之前被声明。该装饰器被应用于方法的属性描述符，可以用来观察、修改或替换方法定义。方法装饰器不能在声明文件中使用，不能在重载上使用，也不能在任何其他环境下使用（比如在 <code>declare</code>类中）。</p>\n<p>方法装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：</p>\n<ol>\n<li>静态成员的类的构造函数，或者实例成员的类的原型。</li>\n<li>成员的名称。</li>\n<li>该成员的属性描述符。</li>\n</ol>\n<blockquote>\n<p>注意：如果你的脚本目标小于ES5，<em>属性描述符</em>将无法定义。</p>\n</blockquote>\n<p>如果方法装饰器返回一个值，它将被用作方法的<em>属性描述符</em>。</p>\n<blockquote>\n<p>注意：如果你的脚本目标小于ES5，返回值会被忽略。</p>\n</blockquote>\n<p>下面是一个方法装饰器（<code>@enumerable</code>）应用于<code>Greeter</code>类的一个方法的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">message</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span> = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@enumerable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用下面的函数声明来定义<code>@enumerable</code>装饰器：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">enumerable</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">descriptor</span>: <span class=\"title class_\">PropertyDescriptor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    descriptor.<span class=\"property\">enumerable</span> = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>@enumerable(false)</code>装饰器是一个 <a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories\">装饰器工厂</a>。当<code>@enumerable(false)</code>装饰器被调用时，它修改了属性描述符的<code>enumerable</code>属性。</p>\n<h2 id=\"8-8-访问器装饰器\"><a href=\"#8-8-访问器装饰器\" class=\"headerlink\" title=\"8.8 访问器装饰器\"></a>8.8 访问器装饰器</h2><p>一个访问器装饰器就在访问器声明之前被声明。访问器装饰器被应用于访问器的属性描述符，可以用来观察、修改或替换访问器的定义。一个访问器装饰器不能在声明文件中使用，也不能在任何其他环境中使用（比如在<code>declare</code>类中）。</p>\n<blockquote>\n<p>注意：TypeScript不允许装饰单个成员的 <code>get</code>和<code>set</code>访问器。相反，该成员的所有装饰器必须应用于文件顺序中指定的第一个访问器。这是因为装饰器适用于一个<em>属性描述符</em>，它结合了获取和设置访问器，而不是每个声明单独。</p>\n</blockquote>\n<p>访问器装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：</p>\n<ol>\n<li>静态成员的类的构造函数，或者实例成员的类的原型。</li>\n<li>成员的名称。</li>\n<li>该成员的属性描述符。</li>\n</ol>\n<blockquote>\n<p>注意：如果你的脚本目标小于ES5，<em>属性描述符</em>将无法定义。</p>\n</blockquote>\n<p>如果访问器装饰器返回一个值，它将被用作该成员的<em>属性描述符</em>。</p>\n<blockquote>\n<p>注意：如果你的脚本目标小于ES5，返回值会被忽略。</p>\n</blockquote>\n<p>下面是一个访问器装饰器（<code>@configurable</code>）的例子，它应用于<code>Point</code>类的一个成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_x</span> = x;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_y</span> = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@configurable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">x</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_x</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@configurable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">y</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_y</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用下面的函数声明来定义<code>@configurable</code>装饰器：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">configurable</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">descriptor</span>: <span class=\"title class_\">PropertyDescriptor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    descriptor.<span class=\"property\">configurable</span> = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-9-属性装饰器\"><a href=\"#8-9-属性装饰器\" class=\"headerlink\" title=\"8.9 属性装饰器\"></a>8.9 属性装饰器</h2><p>一个<em>属性装饰器</em>就在一个属性声明之前被声明。一个属性装饰器不能在声明文件中使用，也不能在任何其他环境下使用（比如在 <code>declare</code> 类中）。</p>\n<p>属性装饰器的表达式将在运行时作为一个函数被调用，有以下两个参数：</p>\n<ol>\n<li>静态成员的类的构造函数，或者实例成员的类的原型。</li>\n<li>成员的名称。</li>\n</ol>\n<blockquote>\n<p>注意：由于<em>属性装饰器</em>在TypeScript中的初始化方式，属性描述符不会作为参数提供给属性装饰器。这是因为目前没有机制在定义原型成员时描述一个实例属性，也没有办法观察或修改一个属性的初始化器。返回值也被忽略了。因此，一个属性装饰器只能用来观察一个类的特定名称的属性已经被声明。</p>\n</blockquote>\n<p>我们可以使用这些信息来记录关于该属性的元数据，如下面的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@format</span>(<span class=\"string\">&quot;Hello, %s&quot;</span>)</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">message</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span> = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> formatString = <span class=\"title function_\">getFormat</span>(<span class=\"variable language_\">this</span>, <span class=\"string\">&quot;greeting&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> formatString.<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;%s&quot;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们可以使用以下函数声明来定义<code>@format</code>装饰器和<code>getFormat</code>函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> formatMetadataKey = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;format&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">format</span>(<span class=\"params\"><span class=\"attr\">formatString</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">metadata</span>(formatMetadataKey, formatString);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFormat</span>(<span class=\"params\"><span class=\"attr\">target</span>: <span class=\"built_in\">any</span>, <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getMetadata</span>(formatMetadataKey, target, propertyKey);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>@format(&quot;Hello, %s&quot;) </code>装饰器是一个<a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories\">装饰器工厂</a>。当<code>@format(&quot;Hello, %s&quot;)</code>被调用时，它使用<code>reflect-metadata</code>库中的<code>Reflect.metadata</code>函数为该属性添加一个元数据条目。当<code>getFormat</code>被调用时，它读取该格式的元数据值。</p>\n<blockquote>\n<p>注意：这个例子需要<code>reflect-metadata</code>库。关于<code>reflect-metadata</code>库的更多信息，请参见<a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\">Metadata</a>。</p>\n</blockquote>\n<h2 id=\"8-10-参数装饰器\"><a href=\"#8-10-参数装饰器\" class=\"headerlink\" title=\"8.10 参数装饰器\"></a>8.10 参数装饰器</h2><p><em>参数装饰器</em>就在参数声明之前被声明。参数装饰器被应用于类构造器或方法声明的函数。一个参数装饰器不能在声明文件、重载或任何其他环境中使用（比如在 <code>declare</code> 类中）。</p>\n<p>参数装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：</p>\n<ol>\n<li>对于静态成员，可以是该类的构造函数，对于实例成员，可以是该类的原型。</li>\n<li>该成员的名称。</li>\n<li>参数在函数的参数列表中的序数索引。</li>\n</ol>\n<blockquote>\n<p>注意：一个参数装饰器只能用来观察一个方法上已经声明了一个参数。</p>\n</blockquote>\n<p>参数装饰器的返回值被忽略了。</p>\n<p>下面是一个参数装饰器（<code>@required</code>）应用于<code>BugReport</code>类的一个成员的参数的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BugReport</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span> = <span class=\"string\">&quot;report&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">t</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"title function_\">print</span>(<span class=\"params\"><span class=\"meta\">@required</span> <span class=\"attr\">verbose</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (verbose) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">`type: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.<span class=\"keyword\">type</span>&#125;</span>\\ntitle: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.title&#125;</span>`</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">title</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们可以使用以下函数声明来定义<code>@required</code>和<code>@validate</code>装饰器。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> requiredMetadataKey = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;required&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">required</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">target</span>: <span class=\"title class_\">Object</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">symbol</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">parameterIndex</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">existingRequiredParameters</span>: <span class=\"built_in\">number</span>[] =</span><br><span class=\"line\">    <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getOwnMetadata</span>(requiredMetadataKey, target, propertyKey) || [];</span><br><span class=\"line\">  existingRequiredParameters.<span class=\"title function_\">push</span>(parameterIndex);</span><br><span class=\"line\">  <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">defineMetadata</span>(</span><br><span class=\"line\">    requiredMetadataKey,</span><br><span class=\"line\">    existingRequiredParameters,</span><br><span class=\"line\">    target,</span><br><span class=\"line\">    propertyKey,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">validate</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">propertyName</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">descriptor</span>: <span class=\"title class_\">TypedPropertyDescriptor</span>&lt;<span class=\"title class_\">Function</span>&gt;,</span></span><br><span class=\"line\"><span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> method = descriptor.<span class=\"property\">value</span>!;</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.<span class=\"property\">value</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">requiredParameters</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getOwnMetadata</span>(</span><br><span class=\"line\">      requiredMetadataKey,</span><br><span class=\"line\">      target,</span><br><span class=\"line\">      propertyName,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requiredParameters) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> parameterIndex <span class=\"keyword\">of</span> requiredParameters) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">          parameterIndex &gt;= <span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span> ||</span><br><span class=\"line\">          <span class=\"variable language_\">arguments</span>[parameterIndex] === <span class=\"literal\">undefined</span></span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;Missing required argument.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> method.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@required</code>装饰器添加了一个元数据条目，将参数标记为必填。然后，<code>@validate</code>装饰器将现有的<code>greet</code>方法包装在一个函数中，在调用原始方法之前验证参数。</p>\n<blockquote>\n<p>注意：这个例子需要<code>reflect-metadata</code>库。关于<code>reflect-metadata</code>库的更多信息，请参见<a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\">Metadata</a> 。</p>\n</blockquote>\n<h2 id=\"8-11-Metadata\"><a href=\"#8-11-Metadata\" class=\"headerlink\" title=\"8.11 Metadata\"></a>8.11 Metadata</h2><p>一些例子使用了<code>reflect-metadata</code>库，它为一个<a href=\"https://github.com/rbuckton/ReflectDecorators\">实验性的元数据API</a>. 添加了一个<code>polyfill</code>。这个库还不是ECMAScript（JavaScript）标准的一部分。然而，一旦装饰器被正式采纳为ECMAScript标准的一部分，这些扩展将被提议采纳。</p>\n<p>你可以通过npm来安装这个库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript包括试验性的支持，为具有装饰器的声明排放某些类型的元数据。要启用这个实验性支持，你必须在命令行或在你的<code>tsconfig.json</code>中设置<code>emitDecoratorMetadata</code>编译器选项。</p>\n<ul>\n<li><strong>Command Line</strong></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>tsconfig.json</strong></li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ES5&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;experimentalDecorators&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;emitDecoratorMetadata&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>启用后，只要导入了<code>reflect-metadata</code>库，额外的设计时类型信息就会在运行时暴露。</p>\n<p>我们可以在下面的例子中看到这个作用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Line</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_start</span>: <span class=\"title class_\">Point</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_end</span>: <span class=\"title class_\">Point</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">start</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_start</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">start</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_start</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">end</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_end</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">end</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_end</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> validate&lt;T&gt;(</span><br><span class=\"line\">  <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span><br><span class=\"line\">  <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">descriptor</span>: <span class=\"title class_\">TypedPropertyDescriptor</span>&lt;T&gt;,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> set = descriptor.<span class=\"property\">set</span>!;</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.<span class=\"property\">set</span> = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"attr\">value</span>: T</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">type</span> = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getMetadata</span>(<span class=\"string\">&quot;design:type&quot;</span>, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(value <span class=\"keyword\">instanceof</span> <span class=\"keyword\">type</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(</span><br><span class=\"line\">        <span class=\"string\">`Invalid type, got <span class=\"subst\">$&#123;<span class=\"keyword\">typeof</span> value&#125;</span> not <span class=\"subst\">$&#123;<span class=\"keyword\">type</span>.name&#125;</span>.`</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    set.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, value);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> line = <span class=\"keyword\">new</span> <span class=\"title class_\">Line</span>();</span><br><span class=\"line\">line.<span class=\"property\">start</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @ts-ignore</span></span><br><span class=\"line\"><span class=\"comment\">// line.end = &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时会失败:</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; Invalid type, got object not Point</span></span><br></pre></td></tr></table></figure>\n\n<p>TypeScript编译器将使用<code>@Reflect.metadata</code>装饰器注入设计时类型信息。你可以认为它相当于下面的TypeScript：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Line</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_start</span>: <span class=\"title class_\">Point</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_end</span>: <span class=\"title class_\">Point</span>;</span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.<span class=\"title function_\">metadata</span>(<span class=\"string\">&quot;design:type&quot;</span>, <span class=\"title class_\">Point</span>)</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">start</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_start</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">start</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_start</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.<span class=\"title function_\">metadata</span>(<span class=\"string\">&quot;design:type&quot;</span>, <span class=\"title class_\">Point</span>)</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">end</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_end</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">end</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_end</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：装饰器元数据是一个实验性的功能，在未来的版本中可能会引入破坏性的变化。</p>\n</blockquote>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"八、装饰器（Decorators）\"><a href=\"#八、装饰器（Decorators）\" class=\"headerlink\" title=\"八、装饰器（Decorators）\"></a>八、装饰器（Decorators）</h1><h2 id=\"8-1-简介\"><a href=\"#8-1-简介\" class=\"headerlink\" title=\"8.1 简介\"></a>8.1 简介</h2><p>随着TypeScript和ES6中类的引入，现在存在某些场景需要额外的功能，来支持注释或修改类和类成员。装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是JavaScript的 <a href=\"https://github.com/tc39/proposal-decorators\">第二阶段</a>建议，并作为TypeScript的一个实验性功能提供。</p>\n<blockquote>\n<p>注意：装饰器是一个实验性的功能，在未来的版本中可能会改变。</p>\n</blockquote>\n<p>要启用对装饰器的实验性支持，你必须在命令行或在 <code>tsconfig.json</code> 中启用 <code>experimentalDecorators</code> 编译器选项。</p>\n<ul>\n<li><strong>命令行</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --target <span class=\"title class_\">ES5</span> --experimentalDecorators</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>tssconfig.json</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;target&quot;</span>: <span class=\"string\">&quot;ES5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;experimentalDecorators&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-2-装饰器\"><a href=\"#8-2-装饰器\" class=\"headerlink\" title=\"8.2 装饰器\"></a>8.2 装饰器</h2><p>装饰器是一种特殊的声明，可以附加到类声明、方法、访问器、属性或参数上。装饰器使用 <code>@expression</code>的形式，其中<code>expression</code>必须评估为一个函数，该函数将在运行时被调用，并带有关于被装饰的声明的信息。</p>\n<p>例如，对于装饰器 <code>@sealed</code>，我们可以将 <code>sealed</code> 的函数写成如下:</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sealed</span>(<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对 &quot;target&quot;做一些事情 ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-3-装饰器工厂\"><a href=\"#8-3-装饰器工厂\" class=\"headerlink\" title=\"8.3 装饰器工厂\"></a>8.3 装饰器工厂</h2><p>如果我们想自定义装饰器如何应用于声明，我们可以写一个装饰器工厂。装饰器工厂是一个简单的函数，它返回将在运行时被装饰器调用的表达式。</p>\n<p>我们可以用以下方式写一个装饰器工厂：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">color</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这是装饰器工厂，它设置了</span></span><br><span class=\"line\">  <span class=\"comment\">// 返回的装饰器函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">target</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这就是装饰器</span></span><br><span class=\"line\">    <span class=\"comment\">// 用 &quot;target&quot; 和 &quot;value&quot;做一些事情...</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-4-装饰器构成\"><a href=\"#8-4-装饰器构成\" class=\"headerlink\" title=\"8.4 装饰器构成\"></a>8.4 装饰器构成</h2><p>多个装饰器可以应用于一个声明，例如在一行中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@f</span> <span class=\"meta\">@g</span> x</span><br></pre></td></tr></table></figure>\n\n<p>多行的语法：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@f</span></span><br><span class=\"line\"><span class=\"meta\">@g</span></span><br><span class=\"line\">x</span><br></pre></td></tr></table></figure>\n\n<p>当多个装饰器适用于一个声明时，它们的评估类似于数学中的 <a href=\"https://wikipedia.org/wiki/Function_composition\">函数组合</a>。在这种模式下，当组合函数 f 和 g 时，所产生的组合<code>(f∘g)(x)</code> 等同于 <code>f(g(x))</code>。</p>\n<p>因此，在TypeScript中对一个声明的多个装饰器进行评估时，会执行以下步骤：</p>\n<ol>\n<li><p>每个装饰器的表达式都是自上而下地进行评估的。</p>\n</li>\n<li><p>然后将结果作为函数从下往上调用。</p>\n</li>\n</ol>\n<p>如果我们使用<a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories\">装饰器工厂</a>，可以通过下面的例子观察这个评估顺序：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">first</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;first(): factory evaluated&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">descriptor</span>: <span class=\"title class_\">PropertyDescriptor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;first(): called&quot;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">second</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;second(): factory evaluated&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">descriptor</span>: <span class=\"title class_\">PropertyDescriptor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;second(): called&quot;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleClass</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@first</span>()</span><br><span class=\"line\">  <span class=\"meta\">@second</span>()</span><br><span class=\"line\">  <span class=\"title function_\">method</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这将把这个输出打印到控制台：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">first(): factory evaluated</span><br><span class=\"line\">second(): factory evaluated</span><br><span class=\"line\">second(): called</span><br><span class=\"line\">first(): called</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-5-装饰器评估\"><a href=\"#8-5-装饰器评估\" class=\"headerlink\" title=\"8.5 装饰器评估\"></a>8.5 装饰器评估</h2><p>对于应用于类内各种声明的装饰器，有一个明确的顺序：</p>\n<ol>\n<li>对于每个实例成员，首先是<em>参数装饰器</em>，然后是<em>方法</em>、<em>访问器</em>或<em>属性装饰器</em>。</li>\n<li>对于每个静态成员，先是<em>参数装饰器</em>，然后是<em>方法</em>、<em>存取器</em>或<em>属性装饰器</em>。</li>\n<li><em>参数装饰器被</em>应用于构造函数。</li>\n<li><em>类装饰器</em>适用于类。</li>\n</ol>\n<h2 id=\"8-6-类装饰器\"><a href=\"#8-6-类装饰器\" class=\"headerlink\" title=\"8.6 类装饰器\"></a>8.6 类装饰器</h2><p><em>类装饰器</em>就在类声明之前被声明。类装饰器被应用于类的构造函数，可以用来观察、修改或替换类定义。类装饰器不能在声明文件中使用，也不能在任何其他环境下使用（比如在 <code>declare</code> 类上）。</p>\n<p>类装饰器的表达式在运行时将作为一个函数被调用，被装饰的类的构造器是它唯一的参数。</p>\n<p>如果类装饰器返回一个值，它将用提供的构造函数替换类声明。</p>\n<blockquote>\n<p>注意：如果你选择返回一个新的构造函数，必须注意维护原始原型。在运行时应用装饰器的逻辑不会为你这样做。</p>\n</blockquote>\n<p>下面是一个应用于<code>BugReport</code>类的类装饰器（<code>@sealed</code>）的例子。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@sealed</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BugReport</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span> = <span class=\"string\">&quot;report&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">t</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用下面的函数声明来定义<code>@sealed</code>装饰器。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sealed</span>(<span class=\"params\"><span class=\"attr\">constructor</span>: <span class=\"title class_\">Function</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">seal</span>(constructor);</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">seal</span>(constructor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>@sealed</code>被执行时，它将同时封闭构造函数和它的原型，因此将阻止在运行时通过访问<code>BugReport.prototype</code>或通过定义<code>BugReport</code>本身的属性来向该类添加或删除任何进一步的功能（注意ES2015类实际上只是基于原型的构造函数的语法糖）。这个装饰器并不能阻止类对<code>BugReport</code>进行子类化。</p>\n<p>接下来我们有一个如何覆盖构造函数以设置新的默认值的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> reportableClassDecorator&lt;T <span class=\"keyword\">extends</span> &#123; <span class=\"title function_\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]): &#123;&#125; &#125;&gt;(</span><br><span class=\"line\">  <span class=\"attr\">constructor</span>: T,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> constructor &#123;</span><br><span class=\"line\">    reportingURL = <span class=\"string\">&quot;http://www...&quot;</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@reportableClassDecorator</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BugReport</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span> = <span class=\"string\">&quot;report&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">t</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> bug = <span class=\"keyword\">new</span> <span class=\"title class_\">BugReport</span>(<span class=\"string\">&quot;Needs dark mode&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bug.<span class=\"property\">title</span>); <span class=\"comment\">// 打印 &quot;Needs dark mode&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bug.<span class=\"property\">type</span>); <span class=\"comment\">// 打印 &quot;report&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意，装饰器不会改变TypeScript的类型</span></span><br><span class=\"line\"><span class=\"comment\">// 因此，类型系统对新的属性`reportingURL`是不可知的。</span></span><br><span class=\"line\">bug.<span class=\"property\">reportingURL</span>;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/img/TypeScript/11-08.png\" alt=\"image-20211224200305351\" style=\"zoom:50%;\" />\n\n<h2 id=\"8-7-方法装饰器\"><a href=\"#8-7-方法装饰器\" class=\"headerlink\" title=\"8.7 方法装饰器\"></a>8.7 方法装饰器</h2><p>方法装饰器就在方法声明之前被声明。该装饰器被应用于方法的属性描述符，可以用来观察、修改或替换方法定义。方法装饰器不能在声明文件中使用，不能在重载上使用，也不能在任何其他环境下使用（比如在 <code>declare</code>类中）。</p>\n<p>方法装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：</p>\n<ol>\n<li>静态成员的类的构造函数，或者实例成员的类的原型。</li>\n<li>成员的名称。</li>\n<li>该成员的属性描述符。</li>\n</ol>\n<blockquote>\n<p>注意：如果你的脚本目标小于ES5，<em>属性描述符</em>将无法定义。</p>\n</blockquote>\n<p>如果方法装饰器返回一个值，它将被用作方法的<em>属性描述符</em>。</p>\n<blockquote>\n<p>注意：如果你的脚本目标小于ES5，返回值会被忽略。</p>\n</blockquote>\n<p>下面是一个方法装饰器（<code>@enumerable</code>）应用于<code>Greeter</code>类的一个方法的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">message</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span> = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@enumerable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用下面的函数声明来定义<code>@enumerable</code>装饰器：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">enumerable</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">descriptor</span>: <span class=\"title class_\">PropertyDescriptor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    descriptor.<span class=\"property\">enumerable</span> = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>@enumerable(false)</code>装饰器是一个 <a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories\">装饰器工厂</a>。当<code>@enumerable(false)</code>装饰器被调用时，它修改了属性描述符的<code>enumerable</code>属性。</p>\n<h2 id=\"8-8-访问器装饰器\"><a href=\"#8-8-访问器装饰器\" class=\"headerlink\" title=\"8.8 访问器装饰器\"></a>8.8 访问器装饰器</h2><p>一个访问器装饰器就在访问器声明之前被声明。访问器装饰器被应用于访问器的属性描述符，可以用来观察、修改或替换访问器的定义。一个访问器装饰器不能在声明文件中使用，也不能在任何其他环境中使用（比如在<code>declare</code>类中）。</p>\n<blockquote>\n<p>注意：TypeScript不允许装饰单个成员的 <code>get</code>和<code>set</code>访问器。相反，该成员的所有装饰器必须应用于文件顺序中指定的第一个访问器。这是因为装饰器适用于一个<em>属性描述符</em>，它结合了获取和设置访问器，而不是每个声明单独。</p>\n</blockquote>\n<p>访问器装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：</p>\n<ol>\n<li>静态成员的类的构造函数，或者实例成员的类的原型。</li>\n<li>成员的名称。</li>\n<li>该成员的属性描述符。</li>\n</ol>\n<blockquote>\n<p>注意：如果你的脚本目标小于ES5，<em>属性描述符</em>将无法定义。</p>\n</blockquote>\n<p>如果访问器装饰器返回一个值，它将被用作该成员的<em>属性描述符</em>。</p>\n<blockquote>\n<p>注意：如果你的脚本目标小于ES5，返回值会被忽略。</p>\n</blockquote>\n<p>下面是一个访问器装饰器（<code>@configurable</code>）的例子，它应用于<code>Point</code>类的一个成员。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_x</span> = x;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_y</span> = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@configurable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">x</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_x</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@configurable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">y</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_y</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用下面的函数声明来定义<code>@configurable</code>装饰器：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">configurable</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">descriptor</span>: <span class=\"title class_\">PropertyDescriptor</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    descriptor.<span class=\"property\">configurable</span> = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-9-属性装饰器\"><a href=\"#8-9-属性装饰器\" class=\"headerlink\" title=\"8.9 属性装饰器\"></a>8.9 属性装饰器</h2><p>一个<em>属性装饰器</em>就在一个属性声明之前被声明。一个属性装饰器不能在声明文件中使用，也不能在任何其他环境下使用（比如在 <code>declare</code> 类中）。</p>\n<p>属性装饰器的表达式将在运行时作为一个函数被调用，有以下两个参数：</p>\n<ol>\n<li>静态成员的类的构造函数，或者实例成员的类的原型。</li>\n<li>成员的名称。</li>\n</ol>\n<blockquote>\n<p>注意：由于<em>属性装饰器</em>在TypeScript中的初始化方式，属性描述符不会作为参数提供给属性装饰器。这是因为目前没有机制在定义原型成员时描述一个实例属性，也没有办法观察或修改一个属性的初始化器。返回值也被忽略了。因此，一个属性装饰器只能用来观察一个类的特定名称的属性已经被声明。</p>\n</blockquote>\n<p>我们可以使用这些信息来记录关于该属性的元数据，如下面的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@format</span>(<span class=\"string\">&quot;Hello, %s&quot;</span>)</span><br><span class=\"line\">  <span class=\"attr\">greeting</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">message</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span> = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> formatString = <span class=\"title function_\">getFormat</span>(<span class=\"variable language_\">this</span>, <span class=\"string\">&quot;greeting&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> formatString.<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;%s&quot;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们可以使用以下函数声明来定义<code>@format</code>装饰器和<code>getFormat</code>函数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> formatMetadataKey = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;format&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">format</span>(<span class=\"params\"><span class=\"attr\">formatString</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">metadata</span>(formatMetadataKey, formatString);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getFormat</span>(<span class=\"params\"><span class=\"attr\">target</span>: <span class=\"built_in\">any</span>, <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getMetadata</span>(formatMetadataKey, target, propertyKey);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>@format(&quot;Hello, %s&quot;) </code>装饰器是一个<a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-factories\">装饰器工厂</a>。当<code>@format(&quot;Hello, %s&quot;)</code>被调用时，它使用<code>reflect-metadata</code>库中的<code>Reflect.metadata</code>函数为该属性添加一个元数据条目。当<code>getFormat</code>被调用时，它读取该格式的元数据值。</p>\n<blockquote>\n<p>注意：这个例子需要<code>reflect-metadata</code>库。关于<code>reflect-metadata</code>库的更多信息，请参见<a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\">Metadata</a>。</p>\n</blockquote>\n<h2 id=\"8-10-参数装饰器\"><a href=\"#8-10-参数装饰器\" class=\"headerlink\" title=\"8.10 参数装饰器\"></a>8.10 参数装饰器</h2><p><em>参数装饰器</em>就在参数声明之前被声明。参数装饰器被应用于类构造器或方法声明的函数。一个参数装饰器不能在声明文件、重载或任何其他环境中使用（比如在 <code>declare</code> 类中）。</p>\n<p>参数装饰器的表达式将在运行时作为一个函数被调用，有以下三个参数：</p>\n<ol>\n<li>对于静态成员，可以是该类的构造函数，对于实例成员，可以是该类的原型。</li>\n<li>该成员的名称。</li>\n<li>参数在函数的参数列表中的序数索引。</li>\n</ol>\n<blockquote>\n<p>注意：一个参数装饰器只能用来观察一个方法上已经声明了一个参数。</p>\n</blockquote>\n<p>参数装饰器的返回值被忽略了。</p>\n<p>下面是一个参数装饰器（<code>@required</code>）应用于<code>BugReport</code>类的一个成员的参数的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BugReport</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span> = <span class=\"string\">&quot;report&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">t</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"title function_\">print</span>(<span class=\"params\"><span class=\"meta\">@required</span> <span class=\"attr\">verbose</span>: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (verbose) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">`type: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.<span class=\"keyword\">type</span>&#125;</span>\\ntitle: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.title&#125;</span>`</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">title</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们可以使用以下函数声明来定义<code>@required</code>和<code>@validate</code>装饰器。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> requiredMetadataKey = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;required&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">required</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">target</span>: <span class=\"title class_\">Object</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span> | <span class=\"built_in\">symbol</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">parameterIndex</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"attr\">existingRequiredParameters</span>: <span class=\"built_in\">number</span>[] =</span><br><span class=\"line\">    <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getOwnMetadata</span>(requiredMetadataKey, target, propertyKey) || [];</span><br><span class=\"line\">  existingRequiredParameters.<span class=\"title function_\">push</span>(parameterIndex);</span><br><span class=\"line\">  <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">defineMetadata</span>(</span><br><span class=\"line\">    requiredMetadataKey,</span><br><span class=\"line\">    existingRequiredParameters,</span><br><span class=\"line\">    target,</span><br><span class=\"line\">    propertyKey,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">validate</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">propertyName</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">descriptor</span>: <span class=\"title class_\">TypedPropertyDescriptor</span>&lt;<span class=\"title class_\">Function</span>&gt;,</span></span><br><span class=\"line\"><span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> method = descriptor.<span class=\"property\">value</span>!;</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.<span class=\"property\">value</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"attr\">requiredParameters</span>: <span class=\"built_in\">number</span>[] = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getOwnMetadata</span>(</span><br><span class=\"line\">      requiredMetadataKey,</span><br><span class=\"line\">      target,</span><br><span class=\"line\">      propertyName,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requiredParameters) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> parameterIndex <span class=\"keyword\">of</span> requiredParameters) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">          parameterIndex &gt;= <span class=\"variable language_\">arguments</span>.<span class=\"property\">length</span> ||</span><br><span class=\"line\">          <span class=\"variable language_\">arguments</span>[parameterIndex] === <span class=\"literal\">undefined</span></span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;Missing required argument.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> method.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@required</code>装饰器添加了一个元数据条目，将参数标记为必填。然后，<code>@validate</code>装饰器将现有的<code>greet</code>方法包装在一个函数中，在调用原始方法之前验证参数。</p>\n<blockquote>\n<p>注意：这个例子需要<code>reflect-metadata</code>库。关于<code>reflect-metadata</code>库的更多信息，请参见<a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#metadata\">Metadata</a> 。</p>\n</blockquote>\n<h2 id=\"8-11-Metadata\"><a href=\"#8-11-Metadata\" class=\"headerlink\" title=\"8.11 Metadata\"></a>8.11 Metadata</h2><p>一些例子使用了<code>reflect-metadata</code>库，它为一个<a href=\"https://github.com/rbuckton/ReflectDecorators\">实验性的元数据API</a>. 添加了一个<code>polyfill</code>。这个库还不是ECMAScript（JavaScript）标准的一部分。然而，一旦装饰器被正式采纳为ECMAScript标准的一部分，这些扩展将被提议采纳。</p>\n<p>你可以通过npm来安装这个库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>\n\n<p>TypeScript包括试验性的支持，为具有装饰器的声明排放某些类型的元数据。要启用这个实验性支持，你必须在命令行或在你的<code>tsconfig.json</code>中设置<code>emitDecoratorMetadata</code>编译器选项。</p>\n<ul>\n<li><strong>Command Line</strong></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>tsconfig.json</strong></li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ES5&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;experimentalDecorators&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;emitDecoratorMetadata&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>启用后，只要导入了<code>reflect-metadata</code>库，额外的设计时类型信息就会在运行时暴露。</p>\n<p>我们可以在下面的例子中看到这个作用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Line</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_start</span>: <span class=\"title class_\">Point</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_end</span>: <span class=\"title class_\">Point</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">start</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_start</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">start</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_start</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">end</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_end</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">end</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_end</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> validate&lt;T&gt;(</span><br><span class=\"line\">  <span class=\"attr\">target</span>: <span class=\"built_in\">any</span>,</span><br><span class=\"line\">  <span class=\"attr\">propertyKey</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  <span class=\"attr\">descriptor</span>: <span class=\"title class_\">TypedPropertyDescriptor</span>&lt;T&gt;,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> set = descriptor.<span class=\"property\">set</span>!;</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.<span class=\"property\">set</span> = <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"attr\">value</span>: T</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">type</span> = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">getMetadata</span>(<span class=\"string\">&quot;design:type&quot;</span>, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(value <span class=\"keyword\">instanceof</span> <span class=\"keyword\">type</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(</span><br><span class=\"line\">        <span class=\"string\">`Invalid type, got <span class=\"subst\">$&#123;<span class=\"keyword\">typeof</span> value&#125;</span> not <span class=\"subst\">$&#123;<span class=\"keyword\">type</span>.name&#125;</span>.`</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    set.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, value);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> line = <span class=\"keyword\">new</span> <span class=\"title class_\">Line</span>();</span><br><span class=\"line\">line.<span class=\"property\">start</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @ts-ignore</span></span><br><span class=\"line\"><span class=\"comment\">// line.end = &#123;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时会失败:</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; Invalid type, got object not Point</span></span><br></pre></td></tr></table></figure>\n\n<p>TypeScript编译器将使用<code>@Reflect.metadata</code>装饰器注入设计时类型信息。你可以认为它相当于下面的TypeScript：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Line</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_start</span>: <span class=\"title class_\">Point</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">_end</span>: <span class=\"title class_\">Point</span>;</span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.<span class=\"title function_\">metadata</span>(<span class=\"string\">&quot;design:type&quot;</span>, <span class=\"title class_\">Point</span>)</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">start</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_start</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">start</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_start</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.<span class=\"title function_\">metadata</span>(<span class=\"string\">&quot;design:type&quot;</span>, <span class=\"title class_\">Point</span>)</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">end</span>(<span class=\"params\"><span class=\"attr\">value</span>: <span class=\"title class_\">Point</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_end</span> = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">end</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_end</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：装饰器元数据是一个实验性的功能，在未来的版本中可能会引入破坏性的变化。</p>\n</blockquote>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "3-1、高级篇：混入",
        "toc": true,
        "abbrlink": 5812,
        "date": "2024-01-28T13:09:53.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_02.jpeg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 十、混入\n\n除了传统的OO层次结构外，另一种流行的从可重用组件中建立类的方式是，通过组合更简单的部分类来建立它们。你可能对 `Scala`等语言的`mixins`或`traits`的想法很熟悉，这种模式在JavaScript社区也达到了一定的普及。\n\n## 10.1 混入是如何工作的？\n\n该模式依赖于使用泛型与类继承来扩展基类。TypeScript最好的mixin支持是通过类表达模式完成的。你可以在 [这里](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/)阅读更多关于这种模式在JavaScript中的工作方式。\n\n为了开始工作，我们需要一个类，在这个类上应用混入：\n\n```tsx\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n```\n\n然后你需要一个类型和一个工厂函数，它返回一个扩展基类的表达式。\n\n```tsx\n// 为了开始工作，我们需要一个类型，我们将用它来扩展其他类。\n// 主要的责任是声明, 传入的类型是一个类。\n\ntype Constructor = new (...args: any[]) => {};\n\n// 这个混集器增加了一个 `scale` 属性，并带有getters和setters\n// 用来改变它的封装的私有属性。\n\nfunction Scale<TBase extends Constructor>(Base: TBase) {\n  return class Scaling extends Base {\n    // 混入不能声明私有/受保护的属性\n    // 但是，你可以使用ES2020的私有字段\n    _scale = 1;\n\n    setScale(scale: number) {\n      this._scale = scale;\n    }\n\n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n```\n\n有了这些设置，你就可以创建一个代表基类的类，并应用混合元素。\n\n```tsx\n// 从Sprite类构成一个新的类。\n// 用Mixin Scale应用程序:\nconst EightBitSprite = Scale(Sprite);\n\nconst flappySprite = new EightBitSprite(\"Bird\");\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\n```\n\n## 10.2 受约束的混入\n\n在上述形式中，混入没有关于类的底层知识，这可能使它很难创建你想要的设计。\n\n为了模拟这一点，我们修改了原来的构造函数类型以接受一个通用参数。\n\n```tsx\n// 这就是我们之前的构造函数\ntype Constructor = new (...args: any[]) => {};\n// 现在我们使用一个通用的版本，它可以在以下方面应用一个约束\n// 该混入所适用的类\ntype GConstructor<T = {}> = new (...args: any[]) => T;\n```\n\n这允许创建只与受限基类一起工作的类。\n\n```tsx\ntype Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;\ntype Spritable = GConstructor<Sprite>;\ntype Loggable = GConstructor<{ print: () => void }>;\n```\n\n然后，你可以创建混入函数，只有当你有一个特定的基础时，它才能发挥作用。\n\n```tsx\nfunction Jumpable<TBase extends Positionable>(Base: TBase) {\n  return class Jumpable extends Base {\n    jump() {\n      // 这个混合器只有在传递给基类的情况下才会起作用。\n      // 类中定义了setPos，因为有了可定位的约束。\n      this.setPos(0, 20);\n    }\n  };\n}\n```\n\n## 10.3 替代模式\n\n本文档的前几个版本推荐了一种编写混入函数的方法，即分别创建运行时和类型层次，然后在最后将它们合并：\n\n```tsx\n// 每个mixin都是一个传统的ES类\nclass Jumpable {\n  jump() {}\n}\n\nclass Duckable {\n  duck() {}\n}\n\n// 基类\nclass Sprite {\n  x = 0;\n  y = 0;\n}\n\n// 然后，你创建一个接口，\n// 将预期的混合函数与你的基础函数同名，\n// 合并在一起。\ninterface Sprite extends Jumpable, Duckable {}\n// 在运行时，通过JS将混入应用到基类中\napplyMixins(Sprite, [Jumpable, Duckable]);\n\nlet player = new Sprite();\nplayer.jump();\nconsole.log(player.x, player.y);\n\n// 它可以存在于你代码库的任何地方\nfunction applyMixins(derivedCtor: any, constructors: any[]) {\n  constructors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||\n          Object.create(null),\n      );\n    });\n  });\n}\n```\n\n这种模式较少依赖于编译器，而更多地依赖于你的代码库，以确保运行时和类型系统都能正确地保持同步。\n\n## 10.4 限制条件\n\nmixin模式在TypeScript编译器中通过代码流分析得到了本地支持。在一些情况下，你会遇到本地支持的边界。\n\n### 10.4.1 装饰器和混入 [`#4881`](https://github.com/microsoft/TypeScript/issues/4881)\n\n你不能使用装饰器来通过代码流分析提供混入：\n\n```tsx\n// 一个复制mixin模式的装饰器函数。\nconst Pausable = (target: typeof Player) => {\n  return class Pausable extends target {\n    shouldFreeze = false;\n  };\n};\n\n@Pausable\nclass Player {\n  x = 0;\n  y = 0;\n}\n\n// 播放器类没有合并装饰器的类型\nconst player = new Player();\nplayer.shouldFreeze;\n// Ⓧ 属性'shouldFreeze'在类型'Player'上不存在\n\n// 运行时方面可以通过类型组合或接口合并来手动复制。\ntype FreezablePlayer = Player & { shouldFreeze: boolean };\n\nconst playerTwo = new Player() as unknown as FreezablePlayer;\nplayerTwo.shouldFreeze;\n```\n\n### 10.4.2 静态属性混入 [`#17829`](https://github.com/microsoft/TypeScript/issues/17829)\n\n与其说是约束，不如说是一个难题。类表达式模式创建了单子，所以它们不能在类型系统中被映射以支持不同的变量类型。\n\n你可以通过使用函数返回你的类来解决这个问题，这些类基于泛型而不同：\n\n```tsx\nfunction base<T>() {\n  class Base {\n    static prop: T;\n  }\n  return Base;\n}\n\nfunction derived<T>() {\n  class Derived extends base<T>() {\n    static anotherProp: T;\n  }\n  return Derived;\n}\n\nclass Spec extends derived<string>() {}\n\nSpec.prop; // string\nSpec.anotherProp; // string\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/3-1、高级篇：混入.md",
        "raw": "---\ntitle: 3-1、高级篇：混入\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 5812\ndate: 2024-01-28 21:09:53\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 十、混入\n\n除了传统的OO层次结构外，另一种流行的从可重用组件中建立类的方式是，通过组合更简单的部分类来建立它们。你可能对 `Scala`等语言的`mixins`或`traits`的想法很熟悉，这种模式在JavaScript社区也达到了一定的普及。\n\n## 10.1 混入是如何工作的？\n\n该模式依赖于使用泛型与类继承来扩展基类。TypeScript最好的mixin支持是通过类表达模式完成的。你可以在 [这里](https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/)阅读更多关于这种模式在JavaScript中的工作方式。\n\n为了开始工作，我们需要一个类，在这个类上应用混入：\n\n```tsx\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n```\n\n然后你需要一个类型和一个工厂函数，它返回一个扩展基类的表达式。\n\n```tsx\n// 为了开始工作，我们需要一个类型，我们将用它来扩展其他类。\n// 主要的责任是声明, 传入的类型是一个类。\n\ntype Constructor = new (...args: any[]) => {};\n\n// 这个混集器增加了一个 `scale` 属性，并带有getters和setters\n// 用来改变它的封装的私有属性。\n\nfunction Scale<TBase extends Constructor>(Base: TBase) {\n  return class Scaling extends Base {\n    // 混入不能声明私有/受保护的属性\n    // 但是，你可以使用ES2020的私有字段\n    _scale = 1;\n\n    setScale(scale: number) {\n      this._scale = scale;\n    }\n\n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n```\n\n有了这些设置，你就可以创建一个代表基类的类，并应用混合元素。\n\n```tsx\n// 从Sprite类构成一个新的类。\n// 用Mixin Scale应用程序:\nconst EightBitSprite = Scale(Sprite);\n\nconst flappySprite = new EightBitSprite(\"Bird\");\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\n```\n\n## 10.2 受约束的混入\n\n在上述形式中，混入没有关于类的底层知识，这可能使它很难创建你想要的设计。\n\n为了模拟这一点，我们修改了原来的构造函数类型以接受一个通用参数。\n\n```tsx\n// 这就是我们之前的构造函数\ntype Constructor = new (...args: any[]) => {};\n// 现在我们使用一个通用的版本，它可以在以下方面应用一个约束\n// 该混入所适用的类\ntype GConstructor<T = {}> = new (...args: any[]) => T;\n```\n\n这允许创建只与受限基类一起工作的类。\n\n```tsx\ntype Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;\ntype Spritable = GConstructor<Sprite>;\ntype Loggable = GConstructor<{ print: () => void }>;\n```\n\n然后，你可以创建混入函数，只有当你有一个特定的基础时，它才能发挥作用。\n\n```tsx\nfunction Jumpable<TBase extends Positionable>(Base: TBase) {\n  return class Jumpable extends Base {\n    jump() {\n      // 这个混合器只有在传递给基类的情况下才会起作用。\n      // 类中定义了setPos，因为有了可定位的约束。\n      this.setPos(0, 20);\n    }\n  };\n}\n```\n\n## 10.3 替代模式\n\n本文档的前几个版本推荐了一种编写混入函数的方法，即分别创建运行时和类型层次，然后在最后将它们合并：\n\n```tsx\n// 每个mixin都是一个传统的ES类\nclass Jumpable {\n  jump() {}\n}\n\nclass Duckable {\n  duck() {}\n}\n\n// 基类\nclass Sprite {\n  x = 0;\n  y = 0;\n}\n\n// 然后，你创建一个接口，\n// 将预期的混合函数与你的基础函数同名，\n// 合并在一起。\ninterface Sprite extends Jumpable, Duckable {}\n// 在运行时，通过JS将混入应用到基类中\napplyMixins(Sprite, [Jumpable, Duckable]);\n\nlet player = new Sprite();\nplayer.jump();\nconsole.log(player.x, player.y);\n\n// 它可以存在于你代码库的任何地方\nfunction applyMixins(derivedCtor: any, constructors: any[]) {\n  constructors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||\n          Object.create(null),\n      );\n    });\n  });\n}\n```\n\n这种模式较少依赖于编译器，而更多地依赖于你的代码库，以确保运行时和类型系统都能正确地保持同步。\n\n## 10.4 限制条件\n\nmixin模式在TypeScript编译器中通过代码流分析得到了本地支持。在一些情况下，你会遇到本地支持的边界。\n\n### 10.4.1 装饰器和混入 [`#4881`](https://github.com/microsoft/TypeScript/issues/4881)\n\n你不能使用装饰器来通过代码流分析提供混入：\n\n```tsx\n// 一个复制mixin模式的装饰器函数。\nconst Pausable = (target: typeof Player) => {\n  return class Pausable extends target {\n    shouldFreeze = false;\n  };\n};\n\n@Pausable\nclass Player {\n  x = 0;\n  y = 0;\n}\n\n// 播放器类没有合并装饰器的类型\nconst player = new Player();\nplayer.shouldFreeze;\n// Ⓧ 属性'shouldFreeze'在类型'Player'上不存在\n\n// 运行时方面可以通过类型组合或接口合并来手动复制。\ntype FreezablePlayer = Player & { shouldFreeze: boolean };\n\nconst playerTwo = new Player() as unknown as FreezablePlayer;\nplayerTwo.shouldFreeze;\n```\n\n### 10.4.2 静态属性混入 [`#17829`](https://github.com/microsoft/TypeScript/issues/17829)\n\n与其说是约束，不如说是一个难题。类表达式模式创建了单子，所以它们不能在类型系统中被映射以支持不同的变量类型。\n\n你可以通过使用函数返回你的类来解决这个问题，这些类基于泛型而不同：\n\n```tsx\nfunction base<T>() {\n  class Base {\n    static prop: T;\n  }\n  return Base;\n}\n\nfunction derived<T>() {\n  class Derived extends base<T>() {\n    static anotherProp: T;\n  }\n  return Derived;\n}\n\nclass Spec extends derived<string>() {}\n\nSpec.prop; // string\nSpec.anotherProp; // string\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/3-1、高级篇：混入",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjaob002294v38bxi4enl",
        "content": "<h1 id=\"十、混入\"><a href=\"#十、混入\" class=\"headerlink\" title=\"十、混入\"></a>十、混入</h1><p>除了传统的OO层次结构外，另一种流行的从可重用组件中建立类的方式是，通过组合更简单的部分类来建立它们。你可能对 <code>Scala</code>等语言的<code>mixins</code>或<code>traits</code>的想法很熟悉，这种模式在JavaScript社区也达到了一定的普及。</p>\n<h2 id=\"10-1-混入是如何工作的？\"><a href=\"#10-1-混入是如何工作的？\" class=\"headerlink\" title=\"10.1 混入是如何工作的？\"></a>10.1 混入是如何工作的？</h2><p>该模式依赖于使用泛型与类继承来扩展基类。TypeScript最好的mixin支持是通过类表达模式完成的。你可以在 <a href=\"https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\">这里</a>阅读更多关于这种模式在JavaScript中的工作方式。</p>\n<p>为了开始工作，我们需要一个类，在这个类上应用混入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sprite</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后你需要一个类型和一个工厂函数，它返回一个扩展基类的表达式。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为了开始工作，我们需要一个类型，我们将用它来扩展其他类。</span></span><br><span class=\"line\"><span class=\"comment\">// 主要的责任是声明, 传入的类型是一个类。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Constructor</span> = <span class=\"title function_\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个混集器增加了一个 `scale` 属性，并带有getters和setters</span></span><br><span class=\"line\"><span class=\"comment\">// 用来改变它的封装的私有属性。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title class_\">Scale</span>&lt;<span class=\"title class_\">TBase</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Constructor</span>&gt;(<span class=\"title class_\">Base</span>: <span class=\"title class_\">TBase</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Scaling</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 混入不能声明私有/受保护的属性</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是，你可以使用ES2020的私有字段</span></span><br><span class=\"line\">    _scale = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">setScale</span>(<span class=\"params\"><span class=\"attr\">scale</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">_scale</span> = scale;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">scale</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_scale</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了这些设置，你就可以创建一个代表基类的类，并应用混合元素。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从Sprite类构成一个新的类。</span></span><br><span class=\"line\"><span class=\"comment\">// 用Mixin Scale应用程序:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">EightBitSprite</span> = <span class=\"title class_\">Scale</span>(<span class=\"title class_\">Sprite</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> flappySprite = <span class=\"keyword\">new</span> <span class=\"title class_\">EightBitSprite</span>(<span class=\"string\">&quot;Bird&quot;</span>);</span><br><span class=\"line\">flappySprite.<span class=\"title function_\">setScale</span>(<span class=\"number\">0.8</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(flappySprite.<span class=\"property\">scale</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-2-受约束的混入\"><a href=\"#10-2-受约束的混入\" class=\"headerlink\" title=\"10.2 受约束的混入\"></a>10.2 受约束的混入</h2><p>在上述形式中，混入没有关于类的底层知识，这可能使它很难创建你想要的设计。</p>\n<p>为了模拟这一点，我们修改了原来的构造函数类型以接受一个通用参数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这就是我们之前的构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Constructor</span> = <span class=\"title function_\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 现在我们使用一个通用的版本，它可以在以下方面应用一个约束</span></span><br><span class=\"line\"><span class=\"comment\">// 该混入所适用的类</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">GConstructor</span>&lt;T = &#123;&#125;&gt; = <span class=\"title function_\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; T;</span><br></pre></td></tr></table></figure>\n\n<p>这允许创建只与受限基类一起工作的类。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Positionable</span> = <span class=\"title class_\">GConstructor</span>&lt;&#123; <span class=\"attr\">setPos</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">void</span> &#125;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Spritable</span> = <span class=\"title class_\">GConstructor</span>&lt;<span class=\"title class_\">Sprite</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Loggable</span> = <span class=\"title class_\">GConstructor</span>&lt;&#123; <span class=\"attr\">print</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>然后，你可以创建混入函数，只有当你有一个特定的基础时，它才能发挥作用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title class_\">Jumpable</span>&lt;<span class=\"title class_\">TBase</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Positionable</span>&gt;(<span class=\"title class_\">Base</span>: <span class=\"title class_\">TBase</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Jumpable</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">jump</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这个混合器只有在传递给基类的情况下才会起作用。</span></span><br><span class=\"line\">      <span class=\"comment\">// 类中定义了setPos，因为有了可定位的约束。</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">setPos</span>(<span class=\"number\">0</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-3-替代模式\"><a href=\"#10-3-替代模式\" class=\"headerlink\" title=\"10.3 替代模式\"></a>10.3 替代模式</h2><p>本文档的前几个版本推荐了一种编写混入函数的方法，即分别创建运行时和类型层次，然后在最后将它们合并：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个mixin都是一个传统的ES类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Jumpable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">jump</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Duckable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">duck</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sprite</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后，你创建一个接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 将预期的混合函数与你的基础函数同名，</span></span><br><span class=\"line\"><span class=\"comment\">// 合并在一起。</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Sprite</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Jumpable</span>, <span class=\"title class_\">Duckable</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在运行时，通过JS将混入应用到基类中</span></span><br><span class=\"line\"><span class=\"title function_\">applyMixins</span>(<span class=\"title class_\">Sprite</span>, [<span class=\"title class_\">Jumpable</span>, <span class=\"title class_\">Duckable</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> player = <span class=\"keyword\">new</span> <span class=\"title class_\">Sprite</span>();</span><br><span class=\"line\">player.<span class=\"title function_\">jump</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(player.<span class=\"property\">x</span>, player.<span class=\"property\">y</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 它可以存在于你代码库的任何地方</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">applyMixins</span>(<span class=\"params\"><span class=\"attr\">derivedCtor</span>: <span class=\"built_in\">any</span>, <span class=\"attr\">constructors</span>: <span class=\"built_in\">any</span>[]</span>) &#123;</span><br><span class=\"line\">  constructors.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">baseCtor</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyNames</span>(baseCtor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(</span><br><span class=\"line\">        derivedCtor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>,</span><br><span class=\"line\">        name,</span><br><span class=\"line\">        <span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptor</span>(baseCtor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>, name) ||</span><br><span class=\"line\">          <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种模式较少依赖于编译器，而更多地依赖于你的代码库，以确保运行时和类型系统都能正确地保持同步。</p>\n<h2 id=\"10-4-限制条件\"><a href=\"#10-4-限制条件\" class=\"headerlink\" title=\"10.4 限制条件\"></a>10.4 限制条件</h2><p>mixin模式在TypeScript编译器中通过代码流分析得到了本地支持。在一些情况下，你会遇到本地支持的边界。</p>\n<h3 id=\"10-4-1-装饰器和混入-4881\"><a href=\"#10-4-1-装饰器和混入-4881\" class=\"headerlink\" title=\"10.4.1 装饰器和混入 #4881\"></a>10.4.1 装饰器和混入 <a href=\"https://github.com/microsoft/TypeScript/issues/4881\"><code>#4881</code></a></h3><p>你不能使用装饰器来通过代码流分析提供混入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个复制mixin模式的装饰器函数。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Pausable</span> = (<span class=\"params\"><span class=\"attr\">target</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Player</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Pausable</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">target</span> &#123;</span><br><span class=\"line\">    shouldFreeze = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pausable</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Player</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 播放器类没有合并装饰器的类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> player = <span class=\"keyword\">new</span> <span class=\"title class_\">Player</span>();</span><br><span class=\"line\">player.<span class=\"property\">shouldFreeze</span>;</span><br><span class=\"line\"><span class=\"comment\">// Ⓧ 属性&#x27;shouldFreeze&#x27;在类型&#x27;Player&#x27;上不存在</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时方面可以通过类型组合或接口合并来手动复制。</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FreezablePlayer</span> = <span class=\"title class_\">Player</span> &amp; &#123; <span class=\"attr\">shouldFreeze</span>: <span class=\"built_in\">boolean</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> playerTwo = <span class=\"keyword\">new</span> <span class=\"title class_\">Player</span>() <span class=\"keyword\">as</span> <span class=\"built_in\">unknown</span> <span class=\"keyword\">as</span> <span class=\"title class_\">FreezablePlayer</span>;</span><br><span class=\"line\">playerTwo.<span class=\"property\">shouldFreeze</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-4-2-静态属性混入-17829\"><a href=\"#10-4-2-静态属性混入-17829\" class=\"headerlink\" title=\"10.4.2 静态属性混入 #17829\"></a>10.4.2 静态属性混入 <a href=\"https://github.com/microsoft/TypeScript/issues/17829\"><code>#17829</code></a></h3><p>与其说是约束，不如说是一个难题。类表达式模式创建了单子，所以它们不能在类型系统中被映射以支持不同的变量类型。</p>\n<p>你可以通过使用函数返回你的类来解决这个问题，这些类基于泛型而不同：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> base&lt;T&gt;() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"attr\">prop</span>: T;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Base</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> derived&lt;T&gt;() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">base</span>&lt;T&gt;() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"attr\">anotherProp</span>: T;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Derived</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Spec</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">derived</span>&lt;<span class=\"built_in\">string</span>&gt;() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Spec</span>.<span class=\"property\">prop</span>; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"title class_\">Spec</span>.<span class=\"property\">anotherProp</span>; <span class=\"comment\">// string</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"十、混入\"><a href=\"#十、混入\" class=\"headerlink\" title=\"十、混入\"></a>十、混入</h1><p>除了传统的OO层次结构外，另一种流行的从可重用组件中建立类的方式是，通过组合更简单的部分类来建立它们。你可能对 <code>Scala</code>等语言的<code>mixins</code>或<code>traits</code>的想法很熟悉，这种模式在JavaScript社区也达到了一定的普及。</p>\n<h2 id=\"10-1-混入是如何工作的？\"><a href=\"#10-1-混入是如何工作的？\" class=\"headerlink\" title=\"10.1 混入是如何工作的？\"></a>10.1 混入是如何工作的？</h2><p>该模式依赖于使用泛型与类继承来扩展基类。TypeScript最好的mixin支持是通过类表达模式完成的。你可以在 <a href=\"https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\">这里</a>阅读更多关于这种模式在JavaScript中的工作方式。</p>\n<p>为了开始工作，我们需要一个类，在这个类上应用混入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sprite</span> &#123;</span><br><span class=\"line\">  name = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后你需要一个类型和一个工厂函数，它返回一个扩展基类的表达式。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为了开始工作，我们需要一个类型，我们将用它来扩展其他类。</span></span><br><span class=\"line\"><span class=\"comment\">// 主要的责任是声明, 传入的类型是一个类。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Constructor</span> = <span class=\"title function_\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个混集器增加了一个 `scale` 属性，并带有getters和setters</span></span><br><span class=\"line\"><span class=\"comment\">// 用来改变它的封装的私有属性。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title class_\">Scale</span>&lt;<span class=\"title class_\">TBase</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Constructor</span>&gt;(<span class=\"title class_\">Base</span>: <span class=\"title class_\">TBase</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Scaling</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 混入不能声明私有/受保护的属性</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是，你可以使用ES2020的私有字段</span></span><br><span class=\"line\">    _scale = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">setScale</span>(<span class=\"params\"><span class=\"attr\">scale</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">_scale</span> = scale;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">scale</span>(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_scale</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了这些设置，你就可以创建一个代表基类的类，并应用混合元素。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从Sprite类构成一个新的类。</span></span><br><span class=\"line\"><span class=\"comment\">// 用Mixin Scale应用程序:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">EightBitSprite</span> = <span class=\"title class_\">Scale</span>(<span class=\"title class_\">Sprite</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> flappySprite = <span class=\"keyword\">new</span> <span class=\"title class_\">EightBitSprite</span>(<span class=\"string\">&quot;Bird&quot;</span>);</span><br><span class=\"line\">flappySprite.<span class=\"title function_\">setScale</span>(<span class=\"number\">0.8</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(flappySprite.<span class=\"property\">scale</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-2-受约束的混入\"><a href=\"#10-2-受约束的混入\" class=\"headerlink\" title=\"10.2 受约束的混入\"></a>10.2 受约束的混入</h2><p>在上述形式中，混入没有关于类的底层知识，这可能使它很难创建你想要的设计。</p>\n<p>为了模拟这一点，我们修改了原来的构造函数类型以接受一个通用参数。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这就是我们之前的构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Constructor</span> = <span class=\"title function_\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 现在我们使用一个通用的版本，它可以在以下方面应用一个约束</span></span><br><span class=\"line\"><span class=\"comment\">// 该混入所适用的类</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">GConstructor</span>&lt;T = &#123;&#125;&gt; = <span class=\"title function_\">new</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; T;</span><br></pre></td></tr></table></figure>\n\n<p>这允许创建只与受限基类一起工作的类。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Positionable</span> = <span class=\"title class_\">GConstructor</span>&lt;&#123; <span class=\"attr\">setPos</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">void</span> &#125;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Spritable</span> = <span class=\"title class_\">GConstructor</span>&lt;<span class=\"title class_\">Sprite</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Loggable</span> = <span class=\"title class_\">GConstructor</span>&lt;&#123; <span class=\"attr\">print</span>: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span> &#125;&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>然后，你可以创建混入函数，只有当你有一个特定的基础时，它才能发挥作用。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title class_\">Jumpable</span>&lt;<span class=\"title class_\">TBase</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Positionable</span>&gt;(<span class=\"title class_\">Base</span>: <span class=\"title class_\">TBase</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Jumpable</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">jump</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这个混合器只有在传递给基类的情况下才会起作用。</span></span><br><span class=\"line\">      <span class=\"comment\">// 类中定义了setPos，因为有了可定位的约束。</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">setPos</span>(<span class=\"number\">0</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-3-替代模式\"><a href=\"#10-3-替代模式\" class=\"headerlink\" title=\"10.3 替代模式\"></a>10.3 替代模式</h2><p>本文档的前几个版本推荐了一种编写混入函数的方法，即分别创建运行时和类型层次，然后在最后将它们合并：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个mixin都是一个传统的ES类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Jumpable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">jump</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Duckable</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">duck</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sprite</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后，你创建一个接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 将预期的混合函数与你的基础函数同名，</span></span><br><span class=\"line\"><span class=\"comment\">// 合并在一起。</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Sprite</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Jumpable</span>, <span class=\"title class_\">Duckable</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在运行时，通过JS将混入应用到基类中</span></span><br><span class=\"line\"><span class=\"title function_\">applyMixins</span>(<span class=\"title class_\">Sprite</span>, [<span class=\"title class_\">Jumpable</span>, <span class=\"title class_\">Duckable</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> player = <span class=\"keyword\">new</span> <span class=\"title class_\">Sprite</span>();</span><br><span class=\"line\">player.<span class=\"title function_\">jump</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(player.<span class=\"property\">x</span>, player.<span class=\"property\">y</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 它可以存在于你代码库的任何地方</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">applyMixins</span>(<span class=\"params\"><span class=\"attr\">derivedCtor</span>: <span class=\"built_in\">any</span>, <span class=\"attr\">constructors</span>: <span class=\"built_in\">any</span>[]</span>) &#123;</span><br><span class=\"line\">  constructors.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">baseCtor</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyNames</span>(baseCtor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(</span><br><span class=\"line\">        derivedCtor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>,</span><br><span class=\"line\">        name,</span><br><span class=\"line\">        <span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptor</span>(baseCtor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>, name) ||</span><br><span class=\"line\">          <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种模式较少依赖于编译器，而更多地依赖于你的代码库，以确保运行时和类型系统都能正确地保持同步。</p>\n<h2 id=\"10-4-限制条件\"><a href=\"#10-4-限制条件\" class=\"headerlink\" title=\"10.4 限制条件\"></a>10.4 限制条件</h2><p>mixin模式在TypeScript编译器中通过代码流分析得到了本地支持。在一些情况下，你会遇到本地支持的边界。</p>\n<h3 id=\"10-4-1-装饰器和混入-4881\"><a href=\"#10-4-1-装饰器和混入-4881\" class=\"headerlink\" title=\"10.4.1 装饰器和混入 #4881\"></a>10.4.1 装饰器和混入 <a href=\"https://github.com/microsoft/TypeScript/issues/4881\"><code>#4881</code></a></h3><p>你不能使用装饰器来通过代码流分析提供混入：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个复制mixin模式的装饰器函数。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Pausable</span> = (<span class=\"params\"><span class=\"attr\">target</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Player</span></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Pausable</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">target</span> &#123;</span><br><span class=\"line\">    shouldFreeze = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Pausable</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Player</span> &#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 播放器类没有合并装饰器的类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> player = <span class=\"keyword\">new</span> <span class=\"title class_\">Player</span>();</span><br><span class=\"line\">player.<span class=\"property\">shouldFreeze</span>;</span><br><span class=\"line\"><span class=\"comment\">// Ⓧ 属性&#x27;shouldFreeze&#x27;在类型&#x27;Player&#x27;上不存在</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行时方面可以通过类型组合或接口合并来手动复制。</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">FreezablePlayer</span> = <span class=\"title class_\">Player</span> &amp; &#123; <span class=\"attr\">shouldFreeze</span>: <span class=\"built_in\">boolean</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> playerTwo = <span class=\"keyword\">new</span> <span class=\"title class_\">Player</span>() <span class=\"keyword\">as</span> <span class=\"built_in\">unknown</span> <span class=\"keyword\">as</span> <span class=\"title class_\">FreezablePlayer</span>;</span><br><span class=\"line\">playerTwo.<span class=\"property\">shouldFreeze</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-4-2-静态属性混入-17829\"><a href=\"#10-4-2-静态属性混入-17829\" class=\"headerlink\" title=\"10.4.2 静态属性混入 #17829\"></a>10.4.2 静态属性混入 <a href=\"https://github.com/microsoft/TypeScript/issues/17829\"><code>#17829</code></a></h3><p>与其说是约束，不如说是一个难题。类表达式模式创建了单子，所以它们不能在类型系统中被映射以支持不同的变量类型。</p>\n<p>你可以通过使用函数返回你的类来解决这个问题，这些类基于泛型而不同：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> base&lt;T&gt;() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"attr\">prop</span>: T;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Base</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> derived&lt;T&gt;() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">base</span>&lt;T&gt;() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"attr\">anotherProp</span>: T;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Derived</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Spec</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">derived</span>&lt;<span class=\"built_in\">string</span>&gt;() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Spec</span>.<span class=\"property\">prop</span>; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"title class_\">Spec</span>.<span class=\"property\">anotherProp</span>; <span class=\"comment\">// string</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "3-3、高级篇：模块",
        "toc": true,
        "abbrlink": 36877,
        "date": "2024-01-28T13:10:56.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_02.jpeg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 十二、模块\n\n从ECMAScript 2015开始，JavaScript有一个模块的概念。TypeScript也有这个概念。\n\n模块在自己的范围内执行，而不是在全局范围内；这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地使用其中一种 [导出形式](https://www.typescriptlang.org/docs/handbook/modules.html#export)导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用[导入的形式](https://www.typescriptlang.org/docs/handbook/modules.html#import)将其导入。\n\n模块是声明性的；模块之间的关系是在文件级别上以导入和导出的方式指定的。\n\n模块使用模块加载器相互导入。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖关系。在JavaScript中使用的著名的模块加载器是Node.js的[CommonJS](https://wikipedia.org/wiki/CommonJS) 模块的加载器和Web应用程序中[AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md)模块的 [RequireJS](http://requirejs.org/) 加载器。\n\n在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级 `import` 或 `export` 的文件都被认为是一个模块。相反，一个没有任何顶级 `import` 或 `export` 声明的文件被视为一个脚本，其内容可在全局范围内使用（因此也可用于模块）。\n\n## 12.1 导出\n\n### 12.1.1 导出声明\n\n任何声明（如变量、函数、类、类型别名或接口）都可以通过添加 `export` 关键字而被导出。\n\n**StringValidator.ts**\n\n```tsx\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n```\n\n**ZipCodeValidator.ts**\n\n```tsx\nimport { StringValidator } from \"./StringValidator\";\nexport const numberRegexp = /^[0-9]+$/;\nexport class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n```\n\n### 12.1.2 导出别名\n\n当导出需要为调用者重新命名时，导出语句很方便，所以上面的例子可以写成：\n\n```tsx\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };\n```\n\n### 12.1.3 二次导出\n\n通常情况下，模块会扩展其他模块，并部分地暴露出它们的一些特性。一个二次导出并不在本地导入，也不引入本地变量。\n\n**ParseIntBasedZipCodeValidator.ts**\n\n```tsx\nexport class ParseIntBasedZipCodeValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && parseInt(s).toString() === s;\n  }\n}\n// 导出原始验证器但重新命名\nexport { ZipCodeValidator as RegExpBasedZipCodeValidator } from \"./ZipCodeValidator\";\n```\n\n另外，一个模块可以包裹一个或多个模块，并使用 `export * from \"module \"`语法组合它们的所有导出。\n\n**AllValidators.ts**\n\n```tsx\nexport * from \"./StringValidator\"; // 导出'StringValidator'接口\nexport * from \"./ZipCodeValidator\"; // 导出'ZipCodeValidator'类和'numberRegexp'常量值\nexport * from \"./ParseIntBasedZipCodeValidator\"; //  从'ZipCodeValidator.ts'模块导出'ParseIntBasedZipCodeValidator'类并重新导出'RegExpBasedZipCodeValidator'作为'ZipCodeValidator'类的别名。\n```\n\n## 12.4 导入\n\n导入和从模块中导出一样简单。导入一个导出的声明是通过使用下面的一个导入表格完成的。\n\n### 12.4.1 从一个模块中导入一个单一的导出\n\n```tsx\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nlet myValidator = new ZipCodeValidator();\n```\n\n导入也可以被重新命名：\n\n```tsx\nimport { ZipCodeValidator as ZCV } from \"./ZipCodeValidator\";\nlet myValidator = new ZCV();\n```\n\n### 12.4.2 将整个模块导入到一个变量中，并使用它来访问模块的出口。\n\n```tsx\nimport * as validator from \"./ZipCodeValidator\";\nlet myValidator = new validator.ZipCodeValidator();\n```\n\n### 12.4.3 导入一个只有副作用的模块\n\n虽然不是推荐的做法，但有些模块设置了一些全局状态，可以被其他模块使用。这些模块可能没有任何出口，或者消费者对它们的任何出口不感兴趣。要导入这些模块，请使用：\n\n```tsx\nimport \"./my-module.js\";\n```\n\n在TypeScript 3.8之前，你可以使用 `import` 导入一个类型。在TypeScript 3.8中，你可以使用 `import` 语句导入一个类型，或者使用 `import type`。\n\n```tsx\n// 重复使用相同的 import\nimport { APIResponseType } from \"./api\";\n// 明确使用导入类型\nimport type { APIResponseType } from \"./api\";\n```\n\n`import type` 总是被保证从你的JavaScript中删除，而且像Babel这样的工具可以通过 [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules) 编译器标志对你的代码做出更好的假设。你可以在[3.8 release notes](https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports) 的发行说明中阅读更多内容。\n\n## 12.5 默认输出\n\n每个模块都可以选择输出一个 `default` 输出。默认输出用关键字 `default`标记；每个模块只能有一个 `default`输出。`default` 输出使用不同的导入形式导入。\n\n`default` 导出真的很方便。例如，像jQuery这样的库可能有一个默认导出的jQuery或`$`，我们可能也会以 `$`或jQuery的名字导入。\n\n[JQuery.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/JQuery.d.ts)\n\n```tsx\ndeclare let $: JQuery;\nexport default $;\n```\n\n**App.ts**\n\n```tsx\nimport $ from \"jquery\";\n$(\"button.continue\").html(\"Next Step...\");\n```\n\n类和函数声明可以直接作为默认导出而编写。默认导出的类和函数声明名称是可选的。\n\n**ZipCodeValidator.ts**\n\n```tsx\nexport default class ZipCodeValidator {\n  static numberRegexp = /^[0-9]+$/;\n  isAcceptable(s: string) {\n    return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);\n  }\n}\n```\n\n**Test.ts**\n\n```tsx\nimport validator from \"./ZipCodeValidator\";\nlet myValidator = new validator();\n```\n\n或者：\n\n**StaticZipCodeValidator.ts**\n\n```tsx\nconst numberRegexp = /^[0-9]+$/;\nexport default function (s: string) {\n  return s.length === 5 && numberRegexp.test(s);\n}\n```\n\n**Test.ts**\n\n```tsx\nimport validate from \"./StaticZipCodeValidator\";\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 使用函数验证\nstrings.forEach((s) => {\n  console.log(`\"${s}\" ${validate(s) ? \"matches\" : \"does not match\"}`);\n});\n```\n\n`default` 出口也可以只是数值。\n\n**OneTwoThree.ts**\n\n```tsx\nexport default \"123\";\n```\n\n**Log.ts**\n\n```tsx\nimport num from \"./OneTwoThree\";\nconsole.log(num); // \"123\"\n```\n\n## 12.6 `as x` 导出全部\n\n在TypeScript 3.8中，你可以使用`export * as ns`作为一种速记方法来重新导出另一个有名字的模块。\n\n```tsx\nexport * as utilities from \"./utilities\";\n```\n\n这从一个模块中获取所有的依赖性，并使其成为一个导出的字段，你可以像这样导入它：\n\n```tsx\nimport { utilities } from \"./index\";\n```\n\n## 12.7 `export =` 与`import = require()`\n\nCommonJS和AMD通常都有一个 `exports` 对象的概念，它包含了一个模块的所有出口。\n\n它们也支持用一个自定义的单一对象来替换 `exports` 对象。默认的 exports 是为了作为这种行为的替代；然而，两者是不兼容的。TypeScript 支持 `export =` 来模拟传统的 CommonJS 和 AMD 工作流程。\n\n`export =` 语法指定了一个从模块导出的单一对象。这可以是一个类，接口，命名空间，函数，或枚举。\n\n当使用`export =`导出一个模块时，必须使用TypeScript特定的`import module = require(\"module\")`来导入模块。\n\n**ZipCodeValidator.ts**\n\n```tsx\nlet numberRegexp = /^[0-9]+$/;\nclass ZipCodeValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\nexport = ZipCodeValidator;\n```\n\n**Test.ts**\n\n```tsx\nimport zip = require(\"./ZipCodeValidator\");\n// 一些可以尝试的样本\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validator = new zip();\n// 显示每个字符串是否通过每个验证器\nstrings.forEach((s) => {\n  console.log(\n    `\"${s}\" - ${validator.isAcceptable(s) ? \"matches\" : \"does not match\"}`,\n  );\n});\n```\n\n## 12.8 模块的代码生成\n\n根据编译时指定的模块目标，编译器将为Node.js（[CommonJS](http://wiki.commonjs.org/wiki/CommonJS)）、require.js（[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)）、 [UMD](https://github.com/umdjs/umd)、 [SystemJS](https://github.com/systemjs/systemjs)或[ECMAScript 2015本地模块](http://www.ecma-international.org/ecma-262/6.0/#sec-modules)（ES6）模块加载系统生成相应的代码。关于生成的代码中的 `define`、`require`和`register`调用的更多信息，请查阅每个模块加载器的文档。\n\n这个简单的例子显示了，导入和导出过程中使用的名称，是如何被翻译成模块加载代码的。\n\n**SimpleModule.ts**\n\n```tsx\nimport m = require(\"mod\");\nexport let t = m.something + 1;\n```\n\n**AMD / RequireJS SimpleModule.js**\n\n```tsx\ndefine([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) {\n  exports.t = mod_1.something + 1;\n});\n```\n\n**CommonJS / Node SimpleModule.js**\n\n```tsx\nvar mod_1 = require(\"./mod\");\nexports.t = mod_1.something + 1;\n```\n\n**UMD SimpleModule.js**\n\n```tsx\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([\"require\", \"exports\", \"./mod\"], factory);\n  }\n})(function (require, exports) {\n  var mod_1 = require(\"./mod\");\n  exports.t = mod_1.something + 1;\n});\n```\n\n**System SimpleModule.js**\n\n```tsx\nSystem.register([\"./mod\"], function (exports_1) {\n  var mod_1;\n  var t;\n  return {\n    setters: [\n      function (mod_1_1) {\n        mod_1 = mod_1_1;\n      },\n    ],\n    execute: function () {\n      exports_1(\"t\", (t = mod_1.something + 1));\n    },\n  };\n});\n```\n\n**Native ECMAScript 2015 modules SimpleModule.js**\n\n```tsx\nimport { something } from \"./mod\";\nexport var t = something + 1;\n```\n\n## 12.9 案例\n\n下面，我们整合了之前例子中使用的Validator实现，只从每个模块导出一个命名的导出。\n\n要进行编译，我们必须在命令行中指定一个模块目标。对于Node.js，使用`--module commonjs`；对于require.js，使用`--module amd`。比如说：\n\n```tsx\ntsc --module commonjs Test.ts\n```\n\n编译时，每个模块将成为一个单独的`.js`文件。与参考标签一样，编译器将遵循 `import` 语句来编译依赖的文件。\n\n**Validation.ts**\n\n```tsx\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n```\n\n**LettersOnlyValidator.ts**\n\n```tsx\nimport { StringValidator } from \"./Validation\";\nconst lettersRegexp = /^[A-Za-z]+$/;\nexport class LettersOnlyValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return lettersRegexp.test(s);\n  }\n}\n```\n\n**ZipCodeValidator.ts**\n\n```tsx\nimport { StringValidator } from \"./Validation\";\nconst numberRegexp = /^[0-9]+$/;\nexport class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n```\n\n**Test.ts**\n\n```tsx\nimport { StringValidator } from \"./Validation\";\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nimport { LettersOnlyValidator } from \"./LettersOnlyValidator\";\n// 一些可以尝试的样本\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n// 显示每个字符串是否通过每个验证器\nstrings.forEach((s) => {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`,\n    );\n  }\n});\n```\n\n## 12.10 可选模块加载和其他高级加载场景\n\n在某些情况下，你可能只想在某些条件下加载一个模块。在TypeScript中，我们可以使用下面所示的模式来实现这个和其他高级的加载场景，直接调用模块加载器而不失去类型安全。\n\n编译器会检测每个模块是否在编译好的JavaScript中被使用。如果一个模块的标识符只被用作类型注释的一部分，而从未被用作表达式，那么就不会为该模块编译 `require` 调用。这种对未使用的引用的消除是一种很好的性能优化，同时也允许对这些模块进行选择性加载。\n\n该模式的核心思想是，`import id = require(\"...\") `语句使我们能够访问模块所暴露的类型。模块加载器（通过`require`）被动态地调用，如下面的`if`块所示。这样就利用了引用隔离的优化，使模块只在需要时才被加载。为了使这种模式发挥作用，重要的是通过 `import` 定义的符号只在类型位置使用（也就是说，决不在会被编译到JavaScript的位置）。\n\n为了维护类型安全，我们可以使用 `typeof` 关键字。`typeof` 关键字在类型位置上使用时，会产生一个值的类型，在这里是模块的类型。\n\n- **Node.js中的动态模块加载**\n\n```tsx\ndeclare function require(moduleName: string): any;\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\nif (needZipValidation) {\n  let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");\n  let validator = new ZipCodeValidator();\n  if (validator.isAcceptable(\"...\")) {\n    /* ... */\n  }\n}\n```\n\n- **例子：在require.js中动态加载模块**\n\n```tsx\ndeclare function require(\n  moduleNames: string[],\n  onLoad: (...args: any[]) => void,\n): void;\nimport * as Zip from \"./ZipCodeValidator\";\nif (needZipValidation) {\n  require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) => {\n    let validator = new ZipCodeValidator.ZipCodeValidator();\n    if (validator.isAcceptable(\"...\")) {\n      /* ... */\n    }\n  });\n}\n```\n\n- **例子：System.js中的动态模块加载**\n\n```tsx\ndeclare const System: any;\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\nif (needZipValidation) {\n  System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) => {\n    var x = new ZipCodeValidator();\n    if (x.isAcceptable(\"...\")) {\n      /* ... */\n    }\n  });\n}\n```\n\n## 12.11 与其他JavaScript库一起工作\n\n为了描述不是用TypeScript编写的库的形状，我们需要声明该库所暴露的API。\n\n我们把不定义实现的声明称为 \"环境\"。通常情况下，这些都是在`.d.ts`文件中定义的。如果你熟悉C/C++，你可以把它们看作是`.h`文件。让我们来看看几个例子。\n\n### 12.11.1 环境模块\n\n在Node.js中，大多数任务是通过加载一个或多个模块完成的。我们可以在自己的`.d.ts`文件中定义每个模块，并进行顶层导出声明，但把它们写成一个更大的`.d.ts`文件会更方便。要做到这一点，我们使用一个类似于环境命名空间的结构，但我们使用 `module` 关键字和引号的模块名称，这将在以后的导入中可用。比如说：\n\n**node.d.ts (简要摘录)**\n\n```tsx\ndeclare module \"url\" {\n  export interface Url {\n    protocol?: string;\n    hostname?: string;\n    pathname?: string;\n  }\n  export function parse(\n    urlStr: string,\n    parseQueryString?,\n    slashesDenoteHost?,\n  ): Url;\n}\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export var sep: string;\n}\n```\n\n现在我们可以 `/// <reference> node.d.ts`，然后使用 `import url = require(\"url\"); `或 `import * as URL from \"url\"`加载模块。\n\n```tsx\n/// <reference path=\"node.d.ts\"/>\nimport * as URL from \"url\";\nlet myUrl = URL.parse(\"https://www.typescriptlang.org\");\n```\n\n### 12.11.2 速记的环境模块\n\n如果你不想在使用一个新模块之前花时间写出声明，你可以使用速记声明来快速入门。\n\n**declarations.d.ts**\n\n```tsx\ndeclare module \"hot-new-module\";\n```\n\n所有来自速记模块的导入都将具有任意类型。\n\n```tsx\nimport x, { y } from \"hot-new-module\";\nx(y);\n```\n\n### 12.11.3 通配符模块的声明\n\n一些模块加载器，如 [SystemJS](https://github.com/systemjs/systemjs/blob/master/docs/module-types.md) 和 [AMD](https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md) 允许导入非JavaScript内容。这些模块通常使用一个前缀或后缀来表示特殊的加载语义。通配符模块声明可以用来涵盖这些情况。\n\n```tsx\ndeclare module \"*!text\" {\n  const content: string;\n  export default content;\n}\n// 有些人则反其道而行之。\ndeclare module \"json!*\" {\n  const value: any;\n  export default value;\n}\n```\n\n现在你可以导入符合` \"*!text \"`或` \"json!*\"`的东西。\n\n```tsx\nimport fileContent from \"./xyz.txt!text\";\nimport data from \"json!http://example.com/data.json\";\nconsole.log(data, fileContent);\n```\n\n### 12.11.4 UMD 模块\n\n有些库被设计成可以在许多模块加载器中使用，或者没有模块加载（全局变量）也可以。这些被称为UMD模块。这些库可以通过导入或全局变量访问。比如说：\n\n**math-lib.d.ts**\n\n```tsx\nexport function isPrime(x: number): boolean;\nexport as namespace mathLib;\n```\n\n然后，该库可以作为模块内的导入使用：\n\n```tsx\nimport { isPrime } from \"math-lib\";\nisPrime(2);\nmathLib.isPrime(2); // 错误：不能从模块内部使用全局定义\n```\n\n它也可以作为一个全局变量使用，但只能在一个脚本中使用。(脚本是一个没有导入或导出的文件）。\n\n```tsx\nmathLib.isPrime(2);\n```\n\n## 12.12 构建模块的指导意见\n\n### 12.12.1 尽可能接近顶层导出(export)\n\n你的模块的消费者在使用你道出的东西时，应该有尽可能少的困扰。增加过多的嵌套层次往往是很麻烦的，所以要仔细考虑你想如何组织代码。\n\n从你的模块中导出一个命名空间，就是一个增加过多嵌套层次的例子。虽然命名空间有时有其用途，但在使用模块时，它们增加了额外的间接性。这很快就会成为用户的一个痛点，而且通常是不必要的。\n\n输出类上的静态方法也有类似的问题——类本身增加了一层嵌套。除非它以一种明显有用的方式增加了表达能力或意图，否则考虑简单地导出一个辅助函数。\n\n1. **如果你只导出了一个`class`或`function`则使用 `export default`**\n\n正如 \"在顶层导出 \"可以减少模块消费者的困扰，引入一个默认导出也是如此。如果一个模块的主要目的是容纳一个特定的出口，那么你应该考虑把它作为一个默认出口。这使得导入和实际使用导入都更容易一些。比如说：\n\n**MyClass.ts**\n\n```tsx\nexport default class SomeType {\n  constructor() { ... }\n}\n```\n\n**MyFunc.ts**\n\n```tsx\nexport default function getThing() {\n  return \"thing\";\n}\n```\n\n**Consumer.ts**\n\n```tsx\nimport t from \"./MyClass\";\nimport f from \"./MyFunc\";\nlet x = new t();\nconsole.log(f());\n```\n\n这对消费者来说是最好的。他们可以随心所欲地命名你的类型（本例中为`t`），并且不必做任何过度的点缀来寻找你的对象。\n\n2. **如果你要导出多个对象，把它们都放在顶层**\n\n**MyThings.ts**\n\n```tsx\nexport class SomeType {\n  /* ... */\n}\nexport function someFunc() {\n  /* ... */\n}\n```\n\n反之，在导入时，也是如此。\n\n3. **明确列出进口名称**\n\n**Consumer.ts**\n\n```tsx\nimport { SomeType, someFunc } from \"./MyThings\";\nlet x = new SomeType();\nlet y = someFunc();\n```\n\n如果你要导入大量的东西，请使用命名空间导入模式：\n\n**MyLargeModule.ts**\n\n```tsx\nexport class Dog { ... }\nexport class Cat { ... }\nexport class Tree { ... }\nexport class Flower { ... }\n```\n\n**Consumer.ts**\n\n```tsx\nimport * as myLargeModule from \"./MyLargeModule.ts\";\nlet x = new myLargeModule.Dog();\n```\n\n### 12.12.2 扩展的重新导出\n\n通常情况下，你需要在一个模块上扩展功能。一个常见的JS模式是用扩展来增强原始对象，类似于JQuery扩展的工作方式。正如我们之前提到的，模块不会像全局命名空间对象那样进行合并。推荐的解决方案是不改变原始对象，而是导出一个提供新功能的新实体。\n\n考虑一个简单的计算器实现，定义在模块`Calculator.ts`中。该模块还导出了一个辅助函数，通过传递一个输入字符串列表并在最后写入结果，来测试计算器的功能。\n\n**Calculator.ts**\n\n```tsx\nexport class Calculator {\n  private current = 0;\n  private memory = 0;\n  private operator: string;\n  protected processDigit(digit: string, currentValue: number) {\n    if (digit >= \"0\" && digit <= \"9\") {\n      return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0));\n    }\n  }\n  protected processOperator(operator: string) {\n    if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) >= 0) {\n      return operator;\n    }\n  }\n  protected evaluateOperator(\n    operator: string,\n    left: number,\n    right: number,\n  ): number {\n    switch (this.operator) {\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n    }\n  }\n  private evaluate() {\n    if (this.operator) {\n      this.memory = this.evaluateOperator(\n        this.operator,\n        this.memory,\n        this.current,\n      );\n    } else {\n      this.memory = this.current;\n    }\n    this.current = 0;\n  }\n  public handleChar(char: string) {\n    if (char === \"=\") {\n      this.evaluate();\n      return;\n    } else {\n      let value = this.processDigit(char, this.current);\n      if (value !== undefined) {\n        this.current = value;\n        return;\n      } else {\n        let value = this.processOperator(char);\n        if (value !== undefined) {\n          this.evaluate();\n          this.operator = value;\n          return;\n        }\n      }\n    }\n    throw new Error(`Unsupported input: '${char}'`);\n  }\n  public getResult() {\n    return this.memory;\n  }\n}\nexport function test(c: Calculator, input: string) {\n  for (let i = 0; i < input.length; i++) {\n    c.handleChar(input[i]);\n  }\n  console.log(`result of '${input}' is '${c.getResult()}'`);\n}\n```\n\n下面是一个使用暴露测试功能的计算器的简单测试。\n\n**TestCalculator.ts**\n\n```tsx\nimport { Calculator, test } from \"./Calculator\";\nlet c = new Calculator();\ntest(c, \"1+2*33/11=\"); // 输出 9\n```\n\n现在，为了扩展这个功能，以增加对10以外的数字输入的支持，我们来创建 `ProgrammerCalculator.ts`\n\n**ProgrammerCalculator.ts**\n\n```tsx\nimport { Calculator } from \"./Calculator\";\nclass ProgrammerCalculator extends Calculator {\n  static digits = [\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n  ];\n  constructor(public base: number) {\n    super();\n    const maxBase = ProgrammerCalculator.digits.length;\n    if (base <= 0 || base > maxBase) {\n      throw new Error(`base has to be within 0 to ${maxBase} inclusive.`);\n    }\n  }\n  protected processDigit(digit: string, currentValue: number) {\n    if (ProgrammerCalculator.digits.indexOf(digit) >= 0) {\n      return (\n        currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit)\n      );\n    }\n  }\n}\n// 将新的扩展计算器导出为 Calculator\nexport { ProgrammerCalculator as Calculator };\n// 同时，导出辅助函数\nexport { test } from \"./Calculator\";\n```\n\n新模块 `ProgrammerCalculator` 输出的API形状与原来的 `Calculator` 模块相似，但并没有增强原来模块中的任何对象。下面是对我们的`ProgrammerCalculator`类的测试。\n\n**TestProgrammerCalculator.ts**\n\n```tsx\nimport { Calculator, test } from \"./ProgrammerCalculator\";\nlet c = new Calculator(2);\ntest(c, \"001+010=\"); // 输出 3\n```\n\n### 12.12.3 不要在模块中使用命名空间\n\n当第一次转移到基于模块的代码设计时，一个常见的趋势是，将 export 包裹在一个额外的命名空间层中。模块有自己的范围，只有导出的声明在模块外可见。考虑到这一点，如果有命名空间的话，它在使用模块时提供的价值非常小。\n\n在组织方面，命名空间对于在全局范围内，将逻辑上相关的对象和类型组合在一起很方便。例如，在C#中，你会在 `System.Collections` 中找到所有的集合类型。通过将我们的类型组织到分层的命名空间中，我们为这些类型的用户提供了良好的 \"发现 \"体验。另一方面，模块已经存在于文件系统中，是必然的。我们必须通过路径和文件名来解决它们，所以有一个逻辑的组织方案供我们使用。我们可以有一个`/collections/generic/`文件夹，里面有一个列表模块。\n\n命名空间对于避免全局范围内的命名冲突很重要。例如，你可能有 `My.Application.Customer.AddForm`和`My.Application.Order.AddForm`两个名字相同的类型，但名字空间不同。然而，对于模块来说，这不是一个问题。在一个模块中，没有合理的理由让两个对象具有相同的名字。从消费方面来看，任何给定模块的消费者都可以选择他们将用来引用模块的名称，所以意外的命名冲突是不可能的。\n\n### 12.12.4 红线\n\n以下所有情况都是模块结构化的红线。如果你的文件有这些情况，请仔细检查你是否试图，对你的外部模块进行命名空间定义。\n\n- 一个文件的唯一顶层声明是 `export namespace Foo { ... } `(移除`Foo`，并将所有内容 \"上移 \"一个级别）\n- 多个文件在顶层有相同的`export namespace Foo {` (不要以为这些文件会合并成一个 `Foo`!)\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/3-3、高级篇：模块.md",
        "raw": "---\ntitle: 3-3、高级篇：模块\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 36877\ndate: 2024-01-28 21:10:56\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 十二、模块\n\n从ECMAScript 2015开始，JavaScript有一个模块的概念。TypeScript也有这个概念。\n\n模块在自己的范围内执行，而不是在全局范围内；这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地使用其中一种 [导出形式](https://www.typescriptlang.org/docs/handbook/modules.html#export)导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用[导入的形式](https://www.typescriptlang.org/docs/handbook/modules.html#import)将其导入。\n\n模块是声明性的；模块之间的关系是在文件级别上以导入和导出的方式指定的。\n\n模块使用模块加载器相互导入。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖关系。在JavaScript中使用的著名的模块加载器是Node.js的[CommonJS](https://wikipedia.org/wiki/CommonJS) 模块的加载器和Web应用程序中[AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md)模块的 [RequireJS](http://requirejs.org/) 加载器。\n\n在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级 `import` 或 `export` 的文件都被认为是一个模块。相反，一个没有任何顶级 `import` 或 `export` 声明的文件被视为一个脚本，其内容可在全局范围内使用（因此也可用于模块）。\n\n## 12.1 导出\n\n### 12.1.1 导出声明\n\n任何声明（如变量、函数、类、类型别名或接口）都可以通过添加 `export` 关键字而被导出。\n\n**StringValidator.ts**\n\n```tsx\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n```\n\n**ZipCodeValidator.ts**\n\n```tsx\nimport { StringValidator } from \"./StringValidator\";\nexport const numberRegexp = /^[0-9]+$/;\nexport class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n```\n\n### 12.1.2 导出别名\n\n当导出需要为调用者重新命名时，导出语句很方便，所以上面的例子可以写成：\n\n```tsx\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\nexport { ZipCodeValidator };\nexport { ZipCodeValidator as mainValidator };\n```\n\n### 12.1.3 二次导出\n\n通常情况下，模块会扩展其他模块，并部分地暴露出它们的一些特性。一个二次导出并不在本地导入，也不引入本地变量。\n\n**ParseIntBasedZipCodeValidator.ts**\n\n```tsx\nexport class ParseIntBasedZipCodeValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && parseInt(s).toString() === s;\n  }\n}\n// 导出原始验证器但重新命名\nexport { ZipCodeValidator as RegExpBasedZipCodeValidator } from \"./ZipCodeValidator\";\n```\n\n另外，一个模块可以包裹一个或多个模块，并使用 `export * from \"module \"`语法组合它们的所有导出。\n\n**AllValidators.ts**\n\n```tsx\nexport * from \"./StringValidator\"; // 导出'StringValidator'接口\nexport * from \"./ZipCodeValidator\"; // 导出'ZipCodeValidator'类和'numberRegexp'常量值\nexport * from \"./ParseIntBasedZipCodeValidator\"; //  从'ZipCodeValidator.ts'模块导出'ParseIntBasedZipCodeValidator'类并重新导出'RegExpBasedZipCodeValidator'作为'ZipCodeValidator'类的别名。\n```\n\n## 12.4 导入\n\n导入和从模块中导出一样简单。导入一个导出的声明是通过使用下面的一个导入表格完成的。\n\n### 12.4.1 从一个模块中导入一个单一的导出\n\n```tsx\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nlet myValidator = new ZipCodeValidator();\n```\n\n导入也可以被重新命名：\n\n```tsx\nimport { ZipCodeValidator as ZCV } from \"./ZipCodeValidator\";\nlet myValidator = new ZCV();\n```\n\n### 12.4.2 将整个模块导入到一个变量中，并使用它来访问模块的出口。\n\n```tsx\nimport * as validator from \"./ZipCodeValidator\";\nlet myValidator = new validator.ZipCodeValidator();\n```\n\n### 12.4.3 导入一个只有副作用的模块\n\n虽然不是推荐的做法，但有些模块设置了一些全局状态，可以被其他模块使用。这些模块可能没有任何出口，或者消费者对它们的任何出口不感兴趣。要导入这些模块，请使用：\n\n```tsx\nimport \"./my-module.js\";\n```\n\n在TypeScript 3.8之前，你可以使用 `import` 导入一个类型。在TypeScript 3.8中，你可以使用 `import` 语句导入一个类型，或者使用 `import type`。\n\n```tsx\n// 重复使用相同的 import\nimport { APIResponseType } from \"./api\";\n// 明确使用导入类型\nimport type { APIResponseType } from \"./api\";\n```\n\n`import type` 总是被保证从你的JavaScript中删除，而且像Babel这样的工具可以通过 [`isolatedModules`](https://www.typescriptlang.org/tsconfig#isolatedModules) 编译器标志对你的代码做出更好的假设。你可以在[3.8 release notes](https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports) 的发行说明中阅读更多内容。\n\n## 12.5 默认输出\n\n每个模块都可以选择输出一个 `default` 输出。默认输出用关键字 `default`标记；每个模块只能有一个 `default`输出。`default` 输出使用不同的导入形式导入。\n\n`default` 导出真的很方便。例如，像jQuery这样的库可能有一个默认导出的jQuery或`$`，我们可能也会以 `$`或jQuery的名字导入。\n\n[JQuery.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/JQuery.d.ts)\n\n```tsx\ndeclare let $: JQuery;\nexport default $;\n```\n\n**App.ts**\n\n```tsx\nimport $ from \"jquery\";\n$(\"button.continue\").html(\"Next Step...\");\n```\n\n类和函数声明可以直接作为默认导出而编写。默认导出的类和函数声明名称是可选的。\n\n**ZipCodeValidator.ts**\n\n```tsx\nexport default class ZipCodeValidator {\n  static numberRegexp = /^[0-9]+$/;\n  isAcceptable(s: string) {\n    return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);\n  }\n}\n```\n\n**Test.ts**\n\n```tsx\nimport validator from \"./ZipCodeValidator\";\nlet myValidator = new validator();\n```\n\n或者：\n\n**StaticZipCodeValidator.ts**\n\n```tsx\nconst numberRegexp = /^[0-9]+$/;\nexport default function (s: string) {\n  return s.length === 5 && numberRegexp.test(s);\n}\n```\n\n**Test.ts**\n\n```tsx\nimport validate from \"./StaticZipCodeValidator\";\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 使用函数验证\nstrings.forEach((s) => {\n  console.log(`\"${s}\" ${validate(s) ? \"matches\" : \"does not match\"}`);\n});\n```\n\n`default` 出口也可以只是数值。\n\n**OneTwoThree.ts**\n\n```tsx\nexport default \"123\";\n```\n\n**Log.ts**\n\n```tsx\nimport num from \"./OneTwoThree\";\nconsole.log(num); // \"123\"\n```\n\n## 12.6 `as x` 导出全部\n\n在TypeScript 3.8中，你可以使用`export * as ns`作为一种速记方法来重新导出另一个有名字的模块。\n\n```tsx\nexport * as utilities from \"./utilities\";\n```\n\n这从一个模块中获取所有的依赖性，并使其成为一个导出的字段，你可以像这样导入它：\n\n```tsx\nimport { utilities } from \"./index\";\n```\n\n## 12.7 `export =` 与`import = require()`\n\nCommonJS和AMD通常都有一个 `exports` 对象的概念，它包含了一个模块的所有出口。\n\n它们也支持用一个自定义的单一对象来替换 `exports` 对象。默认的 exports 是为了作为这种行为的替代；然而，两者是不兼容的。TypeScript 支持 `export =` 来模拟传统的 CommonJS 和 AMD 工作流程。\n\n`export =` 语法指定了一个从模块导出的单一对象。这可以是一个类，接口，命名空间，函数，或枚举。\n\n当使用`export =`导出一个模块时，必须使用TypeScript特定的`import module = require(\"module\")`来导入模块。\n\n**ZipCodeValidator.ts**\n\n```tsx\nlet numberRegexp = /^[0-9]+$/;\nclass ZipCodeValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\nexport = ZipCodeValidator;\n```\n\n**Test.ts**\n\n```tsx\nimport zip = require(\"./ZipCodeValidator\");\n// 一些可以尝试的样本\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validator = new zip();\n// 显示每个字符串是否通过每个验证器\nstrings.forEach((s) => {\n  console.log(\n    `\"${s}\" - ${validator.isAcceptable(s) ? \"matches\" : \"does not match\"}`,\n  );\n});\n```\n\n## 12.8 模块的代码生成\n\n根据编译时指定的模块目标，编译器将为Node.js（[CommonJS](http://wiki.commonjs.org/wiki/CommonJS)）、require.js（[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)）、 [UMD](https://github.com/umdjs/umd)、 [SystemJS](https://github.com/systemjs/systemjs)或[ECMAScript 2015本地模块](http://www.ecma-international.org/ecma-262/6.0/#sec-modules)（ES6）模块加载系统生成相应的代码。关于生成的代码中的 `define`、`require`和`register`调用的更多信息，请查阅每个模块加载器的文档。\n\n这个简单的例子显示了，导入和导出过程中使用的名称，是如何被翻译成模块加载代码的。\n\n**SimpleModule.ts**\n\n```tsx\nimport m = require(\"mod\");\nexport let t = m.something + 1;\n```\n\n**AMD / RequireJS SimpleModule.js**\n\n```tsx\ndefine([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) {\n  exports.t = mod_1.something + 1;\n});\n```\n\n**CommonJS / Node SimpleModule.js**\n\n```tsx\nvar mod_1 = require(\"./mod\");\nexports.t = mod_1.something + 1;\n```\n\n**UMD SimpleModule.js**\n\n```tsx\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([\"require\", \"exports\", \"./mod\"], factory);\n  }\n})(function (require, exports) {\n  var mod_1 = require(\"./mod\");\n  exports.t = mod_1.something + 1;\n});\n```\n\n**System SimpleModule.js**\n\n```tsx\nSystem.register([\"./mod\"], function (exports_1) {\n  var mod_1;\n  var t;\n  return {\n    setters: [\n      function (mod_1_1) {\n        mod_1 = mod_1_1;\n      },\n    ],\n    execute: function () {\n      exports_1(\"t\", (t = mod_1.something + 1));\n    },\n  };\n});\n```\n\n**Native ECMAScript 2015 modules SimpleModule.js**\n\n```tsx\nimport { something } from \"./mod\";\nexport var t = something + 1;\n```\n\n## 12.9 案例\n\n下面，我们整合了之前例子中使用的Validator实现，只从每个模块导出一个命名的导出。\n\n要进行编译，我们必须在命令行中指定一个模块目标。对于Node.js，使用`--module commonjs`；对于require.js，使用`--module amd`。比如说：\n\n```tsx\ntsc --module commonjs Test.ts\n```\n\n编译时，每个模块将成为一个单独的`.js`文件。与参考标签一样，编译器将遵循 `import` 语句来编译依赖的文件。\n\n**Validation.ts**\n\n```tsx\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n```\n\n**LettersOnlyValidator.ts**\n\n```tsx\nimport { StringValidator } from \"./Validation\";\nconst lettersRegexp = /^[A-Za-z]+$/;\nexport class LettersOnlyValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return lettersRegexp.test(s);\n  }\n}\n```\n\n**ZipCodeValidator.ts**\n\n```tsx\nimport { StringValidator } from \"./Validation\";\nconst numberRegexp = /^[0-9]+$/;\nexport class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n```\n\n**Test.ts**\n\n```tsx\nimport { StringValidator } from \"./Validation\";\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nimport { LettersOnlyValidator } from \"./LettersOnlyValidator\";\n// 一些可以尝试的样本\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n// 显示每个字符串是否通过每个验证器\nstrings.forEach((s) => {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`,\n    );\n  }\n});\n```\n\n## 12.10 可选模块加载和其他高级加载场景\n\n在某些情况下，你可能只想在某些条件下加载一个模块。在TypeScript中，我们可以使用下面所示的模式来实现这个和其他高级的加载场景，直接调用模块加载器而不失去类型安全。\n\n编译器会检测每个模块是否在编译好的JavaScript中被使用。如果一个模块的标识符只被用作类型注释的一部分，而从未被用作表达式，那么就不会为该模块编译 `require` 调用。这种对未使用的引用的消除是一种很好的性能优化，同时也允许对这些模块进行选择性加载。\n\n该模式的核心思想是，`import id = require(\"...\") `语句使我们能够访问模块所暴露的类型。模块加载器（通过`require`）被动态地调用，如下面的`if`块所示。这样就利用了引用隔离的优化，使模块只在需要时才被加载。为了使这种模式发挥作用，重要的是通过 `import` 定义的符号只在类型位置使用（也就是说，决不在会被编译到JavaScript的位置）。\n\n为了维护类型安全，我们可以使用 `typeof` 关键字。`typeof` 关键字在类型位置上使用时，会产生一个值的类型，在这里是模块的类型。\n\n- **Node.js中的动态模块加载**\n\n```tsx\ndeclare function require(moduleName: string): any;\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\nif (needZipValidation) {\n  let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");\n  let validator = new ZipCodeValidator();\n  if (validator.isAcceptable(\"...\")) {\n    /* ... */\n  }\n}\n```\n\n- **例子：在require.js中动态加载模块**\n\n```tsx\ndeclare function require(\n  moduleNames: string[],\n  onLoad: (...args: any[]) => void,\n): void;\nimport * as Zip from \"./ZipCodeValidator\";\nif (needZipValidation) {\n  require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) => {\n    let validator = new ZipCodeValidator.ZipCodeValidator();\n    if (validator.isAcceptable(\"...\")) {\n      /* ... */\n    }\n  });\n}\n```\n\n- **例子：System.js中的动态模块加载**\n\n```tsx\ndeclare const System: any;\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\nif (needZipValidation) {\n  System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) => {\n    var x = new ZipCodeValidator();\n    if (x.isAcceptable(\"...\")) {\n      /* ... */\n    }\n  });\n}\n```\n\n## 12.11 与其他JavaScript库一起工作\n\n为了描述不是用TypeScript编写的库的形状，我们需要声明该库所暴露的API。\n\n我们把不定义实现的声明称为 \"环境\"。通常情况下，这些都是在`.d.ts`文件中定义的。如果你熟悉C/C++，你可以把它们看作是`.h`文件。让我们来看看几个例子。\n\n### 12.11.1 环境模块\n\n在Node.js中，大多数任务是通过加载一个或多个模块完成的。我们可以在自己的`.d.ts`文件中定义每个模块，并进行顶层导出声明，但把它们写成一个更大的`.d.ts`文件会更方便。要做到这一点，我们使用一个类似于环境命名空间的结构，但我们使用 `module` 关键字和引号的模块名称，这将在以后的导入中可用。比如说：\n\n**node.d.ts (简要摘录)**\n\n```tsx\ndeclare module \"url\" {\n  export interface Url {\n    protocol?: string;\n    hostname?: string;\n    pathname?: string;\n  }\n  export function parse(\n    urlStr: string,\n    parseQueryString?,\n    slashesDenoteHost?,\n  ): Url;\n}\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export var sep: string;\n}\n```\n\n现在我们可以 `/// <reference> node.d.ts`，然后使用 `import url = require(\"url\"); `或 `import * as URL from \"url\"`加载模块。\n\n```tsx\n/// <reference path=\"node.d.ts\"/>\nimport * as URL from \"url\";\nlet myUrl = URL.parse(\"https://www.typescriptlang.org\");\n```\n\n### 12.11.2 速记的环境模块\n\n如果你不想在使用一个新模块之前花时间写出声明，你可以使用速记声明来快速入门。\n\n**declarations.d.ts**\n\n```tsx\ndeclare module \"hot-new-module\";\n```\n\n所有来自速记模块的导入都将具有任意类型。\n\n```tsx\nimport x, { y } from \"hot-new-module\";\nx(y);\n```\n\n### 12.11.3 通配符模块的声明\n\n一些模块加载器，如 [SystemJS](https://github.com/systemjs/systemjs/blob/master/docs/module-types.md) 和 [AMD](https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md) 允许导入非JavaScript内容。这些模块通常使用一个前缀或后缀来表示特殊的加载语义。通配符模块声明可以用来涵盖这些情况。\n\n```tsx\ndeclare module \"*!text\" {\n  const content: string;\n  export default content;\n}\n// 有些人则反其道而行之。\ndeclare module \"json!*\" {\n  const value: any;\n  export default value;\n}\n```\n\n现在你可以导入符合` \"*!text \"`或` \"json!*\"`的东西。\n\n```tsx\nimport fileContent from \"./xyz.txt!text\";\nimport data from \"json!http://example.com/data.json\";\nconsole.log(data, fileContent);\n```\n\n### 12.11.4 UMD 模块\n\n有些库被设计成可以在许多模块加载器中使用，或者没有模块加载（全局变量）也可以。这些被称为UMD模块。这些库可以通过导入或全局变量访问。比如说：\n\n**math-lib.d.ts**\n\n```tsx\nexport function isPrime(x: number): boolean;\nexport as namespace mathLib;\n```\n\n然后，该库可以作为模块内的导入使用：\n\n```tsx\nimport { isPrime } from \"math-lib\";\nisPrime(2);\nmathLib.isPrime(2); // 错误：不能从模块内部使用全局定义\n```\n\n它也可以作为一个全局变量使用，但只能在一个脚本中使用。(脚本是一个没有导入或导出的文件）。\n\n```tsx\nmathLib.isPrime(2);\n```\n\n## 12.12 构建模块的指导意见\n\n### 12.12.1 尽可能接近顶层导出(export)\n\n你的模块的消费者在使用你道出的东西时，应该有尽可能少的困扰。增加过多的嵌套层次往往是很麻烦的，所以要仔细考虑你想如何组织代码。\n\n从你的模块中导出一个命名空间，就是一个增加过多嵌套层次的例子。虽然命名空间有时有其用途，但在使用模块时，它们增加了额外的间接性。这很快就会成为用户的一个痛点，而且通常是不必要的。\n\n输出类上的静态方法也有类似的问题——类本身增加了一层嵌套。除非它以一种明显有用的方式增加了表达能力或意图，否则考虑简单地导出一个辅助函数。\n\n1. **如果你只导出了一个`class`或`function`则使用 `export default`**\n\n正如 \"在顶层导出 \"可以减少模块消费者的困扰，引入一个默认导出也是如此。如果一个模块的主要目的是容纳一个特定的出口，那么你应该考虑把它作为一个默认出口。这使得导入和实际使用导入都更容易一些。比如说：\n\n**MyClass.ts**\n\n```tsx\nexport default class SomeType {\n  constructor() { ... }\n}\n```\n\n**MyFunc.ts**\n\n```tsx\nexport default function getThing() {\n  return \"thing\";\n}\n```\n\n**Consumer.ts**\n\n```tsx\nimport t from \"./MyClass\";\nimport f from \"./MyFunc\";\nlet x = new t();\nconsole.log(f());\n```\n\n这对消费者来说是最好的。他们可以随心所欲地命名你的类型（本例中为`t`），并且不必做任何过度的点缀来寻找你的对象。\n\n2. **如果你要导出多个对象，把它们都放在顶层**\n\n**MyThings.ts**\n\n```tsx\nexport class SomeType {\n  /* ... */\n}\nexport function someFunc() {\n  /* ... */\n}\n```\n\n反之，在导入时，也是如此。\n\n3. **明确列出进口名称**\n\n**Consumer.ts**\n\n```tsx\nimport { SomeType, someFunc } from \"./MyThings\";\nlet x = new SomeType();\nlet y = someFunc();\n```\n\n如果你要导入大量的东西，请使用命名空间导入模式：\n\n**MyLargeModule.ts**\n\n```tsx\nexport class Dog { ... }\nexport class Cat { ... }\nexport class Tree { ... }\nexport class Flower { ... }\n```\n\n**Consumer.ts**\n\n```tsx\nimport * as myLargeModule from \"./MyLargeModule.ts\";\nlet x = new myLargeModule.Dog();\n```\n\n### 12.12.2 扩展的重新导出\n\n通常情况下，你需要在一个模块上扩展功能。一个常见的JS模式是用扩展来增强原始对象，类似于JQuery扩展的工作方式。正如我们之前提到的，模块不会像全局命名空间对象那样进行合并。推荐的解决方案是不改变原始对象，而是导出一个提供新功能的新实体。\n\n考虑一个简单的计算器实现，定义在模块`Calculator.ts`中。该模块还导出了一个辅助函数，通过传递一个输入字符串列表并在最后写入结果，来测试计算器的功能。\n\n**Calculator.ts**\n\n```tsx\nexport class Calculator {\n  private current = 0;\n  private memory = 0;\n  private operator: string;\n  protected processDigit(digit: string, currentValue: number) {\n    if (digit >= \"0\" && digit <= \"9\") {\n      return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0));\n    }\n  }\n  protected processOperator(operator: string) {\n    if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) >= 0) {\n      return operator;\n    }\n  }\n  protected evaluateOperator(\n    operator: string,\n    left: number,\n    right: number,\n  ): number {\n    switch (this.operator) {\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n    }\n  }\n  private evaluate() {\n    if (this.operator) {\n      this.memory = this.evaluateOperator(\n        this.operator,\n        this.memory,\n        this.current,\n      );\n    } else {\n      this.memory = this.current;\n    }\n    this.current = 0;\n  }\n  public handleChar(char: string) {\n    if (char === \"=\") {\n      this.evaluate();\n      return;\n    } else {\n      let value = this.processDigit(char, this.current);\n      if (value !== undefined) {\n        this.current = value;\n        return;\n      } else {\n        let value = this.processOperator(char);\n        if (value !== undefined) {\n          this.evaluate();\n          this.operator = value;\n          return;\n        }\n      }\n    }\n    throw new Error(`Unsupported input: '${char}'`);\n  }\n  public getResult() {\n    return this.memory;\n  }\n}\nexport function test(c: Calculator, input: string) {\n  for (let i = 0; i < input.length; i++) {\n    c.handleChar(input[i]);\n  }\n  console.log(`result of '${input}' is '${c.getResult()}'`);\n}\n```\n\n下面是一个使用暴露测试功能的计算器的简单测试。\n\n**TestCalculator.ts**\n\n```tsx\nimport { Calculator, test } from \"./Calculator\";\nlet c = new Calculator();\ntest(c, \"1+2*33/11=\"); // 输出 9\n```\n\n现在，为了扩展这个功能，以增加对10以外的数字输入的支持，我们来创建 `ProgrammerCalculator.ts`\n\n**ProgrammerCalculator.ts**\n\n```tsx\nimport { Calculator } from \"./Calculator\";\nclass ProgrammerCalculator extends Calculator {\n  static digits = [\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n  ];\n  constructor(public base: number) {\n    super();\n    const maxBase = ProgrammerCalculator.digits.length;\n    if (base <= 0 || base > maxBase) {\n      throw new Error(`base has to be within 0 to ${maxBase} inclusive.`);\n    }\n  }\n  protected processDigit(digit: string, currentValue: number) {\n    if (ProgrammerCalculator.digits.indexOf(digit) >= 0) {\n      return (\n        currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit)\n      );\n    }\n  }\n}\n// 将新的扩展计算器导出为 Calculator\nexport { ProgrammerCalculator as Calculator };\n// 同时，导出辅助函数\nexport { test } from \"./Calculator\";\n```\n\n新模块 `ProgrammerCalculator` 输出的API形状与原来的 `Calculator` 模块相似，但并没有增强原来模块中的任何对象。下面是对我们的`ProgrammerCalculator`类的测试。\n\n**TestProgrammerCalculator.ts**\n\n```tsx\nimport { Calculator, test } from \"./ProgrammerCalculator\";\nlet c = new Calculator(2);\ntest(c, \"001+010=\"); // 输出 3\n```\n\n### 12.12.3 不要在模块中使用命名空间\n\n当第一次转移到基于模块的代码设计时，一个常见的趋势是，将 export 包裹在一个额外的命名空间层中。模块有自己的范围，只有导出的声明在模块外可见。考虑到这一点，如果有命名空间的话，它在使用模块时提供的价值非常小。\n\n在组织方面，命名空间对于在全局范围内，将逻辑上相关的对象和类型组合在一起很方便。例如，在C#中，你会在 `System.Collections` 中找到所有的集合类型。通过将我们的类型组织到分层的命名空间中，我们为这些类型的用户提供了良好的 \"发现 \"体验。另一方面，模块已经存在于文件系统中，是必然的。我们必须通过路径和文件名来解决它们，所以有一个逻辑的组织方案供我们使用。我们可以有一个`/collections/generic/`文件夹，里面有一个列表模块。\n\n命名空间对于避免全局范围内的命名冲突很重要。例如，你可能有 `My.Application.Customer.AddForm`和`My.Application.Order.AddForm`两个名字相同的类型，但名字空间不同。然而，对于模块来说，这不是一个问题。在一个模块中，没有合理的理由让两个对象具有相同的名字。从消费方面来看，任何给定模块的消费者都可以选择他们将用来引用模块的名称，所以意外的命名冲突是不可能的。\n\n### 12.12.4 红线\n\n以下所有情况都是模块结构化的红线。如果你的文件有这些情况，请仔细检查你是否试图，对你的外部模块进行命名空间定义。\n\n- 一个文件的唯一顶层声明是 `export namespace Foo { ... } `(移除`Foo`，并将所有内容 \"上移 \"一个级别）\n- 多个文件在顶层有相同的`export namespace Foo {` (不要以为这些文件会合并成一个 `Foo`!)\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/3-3、高级篇：模块",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjaob002494v3a6ishczd",
        "content": "<h1 id=\"十二、模块\"><a href=\"#十二、模块\" class=\"headerlink\" title=\"十二、模块\"></a>十二、模块</h1><p>从ECMAScript 2015开始，JavaScript有一个模块的概念。TypeScript也有这个概念。</p>\n<p>模块在自己的范围内执行，而不是在全局范围内；这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地使用其中一种 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#export\">导出形式</a>导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用<a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#import\">导入的形式</a>将其导入。</p>\n<p>模块是声明性的；模块之间的关系是在文件级别上以导入和导出的方式指定的。</p>\n<p>模块使用模块加载器相互导入。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖关系。在JavaScript中使用的著名的模块加载器是Node.js的<a href=\"https://wikipedia.org/wiki/CommonJS\">CommonJS</a> 模块的加载器和Web应用程序中<a href=\"https://github.com/amdjs/amdjs-api/blob/master/AMD.md\">AMD</a>模块的 <a href=\"http://requirejs.org/\">RequireJS</a> 加载器。</p>\n<p>在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级 <code>import</code> 或 <code>export</code> 的文件都被认为是一个模块。相反，一个没有任何顶级 <code>import</code> 或 <code>export</code> 声明的文件被视为一个脚本，其内容可在全局范围内使用（因此也可用于模块）。</p>\n<h2 id=\"12-1-导出\"><a href=\"#12-1-导出\" class=\"headerlink\" title=\"12.1 导出\"></a>12.1 导出</h2><h3 id=\"12-1-1-导出声明\"><a href=\"#12-1-1-导出声明\" class=\"headerlink\" title=\"12.1.1 导出声明\"></a>12.1.1 导出声明</h3><p>任何声明（如变量、函数、类、类型别名或接口）都可以通过添加 <code>export</code> 关键字而被导出。</p>\n<p><strong>StringValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StringValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StringValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-1-2-导出别名\"><a href=\"#12-1-2-导出别名\" class=\"headerlink\" title=\"12.1.2 导出别名\"></a>12.1.2 导出别名</h3><p>当导出需要为调用者重新命名时，导出语句很方便，所以上面的例子可以写成：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-1-3-二次导出\"><a href=\"#12-1-3-二次导出\" class=\"headerlink\" title=\"12.1.3 二次导出\"></a>12.1.3 二次导出</h3><p>通常情况下，模块会扩展其他模块，并部分地暴露出它们的一些特性。一个二次导出并不在本地导入，也不引入本地变量。</p>\n<p><strong>ParseIntBasedZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParseIntBasedZipCodeValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; <span class=\"built_in\">parseInt</span>(s).<span class=\"title function_\">toString</span>() === s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 导出原始验证器但重新命名</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> <span class=\"title class_\">RegExpBasedZipCodeValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>另外，一个模块可以包裹一个或多个模块，并使用 <code>export * from &quot;module &quot;</code>语法组合它们的所有导出。</p>\n<p><strong>AllValidators.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StringValidator&quot;</span>; <span class=\"comment\">// 导出&#x27;StringValidator&#x27;接口</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>; <span class=\"comment\">// 导出&#x27;ZipCodeValidator&#x27;类和&#x27;numberRegexp&#x27;常量值</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ParseIntBasedZipCodeValidator&quot;</span>; <span class=\"comment\">//  从&#x27;ZipCodeValidator.ts&#x27;模块导出&#x27;ParseIntBasedZipCodeValidator&#x27;类并重新导出&#x27;RegExpBasedZipCodeValidator&#x27;作为&#x27;ZipCodeValidator&#x27;类的别名。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-4-导入\"><a href=\"#12-4-导入\" class=\"headerlink\" title=\"12.4 导入\"></a>12.4 导入</h2><p>导入和从模块中导出一样简单。导入一个导出的声明是通过使用下面的一个导入表格完成的。</p>\n<h3 id=\"12-4-1-从一个模块中导入一个单一的导出\"><a href=\"#12-4-1-从一个模块中导入一个单一的导出\" class=\"headerlink\" title=\"12.4.1 从一个模块中导入一个单一的导出\"></a>12.4.1 从一个模块中导入一个单一的导出</h3><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br></pre></td></tr></table></figure>\n\n<p>导入也可以被重新命名：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> <span class=\"variable constant_\">ZCV</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> <span class=\"title function_\">ZCV</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-4-2-将整个模块导入到一个变量中，并使用它来访问模块的出口。\"><a href=\"#12-4-2-将整个模块导入到一个变量中，并使用它来访问模块的出口。\" class=\"headerlink\" title=\"12.4.2 将整个模块导入到一个变量中，并使用它来访问模块的出口。\"></a>12.4.2 将整个模块导入到一个变量中，并使用它来访问模块的出口。</h3><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> validator <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> validator.<span class=\"title class_\">ZipCodeValidator</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-4-3-导入一个只有副作用的模块\"><a href=\"#12-4-3-导入一个只有副作用的模块\" class=\"headerlink\" title=\"12.4.3 导入一个只有副作用的模块\"></a>12.4.3 导入一个只有副作用的模块</h3><p>虽然不是推荐的做法，但有些模块设置了一些全局状态，可以被其他模块使用。这些模块可能没有任何出口，或者消费者对它们的任何出口不感兴趣。要导入这些模块，请使用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./my-module.js&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在TypeScript 3.8之前，你可以使用 <code>import</code> 导入一个类型。在TypeScript 3.8中，你可以使用 <code>import</code> 语句导入一个类型，或者使用 <code>import type</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重复使用相同的 import</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">APIResponseType</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./api&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 明确使用导入类型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; <span class=\"title class_\">APIResponseType</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./api&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>import type</code> 总是被保证从你的JavaScript中删除，而且像Babel这样的工具可以通过 <a href=\"https://www.typescriptlang.org/tsconfig#isolatedModules\"><code>isolatedModules</code></a> 编译器标志对你的代码做出更好的假设。你可以在<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports\">3.8 release notes</a> 的发行说明中阅读更多内容。</p>\n<h2 id=\"12-5-默认输出\"><a href=\"#12-5-默认输出\" class=\"headerlink\" title=\"12.5 默认输出\"></a>12.5 默认输出</h2><p>每个模块都可以选择输出一个 <code>default</code> 输出。默认输出用关键字 <code>default</code>标记；每个模块只能有一个 <code>default</code>输出。<code>default</code> 输出使用不同的导入形式导入。</p>\n<p><code>default</code> 导出真的很方便。例如，像jQuery这样的库可能有一个默认导出的jQuery或<code>$</code>，我们可能也会以 <code>$</code>或jQuery的名字导入。</p>\n<p><a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/JQuery.d.ts\">JQuery.d.ts</a></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">let</span> <span class=\"attr\">$</span>: <span class=\"title class_\">JQuery</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> $;</span><br></pre></td></tr></table></figure>\n\n<p><strong>App.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&quot;jquery&quot;</span>;</span><br><span class=\"line\">$(<span class=\"string\">&quot;button.continue&quot;</span>).<span class=\"title function_\">html</span>(<span class=\"string\">&quot;Next Step...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>类和函数声明可以直接作为默认导出而编写。默认导出的类和函数声明名称是可选的。</p>\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; <span class=\"title class_\">ZipCodeValidator</span>.<span class=\"property\">numberRegexp</span>.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> validator <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> <span class=\"title function_\">validator</span>();</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<p><strong>StaticZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> validate <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StaticZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 使用函数验证</span></span><br><span class=\"line\">strings.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; <span class=\"subst\">$&#123;validate(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>default</code> 出口也可以只是数值。</p>\n<p><strong>OneTwoThree.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Log.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> num <span class=\"keyword\">from</span> <span class=\"string\">&quot;./OneTwoThree&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num); <span class=\"comment\">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-6-as-x-导出全部\"><a href=\"#12-6-as-x-导出全部\" class=\"headerlink\" title=\"12.6 as x 导出全部\"></a>12.6 <code>as x</code> 导出全部</h2><p>在TypeScript 3.8中，你可以使用<code>export * as ns</code>作为一种速记方法来重新导出另一个有名字的模块。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">as</span> utilities <span class=\"keyword\">from</span> <span class=\"string\">&quot;./utilities&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这从一个模块中获取所有的依赖性，并使其成为一个导出的字段，你可以像这样导入它：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; utilities &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./index&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-7-export-与import-require\"><a href=\"#12-7-export-与import-require\" class=\"headerlink\" title=\"12.7 export = 与import = require()\"></a>12.7 <code>export =</code> 与<code>import = require()</code></h2><p>CommonJS和AMD通常都有一个 <code>exports</code> 对象的概念，它包含了一个模块的所有出口。</p>\n<p>它们也支持用一个自定义的单一对象来替换 <code>exports</code> 对象。默认的 exports 是为了作为这种行为的替代；然而，两者是不兼容的。TypeScript 支持 <code>export =</code> 来模拟传统的 CommonJS 和 AMD 工作流程。</p>\n<p><code>export =</code> 语法指定了一个从模块导出的单一对象。这可以是一个类，接口，命名空间，函数，或枚举。</p>\n<p>当使用<code>export =</code>导出一个模块时，必须使用TypeScript特定的<code>import module = require(&quot;module&quot;)</code>来导入模块。</p>\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> = <span class=\"title class_\">ZipCodeValidator</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> zip = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 一些可以尝试的样本</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> <span class=\"title function_\">zip</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每个字符串是否通过每个验证器</span></span><br><span class=\"line\">strings.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">    <span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;validator.isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span>`</span>,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-8-模块的代码生成\"><a href=\"#12-8-模块的代码生成\" class=\"headerlink\" title=\"12.8 模块的代码生成\"></a>12.8 模块的代码生成</h2><p>根据编译时指定的模块目标，编译器将为Node.js（<a href=\"http://wiki.commonjs.org/wiki/CommonJS\">CommonJS</a>）、require.js（<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">AMD</a>）、 <a href=\"https://github.com/umdjs/umd\">UMD</a>、 <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>或<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-modules\">ECMAScript 2015本地模块</a>（ES6）模块加载系统生成相应的代码。关于生成的代码中的 <code>define</code>、<code>require</code>和<code>register</code>调用的更多信息，请查阅每个模块加载器的文档。</p>\n<p>这个简单的例子显示了，导入和导出过程中使用的名称，是如何被翻译成模块加载代码的。</p>\n<p><strong>SimpleModule.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> m = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;mod&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> t = m.<span class=\"property\">something</span> + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AMD &#x2F; RequireJS SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./mod&quot;</span>], <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>, mod_1</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">t</span> = mod_1.<span class=\"property\">something</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>CommonJS &#x2F; Node SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mod_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./mod&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">t</span> = mod_1.<span class=\"property\">something</span> + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>UMD SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\">factory</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">module</span> === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v = <span class=\"title function_\">factory</span>(<span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v !== <span class=\"literal\">undefined</span>) <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = v;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; define.<span class=\"property\">amd</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">define</span>([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./mod&quot;</span>], factory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mod_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./mod&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">t</span> = mod_1.<span class=\"property\">something</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>System SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">System</span>.<span class=\"title function_\">register</span>([<span class=\"string\">&quot;./mod&quot;</span>], <span class=\"keyword\">function</span> (<span class=\"params\">exports_1</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mod_1;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">setters</span>: [</span><br><span class=\"line\">      <span class=\"keyword\">function</span> (<span class=\"params\">mod_1_1</span>) &#123;</span><br><span class=\"line\">        mod_1 = mod_1_1;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">execute</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">exports_1</span>(<span class=\"string\">&quot;t&quot;</span>, (t = mod_1.<span class=\"property\">something</span> + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Native ECMAScript 2015 modules SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; something &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./mod&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> t = something + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-9-案例\"><a href=\"#12-9-案例\" class=\"headerlink\" title=\"12.9 案例\"></a>12.9 案例</h2><p>下面，我们整合了之前例子中使用的Validator实现，只从每个模块导出一个命名的导出。</p>\n<p>要进行编译，我们必须在命令行中指定一个模块目标。对于Node.js，使用<code>--module commonjs</code>；对于require.js，使用<code>--module amd</code>。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --<span class=\"variable language_\">module</span> commonjs <span class=\"title class_\">Test</span>.<span class=\"property\">ts</span></span><br></pre></td></tr></table></figure>\n\n<p>编译时，每个模块将成为一个单独的<code>.js</code>文件。与参考标签一样，编译器将遵循 <code>import</code> 语句来编译依赖的文件。</p>\n<p><strong>Validation.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>LettersOnlyValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StringValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> lettersRegexp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LettersOnlyValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lettersRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StringValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StringValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">LettersOnlyValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./LettersOnlyValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 一些可以尝试的样本</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">validators</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">LettersOnlyValidator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每个字符串是否通过每个验证器</span></span><br><span class=\"line\">strings.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">      <span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">        validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">      &#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-10-可选模块加载和其他高级加载场景\"><a href=\"#12-10-可选模块加载和其他高级加载场景\" class=\"headerlink\" title=\"12.10 可选模块加载和其他高级加载场景\"></a>12.10 可选模块加载和其他高级加载场景</h2><p>在某些情况下，你可能只想在某些条件下加载一个模块。在TypeScript中，我们可以使用下面所示的模式来实现这个和其他高级的加载场景，直接调用模块加载器而不失去类型安全。</p>\n<p>编译器会检测每个模块是否在编译好的JavaScript中被使用。如果一个模块的标识符只被用作类型注释的一部分，而从未被用作表达式，那么就不会为该模块编译 <code>require</code> 调用。这种对未使用的引用的消除是一种很好的性能优化，同时也允许对这些模块进行选择性加载。</p>\n<p>该模式的核心思想是，<code>import id = require(&quot;...&quot;) </code>语句使我们能够访问模块所暴露的类型。模块加载器（通过<code>require</code>）被动态地调用，如下面的<code>if</code>块所示。这样就利用了引用隔离的优化，使模块只在需要时才被加载。为了使这种模式发挥作用，重要的是通过 <code>import</code> 定义的符号只在类型位置使用（也就是说，决不在会被编译到JavaScript的位置）。</p>\n<p>为了维护类型安全，我们可以使用 <code>typeof</code> 关键字。<code>typeof</code> 关键字在类型位置上使用时，会产生一个值的类型，在这里是模块的类型。</p>\n<ul>\n<li><strong>Node.js中的动态模块加载</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">require</span>(<span class=\"params\"><span class=\"attr\">moduleName</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> <span class=\"title class_\">Zip</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidation) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title class_\">ZipCodeValidator</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Zip</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (validator.<span class=\"title function_\">isAcceptable</span>(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>例子：在require.js中动态加载模块</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">require</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">moduleNames</span>: <span class=\"built_in\">string</span>[],</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">onLoad</span>: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">Zip</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidation) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>], <span class=\"function\">(<span class=\"params\"><span class=\"title class_\">ZipCodeValidator</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Zip</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>.<span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validator.<span class=\"title function_\">isAcceptable</span>(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>例子：System.js中的动态模块加载</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> <span class=\"title class_\">System</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> <span class=\"title class_\">Zip</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidation) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\"><span class=\"title class_\">ZipCodeValidator</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Zip</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.<span class=\"title function_\">isAcceptable</span>(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-11-与其他JavaScript库一起工作\"><a href=\"#12-11-与其他JavaScript库一起工作\" class=\"headerlink\" title=\"12.11 与其他JavaScript库一起工作\"></a>12.11 与其他JavaScript库一起工作</h2><p>为了描述不是用TypeScript编写的库的形状，我们需要声明该库所暴露的API。</p>\n<p>我们把不定义实现的声明称为 “环境”。通常情况下，这些都是在<code>.d.ts</code>文件中定义的。如果你熟悉C&#x2F;C++，你可以把它们看作是<code>.h</code>文件。让我们来看看几个例子。</p>\n<h3 id=\"12-11-1-环境模块\"><a href=\"#12-11-1-环境模块\" class=\"headerlink\" title=\"12.11.1 环境模块\"></a>12.11.1 环境模块</h3><p>在Node.js中，大多数任务是通过加载一个或多个模块完成的。我们可以在自己的<code>.d.ts</code>文件中定义每个模块，并进行顶层导出声明，但把它们写成一个更大的<code>.d.ts</code>文件会更方便。要做到这一点，我们使用一个类似于环境命名空间的结构，但我们使用 <code>module</code> 关键字和引号的模块名称，这将在以后的导入中可用。比如说：</p>\n<p><strong>node.d.ts (简要摘录)</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;url&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Url</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">protocol</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">hostname</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">pathname</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">parse</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">urlStr</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    parseQueryString?,</span></span><br><span class=\"line\"><span class=\"params\">    slashesDenoteHost?,</span></span><br><span class=\"line\"><span class=\"params\">  </span>): <span class=\"title class_\">Url</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;path&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">normalize</span>(<span class=\"params\"><span class=\"attr\">p</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">join</span>(<span class=\"params\">...<span class=\"attr\">paths</span>: <span class=\"built_in\">any</span>[]</span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">var</span> <span class=\"attr\">sep</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们可以 <code>/// &lt;reference&gt; node.d.ts</code>，然后使用 <code>import url = require(&quot;url&quot;); </code>或 <code>import * as URL from &quot;url&quot;</code>加载模块。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"variable constant_\">URL</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;url&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myUrl = <span class=\"variable constant_\">URL</span>.<span class=\"title function_\">parse</span>(<span class=\"string\">&quot;https://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-11-2-速记的环境模块\"><a href=\"#12-11-2-速记的环境模块\" class=\"headerlink\" title=\"12.11.2 速记的环境模块\"></a>12.11.2 速记的环境模块</h3><p>如果你不想在使用一个新模块之前花时间写出声明，你可以使用速记声明来快速入门。</p>\n<p><strong>declarations.d.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;hot-new-module&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所有来自速记模块的导入都将具有任意类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> x, &#123; y &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;hot-new-module&quot;</span>;</span><br><span class=\"line\"><span class=\"title function_\">x</span>(y);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-11-3-通配符模块的声明\"><a href=\"#12-11-3-通配符模块的声明\" class=\"headerlink\" title=\"12.11.3 通配符模块的声明\"></a>12.11.3 通配符模块的声明</h3><p>一些模块加载器，如 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/module-types.md\">SystemJS</a> 和 <a href=\"https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md\">AMD</a> 允许导入非JavaScript内容。这些模块通常使用一个前缀或后缀来表示特殊的加载语义。通配符模块声明可以用来涵盖这些情况。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;*!text&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> content;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有些人则反其道而行之。</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;json!*&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">value</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在你可以导入符合<code> &quot;*!text &quot;</code>或<code> &quot;json!*&quot;</code>的东西。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fileContent <span class=\"keyword\">from</span> <span class=\"string\">&quot;./xyz.txt!text&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> data <span class=\"keyword\">from</span> <span class=\"string\">&quot;json!http://example.com/data.json&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data, fileContent);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-11-4-UMD-模块\"><a href=\"#12-11-4-UMD-模块\" class=\"headerlink\" title=\"12.11.4 UMD 模块\"></a>12.11.4 UMD 模块</h3><p>有些库被设计成可以在许多模块加载器中使用，或者没有模块加载（全局变量）也可以。这些被称为UMD模块。这些库可以通过导入或全局变量访问。比如说：</p>\n<p><strong>math-lib.d.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">isPrime</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">as</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">mathLib</span>;</span><br></pre></td></tr></table></figure>\n\n<p>然后，该库可以作为模块内的导入使用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; isPrime &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;math-lib&quot;</span>;</span><br><span class=\"line\"><span class=\"title function_\">isPrime</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">mathLib.<span class=\"title function_\">isPrime</span>(<span class=\"number\">2</span>); <span class=\"comment\">// 错误：不能从模块内部使用全局定义</span></span><br></pre></td></tr></table></figure>\n\n<p>它也可以作为一个全局变量使用，但只能在一个脚本中使用。(脚本是一个没有导入或导出的文件）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">mathLib.<span class=\"title function_\">isPrime</span>(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-12-构建模块的指导意见\"><a href=\"#12-12-构建模块的指导意见\" class=\"headerlink\" title=\"12.12 构建模块的指导意见\"></a>12.12 构建模块的指导意见</h2><h3 id=\"12-12-1-尽可能接近顶层导出-export\"><a href=\"#12-12-1-尽可能接近顶层导出-export\" class=\"headerlink\" title=\"12.12.1 尽可能接近顶层导出(export)\"></a>12.12.1 尽可能接近顶层导出(export)</h3><p>你的模块的消费者在使用你道出的东西时，应该有尽可能少的困扰。增加过多的嵌套层次往往是很麻烦的，所以要仔细考虑你想如何组织代码。</p>\n<p>从你的模块中导出一个命名空间，就是一个增加过多嵌套层次的例子。虽然命名空间有时有其用途，但在使用模块时，它们增加了额外的间接性。这很快就会成为用户的一个痛点，而且通常是不必要的。</p>\n<p>输出类上的静态方法也有类似的问题——类本身增加了一层嵌套。除非它以一种明显有用的方式增加了表达能力或意图，否则考虑简单地导出一个辅助函数。</p>\n<ol>\n<li><strong>如果你只导出了一个<code>class</code>或<code>function</code>则使用 <code>export default</code></strong></li>\n</ol>\n<p>正如 “在顶层导出 “可以减少模块消费者的困扰，引入一个默认导出也是如此。如果一个模块的主要目的是容纳一个特定的出口，那么你应该考虑把它作为一个默认出口。这使得导入和实际使用导入都更容易一些。比如说：</p>\n<p><strong>MyClass.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeType</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>MyFunc.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getThing</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;thing&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> t <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyClass&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> f <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyFunc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> <span class=\"title function_\">t</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">f</span>());</span><br></pre></td></tr></table></figure>\n\n<p>这对消费者来说是最好的。他们可以随心所欲地命名你的类型（本例中为<code>t</code>），并且不必做任何过度的点缀来寻找你的对象。</p>\n<ol start=\"2\">\n<li><strong>如果你要导出多个对象，把它们都放在顶层</strong></li>\n</ol>\n<p><strong>MyThings.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeType</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">someFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反之，在导入时，也是如此。</p>\n<ol start=\"3\">\n<li><strong>明确列出进口名称</strong></li>\n</ol>\n<p><strong>Consumer.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">SomeType</span>, someFunc &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyThings&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> <span class=\"title class_\">SomeType</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"title function_\">someFunc</span>();</span><br></pre></td></tr></table></figure>\n\n<p>如果你要导入大量的东西，请使用命名空间导入模式：</p>\n<p><strong>MyLargeModule.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Tree</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Flower</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> myLargeModule <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyLargeModule.ts&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> myLargeModule.<span class=\"title class_\">Dog</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-12-2-扩展的重新导出\"><a href=\"#12-12-2-扩展的重新导出\" class=\"headerlink\" title=\"12.12.2 扩展的重新导出\"></a>12.12.2 扩展的重新导出</h3><p>通常情况下，你需要在一个模块上扩展功能。一个常见的JS模式是用扩展来增强原始对象，类似于JQuery扩展的工作方式。正如我们之前提到的，模块不会像全局命名空间对象那样进行合并。推荐的解决方案是不改变原始对象，而是导出一个提供新功能的新实体。</p>\n<p>考虑一个简单的计算器实现，定义在模块<code>Calculator.ts</code>中。该模块还导出了一个辅助函数，通过传递一个输入字符串列表并在最后写入结果，来测试计算器的功能。</p>\n<p><strong>Calculator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Calculator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> memory = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">operator</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">processDigit</span>(<span class=\"params\"><span class=\"attr\">digit</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">currentValue</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digit &gt;= <span class=\"string\">&quot;0&quot;</span> &amp;&amp; digit &lt;= <span class=\"string\">&quot;9&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> currentValue * <span class=\"number\">10</span> + (digit.<span class=\"title function_\">charCodeAt</span>(<span class=\"number\">0</span>) - <span class=\"string\">&quot;0&quot;</span>.<span class=\"title function_\">charCodeAt</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">processOperator</span>(<span class=\"params\"><span class=\"attr\">operator</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;/&quot;</span>].<span class=\"title function_\">indexOf</span>(operator) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> operator;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">evaluateOperator</span>(</span><br><span class=\"line\">    <span class=\"attr\">operator</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">    <span class=\"attr\">left</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">    <span class=\"attr\">right</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">  ): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">operator</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left - right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left * right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left / right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">evaluate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">operator</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">memory</span> = <span class=\"variable language_\">this</span>.<span class=\"title function_\">evaluateOperator</span>(</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">operator</span>,</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">memory</span>,</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">current</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">memory</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">current</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">current</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">handleChar</span>(<span class=\"params\"><span class=\"attr\">char</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (char === <span class=\"string\">&quot;=&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">evaluate</span>();</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> value = <span class=\"variable language_\">this</span>.<span class=\"title function_\">processDigit</span>(char, <span class=\"variable language_\">this</span>.<span class=\"property\">current</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">current</span> = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"variable language_\">this</span>.<span class=\"title function_\">processOperator</span>(char);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">evaluate</span>();</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">operator</span> = value;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`Unsupported input: &#x27;<span class=\"subst\">$&#123;char&#125;</span>&#x27;`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">getResult</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">memory</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"><span class=\"attr\">c</span>: <span class=\"title class_\">Calculator</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; input.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    c.<span class=\"title function_\">handleChar</span>(input[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`result of &#x27;<span class=\"subst\">$&#123;input&#125;</span>&#x27; is &#x27;<span class=\"subst\">$&#123;c.getResult()&#125;</span>&#x27;`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个使用暴露测试功能的计算器的简单测试。</p>\n<p><strong>TestCalculator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Calculator</span>, test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">Calculator</span>();</span><br><span class=\"line\"><span class=\"title function_\">test</span>(c, <span class=\"string\">&quot;1+2*33/11=&quot;</span>); <span class=\"comment\">// 输出 9</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，为了扩展这个功能，以增加对10以外的数字输入的支持，我们来创建 <code>ProgrammerCalculator.ts</code></p>\n<p><strong>ProgrammerCalculator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Calculator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ProgrammerCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Calculator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> digits = [</span><br><span class=\"line\">    <span class=\"string\">&quot;0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;2&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;3&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;4&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;6&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;7&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;8&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;9&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;A&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;B&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;C&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;D&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;E&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;F&quot;</span>,</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> <span class=\"attr\">base</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> maxBase = <span class=\"title class_\">ProgrammerCalculator</span>.<span class=\"property\">digits</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (base &lt;= <span class=\"number\">0</span> || base &gt; maxBase) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`base has to be within 0 to <span class=\"subst\">$&#123;maxBase&#125;</span> inclusive.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">processDigit</span>(<span class=\"params\"><span class=\"attr\">digit</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">currentValue</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">ProgrammerCalculator</span>.<span class=\"property\">digits</span>.<span class=\"title function_\">indexOf</span>(digit) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        currentValue * <span class=\"variable language_\">this</span>.<span class=\"property\">base</span> + <span class=\"title class_\">ProgrammerCalculator</span>.<span class=\"property\">digits</span>.<span class=\"title function_\">indexOf</span>(digit)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将新的扩展计算器导出为 Calculator</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"title class_\">ProgrammerCalculator</span> <span class=\"keyword\">as</span> <span class=\"title class_\">Calculator</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 同时，导出辅助函数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>新模块 <code>ProgrammerCalculator</code> 输出的API形状与原来的 <code>Calculator</code> 模块相似，但并没有增强原来模块中的任何对象。下面是对我们的<code>ProgrammerCalculator</code>类的测试。</p>\n<p><strong>TestProgrammerCalculator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Calculator</span>, test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ProgrammerCalculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">Calculator</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"title function_\">test</span>(c, <span class=\"string\">&quot;001+010=&quot;</span>); <span class=\"comment\">// 输出 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-12-3-不要在模块中使用命名空间\"><a href=\"#12-12-3-不要在模块中使用命名空间\" class=\"headerlink\" title=\"12.12.3 不要在模块中使用命名空间\"></a>12.12.3 不要在模块中使用命名空间</h3><p>当第一次转移到基于模块的代码设计时，一个常见的趋势是，将 export 包裹在一个额外的命名空间层中。模块有自己的范围，只有导出的声明在模块外可见。考虑到这一点，如果有命名空间的话，它在使用模块时提供的价值非常小。</p>\n<p>在组织方面，命名空间对于在全局范围内，将逻辑上相关的对象和类型组合在一起很方便。例如，在C#中，你会在 <code>System.Collections</code> 中找到所有的集合类型。通过将我们的类型组织到分层的命名空间中，我们为这些类型的用户提供了良好的 “发现 “体验。另一方面，模块已经存在于文件系统中，是必然的。我们必须通过路径和文件名来解决它们，所以有一个逻辑的组织方案供我们使用。我们可以有一个<code>/collections/generic/</code>文件夹，里面有一个列表模块。</p>\n<p>命名空间对于避免全局范围内的命名冲突很重要。例如，你可能有 <code>My.Application.Customer.AddForm</code>和<code>My.Application.Order.AddForm</code>两个名字相同的类型，但名字空间不同。然而，对于模块来说，这不是一个问题。在一个模块中，没有合理的理由让两个对象具有相同的名字。从消费方面来看，任何给定模块的消费者都可以选择他们将用来引用模块的名称，所以意外的命名冲突是不可能的。</p>\n<h3 id=\"12-12-4-红线\"><a href=\"#12-12-4-红线\" class=\"headerlink\" title=\"12.12.4 红线\"></a>12.12.4 红线</h3><p>以下所有情况都是模块结构化的红线。如果你的文件有这些情况，请仔细检查你是否试图，对你的外部模块进行命名空间定义。</p>\n<ul>\n<li>一个文件的唯一顶层声明是 <code>export namespace Foo &#123; ... &#125; </code>(移除<code>Foo</code>，并将所有内容 “上移 “一个级别）</li>\n<li>多个文件在顶层有相同的<code>export namespace Foo &#123;</code> (不要以为这些文件会合并成一个 <code>Foo</code>!)</li>\n</ul>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"十二、模块\"><a href=\"#十二、模块\" class=\"headerlink\" title=\"十二、模块\"></a>十二、模块</h1><p>从ECMAScript 2015开始，JavaScript有一个模块的概念。TypeScript也有这个概念。</p>\n<p>模块在自己的范围内执行，而不是在全局范围内；这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地使用其中一种 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#export\">导出形式</a>导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用<a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#import\">导入的形式</a>将其导入。</p>\n<p>模块是声明性的；模块之间的关系是在文件级别上以导入和导出的方式指定的。</p>\n<p>模块使用模块加载器相互导入。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖关系。在JavaScript中使用的著名的模块加载器是Node.js的<a href=\"https://wikipedia.org/wiki/CommonJS\">CommonJS</a> 模块的加载器和Web应用程序中<a href=\"https://github.com/amdjs/amdjs-api/blob/master/AMD.md\">AMD</a>模块的 <a href=\"http://requirejs.org/\">RequireJS</a> 加载器。</p>\n<p>在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级 <code>import</code> 或 <code>export</code> 的文件都被认为是一个模块。相反，一个没有任何顶级 <code>import</code> 或 <code>export</code> 声明的文件被视为一个脚本，其内容可在全局范围内使用（因此也可用于模块）。</p>\n<h2 id=\"12-1-导出\"><a href=\"#12-1-导出\" class=\"headerlink\" title=\"12.1 导出\"></a>12.1 导出</h2><h3 id=\"12-1-1-导出声明\"><a href=\"#12-1-1-导出声明\" class=\"headerlink\" title=\"12.1.1 导出声明\"></a>12.1.1 导出声明</h3><p>任何声明（如变量、函数、类、类型别名或接口）都可以通过添加 <code>export</code> 关键字而被导出。</p>\n<p><strong>StringValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StringValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StringValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-1-2-导出别名\"><a href=\"#12-1-2-导出别名\" class=\"headerlink\" title=\"12.1.2 导出别名\"></a>12.1.2 导出别名</h3><p>当导出需要为调用者重新命名时，导出语句很方便，所以上面的例子可以写成：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-1-3-二次导出\"><a href=\"#12-1-3-二次导出\" class=\"headerlink\" title=\"12.1.3 二次导出\"></a>12.1.3 二次导出</h3><p>通常情况下，模块会扩展其他模块，并部分地暴露出它们的一些特性。一个二次导出并不在本地导入，也不引入本地变量。</p>\n<p><strong>ParseIntBasedZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParseIntBasedZipCodeValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; <span class=\"built_in\">parseInt</span>(s).<span class=\"title function_\">toString</span>() === s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 导出原始验证器但重新命名</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> <span class=\"title class_\">RegExpBasedZipCodeValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>另外，一个模块可以包裹一个或多个模块，并使用 <code>export * from &quot;module &quot;</code>语法组合它们的所有导出。</p>\n<p><strong>AllValidators.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StringValidator&quot;</span>; <span class=\"comment\">// 导出&#x27;StringValidator&#x27;接口</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>; <span class=\"comment\">// 导出&#x27;ZipCodeValidator&#x27;类和&#x27;numberRegexp&#x27;常量值</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ParseIntBasedZipCodeValidator&quot;</span>; <span class=\"comment\">//  从&#x27;ZipCodeValidator.ts&#x27;模块导出&#x27;ParseIntBasedZipCodeValidator&#x27;类并重新导出&#x27;RegExpBasedZipCodeValidator&#x27;作为&#x27;ZipCodeValidator&#x27;类的别名。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-4-导入\"><a href=\"#12-4-导入\" class=\"headerlink\" title=\"12.4 导入\"></a>12.4 导入</h2><p>导入和从模块中导出一样简单。导入一个导出的声明是通过使用下面的一个导入表格完成的。</p>\n<h3 id=\"12-4-1-从一个模块中导入一个单一的导出\"><a href=\"#12-4-1-从一个模块中导入一个单一的导出\" class=\"headerlink\" title=\"12.4.1 从一个模块中导入一个单一的导出\"></a>12.4.1 从一个模块中导入一个单一的导出</h3><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br></pre></td></tr></table></figure>\n\n<p>导入也可以被重新命名：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> <span class=\"variable constant_\">ZCV</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> <span class=\"title function_\">ZCV</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-4-2-将整个模块导入到一个变量中，并使用它来访问模块的出口。\"><a href=\"#12-4-2-将整个模块导入到一个变量中，并使用它来访问模块的出口。\" class=\"headerlink\" title=\"12.4.2 将整个模块导入到一个变量中，并使用它来访问模块的出口。\"></a>12.4.2 将整个模块导入到一个变量中，并使用它来访问模块的出口。</h3><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> validator <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> validator.<span class=\"title class_\">ZipCodeValidator</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-4-3-导入一个只有副作用的模块\"><a href=\"#12-4-3-导入一个只有副作用的模块\" class=\"headerlink\" title=\"12.4.3 导入一个只有副作用的模块\"></a>12.4.3 导入一个只有副作用的模块</h3><p>虽然不是推荐的做法，但有些模块设置了一些全局状态，可以被其他模块使用。这些模块可能没有任何出口，或者消费者对它们的任何出口不感兴趣。要导入这些模块，请使用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./my-module.js&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在TypeScript 3.8之前，你可以使用 <code>import</code> 导入一个类型。在TypeScript 3.8中，你可以使用 <code>import</code> 语句导入一个类型，或者使用 <code>import type</code>。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重复使用相同的 import</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">APIResponseType</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./api&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 明确使用导入类型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">type</span> &#123; <span class=\"title class_\">APIResponseType</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./api&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>import type</code> 总是被保证从你的JavaScript中删除，而且像Babel这样的工具可以通过 <a href=\"https://www.typescriptlang.org/tsconfig#isolatedModules\"><code>isolatedModules</code></a> 编译器标志对你的代码做出更好的假设。你可以在<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports\">3.8 release notes</a> 的发行说明中阅读更多内容。</p>\n<h2 id=\"12-5-默认输出\"><a href=\"#12-5-默认输出\" class=\"headerlink\" title=\"12.5 默认输出\"></a>12.5 默认输出</h2><p>每个模块都可以选择输出一个 <code>default</code> 输出。默认输出用关键字 <code>default</code>标记；每个模块只能有一个 <code>default</code>输出。<code>default</code> 输出使用不同的导入形式导入。</p>\n<p><code>default</code> 导出真的很方便。例如，像jQuery这样的库可能有一个默认导出的jQuery或<code>$</code>，我们可能也会以 <code>$</code>或jQuery的名字导入。</p>\n<p><a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/JQuery.d.ts\">JQuery.d.ts</a></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">let</span> <span class=\"attr\">$</span>: <span class=\"title class_\">JQuery</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> $;</span><br></pre></td></tr></table></figure>\n\n<p><strong>App.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&quot;jquery&quot;</span>;</span><br><span class=\"line\">$(<span class=\"string\">&quot;button.continue&quot;</span>).<span class=\"title function_\">html</span>(<span class=\"string\">&quot;Next Step...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>类和函数声明可以直接作为默认导出而编写。默认导出的类和函数声明名称是可选的。</p>\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; <span class=\"title class_\">ZipCodeValidator</span>.<span class=\"property\">numberRegexp</span>.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> validator <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> <span class=\"title function_\">validator</span>();</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<p><strong>StaticZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> validate <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StaticZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 使用函数验证</span></span><br><span class=\"line\">strings.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; <span class=\"subst\">$&#123;validate(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>default</code> 出口也可以只是数值。</p>\n<p><strong>OneTwoThree.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Log.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> num <span class=\"keyword\">from</span> <span class=\"string\">&quot;./OneTwoThree&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num); <span class=\"comment\">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-6-as-x-导出全部\"><a href=\"#12-6-as-x-导出全部\" class=\"headerlink\" title=\"12.6 as x 导出全部\"></a>12.6 <code>as x</code> 导出全部</h2><p>在TypeScript 3.8中，你可以使用<code>export * as ns</code>作为一种速记方法来重新导出另一个有名字的模块。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">as</span> utilities <span class=\"keyword\">from</span> <span class=\"string\">&quot;./utilities&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这从一个模块中获取所有的依赖性，并使其成为一个导出的字段，你可以像这样导入它：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; utilities &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./index&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-7-export-与import-require\"><a href=\"#12-7-export-与import-require\" class=\"headerlink\" title=\"12.7 export = 与import = require()\"></a>12.7 <code>export =</code> 与<code>import = require()</code></h2><p>CommonJS和AMD通常都有一个 <code>exports</code> 对象的概念，它包含了一个模块的所有出口。</p>\n<p>它们也支持用一个自定义的单一对象来替换 <code>exports</code> 对象。默认的 exports 是为了作为这种行为的替代；然而，两者是不兼容的。TypeScript 支持 <code>export =</code> 来模拟传统的 CommonJS 和 AMD 工作流程。</p>\n<p><code>export =</code> 语法指定了一个从模块导出的单一对象。这可以是一个类，接口，命名空间，函数，或枚举。</p>\n<p>当使用<code>export =</code>导出一个模块时，必须使用TypeScript特定的<code>import module = require(&quot;module&quot;)</code>来导入模块。</p>\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> = <span class=\"title class_\">ZipCodeValidator</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> zip = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 一些可以尝试的样本</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> <span class=\"title function_\">zip</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每个字符串是否通过每个验证器</span></span><br><span class=\"line\">strings.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">    <span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;validator.isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span>`</span>,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-8-模块的代码生成\"><a href=\"#12-8-模块的代码生成\" class=\"headerlink\" title=\"12.8 模块的代码生成\"></a>12.8 模块的代码生成</h2><p>根据编译时指定的模块目标，编译器将为Node.js（<a href=\"http://wiki.commonjs.org/wiki/CommonJS\">CommonJS</a>）、require.js（<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">AMD</a>）、 <a href=\"https://github.com/umdjs/umd\">UMD</a>、 <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>或<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-modules\">ECMAScript 2015本地模块</a>（ES6）模块加载系统生成相应的代码。关于生成的代码中的 <code>define</code>、<code>require</code>和<code>register</code>调用的更多信息，请查阅每个模块加载器的文档。</p>\n<p>这个简单的例子显示了，导入和导出过程中使用的名称，是如何被翻译成模块加载代码的。</p>\n<p><strong>SimpleModule.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> m = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;mod&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> t = m.<span class=\"property\">something</span> + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AMD &#x2F; RequireJS SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./mod&quot;</span>], <span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>, mod_1</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">t</span> = mod_1.<span class=\"property\">something</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>CommonJS &#x2F; Node SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mod_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./mod&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">t</span> = mod_1.<span class=\"property\">something</span> + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>UMD SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\">factory</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">module</span> === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v = <span class=\"title function_\">factory</span>(<span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v !== <span class=\"literal\">undefined</span>) <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = v;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; define.<span class=\"property\">amd</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">define</span>([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./mod&quot;</span>], factory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mod_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./mod&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.<span class=\"property\">t</span> = mod_1.<span class=\"property\">something</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>System SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">System</span>.<span class=\"title function_\">register</span>([<span class=\"string\">&quot;./mod&quot;</span>], <span class=\"keyword\">function</span> (<span class=\"params\">exports_1</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> mod_1;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">setters</span>: [</span><br><span class=\"line\">      <span class=\"keyword\">function</span> (<span class=\"params\">mod_1_1</span>) &#123;</span><br><span class=\"line\">        mod_1 = mod_1_1;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">execute</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">exports_1</span>(<span class=\"string\">&quot;t&quot;</span>, (t = mod_1.<span class=\"property\">something</span> + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>Native ECMAScript 2015 modules SimpleModule.js</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; something &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./mod&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> t = something + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-9-案例\"><a href=\"#12-9-案例\" class=\"headerlink\" title=\"12.9 案例\"></a>12.9 案例</h2><p>下面，我们整合了之前例子中使用的Validator实现，只从每个模块导出一个命名的导出。</p>\n<p>要进行编译，我们必须在命令行中指定一个模块目标。对于Node.js，使用<code>--module commonjs</code>；对于require.js，使用<code>--module amd</code>。比如说：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --<span class=\"variable language_\">module</span> commonjs <span class=\"title class_\">Test</span>.<span class=\"property\">ts</span></span><br></pre></td></tr></table></figure>\n\n<p>编译时，每个模块将成为一个单独的<code>.js</code>文件。与参考标签一样，编译器将遵循 <code>import</code> 语句来编译依赖的文件。</p>\n<p><strong>Validation.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>LettersOnlyValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StringValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> lettersRegexp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LettersOnlyValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lettersRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StringValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">StringValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">LettersOnlyValidator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./LettersOnlyValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 一些可以尝试的样本</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">validators</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">LettersOnlyValidator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每个字符串是否通过每个验证器</span></span><br><span class=\"line\">strings.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">      <span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">        validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">      &#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-10-可选模块加载和其他高级加载场景\"><a href=\"#12-10-可选模块加载和其他高级加载场景\" class=\"headerlink\" title=\"12.10 可选模块加载和其他高级加载场景\"></a>12.10 可选模块加载和其他高级加载场景</h2><p>在某些情况下，你可能只想在某些条件下加载一个模块。在TypeScript中，我们可以使用下面所示的模式来实现这个和其他高级的加载场景，直接调用模块加载器而不失去类型安全。</p>\n<p>编译器会检测每个模块是否在编译好的JavaScript中被使用。如果一个模块的标识符只被用作类型注释的一部分，而从未被用作表达式，那么就不会为该模块编译 <code>require</code> 调用。这种对未使用的引用的消除是一种很好的性能优化，同时也允许对这些模块进行选择性加载。</p>\n<p>该模式的核心思想是，<code>import id = require(&quot;...&quot;) </code>语句使我们能够访问模块所暴露的类型。模块加载器（通过<code>require</code>）被动态地调用，如下面的<code>if</code>块所示。这样就利用了引用隔离的优化，使模块只在需要时才被加载。为了使这种模式发挥作用，重要的是通过 <code>import</code> 定义的符号只在类型位置使用（也就是说，决不在会被编译到JavaScript的位置）。</p>\n<p>为了维护类型安全，我们可以使用 <code>typeof</code> 关键字。<code>typeof</code> 关键字在类型位置上使用时，会产生一个值的类型，在这里是模块的类型。</p>\n<ul>\n<li><strong>Node.js中的动态模块加载</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">require</span>(<span class=\"params\"><span class=\"attr\">moduleName</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> <span class=\"title class_\">Zip</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidation) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title class_\">ZipCodeValidator</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Zip</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (validator.<span class=\"title function_\">isAcceptable</span>(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>例子：在require.js中动态加载模块</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title function_\">require</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">moduleNames</span>: <span class=\"built_in\">string</span>[],</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"attr\">onLoad</span>: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span>,</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"title class_\">Zip</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidation) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>], <span class=\"function\">(<span class=\"params\"><span class=\"title class_\">ZipCodeValidator</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Zip</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>.<span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validator.<span class=\"title function_\">isAcceptable</span>(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>例子：System.js中的动态模块加载</strong></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> <span class=\"title class_\">System</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">as</span> <span class=\"title class_\">Zip</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidation) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\"><span class=\"title class_\">ZipCodeValidator</span>: <span class=\"keyword\">typeof</span> <span class=\"title class_\">Zip</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.<span class=\"title function_\">isAcceptable</span>(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-11-与其他JavaScript库一起工作\"><a href=\"#12-11-与其他JavaScript库一起工作\" class=\"headerlink\" title=\"12.11 与其他JavaScript库一起工作\"></a>12.11 与其他JavaScript库一起工作</h2><p>为了描述不是用TypeScript编写的库的形状，我们需要声明该库所暴露的API。</p>\n<p>我们把不定义实现的声明称为 “环境”。通常情况下，这些都是在<code>.d.ts</code>文件中定义的。如果你熟悉C&#x2F;C++，你可以把它们看作是<code>.h</code>文件。让我们来看看几个例子。</p>\n<h3 id=\"12-11-1-环境模块\"><a href=\"#12-11-1-环境模块\" class=\"headerlink\" title=\"12.11.1 环境模块\"></a>12.11.1 环境模块</h3><p>在Node.js中，大多数任务是通过加载一个或多个模块完成的。我们可以在自己的<code>.d.ts</code>文件中定义每个模块，并进行顶层导出声明，但把它们写成一个更大的<code>.d.ts</code>文件会更方便。要做到这一点，我们使用一个类似于环境命名空间的结构，但我们使用 <code>module</code> 关键字和引号的模块名称，这将在以后的导入中可用。比如说：</p>\n<p><strong>node.d.ts (简要摘录)</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;url&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Url</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">protocol</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">hostname</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">pathname</span>?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">parse</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"attr\">urlStr</span>: <span class=\"built_in\">string</span>,</span></span><br><span class=\"line\"><span class=\"params\">    parseQueryString?,</span></span><br><span class=\"line\"><span class=\"params\">    slashesDenoteHost?,</span></span><br><span class=\"line\"><span class=\"params\">  </span>): <span class=\"title class_\">Url</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;path&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">normalize</span>(<span class=\"params\"><span class=\"attr\">p</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">join</span>(<span class=\"params\">...<span class=\"attr\">paths</span>: <span class=\"built_in\">any</span>[]</span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">var</span> <span class=\"attr\">sep</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们可以 <code>/// &lt;reference&gt; node.d.ts</code>，然后使用 <code>import url = require(&quot;url&quot;); </code>或 <code>import * as URL from &quot;url&quot;</code>加载模块。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;node.d.ts&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"variable constant_\">URL</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;url&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myUrl = <span class=\"variable constant_\">URL</span>.<span class=\"title function_\">parse</span>(<span class=\"string\">&quot;https://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-11-2-速记的环境模块\"><a href=\"#12-11-2-速记的环境模块\" class=\"headerlink\" title=\"12.11.2 速记的环境模块\"></a>12.11.2 速记的环境模块</h3><p>如果你不想在使用一个新模块之前花时间写出声明，你可以使用速记声明来快速入门。</p>\n<p><strong>declarations.d.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;hot-new-module&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所有来自速记模块的导入都将具有任意类型。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> x, &#123; y &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;hot-new-module&quot;</span>;</span><br><span class=\"line\"><span class=\"title function_\">x</span>(y);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-11-3-通配符模块的声明\"><a href=\"#12-11-3-通配符模块的声明\" class=\"headerlink\" title=\"12.11.3 通配符模块的声明\"></a>12.11.3 通配符模块的声明</h3><p>一些模块加载器，如 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/module-types.md\">SystemJS</a> 和 <a href=\"https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md\">AMD</a> 允许导入非JavaScript内容。这些模块通常使用一个前缀或后缀来表示特殊的加载语义。通配符模块声明可以用来涵盖这些情况。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;*!text&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> content;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有些人则反其道而行之。</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;json!*&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"attr\">value</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在你可以导入符合<code> &quot;*!text &quot;</code>或<code> &quot;json!*&quot;</code>的东西。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fileContent <span class=\"keyword\">from</span> <span class=\"string\">&quot;./xyz.txt!text&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> data <span class=\"keyword\">from</span> <span class=\"string\">&quot;json!http://example.com/data.json&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data, fileContent);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-11-4-UMD-模块\"><a href=\"#12-11-4-UMD-模块\" class=\"headerlink\" title=\"12.11.4 UMD 模块\"></a>12.11.4 UMD 模块</h3><p>有些库被设计成可以在许多模块加载器中使用，或者没有模块加载（全局变量）也可以。这些被称为UMD模块。这些库可以通过导入或全局变量访问。比如说：</p>\n<p><strong>math-lib.d.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">isPrime</span>(<span class=\"params\"><span class=\"attr\">x</span>: <span class=\"built_in\">number</span></span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">as</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">mathLib</span>;</span><br></pre></td></tr></table></figure>\n\n<p>然后，该库可以作为模块内的导入使用：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; isPrime &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;math-lib&quot;</span>;</span><br><span class=\"line\"><span class=\"title function_\">isPrime</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">mathLib.<span class=\"title function_\">isPrime</span>(<span class=\"number\">2</span>); <span class=\"comment\">// 错误：不能从模块内部使用全局定义</span></span><br></pre></td></tr></table></figure>\n\n<p>它也可以作为一个全局变量使用，但只能在一个脚本中使用。(脚本是一个没有导入或导出的文件）。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">mathLib.<span class=\"title function_\">isPrime</span>(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-12-构建模块的指导意见\"><a href=\"#12-12-构建模块的指导意见\" class=\"headerlink\" title=\"12.12 构建模块的指导意见\"></a>12.12 构建模块的指导意见</h2><h3 id=\"12-12-1-尽可能接近顶层导出-export\"><a href=\"#12-12-1-尽可能接近顶层导出-export\" class=\"headerlink\" title=\"12.12.1 尽可能接近顶层导出(export)\"></a>12.12.1 尽可能接近顶层导出(export)</h3><p>你的模块的消费者在使用你道出的东西时，应该有尽可能少的困扰。增加过多的嵌套层次往往是很麻烦的，所以要仔细考虑你想如何组织代码。</p>\n<p>从你的模块中导出一个命名空间，就是一个增加过多嵌套层次的例子。虽然命名空间有时有其用途，但在使用模块时，它们增加了额外的间接性。这很快就会成为用户的一个痛点，而且通常是不必要的。</p>\n<p>输出类上的静态方法也有类似的问题——类本身增加了一层嵌套。除非它以一种明显有用的方式增加了表达能力或意图，否则考虑简单地导出一个辅助函数。</p>\n<ol>\n<li><strong>如果你只导出了一个<code>class</code>或<code>function</code>则使用 <code>export default</code></strong></li>\n</ol>\n<p>正如 “在顶层导出 “可以减少模块消费者的困扰，引入一个默认导出也是如此。如果一个模块的主要目的是容纳一个特定的出口，那么你应该考虑把它作为一个默认出口。这使得导入和实际使用导入都更容易一些。比如说：</p>\n<p><strong>MyClass.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeType</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>MyFunc.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getThing</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;thing&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> t <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyClass&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> f <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyFunc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> <span class=\"title function_\">t</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">f</span>());</span><br></pre></td></tr></table></figure>\n\n<p>这对消费者来说是最好的。他们可以随心所欲地命名你的类型（本例中为<code>t</code>），并且不必做任何过度的点缀来寻找你的对象。</p>\n<ol start=\"2\">\n<li><strong>如果你要导出多个对象，把它们都放在顶层</strong></li>\n</ol>\n<p><strong>MyThings.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SomeType</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">someFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反之，在导入时，也是如此。</p>\n<ol start=\"3\">\n<li><strong>明确列出进口名称</strong></li>\n</ol>\n<p><strong>Consumer.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">SomeType</span>, someFunc &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyThings&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> <span class=\"title class_\">SomeType</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"title function_\">someFunc</span>();</span><br></pre></td></tr></table></figure>\n\n<p>如果你要导入大量的东西，请使用命名空间导入模式：</p>\n<p><strong>MyLargeModule.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Tree</span> &#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Flower</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> myLargeModule <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyLargeModule.ts&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> myLargeModule.<span class=\"title class_\">Dog</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-12-2-扩展的重新导出\"><a href=\"#12-12-2-扩展的重新导出\" class=\"headerlink\" title=\"12.12.2 扩展的重新导出\"></a>12.12.2 扩展的重新导出</h3><p>通常情况下，你需要在一个模块上扩展功能。一个常见的JS模式是用扩展来增强原始对象，类似于JQuery扩展的工作方式。正如我们之前提到的，模块不会像全局命名空间对象那样进行合并。推荐的解决方案是不改变原始对象，而是导出一个提供新功能的新实体。</p>\n<p>考虑一个简单的计算器实现，定义在模块<code>Calculator.ts</code>中。该模块还导出了一个辅助函数，通过传递一个输入字符串列表并在最后写入结果，来测试计算器的功能。</p>\n<p><strong>Calculator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Calculator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> memory = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"attr\">operator</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">processDigit</span>(<span class=\"params\"><span class=\"attr\">digit</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">currentValue</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digit &gt;= <span class=\"string\">&quot;0&quot;</span> &amp;&amp; digit &lt;= <span class=\"string\">&quot;9&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> currentValue * <span class=\"number\">10</span> + (digit.<span class=\"title function_\">charCodeAt</span>(<span class=\"number\">0</span>) - <span class=\"string\">&quot;0&quot;</span>.<span class=\"title function_\">charCodeAt</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">processOperator</span>(<span class=\"params\"><span class=\"attr\">operator</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;/&quot;</span>].<span class=\"title function_\">indexOf</span>(operator) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> operator;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">evaluateOperator</span>(</span><br><span class=\"line\">    <span class=\"attr\">operator</span>: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">    <span class=\"attr\">left</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">    <span class=\"attr\">right</span>: <span class=\"built_in\">number</span>,</span><br><span class=\"line\">  ): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">operator</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left - right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left * right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left / right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"title function_\">evaluate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">operator</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">memory</span> = <span class=\"variable language_\">this</span>.<span class=\"title function_\">evaluateOperator</span>(</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">operator</span>,</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">memory</span>,</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">current</span>,</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">memory</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">current</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">current</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">handleChar</span>(<span class=\"params\"><span class=\"attr\">char</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (char === <span class=\"string\">&quot;=&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">evaluate</span>();</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> value = <span class=\"variable language_\">this</span>.<span class=\"title function_\">processDigit</span>(char, <span class=\"variable language_\">this</span>.<span class=\"property\">current</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">current</span> = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"variable language_\">this</span>.<span class=\"title function_\">processOperator</span>(char);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">evaluate</span>();</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">operator</span> = value;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`Unsupported input: &#x27;<span class=\"subst\">$&#123;char&#125;</span>&#x27;`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">getResult</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">memory</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"><span class=\"attr\">c</span>: <span class=\"title class_\">Calculator</span>, <span class=\"attr\">input</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; input.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    c.<span class=\"title function_\">handleChar</span>(input[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`result of &#x27;<span class=\"subst\">$&#123;input&#125;</span>&#x27; is &#x27;<span class=\"subst\">$&#123;c.getResult()&#125;</span>&#x27;`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个使用暴露测试功能的计算器的简单测试。</p>\n<p><strong>TestCalculator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Calculator</span>, test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">Calculator</span>();</span><br><span class=\"line\"><span class=\"title function_\">test</span>(c, <span class=\"string\">&quot;1+2*33/11=&quot;</span>); <span class=\"comment\">// 输出 9</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，为了扩展这个功能，以增加对10以外的数字输入的支持，我们来创建 <code>ProgrammerCalculator.ts</code></p>\n<p><strong>ProgrammerCalculator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Calculator</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ProgrammerCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Calculator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> digits = [</span><br><span class=\"line\">    <span class=\"string\">&quot;0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;2&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;3&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;4&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;5&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;6&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;7&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;8&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;9&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;A&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;B&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;C&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;D&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;E&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;F&quot;</span>,</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> <span class=\"attr\">base</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> maxBase = <span class=\"title class_\">ProgrammerCalculator</span>.<span class=\"property\">digits</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (base &lt;= <span class=\"number\">0</span> || base &gt; maxBase) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`base has to be within 0 to <span class=\"subst\">$&#123;maxBase&#125;</span> inclusive.`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"title function_\">processDigit</span>(<span class=\"params\"><span class=\"attr\">digit</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">currentValue</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">ProgrammerCalculator</span>.<span class=\"property\">digits</span>.<span class=\"title function_\">indexOf</span>(digit) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        currentValue * <span class=\"variable language_\">this</span>.<span class=\"property\">base</span> + <span class=\"title class_\">ProgrammerCalculator</span>.<span class=\"property\">digits</span>.<span class=\"title function_\">indexOf</span>(digit)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将新的扩展计算器导出为 Calculator</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; <span class=\"title class_\">ProgrammerCalculator</span> <span class=\"keyword\">as</span> <span class=\"title class_\">Calculator</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 同时，导出辅助函数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>新模块 <code>ProgrammerCalculator</code> 输出的API形状与原来的 <code>Calculator</code> 模块相似，但并没有增强原来模块中的任何对象。下面是对我们的<code>ProgrammerCalculator</code>类的测试。</p>\n<p><strong>TestProgrammerCalculator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Calculator</span>, test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ProgrammerCalculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">Calculator</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"title function_\">test</span>(c, <span class=\"string\">&quot;001+010=&quot;</span>); <span class=\"comment\">// 输出 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-12-3-不要在模块中使用命名空间\"><a href=\"#12-12-3-不要在模块中使用命名空间\" class=\"headerlink\" title=\"12.12.3 不要在模块中使用命名空间\"></a>12.12.3 不要在模块中使用命名空间</h3><p>当第一次转移到基于模块的代码设计时，一个常见的趋势是，将 export 包裹在一个额外的命名空间层中。模块有自己的范围，只有导出的声明在模块外可见。考虑到这一点，如果有命名空间的话，它在使用模块时提供的价值非常小。</p>\n<p>在组织方面，命名空间对于在全局范围内，将逻辑上相关的对象和类型组合在一起很方便。例如，在C#中，你会在 <code>System.Collections</code> 中找到所有的集合类型。通过将我们的类型组织到分层的命名空间中，我们为这些类型的用户提供了良好的 “发现 “体验。另一方面，模块已经存在于文件系统中，是必然的。我们必须通过路径和文件名来解决它们，所以有一个逻辑的组织方案供我们使用。我们可以有一个<code>/collections/generic/</code>文件夹，里面有一个列表模块。</p>\n<p>命名空间对于避免全局范围内的命名冲突很重要。例如，你可能有 <code>My.Application.Customer.AddForm</code>和<code>My.Application.Order.AddForm</code>两个名字相同的类型，但名字空间不同。然而，对于模块来说，这不是一个问题。在一个模块中，没有合理的理由让两个对象具有相同的名字。从消费方面来看，任何给定模块的消费者都可以选择他们将用来引用模块的名称，所以意外的命名冲突是不可能的。</p>\n<h3 id=\"12-12-4-红线\"><a href=\"#12-12-4-红线\" class=\"headerlink\" title=\"12.12.4 红线\"></a>12.12.4 红线</h3><p>以下所有情况都是模块结构化的红线。如果你的文件有这些情况，请仔细检查你是否试图，对你的外部模块进行命名空间定义。</p>\n<ul>\n<li>一个文件的唯一顶层声明是 <code>export namespace Foo &#123; ... &#125; </code>(移除<code>Foo</code>，并将所有内容 “上移 “一个级别）</li>\n<li>多个文件在顶层有相同的<code>export namespace Foo &#123;</code> (不要以为这些文件会合并成一个 <code>Foo</code>!)</li>\n</ul>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "3-5、高级篇：命名空间",
        "toc": true,
        "abbrlink": 52849,
        "date": "2024-01-28T13:11:50.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 十四、命名空间\n\n> **关于术语的说明：**需要注意的是，在TypeScript 1.5中，术语已经改变。\"内部模块 \" 现在是 \"命名空间\"。\"外部模块 \"现在只是 \"模块\"，以便与 [ECMAScript 2015](https://www.ecma-international.org/ecma-262/6.0/)的术语保持一致，（即 `module X {` 等同于现在的 `namespace X {`）。\n\n这篇文章概述了在TypeScript中使用命名空间（以前的 \"内部模块\"），用各种方法来组织你的代码。正如我们在术语说明中所暗示的，\"内部模块 \"现在被称为 \"命名空间\"。此外，在声明内部模块时，凡是使用 `module` 关键字的地方，都可以而且应该使用 `namespace` 关键字来代替。这就避免了新用户因使用类似的术语而感到困惑。\n\n## 14.1 第一步\n\n让我们从本页中我们将使用的程序开始。作为例子，我们写了一小套简单的字符串验证器，用来检查用户在网页中的表单中的输入，或者检查外部提供的数据文件的格式。\n\n## 14.2 单一文件中的验证器\n\n```tsx\ninterface StringValidator {\n  isAcceptable(s: string): boolean;\n}\nlet lettersRegexp = /^[A-Za-z]+$/;\nlet numberRegexp = /^[0-9]+$/;\nclass LettersOnlyValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return lettersRegexp.test(s);\n  }\n}\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n// 一些测试案例\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n// 显示每一个字符串是否通过了每个验证器\nfor (let s of strings) {\n  for (let name in validators) {\n    let isMatch = validators[name].isAcceptable(s);\n    console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\n```\n\n## 14.2 命名方式\n\n当我们添加更多的验证器时，我们会希望有某种组织方案，这样我们就可以跟踪我们的类型，而不用担心与其他对象的名称冲突。与其把很多不同的名字放到全局命名空间中，不如把我们的对象包装成一个命名空间。\n\n在这个例子中，我们将把所有与验证器相关的实体移到一个叫做 `Validation` 的命名空间中。因为我们希望这里的接口和类在命名空间之外是可见的，所以我们在它们前面加上 `export`。相反，变量 `lettersRegexp` 和 `numberRegexp` 是实现细节，所以它们没有被导出，也不会被命名空间以外的代码看到。在文件底部的测试代码中，我们现在需要限定在名字空间之外使用的类型的名称，例如 `Validation.LettersOnlyValidator`。\n\n## 14.3 命名的验证器\n\n```tsx\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n  const lettersRegexp = /^[A-Za-z]+$/;\n  const numberRegexp = /^[0-9]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 && numberRegexp.test(s);\n    }\n  }\n}\n// 一些测试案例\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n// 显示每一个字符串是否通过了每个验证器\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`,\n    );\n  }\n}\n```\n\n## 14.4 跨文件分割\n\n随着我们的应用程序的增长，我们将希望把代码分成多个文件，以使它更容易维护。\n\n## 14.5 多文件命名空间\n\n在这里，我们将把我们的 `Validation` 命名空间分成许多文件。尽管这些文件是分开的，但它们都可以为同一个命名空间做出贡献，并且可以像在一个地方定义一样被使用。由于文件之间存在依赖关系，我们将添加引用标签来告诉编译器这些文件之间的关系。我们的测试代码在其他方面没有变化。\n\n**Validation.ts**\n\n```tsx\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\n```\n\n**LettersOnlyValidator.ts**\n\n```tsx\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const lettersRegexp = /^[A-Za-z]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n}\n```\n\n**ZipCodeValidator.ts**\n\n```tsx\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const numberRegexp = /^[0-9]+$/;\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 && numberRegexp.test(s);\n    }\n  }\n}\n```\n\n**Test.ts**\n\n```tsx\n/// <reference path=\"Validation.ts\" />\n/// <reference path=\"LettersOnlyValidator.ts\" />\n/// <reference path=\"ZipCodeValidator.ts\" />\n// 一些测试案例\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n// 显示每一个字符串是否通过了每个验证器\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`,\n    );\n  }\n}\n```\n\n一旦涉及到多个文件，我们就需要确保所有的编译后的代码都能被加载。有两种方法可以做到这一点。\n\n首先，我们可以使用 [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) 选项进行串联输出，将所有的输入文件编译成一个单一的JavaScript输出文件。\n\n```shell\ntsc --outFile sample.js Test.ts\n```\n\n编译器将根据文件中存在的参考标签自动排列输出文件。你也可以单独指定每个文件：\n\n```tsx\ntsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\n```\n\n另外，我们也可以使用按文件编译（默认），为每个输入文件生成一个JavaScript文件。如果产生了多个JS文件，我们就需要在网页上使用 `<script>` 标签，以适当的顺序加载每个发射的文件，例如：\n\n**MyTestPage.html (部分代码)**\n\n```\n<script src=\"Validation.js\" type=\"text/javascript\" />\n<script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n<script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n<script src=\"Test.js\" type=\"text/javascript\" />\n```\n\n## 14.6 别名\n\n另一个可以简化命名空间工作的方法是使用 `import q = x.y.z`来为常用对象创建更短的名称。不要与用于加载模块的 `import x = require(\"name\") ` 语法相混淆，这种语法只是为指定的符号创建一个别名。你可以为任何类型的标识符使用这类导入（通常被称为别名），包括从模块导入创建的对象。\n\n```tsx\nnamespace Shapes {\n  export namespace Polygons {\n    export class Triangle {}\n    export class Square {}\n  }\n}\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // 与'new Shapes.Polygons.Square()'等价\n```\n\n注意，我们没有使用 `require`关键字；相反，我们直接从我们要导入的符号的限定名称中分配。这类似于使用`var`，但也适用于导入符号的类型和命名空间的含义。重要的是，对于数值来说，导入是一个不同于原始符号的引用，所以对别名 `var` 的改变不会反映在原始变量上。\n\n## 14.7 与其他JavaScript库一起工作\n\n为了描述不是用TypeScript编写的库的形状，我们需要声明库所暴露的API。因为大多数JavaScript库只暴露了几个顶级对象，命名空间是表示它们的一个好方法。\n\n我们把不定义实现的声明称为 \"环境\"。通常，这些都是在 `.d.ts` 文件中定义的。如果你熟悉C/C++，你可以把它们看作是 `.h` 文件。让我们来看看几个例子：\n\n**D3.d.ts (简要摘录)**\n\n```tsx\ndeclare namespace D3 {\n  export interface Selectors {\n    select: {\n      (selector: string): Selection;\n      (element: EventTarget): Selection;\n    };\n  }\n  export interface Event {\n    x: number;\n    y: number;\n  }\n  export interface Base extends Selectors {\n    event: Event;\n  }\n}\ndeclare var d3: D3.Base;\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/3-5、高级篇：命名空间.md",
        "raw": "---\ntitle: 3-5、高级篇：命名空间\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 52849\ndate: 2024-01-28 21:11:50\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 十四、命名空间\n\n> **关于术语的说明：**需要注意的是，在TypeScript 1.5中，术语已经改变。\"内部模块 \" 现在是 \"命名空间\"。\"外部模块 \"现在只是 \"模块\"，以便与 [ECMAScript 2015](https://www.ecma-international.org/ecma-262/6.0/)的术语保持一致，（即 `module X {` 等同于现在的 `namespace X {`）。\n\n这篇文章概述了在TypeScript中使用命名空间（以前的 \"内部模块\"），用各种方法来组织你的代码。正如我们在术语说明中所暗示的，\"内部模块 \"现在被称为 \"命名空间\"。此外，在声明内部模块时，凡是使用 `module` 关键字的地方，都可以而且应该使用 `namespace` 关键字来代替。这就避免了新用户因使用类似的术语而感到困惑。\n\n## 14.1 第一步\n\n让我们从本页中我们将使用的程序开始。作为例子，我们写了一小套简单的字符串验证器，用来检查用户在网页中的表单中的输入，或者检查外部提供的数据文件的格式。\n\n## 14.2 单一文件中的验证器\n\n```tsx\ninterface StringValidator {\n  isAcceptable(s: string): boolean;\n}\nlet lettersRegexp = /^[A-Za-z]+$/;\nlet numberRegexp = /^[0-9]+$/;\nclass LettersOnlyValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return lettersRegexp.test(s);\n  }\n}\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n// 一些测试案例\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n// 显示每一个字符串是否通过了每个验证器\nfor (let s of strings) {\n  for (let name in validators) {\n    let isMatch = validators[name].isAcceptable(s);\n    console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\n```\n\n## 14.2 命名方式\n\n当我们添加更多的验证器时，我们会希望有某种组织方案，这样我们就可以跟踪我们的类型，而不用担心与其他对象的名称冲突。与其把很多不同的名字放到全局命名空间中，不如把我们的对象包装成一个命名空间。\n\n在这个例子中，我们将把所有与验证器相关的实体移到一个叫做 `Validation` 的命名空间中。因为我们希望这里的接口和类在命名空间之外是可见的，所以我们在它们前面加上 `export`。相反，变量 `lettersRegexp` 和 `numberRegexp` 是实现细节，所以它们没有被导出，也不会被命名空间以外的代码看到。在文件底部的测试代码中，我们现在需要限定在名字空间之外使用的类型的名称，例如 `Validation.LettersOnlyValidator`。\n\n## 14.3 命名的验证器\n\n```tsx\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n  const lettersRegexp = /^[A-Za-z]+$/;\n  const numberRegexp = /^[0-9]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 && numberRegexp.test(s);\n    }\n  }\n}\n// 一些测试案例\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n// 显示每一个字符串是否通过了每个验证器\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`,\n    );\n  }\n}\n```\n\n## 14.4 跨文件分割\n\n随着我们的应用程序的增长，我们将希望把代码分成多个文件，以使它更容易维护。\n\n## 14.5 多文件命名空间\n\n在这里，我们将把我们的 `Validation` 命名空间分成许多文件。尽管这些文件是分开的，但它们都可以为同一个命名空间做出贡献，并且可以像在一个地方定义一样被使用。由于文件之间存在依赖关系，我们将添加引用标签来告诉编译器这些文件之间的关系。我们的测试代码在其他方面没有变化。\n\n**Validation.ts**\n\n```tsx\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\n```\n\n**LettersOnlyValidator.ts**\n\n```tsx\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const lettersRegexp = /^[A-Za-z]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n}\n```\n\n**ZipCodeValidator.ts**\n\n```tsx\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const numberRegexp = /^[0-9]+$/;\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 && numberRegexp.test(s);\n    }\n  }\n}\n```\n\n**Test.ts**\n\n```tsx\n/// <reference path=\"Validation.ts\" />\n/// <reference path=\"LettersOnlyValidator.ts\" />\n/// <reference path=\"ZipCodeValidator.ts\" />\n// 一些测试案例\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// 要使用的验证器\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n// 显示每一个字符串是否通过了每个验证器\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`,\n    );\n  }\n}\n```\n\n一旦涉及到多个文件，我们就需要确保所有的编译后的代码都能被加载。有两种方法可以做到这一点。\n\n首先，我们可以使用 [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) 选项进行串联输出，将所有的输入文件编译成一个单一的JavaScript输出文件。\n\n```shell\ntsc --outFile sample.js Test.ts\n```\n\n编译器将根据文件中存在的参考标签自动排列输出文件。你也可以单独指定每个文件：\n\n```tsx\ntsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\n```\n\n另外，我们也可以使用按文件编译（默认），为每个输入文件生成一个JavaScript文件。如果产生了多个JS文件，我们就需要在网页上使用 `<script>` 标签，以适当的顺序加载每个发射的文件，例如：\n\n**MyTestPage.html (部分代码)**\n\n```\n<script src=\"Validation.js\" type=\"text/javascript\" />\n<script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n<script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n<script src=\"Test.js\" type=\"text/javascript\" />\n```\n\n## 14.6 别名\n\n另一个可以简化命名空间工作的方法是使用 `import q = x.y.z`来为常用对象创建更短的名称。不要与用于加载模块的 `import x = require(\"name\") ` 语法相混淆，这种语法只是为指定的符号创建一个别名。你可以为任何类型的标识符使用这类导入（通常被称为别名），包括从模块导入创建的对象。\n\n```tsx\nnamespace Shapes {\n  export namespace Polygons {\n    export class Triangle {}\n    export class Square {}\n  }\n}\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // 与'new Shapes.Polygons.Square()'等价\n```\n\n注意，我们没有使用 `require`关键字；相反，我们直接从我们要导入的符号的限定名称中分配。这类似于使用`var`，但也适用于导入符号的类型和命名空间的含义。重要的是，对于数值来说，导入是一个不同于原始符号的引用，所以对别名 `var` 的改变不会反映在原始变量上。\n\n## 14.7 与其他JavaScript库一起工作\n\n为了描述不是用TypeScript编写的库的形状，我们需要声明库所暴露的API。因为大多数JavaScript库只暴露了几个顶级对象，命名空间是表示它们的一个好方法。\n\n我们把不定义实现的声明称为 \"环境\"。通常，这些都是在 `.d.ts` 文件中定义的。如果你熟悉C/C++，你可以把它们看作是 `.h` 文件。让我们来看看几个例子：\n\n**D3.d.ts (简要摘录)**\n\n```tsx\ndeclare namespace D3 {\n  export interface Selectors {\n    select: {\n      (selector: string): Selection;\n      (element: EventTarget): Selection;\n    };\n  }\n  export interface Event {\n    x: number;\n    y: number;\n  }\n  export interface Base extends Selectors {\n    event: Event;\n  }\n}\ndeclare var d3: D3.Base;\n```\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/3-5、高级篇：命名空间",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjaoc002994v3h48oc78u",
        "content": "<h1 id=\"十四、命名空间\"><a href=\"#十四、命名空间\" class=\"headerlink\" title=\"十四、命名空间\"></a>十四、命名空间</h1><blockquote>\n<p><strong>关于术语的说明：</strong>需要注意的是，在TypeScript 1.5中，术语已经改变。”内部模块 “ 现在是 “命名空间”。”外部模块 “现在只是 “模块”，以便与 <a href=\"https://www.ecma-international.org/ecma-262/6.0/\">ECMAScript 2015</a>的术语保持一致，（即 <code>module X &#123;</code> 等同于现在的 <code>namespace X &#123;</code>）。</p>\n</blockquote>\n<p>这篇文章概述了在TypeScript中使用命名空间（以前的 “内部模块”），用各种方法来组织你的代码。正如我们在术语说明中所暗示的，”内部模块 “现在被称为 “命名空间”。此外，在声明内部模块时，凡是使用 <code>module</code> 关键字的地方，都可以而且应该使用 <code>namespace</code> 关键字来代替。这就避免了新用户因使用类似的术语而感到困惑。</p>\n<h2 id=\"14-1-第一步\"><a href=\"#14-1-第一步\" class=\"headerlink\" title=\"14.1 第一步\"></a>14.1 第一步</h2><p>让我们从本页中我们将使用的程序开始。作为例子，我们写了一小套简单的字符串验证器，用来检查用户在网页中的表单中的输入，或者检查外部提供的数据文件的格式。</p>\n<h2 id=\"14-2-单一文件中的验证器\"><a href=\"#14-2-单一文件中的验证器\" class=\"headerlink\" title=\"14.2 单一文件中的验证器\"></a>14.2 单一文件中的验证器</h2><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> lettersRegexp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LettersOnlyValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lettersRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 一些测试案例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">validators</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">LettersOnlyValidator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每一个字符串是否通过了每个验证器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> isMatch = validators[name].<span class=\"title function_\">isAcceptable</span>(s);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`&#x27;<span class=\"subst\">$&#123;s&#125;</span>&#x27; <span class=\"subst\">$&#123;isMatch ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> &#x27;<span class=\"subst\">$&#123;name&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-2-命名方式\"><a href=\"#14-2-命名方式\" class=\"headerlink\" title=\"14.2 命名方式\"></a>14.2 命名方式</h2><p>当我们添加更多的验证器时，我们会希望有某种组织方案，这样我们就可以跟踪我们的类型，而不用担心与其他对象的名称冲突。与其把很多不同的名字放到全局命名空间中，不如把我们的对象包装成一个命名空间。</p>\n<p>在这个例子中，我们将把所有与验证器相关的实体移到一个叫做 <code>Validation</code> 的命名空间中。因为我们希望这里的接口和类在命名空间之外是可见的，所以我们在它们前面加上 <code>export</code>。相反，变量 <code>lettersRegexp</code> 和 <code>numberRegexp</code> 是实现细节，所以它们没有被导出，也不会被命名空间以外的代码看到。在文件底部的测试代码中，我们现在需要限定在名字空间之外使用的类型的名称，例如 <code>Validation.LettersOnlyValidator</code>。</p>\n<h2 id=\"14-3-命名的验证器\"><a href=\"#14-3-命名的验证器\" class=\"headerlink\" title=\"14.3 命名的验证器\"></a>14.3 命名的验证器</h2><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Validation</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lettersRegexp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LettersOnlyValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> lettersRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 一些测试案例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">validators</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">Validation</span>.<span class=\"property\">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Validation</span>.<span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Validation</span>.<span class=\"title class_\">LettersOnlyValidator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每一个字符串是否通过了每个验证器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">      <span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">        validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">      &#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-4-跨文件分割\"><a href=\"#14-4-跨文件分割\" class=\"headerlink\" title=\"14.4 跨文件分割\"></a>14.4 跨文件分割</h2><p>随着我们的应用程序的增长，我们将希望把代码分成多个文件，以使它更容易维护。</p>\n<h2 id=\"14-5-多文件命名空间\"><a href=\"#14-5-多文件命名空间\" class=\"headerlink\" title=\"14.5 多文件命名空间\"></a>14.5 多文件命名空间</h2><p>在这里，我们将把我们的 <code>Validation</code> 命名空间分成许多文件。尽管这些文件是分开的，但它们都可以为同一个命名空间做出贡献，并且可以像在一个地方定义一样被使用。由于文件之间存在依赖关系，我们将添加引用标签来告诉编译器这些文件之间的关系。我们的测试代码在其他方面没有变化。</p>\n<p><strong>Validation.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Validation</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>LettersOnlyValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Validation</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lettersRegexp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LettersOnlyValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> lettersRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Validation</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// 一些测试案例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">validators</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">Validation</span>.<span class=\"property\">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Validation</span>.<span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Validation</span>.<span class=\"title class_\">LettersOnlyValidator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每一个字符串是否通过了每个验证器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">      <span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">        validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">      &#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一旦涉及到多个文件，我们就需要确保所有的编译后的代码都能被加载。有两种方法可以做到这一点。</p>\n<p>首先，我们可以使用 <a href=\"https://www.typescriptlang.org/tsconfig#outFile\"><code>outFile</code></a> 选项进行串联输出，将所有的输入文件编译成一个单一的JavaScript输出文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --outFile sample.js Test.ts</span><br></pre></td></tr></table></figure>\n\n<p>编译器将根据文件中存在的参考标签自动排列输出文件。你也可以单独指定每个文件：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --outFile sample.<span class=\"property\">js</span> <span class=\"title class_\">Validation</span>.<span class=\"property\">ts</span> <span class=\"title class_\">LettersOnlyValidator</span>.<span class=\"property\">ts</span> <span class=\"title class_\">ZipCodeValidator</span>.<span class=\"property\">ts</span> <span class=\"title class_\">Test</span>.<span class=\"property\">ts</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，我们也可以使用按文件编译（默认），为每个输入文件生成一个JavaScript文件。如果产生了多个JS文件，我们就需要在网页上使用 <code>&lt;script&gt;</code> 标签，以适当的顺序加载每个发射的文件，例如：</p>\n<p><strong>MyTestPage.html (部分代码)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class=\"line\">&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class=\"line\">&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class=\"line\">&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-6-别名\"><a href=\"#14-6-别名\" class=\"headerlink\" title=\"14.6 别名\"></a>14.6 别名</h2><p>另一个可以简化命名空间工作的方法是使用 <code>import q = x.y.z</code>来为常用对象创建更短的名称。不要与用于加载模块的 <code>import x = require(&quot;name&quot;) </code> 语法相混淆，这种语法只是为指定的符号创建一个别名。你可以为任何类型的标识符使用这类导入（通常被称为别名），包括从模块导入创建的对象。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Shapes</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">Polygons</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Square</span> &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> polygons = <span class=\"title class_\">Shapes</span>.<span class=\"property\">Polygons</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sq = <span class=\"keyword\">new</span> polygons.<span class=\"title class_\">Square</span>(); <span class=\"comment\">// 与&#x27;new Shapes.Polygons.Square()&#x27;等价</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，我们没有使用 <code>require</code>关键字；相反，我们直接从我们要导入的符号的限定名称中分配。这类似于使用<code>var</code>，但也适用于导入符号的类型和命名空间的含义。重要的是，对于数值来说，导入是一个不同于原始符号的引用，所以对别名 <code>var</code> 的改变不会反映在原始变量上。</p>\n<h2 id=\"14-7-与其他JavaScript库一起工作\"><a href=\"#14-7-与其他JavaScript库一起工作\" class=\"headerlink\" title=\"14.7 与其他JavaScript库一起工作\"></a>14.7 与其他JavaScript库一起工作</h2><p>为了描述不是用TypeScript编写的库的形状，我们需要声明库所暴露的API。因为大多数JavaScript库只暴露了几个顶级对象，命名空间是表示它们的一个好方法。</p>\n<p>我们把不定义实现的声明称为 “环境”。通常，这些都是在 <code>.d.ts</code> 文件中定义的。如果你熟悉C&#x2F;C++，你可以把它们看作是 <code>.h</code> 文件。让我们来看看几个例子：</p>\n<p><strong>D3.d.ts (简要摘录)</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">D3</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Selectors</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">select</span>: &#123;</span><br><span class=\"line\">      (<span class=\"attr\">selector</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Selection</span>;</span><br><span class=\"line\">      (<span class=\"attr\">element</span>: <span class=\"title class_\">EventTarget</span>): <span class=\"title class_\">Selection</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Event</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Base</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Selectors</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">event</span>: <span class=\"title class_\">Event</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"attr\">d3</span>: <span class=\"variable constant_\">D3</span>.<span class=\"property\">Base</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"十四、命名空间\"><a href=\"#十四、命名空间\" class=\"headerlink\" title=\"十四、命名空间\"></a>十四、命名空间</h1><blockquote>\n<p><strong>关于术语的说明：</strong>需要注意的是，在TypeScript 1.5中，术语已经改变。”内部模块 “ 现在是 “命名空间”。”外部模块 “现在只是 “模块”，以便与 <a href=\"https://www.ecma-international.org/ecma-262/6.0/\">ECMAScript 2015</a>的术语保持一致，（即 <code>module X &#123;</code> 等同于现在的 <code>namespace X &#123;</code>）。</p>\n</blockquote>\n<p>这篇文章概述了在TypeScript中使用命名空间（以前的 “内部模块”），用各种方法来组织你的代码。正如我们在术语说明中所暗示的，”内部模块 “现在被称为 “命名空间”。此外，在声明内部模块时，凡是使用 <code>module</code> 关键字的地方，都可以而且应该使用 <code>namespace</code> 关键字来代替。这就避免了新用户因使用类似的术语而感到困惑。</p>\n<h2 id=\"14-1-第一步\"><a href=\"#14-1-第一步\" class=\"headerlink\" title=\"14.1 第一步\"></a>14.1 第一步</h2><p>让我们从本页中我们将使用的程序开始。作为例子，我们写了一小套简单的字符串验证器，用来检查用户在网页中的表单中的输入，或者检查外部提供的数据文件的格式。</p>\n<h2 id=\"14-2-单一文件中的验证器\"><a href=\"#14-2-单一文件中的验证器\" class=\"headerlink\" title=\"14.2 单一文件中的验证器\"></a>14.2 单一文件中的验证器</h2><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> lettersRegexp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LettersOnlyValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lettersRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 一些测试案例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">validators</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">LettersOnlyValidator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每一个字符串是否通过了每个验证器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> isMatch = validators[name].<span class=\"title function_\">isAcceptable</span>(s);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`&#x27;<span class=\"subst\">$&#123;s&#125;</span>&#x27; <span class=\"subst\">$&#123;isMatch ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> &#x27;<span class=\"subst\">$&#123;name&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-2-命名方式\"><a href=\"#14-2-命名方式\" class=\"headerlink\" title=\"14.2 命名方式\"></a>14.2 命名方式</h2><p>当我们添加更多的验证器时，我们会希望有某种组织方案，这样我们就可以跟踪我们的类型，而不用担心与其他对象的名称冲突。与其把很多不同的名字放到全局命名空间中，不如把我们的对象包装成一个命名空间。</p>\n<p>在这个例子中，我们将把所有与验证器相关的实体移到一个叫做 <code>Validation</code> 的命名空间中。因为我们希望这里的接口和类在命名空间之外是可见的，所以我们在它们前面加上 <code>export</code>。相反，变量 <code>lettersRegexp</code> 和 <code>numberRegexp</code> 是实现细节，所以它们没有被导出，也不会被命名空间以外的代码看到。在文件底部的测试代码中，我们现在需要限定在名字空间之外使用的类型的名称，例如 <code>Validation.LettersOnlyValidator</code>。</p>\n<h2 id=\"14-3-命名的验证器\"><a href=\"#14-3-命名的验证器\" class=\"headerlink\" title=\"14.3 命名的验证器\"></a>14.3 命名的验证器</h2><figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Validation</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lettersRegexp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LettersOnlyValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> lettersRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 一些测试案例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">validators</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">Validation</span>.<span class=\"property\">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Validation</span>.<span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Validation</span>.<span class=\"title class_\">LettersOnlyValidator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每一个字符串是否通过了每个验证器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">      <span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">        validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">      &#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-4-跨文件分割\"><a href=\"#14-4-跨文件分割\" class=\"headerlink\" title=\"14.4 跨文件分割\"></a>14.4 跨文件分割</h2><p>随着我们的应用程序的增长，我们将希望把代码分成多个文件，以使它更容易维护。</p>\n<h2 id=\"14-5-多文件命名空间\"><a href=\"#14-5-多文件命名空间\" class=\"headerlink\" title=\"14.5 多文件命名空间\"></a>14.5 多文件命名空间</h2><p>在这里，我们将把我们的 <code>Validation</code> 命名空间分成许多文件。尽管这些文件是分开的，但它们都可以为同一个命名空间做出贡献，并且可以像在一个地方定义一样被使用。由于文件之间存在依赖关系，我们将添加引用标签来告诉编译器这些文件之间的关系。我们的测试代码在其他方面没有变化。</p>\n<p><strong>Validation.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Validation</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>LettersOnlyValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Validation</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lettersRegexp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LettersOnlyValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> lettersRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ZipCodeValidator.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Validation</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ZipCodeValidator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">StringValidator</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">isAcceptable</span>(<span class=\"params\"><span class=\"attr\">s</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.<span class=\"property\">length</span> === <span class=\"number\">5</span> &amp;&amp; numberRegexp.<span class=\"title function_\">test</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Test.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// 一些测试案例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 要使用的验证器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">validators</span>: &#123; [<span class=\"attr\">s</span>: <span class=\"built_in\">string</span>]: <span class=\"title class_\">Validation</span>.<span class=\"property\">StringValidator</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Validation</span>.<span class=\"title class_\">ZipCodeValidator</span>();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Validation</span>.<span class=\"title class_\">LettersOnlyValidator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 显示每一个字符串是否通过了每个验证器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">      <span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">        validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">      &#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一旦涉及到多个文件，我们就需要确保所有的编译后的代码都能被加载。有两种方法可以做到这一点。</p>\n<p>首先，我们可以使用 <a href=\"https://www.typescriptlang.org/tsconfig#outFile\"><code>outFile</code></a> 选项进行串联输出，将所有的输入文件编译成一个单一的JavaScript输出文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --outFile sample.js Test.ts</span><br></pre></td></tr></table></figure>\n\n<p>编译器将根据文件中存在的参考标签自动排列输出文件。你也可以单独指定每个文件：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --outFile sample.<span class=\"property\">js</span> <span class=\"title class_\">Validation</span>.<span class=\"property\">ts</span> <span class=\"title class_\">LettersOnlyValidator</span>.<span class=\"property\">ts</span> <span class=\"title class_\">ZipCodeValidator</span>.<span class=\"property\">ts</span> <span class=\"title class_\">Test</span>.<span class=\"property\">ts</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，我们也可以使用按文件编译（默认），为每个输入文件生成一个JavaScript文件。如果产生了多个JS文件，我们就需要在网页上使用 <code>&lt;script&gt;</code> 标签，以适当的顺序加载每个发射的文件，例如：</p>\n<p><strong>MyTestPage.html (部分代码)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class=\"line\">&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class=\"line\">&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class=\"line\">&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-6-别名\"><a href=\"#14-6-别名\" class=\"headerlink\" title=\"14.6 别名\"></a>14.6 别名</h2><p>另一个可以简化命名空间工作的方法是使用 <code>import q = x.y.z</code>来为常用对象创建更短的名称。不要与用于加载模块的 <code>import x = require(&quot;name&quot;) </code> 语法相混淆，这种语法只是为指定的符号创建一个别名。你可以为任何类型的标识符使用这类导入（通常被称为别名），包括从模块导入创建的对象。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Shapes</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">Polygons</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Square</span> &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> polygons = <span class=\"title class_\">Shapes</span>.<span class=\"property\">Polygons</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sq = <span class=\"keyword\">new</span> polygons.<span class=\"title class_\">Square</span>(); <span class=\"comment\">// 与&#x27;new Shapes.Polygons.Square()&#x27;等价</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，我们没有使用 <code>require</code>关键字；相反，我们直接从我们要导入的符号的限定名称中分配。这类似于使用<code>var</code>，但也适用于导入符号的类型和命名空间的含义。重要的是，对于数值来说，导入是一个不同于原始符号的引用，所以对别名 <code>var</code> 的改变不会反映在原始变量上。</p>\n<h2 id=\"14-7-与其他JavaScript库一起工作\"><a href=\"#14-7-与其他JavaScript库一起工作\" class=\"headerlink\" title=\"14.7 与其他JavaScript库一起工作\"></a>14.7 与其他JavaScript库一起工作</h2><p>为了描述不是用TypeScript编写的库的形状，我们需要声明库所暴露的API。因为大多数JavaScript库只暴露了几个顶级对象，命名空间是表示它们的一个好方法。</p>\n<p>我们把不定义实现的声明称为 “环境”。通常，这些都是在 <code>.d.ts</code> 文件中定义的。如果你熟悉C&#x2F;C++，你可以把它们看作是 <code>.h</code> 文件。让我们来看看几个例子：</p>\n<p><strong>D3.d.ts (简要摘录)</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">D3</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Selectors</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">select</span>: &#123;</span><br><span class=\"line\">      (<span class=\"attr\">selector</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">Selection</span>;</span><br><span class=\"line\">      (<span class=\"attr\">element</span>: <span class=\"title class_\">EventTarget</span>): <span class=\"title class_\">Selection</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Event</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">x</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Base</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Selectors</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">event</span>: <span class=\"title class_\">Event</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> <span class=\"attr\">d3</span>: <span class=\"variable constant_\">D3</span>.<span class=\"property\">Base</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "3-6、高级篇：命名空间与模块",
        "toc": true,
        "abbrlink": 19249,
        "date": "2024-01-28T13:12:22.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_01.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 十五、命名空间与模块\n\n这篇文章概述了在TypeScript中使用模块和命名空间来组织你的代码的各种方法。我们还将讨论一些关于如何使用命名空间和模块的高级话题，并解决在TypeScript中使用它们时的一些常见陷阱。\n\n关于ES模块的更多信息，请参见 [Modules](https://www.typescriptlang.org/docs/handbook/modules.html) 文档。更多关于TypeScript命名空间的信息，请参见 [Namespaces](https://www.typescriptlang.org/docs/handbook/namespaces.html) 文档。\n\n> 注意：在非常老的TypeScript版本中，命名空间被称为 \"内部模块\"，这比JavaScript模块系统要早。\n\n## 15.1 使用模块\n\n模块可以包含代码和声明。\n\n模块也依赖于模块加载器（如CommonJs/Require.js）或支持ES模块的运行时间。模块提供了更好的代码重用，更强的隔离性和更好的捆绑工具支持。\n\n同样值得注意的是，对于Node.js应用程序，模块是默认的，我们在现代代码中**推荐模块而不是命名空间**。\n\n从ECMAScript 2015开始，模块是语言的原生部分，所有兼容的引擎实现都应该支持。因此，对于新项目，模块将是推荐的代码组织机制。\n\n## 15.2 使用命名空间\n\n命名空间是一种TypeScript特有的组织代码的方式。\n\n命名空间是全局命名空间中简单命名的JavaScript对象。这使得命名空间的使用非常简单。与模块不同，它们可以跨越多个文件，并且可以使用 [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)串联。命名空间可以成为Web应用程序中结构化代码的一个好方法，所有的依赖关系都包含在HTML页面的`<script>`标签中。\n\n就像所有的全局命名空间污染一样，可能很难识别组件的依赖关系，特别是在一个大型应用程序中。\n\n## 15.3 命名空间和模块的陷阱\n\n在本节中，我们将介绍使用命名空间和模块的各种常见陷阱，以及如何避免这些陷阱。\n\n### 15.3.1 `/// <reference>` 为模块命名\n\n一个常见的错误是试图使用`///<reference ... />`语法来引用一个模块文件，而不是使用 `import` 语句。为了理解这种区别，我们首先需要理解编译器是如何根据 `import` 的路径（例如，在 `import x from \"...\";`中的 `...`, `import x = require(\"...\");`等等）路径来定位模块的类型信息。\n\n编译器将尝试找到一个 `.ts`，`.tsx`，然后是一个具有适当路径的 `.d.ts`。如果找不到一个特定的文件，那么编译器将寻找一个环境模块声明。回顾一下，这些需要在 `.d.ts` 文件中声明。\n\n- myModules.d.ts\n\n```tsx\n// 在一个.d.ts文件或不是模块的.ts文件中\ndeclare module \"SomeModule\" {\n  export function fn(): string;\n}\n```\n\n- myOtherModule.ts\n\n```tsx\n/// <reference path=\"myModules.d.ts\" />\nimport * as m from \"SomeModule\";\n```\n\n这里的引用标签允许我们找到包含环境模块声明的声明文件。几个TypeScript样本使用的 `node.d.ts` 文件就是这样被消耗的。\n\n### 15.3.2 不必要的命名方式\n\n如果你要把一个程序从命名空间转换为模块，很容易就会出现一个看起来像这样的文件：\n\n- `shapes.ts`\n\n```tsx\nexport namespace Shapes {\n  export class Triangle {\n    /* ... */\n  }\n  export class Square {\n    /* ... */\n  }\n}\n```\n\n这里的顶层命名空间 `Shapes` 毫无理由地将`Triangle`和`Square`包裹起来。这让你的模块的使用者感到困惑和厌烦。\n\n- `shapeConsumer.ts`\n\n```tsx\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n```\n\nTypeScript中模块的一个关键特征是，两个不同的模块永远不会将名字贡献给同一个范围。因为模块的消费者决定给它分配什么名字，所以不需要主动将导出的符号包裹在一个命名空间中。\n\n重申一下为什么你不应该尝试对模块内容进行命名空间，命名空间的一般想法是提供结构体的逻辑分组，并防止名称碰撞。因为模块文件本身已经是一个逻辑分组，它的顶层名称由导入它的代码定义，所以没有必要为导出的对象使用一个额外的模块层。\n\n下面是一个修改后的例子：\n\n- `shapes.ts`\n\n```tsx\nexport class Triangle {\n  /* ... */\n}\nexport class Square {\n  /* ... */\n}\n```\n\n- `shapeConsumer.ts`\n\n```tsx\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Triangle();\n```\n\n### 15.3.3 模块的权衡\n\n就像JS文件和模块之间有一对一的对应关系一样，TypeScript在模块源文件和其发射的JS文件之间有一对一的对应关系。这样做的一个影响是，根据你的目标模块系统，不可能串联多个模块源文件。例如，你不能在针对 `commonjs` 或 `umd` 时使用 [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) 选项，但在 TypeScript 1.8 及更高版本中，在针对 `amd` 或 `system` 时[可以 ](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile)使用 `outFile`。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/3-6、高级篇：命名空间与模块.md",
        "raw": "---\ntitle: 3-6、高级篇：命名空间与模块\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 19249\ndate: 2024-01-28 21:12:22\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 十五、命名空间与模块\n\n这篇文章概述了在TypeScript中使用模块和命名空间来组织你的代码的各种方法。我们还将讨论一些关于如何使用命名空间和模块的高级话题，并解决在TypeScript中使用它们时的一些常见陷阱。\n\n关于ES模块的更多信息，请参见 [Modules](https://www.typescriptlang.org/docs/handbook/modules.html) 文档。更多关于TypeScript命名空间的信息，请参见 [Namespaces](https://www.typescriptlang.org/docs/handbook/namespaces.html) 文档。\n\n> 注意：在非常老的TypeScript版本中，命名空间被称为 \"内部模块\"，这比JavaScript模块系统要早。\n\n## 15.1 使用模块\n\n模块可以包含代码和声明。\n\n模块也依赖于模块加载器（如CommonJs/Require.js）或支持ES模块的运行时间。模块提供了更好的代码重用，更强的隔离性和更好的捆绑工具支持。\n\n同样值得注意的是，对于Node.js应用程序，模块是默认的，我们在现代代码中**推荐模块而不是命名空间**。\n\n从ECMAScript 2015开始，模块是语言的原生部分，所有兼容的引擎实现都应该支持。因此，对于新项目，模块将是推荐的代码组织机制。\n\n## 15.2 使用命名空间\n\n命名空间是一种TypeScript特有的组织代码的方式。\n\n命名空间是全局命名空间中简单命名的JavaScript对象。这使得命名空间的使用非常简单。与模块不同，它们可以跨越多个文件，并且可以使用 [`outFile`](https://www.typescriptlang.org/tsconfig#outFile)串联。命名空间可以成为Web应用程序中结构化代码的一个好方法，所有的依赖关系都包含在HTML页面的`<script>`标签中。\n\n就像所有的全局命名空间污染一样，可能很难识别组件的依赖关系，特别是在一个大型应用程序中。\n\n## 15.3 命名空间和模块的陷阱\n\n在本节中，我们将介绍使用命名空间和模块的各种常见陷阱，以及如何避免这些陷阱。\n\n### 15.3.1 `/// <reference>` 为模块命名\n\n一个常见的错误是试图使用`///<reference ... />`语法来引用一个模块文件，而不是使用 `import` 语句。为了理解这种区别，我们首先需要理解编译器是如何根据 `import` 的路径（例如，在 `import x from \"...\";`中的 `...`, `import x = require(\"...\");`等等）路径来定位模块的类型信息。\n\n编译器将尝试找到一个 `.ts`，`.tsx`，然后是一个具有适当路径的 `.d.ts`。如果找不到一个特定的文件，那么编译器将寻找一个环境模块声明。回顾一下，这些需要在 `.d.ts` 文件中声明。\n\n- myModules.d.ts\n\n```tsx\n// 在一个.d.ts文件或不是模块的.ts文件中\ndeclare module \"SomeModule\" {\n  export function fn(): string;\n}\n```\n\n- myOtherModule.ts\n\n```tsx\n/// <reference path=\"myModules.d.ts\" />\nimport * as m from \"SomeModule\";\n```\n\n这里的引用标签允许我们找到包含环境模块声明的声明文件。几个TypeScript样本使用的 `node.d.ts` 文件就是这样被消耗的。\n\n### 15.3.2 不必要的命名方式\n\n如果你要把一个程序从命名空间转换为模块，很容易就会出现一个看起来像这样的文件：\n\n- `shapes.ts`\n\n```tsx\nexport namespace Shapes {\n  export class Triangle {\n    /* ... */\n  }\n  export class Square {\n    /* ... */\n  }\n}\n```\n\n这里的顶层命名空间 `Shapes` 毫无理由地将`Triangle`和`Square`包裹起来。这让你的模块的使用者感到困惑和厌烦。\n\n- `shapeConsumer.ts`\n\n```tsx\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n```\n\nTypeScript中模块的一个关键特征是，两个不同的模块永远不会将名字贡献给同一个范围。因为模块的消费者决定给它分配什么名字，所以不需要主动将导出的符号包裹在一个命名空间中。\n\n重申一下为什么你不应该尝试对模块内容进行命名空间，命名空间的一般想法是提供结构体的逻辑分组，并防止名称碰撞。因为模块文件本身已经是一个逻辑分组，它的顶层名称由导入它的代码定义，所以没有必要为导出的对象使用一个额外的模块层。\n\n下面是一个修改后的例子：\n\n- `shapes.ts`\n\n```tsx\nexport class Triangle {\n  /* ... */\n}\nexport class Square {\n  /* ... */\n}\n```\n\n- `shapeConsumer.ts`\n\n```tsx\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Triangle();\n```\n\n### 15.3.3 模块的权衡\n\n就像JS文件和模块之间有一对一的对应关系一样，TypeScript在模块源文件和其发射的JS文件之间有一对一的对应关系。这样做的一个影响是，根据你的目标模块系统，不可能串联多个模块源文件。例如，你不能在针对 `commonjs` 或 `umd` 时使用 [`outFile`](https://www.typescriptlang.org/tsconfig#outFile) 选项，但在 TypeScript 1.8 及更高版本中，在针对 `amd` 或 `system` 时[可以 ](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile)使用 `outFile`。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/3-6、高级篇：命名空间与模块",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjaoc002c94v3hpc42qgc",
        "content": "<h1 id=\"十五、命名空间与模块\"><a href=\"#十五、命名空间与模块\" class=\"headerlink\" title=\"十五、命名空间与模块\"></a>十五、命名空间与模块</h1><p>这篇文章概述了在TypeScript中使用模块和命名空间来组织你的代码的各种方法。我们还将讨论一些关于如何使用命名空间和模块的高级话题，并解决在TypeScript中使用它们时的一些常见陷阱。</p>\n<p>关于ES模块的更多信息，请参见 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html\">Modules</a> 文档。更多关于TypeScript命名空间的信息，请参见 <a href=\"https://www.typescriptlang.org/docs/handbook/namespaces.html\">Namespaces</a> 文档。</p>\n<blockquote>\n<p>注意：在非常老的TypeScript版本中，命名空间被称为 “内部模块”，这比JavaScript模块系统要早。</p>\n</blockquote>\n<h2 id=\"15-1-使用模块\"><a href=\"#15-1-使用模块\" class=\"headerlink\" title=\"15.1 使用模块\"></a>15.1 使用模块</h2><p>模块可以包含代码和声明。</p>\n<p>模块也依赖于模块加载器（如CommonJs&#x2F;Require.js）或支持ES模块的运行时间。模块提供了更好的代码重用，更强的隔离性和更好的捆绑工具支持。</p>\n<p>同样值得注意的是，对于Node.js应用程序，模块是默认的，我们在现代代码中<strong>推荐模块而不是命名空间</strong>。</p>\n<p>从ECMAScript 2015开始，模块是语言的原生部分，所有兼容的引擎实现都应该支持。因此，对于新项目，模块将是推荐的代码组织机制。</p>\n<h2 id=\"15-2-使用命名空间\"><a href=\"#15-2-使用命名空间\" class=\"headerlink\" title=\"15.2 使用命名空间\"></a>15.2 使用命名空间</h2><p>命名空间是一种TypeScript特有的组织代码的方式。</p>\n<p>命名空间是全局命名空间中简单命名的JavaScript对象。这使得命名空间的使用非常简单。与模块不同，它们可以跨越多个文件，并且可以使用 <a href=\"https://www.typescriptlang.org/tsconfig#outFile\"><code>outFile</code></a>串联。命名空间可以成为Web应用程序中结构化代码的一个好方法，所有的依赖关系都包含在HTML页面的<code>&lt;script&gt;</code>标签中。</p>\n<p>就像所有的全局命名空间污染一样，可能很难识别组件的依赖关系，特别是在一个大型应用程序中。</p>\n<h2 id=\"15-3-命名空间和模块的陷阱\"><a href=\"#15-3-命名空间和模块的陷阱\" class=\"headerlink\" title=\"15.3 命名空间和模块的陷阱\"></a>15.3 命名空间和模块的陷阱</h2><p>在本节中，我们将介绍使用命名空间和模块的各种常见陷阱，以及如何避免这些陷阱。</p>\n<h3 id=\"15-3-1-为模块命名\"><a href=\"#15-3-1-为模块命名\" class=\"headerlink\" title=\"15.3.1 /// &lt;reference&gt; 为模块命名\"></a>15.3.1 <code>/// &lt;reference&gt;</code> 为模块命名</h3><p>一个常见的错误是试图使用<code>///&lt;reference ... /&gt;</code>语法来引用一个模块文件，而不是使用 <code>import</code> 语句。为了理解这种区别，我们首先需要理解编译器是如何根据 <code>import</code> 的路径（例如，在 <code>import x from &quot;...&quot;;</code>中的 <code>...</code>, <code>import x = require(&quot;...&quot;);</code>等等）路径来定位模块的类型信息。</p>\n<p>编译器将尝试找到一个 <code>.ts</code>，<code>.tsx</code>，然后是一个具有适当路径的 <code>.d.ts</code>。如果找不到一个特定的文件，那么编译器将寻找一个环境模块声明。回顾一下，这些需要在 <code>.d.ts</code> 文件中声明。</p>\n<ul>\n<li>myModules.d.ts</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在一个.d.ts文件或不是模块的.ts文件中</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;SomeModule&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>myOtherModule.ts</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;myModules.d.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> m <span class=\"keyword\">from</span> <span class=\"string\">&quot;SomeModule&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里的引用标签允许我们找到包含环境模块声明的声明文件。几个TypeScript样本使用的 <code>node.d.ts</code> 文件就是这样被消耗的。</p>\n<h3 id=\"15-3-2-不必要的命名方式\"><a href=\"#15-3-2-不必要的命名方式\" class=\"headerlink\" title=\"15.3.2 不必要的命名方式\"></a>15.3.2 不必要的命名方式</h3><p>如果你要把一个程序从命名空间转换为模块，很容易就会出现一个看起来像这样的文件：</p>\n<ul>\n<li><code>shapes.ts</code></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">Shapes</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的顶层命名空间 <code>Shapes</code> 毫无理由地将<code>Triangle</code>和<code>Square</code>包裹起来。这让你的模块的使用者感到困惑和厌烦。</p>\n<ul>\n<li><code>shapeConsumer.ts</code></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> shapes <span class=\"keyword\">from</span> <span class=\"string\">&quot;./shapes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> shapes.<span class=\"property\">Shapes</span>.<span class=\"title class_\">Triangle</span>(); <span class=\"comment\">// shapes.Shapes?</span></span><br></pre></td></tr></table></figure>\n\n<p>TypeScript中模块的一个关键特征是，两个不同的模块永远不会将名字贡献给同一个范围。因为模块的消费者决定给它分配什么名字，所以不需要主动将导出的符号包裹在一个命名空间中。</p>\n<p>重申一下为什么你不应该尝试对模块内容进行命名空间，命名空间的一般想法是提供结构体的逻辑分组，并防止名称碰撞。因为模块文件本身已经是一个逻辑分组，它的顶层名称由导入它的代码定义，所以没有必要为导出的对象使用一个额外的模块层。</p>\n<p>下面是一个修改后的例子：</p>\n<ul>\n<li><code>shapes.ts</code></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>shapeConsumer.ts</code></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> shapes <span class=\"keyword\">from</span> <span class=\"string\">&quot;./shapes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> shapes.<span class=\"title class_\">Triangle</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-3-3-模块的权衡\"><a href=\"#15-3-3-模块的权衡\" class=\"headerlink\" title=\"15.3.3 模块的权衡\"></a>15.3.3 模块的权衡</h3><p>就像JS文件和模块之间有一对一的对应关系一样，TypeScript在模块源文件和其发射的JS文件之间有一对一的对应关系。这样做的一个影响是，根据你的目标模块系统，不可能串联多个模块源文件。例如，你不能在针对 <code>commonjs</code> 或 <code>umd</code> 时使用 <a href=\"https://www.typescriptlang.org/tsconfig#outFile\"><code>outFile</code></a> 选项，但在 TypeScript 1.8 及更高版本中，在针对 <code>amd</code> 或 <code>system</code> 时<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile\">可以 </a>使用 <code>outFile</code>。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"十五、命名空间与模块\"><a href=\"#十五、命名空间与模块\" class=\"headerlink\" title=\"十五、命名空间与模块\"></a>十五、命名空间与模块</h1><p>这篇文章概述了在TypeScript中使用模块和命名空间来组织你的代码的各种方法。我们还将讨论一些关于如何使用命名空间和模块的高级话题，并解决在TypeScript中使用它们时的一些常见陷阱。</p>\n<p>关于ES模块的更多信息，请参见 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html\">Modules</a> 文档。更多关于TypeScript命名空间的信息，请参见 <a href=\"https://www.typescriptlang.org/docs/handbook/namespaces.html\">Namespaces</a> 文档。</p>\n<blockquote>\n<p>注意：在非常老的TypeScript版本中，命名空间被称为 “内部模块”，这比JavaScript模块系统要早。</p>\n</blockquote>\n<h2 id=\"15-1-使用模块\"><a href=\"#15-1-使用模块\" class=\"headerlink\" title=\"15.1 使用模块\"></a>15.1 使用模块</h2><p>模块可以包含代码和声明。</p>\n<p>模块也依赖于模块加载器（如CommonJs&#x2F;Require.js）或支持ES模块的运行时间。模块提供了更好的代码重用，更强的隔离性和更好的捆绑工具支持。</p>\n<p>同样值得注意的是，对于Node.js应用程序，模块是默认的，我们在现代代码中<strong>推荐模块而不是命名空间</strong>。</p>\n<p>从ECMAScript 2015开始，模块是语言的原生部分，所有兼容的引擎实现都应该支持。因此，对于新项目，模块将是推荐的代码组织机制。</p>\n<h2 id=\"15-2-使用命名空间\"><a href=\"#15-2-使用命名空间\" class=\"headerlink\" title=\"15.2 使用命名空间\"></a>15.2 使用命名空间</h2><p>命名空间是一种TypeScript特有的组织代码的方式。</p>\n<p>命名空间是全局命名空间中简单命名的JavaScript对象。这使得命名空间的使用非常简单。与模块不同，它们可以跨越多个文件，并且可以使用 <a href=\"https://www.typescriptlang.org/tsconfig#outFile\"><code>outFile</code></a>串联。命名空间可以成为Web应用程序中结构化代码的一个好方法，所有的依赖关系都包含在HTML页面的<code>&lt;script&gt;</code>标签中。</p>\n<p>就像所有的全局命名空间污染一样，可能很难识别组件的依赖关系，特别是在一个大型应用程序中。</p>\n<h2 id=\"15-3-命名空间和模块的陷阱\"><a href=\"#15-3-命名空间和模块的陷阱\" class=\"headerlink\" title=\"15.3 命名空间和模块的陷阱\"></a>15.3 命名空间和模块的陷阱</h2><p>在本节中，我们将介绍使用命名空间和模块的各种常见陷阱，以及如何避免这些陷阱。</p>\n<h3 id=\"15-3-1-为模块命名\"><a href=\"#15-3-1-为模块命名\" class=\"headerlink\" title=\"15.3.1 /// &lt;reference&gt; 为模块命名\"></a>15.3.1 <code>/// &lt;reference&gt;</code> 为模块命名</h3><p>一个常见的错误是试图使用<code>///&lt;reference ... /&gt;</code>语法来引用一个模块文件，而不是使用 <code>import</code> 语句。为了理解这种区别，我们首先需要理解编译器是如何根据 <code>import</code> 的路径（例如，在 <code>import x from &quot;...&quot;;</code>中的 <code>...</code>, <code>import x = require(&quot;...&quot;);</code>等等）路径来定位模块的类型信息。</p>\n<p>编译器将尝试找到一个 <code>.ts</code>，<code>.tsx</code>，然后是一个具有适当路径的 <code>.d.ts</code>。如果找不到一个特定的文件，那么编译器将寻找一个环境模块声明。回顾一下，这些需要在 <code>.d.ts</code> 文件中声明。</p>\n<ul>\n<li>myModules.d.ts</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在一个.d.ts文件或不是模块的.ts文件中</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;SomeModule&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>myOtherModule.ts</li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;myModules.d.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> m <span class=\"keyword\">from</span> <span class=\"string\">&quot;SomeModule&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里的引用标签允许我们找到包含环境模块声明的声明文件。几个TypeScript样本使用的 <code>node.d.ts</code> 文件就是这样被消耗的。</p>\n<h3 id=\"15-3-2-不必要的命名方式\"><a href=\"#15-3-2-不必要的命名方式\" class=\"headerlink\" title=\"15.3.2 不必要的命名方式\"></a>15.3.2 不必要的命名方式</h3><p>如果你要把一个程序从命名空间转换为模块，很容易就会出现一个看起来像这样的文件：</p>\n<ul>\n<li><code>shapes.ts</code></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> <span class=\"title class_\">Shapes</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的顶层命名空间 <code>Shapes</code> 毫无理由地将<code>Triangle</code>和<code>Square</code>包裹起来。这让你的模块的使用者感到困惑和厌烦。</p>\n<ul>\n<li><code>shapeConsumer.ts</code></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> shapes <span class=\"keyword\">from</span> <span class=\"string\">&quot;./shapes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> shapes.<span class=\"property\">Shapes</span>.<span class=\"title class_\">Triangle</span>(); <span class=\"comment\">// shapes.Shapes?</span></span><br></pre></td></tr></table></figure>\n\n<p>TypeScript中模块的一个关键特征是，两个不同的模块永远不会将名字贡献给同一个范围。因为模块的消费者决定给它分配什么名字，所以不需要主动将导出的符号包裹在一个命名空间中。</p>\n<p>重申一下为什么你不应该尝试对模块内容进行命名空间，命名空间的一般想法是提供结构体的逻辑分组，并防止名称碰撞。因为模块文件本身已经是一个逻辑分组，它的顶层名称由导入它的代码定义，所以没有必要为导出的对象使用一个额外的模块层。</p>\n<p>下面是一个修改后的例子：</p>\n<ul>\n<li><code>shapes.ts</code></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Square</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>shapeConsumer.ts</code></li>\n</ul>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> shapes <span class=\"keyword\">from</span> <span class=\"string\">&quot;./shapes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> shapes.<span class=\"title class_\">Triangle</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-3-3-模块的权衡\"><a href=\"#15-3-3-模块的权衡\" class=\"headerlink\" title=\"15.3.3 模块的权衡\"></a>15.3.3 模块的权衡</h3><p>就像JS文件和模块之间有一对一的对应关系一样，TypeScript在模块源文件和其发射的JS文件之间有一对一的对应关系。这样做的一个影响是，根据你的目标模块系统，不可能串联多个模块源文件。例如，你不能在针对 <code>commonjs</code> 或 <code>umd</code> 时使用 <a href=\"https://www.typescriptlang.org/tsconfig#outFile\"><code>outFile</code></a> 选项，但在 TypeScript 1.8 及更高版本中，在针对 <code>amd</code> 或 <code>system</code> 时<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile\">可以 </a>使用 <code>outFile</code>。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "3-7、高级篇：声明合并",
        "toc": true,
        "abbrlink": 43000,
        "date": "2024-01-28T13:12:47.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 十六、声明合并\n\n## 16.1 简介\n\nTypeScript中的一些独特概念在类型层面上描述了JavaScript对象的形状。一个对TypeScript来说特别独特的例子是 \"声明合并 \"的概念。理解这个概念会让你在处理现有的JavaScript时有一个优势。它还打开了通往更高级抽象概念的大门。\n\n就本文而言，\"声明合并 \"意味着编译器将两个以相同名称声明的独立声明合并为一个定义。这个合并的定义具有两个原始声明的特征。任何数量的声明都可以被合并；它并不局限于两个声明。\n\n## 16.2 基本概念\n\n在TypeScript中，声明至少在三组中的一组创建实体：命名空间、类型或值。创建命名空间的声明创建了一个命名空间，其中包含使用点阵符号访问的名称。创建类型的声明就是这样做的：它们创建了一个类型，这个类型在声明的形状下是可见的，并与给定的名称绑定。最后，创建值的声明会创建在输出的JavaScript中可见的值。\n\n| Declaration Type | Namespace | Type | Value |\n| :--------------- | :-------- | :--- | :---- |\n| Namespace        | X         |      | X     |\n| Class            |           | X    | X     |\n| Enum             |           | X    | X     |\n| Interface        |           | X    |       |\n| Type Alias       |           | X    |       |\n| Function         |           |      | X     |\n| Variable         |           |      | X     |\n\n了解每个声明所创建的内容将有助于你理解当你执行声明合并时被合并的内容。\n\n## 16.3 合并接口\n\n最简单的，也许也是最常见的声明合并类型是接口合并。在最基本的层面上，合并是将两个声明中的成员机械地连接到一个具有相同名称的单一接口中。\n\n```tsx\ninterface Box {\n  height: number;\n  width: number;\n}\ninterface Box {\n  scale: number;\n}\nlet box: Box = { height: 5, width: 6, scale: 10 };\n```\n\n接口的非功能成员应该是唯一的。如果它们不是唯一的，它们必须是同一类型的。如果接口都声明了同名的非功能成员，但类型不同，编译器会发出错误。\n\n对于函数成员，每个同名的函数成员都被视为描述同一个函数的重载。同样值得注意的是，在接口 `A` 与后来的接口 `A` 合并的情况下，第二个接口将比第一个接口有更高的优先权。\n\n就是说，在这个例子中：\n\n```tsx\ninterface Cloner {\n  clone(animal: Animal): Animal;\n}\ninterface Cloner {\n  clone(animal: Sheep): Sheep;\n}\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n```\n\n这三个接口将合并成一个单一的声明，如下：\n\n```tsx\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n请注意，每个组的元素保持相同的顺序，但组本身是合并的，后来的重载组先排序。\n\n这一规则的一个例外是专门的签名。如果一个签名有一个参数的类型是单一的字符串字面类型（例如，不是字符串字面的联合），那么它将被泡在其合并的重载列表的顶部。\n\n例如，以下接口将合并在一起：\n\n```tsx\ninterface Document {\n  createElement(tagName: any): Element;\n}\ninterface Document {\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n}\ninterface Document {\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n}\n```\n\n合并后的 `document` 声明将如下：\n\n```tsx\ninterface Document {\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: any): Element;\n}\n```\n\n## 16.4 合并命名空间\n\n与接口类似，同名的命名空间也会合并其成员。由于命名空间同时创建了一个命名空间和一个值，我们需要了解两者是如何合并的。\n\n为了合并命名空间，每个命名空间中声明的导出接口的类型定义本身也被合并，形成一个单一的命名空间，里面有合并的接口定义。\n\n为了合并名字空间的值，在每个声明地点，如果已经存在一个给定名字的名字空间，那么它将被进一步扩展，方法是利用现有的名字空间，将第二个名字空间的导出成员添加到第一个名字空间中。\n\n在这个例子中，`Animals` 的声明合并：\n\n```tsx\nnamespace Animals {\n  export class Zebra {}\n}\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Dog {}\n}\n```\n\n相当于：\n\n```tsx\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Zebra {}\n  export class Dog {}\n}\n```\n\n这种命名空间合并的模式是一个有用的起点，但是我们还需要了解非导出成员的情况。非导出的成员只在原始（未合并的）命名空间中可见。这意味着在合并后，来自其他声明的合并成员不能看到非导出成员。\n\n我们可以在这个例子中更清楚地看到这一点：\n\n```tsx\nnamespace Animal {\n  let haveMuscles = true;\n  export function animalsHaveMuscles() {\n    return haveMuscles;\n  }\n}\nnamespace Animal {\n  export function doAnimalsHaveMuscles() {\n    return haveMuscles; // 错误，因为这里无法访问haveMuscles。\n  }\n}\n```\n\n因为 `haveMuscles` 没有被导出，所以只有共享同一未合并命名空间的 `animalsHaveMuscles` 函数可以看到这个符号。`doAnimalsHaveMuscles` 函数，即使它是合并后的 `Animal` 命名空间的一部分，也不能看到这个未输出的成员。\n\n### 16.4.1 将命名空间与类、函数和枚举合并起来\n\n命名空间足够灵活，也可以与其他类型的声明合并。要做到这一点，命名空间声明必须跟在它要合并的声明后面。由此产生的声明具有两种声明类型的属性。TypeScript使用这种能力来模拟JavaScript以及其他编程语言中的一些模式。\n\n### 16.4.2 将命名空间与类合并\n\n这给了用户一种描述内部类的方法。\n\n```tsx\nclass Album {\n  label: Album.AlbumLabel;\n}\nnamespace Album {\n  export class AlbumLabel {}\n}\n```\n\n合并成员的可见性规则与[合并命名空间 ](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces)一节中描述的相同，所以我们必须导出 `AlbumLabel` 类，以便合并后的类能看到它。最终的结果是一个类在另一个类里面管理。你也可以使用命名空间来为现有的类添加更多的静态成员。\n\n除了内部类的模式外，你可能也熟悉JavaScript的做法，即创建一个函数，然后通过在函数上添加属性来进一步扩展该函数。TypeScript使用声明合并，以类型安全的方式建立这样的定义。\n\n```tsx\nfunction buildLabel(name: string): string {\n  return buildLabel.prefix + name + buildLabel.suffix;\n}\nnamespace buildLabel {\n  export let suffix = \"\";\n  export let prefix = \"Hello, \";\n}\nconsole.log(buildLabel(\"Sam Smith\"));\n```\n\n同样地，命名空间可以用来扩展具有静态成员的枚举。\n\n```tsx\nenum Color {\n  red = 1,\n  green = 2,\n  blue = 4,\n}\nnamespace Color {\n  export function mixColor(colorName: string) {\n    if (colorName == \"yellow\") {\n      return Color.red + Color.green;\n    } else if (colorName == \"white\") {\n      return Color.red + Color.green + Color.blue;\n    } else if (colorName == \"magenta\") {\n      return Color.red + Color.blue;\n    } else if (colorName == \"cyan\") {\n      return Color.green + Color.blue;\n    }\n  }\n}\n```\n\n### 16.4.3 不被允许的合并\n\n不是所有的合并在TypeScript中都是允许的。目前，类不能与其他类或变量合并。关于模仿类合并的信息，请参阅 [Mixins in TypeScript](https://www.typescriptlang.org/docs/handbook/mixins.html) 部分。\n\n## 16.5 模块增强\n\n虽然JavaScript模块不支持合并，但你可以通过导入然后更新现有对象来打补丁。让我们来看看一个玩具`Observable`的例子：\n\n```tsx\n// observable.ts\nexport class Observable<T> {\n  // ...\n}\n// map.ts\nimport { Observable } from \"./observable\";\nObservable.prototype.map = function (f) {\n  // ...\n};\n```\n\n这在TypeScript中也能正常工作，但编译器不知道 `Observable.prototype.map`。你可以使用模块增强来告诉编译器它的存在。\n\n```tsx\n// observable.ts\nexport class Observable<T> {\n  // ... implementation left as an exercise for the reader ...\n}\n// map.ts\nimport { Observable } from \"./observable\";\ndeclare module \"./observable\" {\n  interface Observable<T> {\n    map<U>(f: (x: T) => U): Observable<U>;\n  }\n}\nObservable.prototype.map = function (f) {\n  // ... another exercise for the reader\n};\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable<number>;\no.map((x) => x.toFixed());\n```\n\n模块名称的解析方式与 `import`/`export` 中的模块指定器相同。更多信息请参见 [Modules](https://www.typescriptlang.org/docs/handbook/modules.html) 。然后，增量中的声明被合并，就像它们与原始文件在同一个文件中声明一样。\n\n然而，有两个限制需要记住：\n\n1. 你不能在扩增中声明新的顶层声明--只是对现有声明的补丁。\n2. 默认出口也不能被增强，只能是命名的出口（因为你需要用出口的名字来增强出口，而 `default` 是一个保留词--详见 [#14080](https://github.com/Microsoft/TypeScript/issues/14080) )\n\n## 16.6 全局增强\n\n你也可以从一个模块内部向全局范围添加声明。\n\n```tsx\n// observable.ts\nexport class Observable<T> {\n  // ... still no implementation ...\n}\ndeclare global {\n  interface Array<T> {\n    toObservable(): Observable<T>;\n  }\n}\nArray.prototype.toObservable = function () {\n  // ...\n};\n```\n\n全局增强的行为和限制与模块增强相同。\n\n——高级篇完——\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/3-7、高级篇：声明合并.md",
        "raw": "---\ntitle: 3-7、高级篇：声明合并\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 43000\ndate: 2024-01-28 21:12:47\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 十六、声明合并\n\n## 16.1 简介\n\nTypeScript中的一些独特概念在类型层面上描述了JavaScript对象的形状。一个对TypeScript来说特别独特的例子是 \"声明合并 \"的概念。理解这个概念会让你在处理现有的JavaScript时有一个优势。它还打开了通往更高级抽象概念的大门。\n\n就本文而言，\"声明合并 \"意味着编译器将两个以相同名称声明的独立声明合并为一个定义。这个合并的定义具有两个原始声明的特征。任何数量的声明都可以被合并；它并不局限于两个声明。\n\n## 16.2 基本概念\n\n在TypeScript中，声明至少在三组中的一组创建实体：命名空间、类型或值。创建命名空间的声明创建了一个命名空间，其中包含使用点阵符号访问的名称。创建类型的声明就是这样做的：它们创建了一个类型，这个类型在声明的形状下是可见的，并与给定的名称绑定。最后，创建值的声明会创建在输出的JavaScript中可见的值。\n\n| Declaration Type | Namespace | Type | Value |\n| :--------------- | :-------- | :--- | :---- |\n| Namespace        | X         |      | X     |\n| Class            |           | X    | X     |\n| Enum             |           | X    | X     |\n| Interface        |           | X    |       |\n| Type Alias       |           | X    |       |\n| Function         |           |      | X     |\n| Variable         |           |      | X     |\n\n了解每个声明所创建的内容将有助于你理解当你执行声明合并时被合并的内容。\n\n## 16.3 合并接口\n\n最简单的，也许也是最常见的声明合并类型是接口合并。在最基本的层面上，合并是将两个声明中的成员机械地连接到一个具有相同名称的单一接口中。\n\n```tsx\ninterface Box {\n  height: number;\n  width: number;\n}\ninterface Box {\n  scale: number;\n}\nlet box: Box = { height: 5, width: 6, scale: 10 };\n```\n\n接口的非功能成员应该是唯一的。如果它们不是唯一的，它们必须是同一类型的。如果接口都声明了同名的非功能成员，但类型不同，编译器会发出错误。\n\n对于函数成员，每个同名的函数成员都被视为描述同一个函数的重载。同样值得注意的是，在接口 `A` 与后来的接口 `A` 合并的情况下，第二个接口将比第一个接口有更高的优先权。\n\n就是说，在这个例子中：\n\n```tsx\ninterface Cloner {\n  clone(animal: Animal): Animal;\n}\ninterface Cloner {\n  clone(animal: Sheep): Sheep;\n}\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n```\n\n这三个接口将合并成一个单一的声明，如下：\n\n```tsx\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n请注意，每个组的元素保持相同的顺序，但组本身是合并的，后来的重载组先排序。\n\n这一规则的一个例外是专门的签名。如果一个签名有一个参数的类型是单一的字符串字面类型（例如，不是字符串字面的联合），那么它将被泡在其合并的重载列表的顶部。\n\n例如，以下接口将合并在一起：\n\n```tsx\ninterface Document {\n  createElement(tagName: any): Element;\n}\ninterface Document {\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n}\ninterface Document {\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n}\n```\n\n合并后的 `document` 声明将如下：\n\n```tsx\ninterface Document {\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: any): Element;\n}\n```\n\n## 16.4 合并命名空间\n\n与接口类似，同名的命名空间也会合并其成员。由于命名空间同时创建了一个命名空间和一个值，我们需要了解两者是如何合并的。\n\n为了合并命名空间，每个命名空间中声明的导出接口的类型定义本身也被合并，形成一个单一的命名空间，里面有合并的接口定义。\n\n为了合并名字空间的值，在每个声明地点，如果已经存在一个给定名字的名字空间，那么它将被进一步扩展，方法是利用现有的名字空间，将第二个名字空间的导出成员添加到第一个名字空间中。\n\n在这个例子中，`Animals` 的声明合并：\n\n```tsx\nnamespace Animals {\n  export class Zebra {}\n}\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Dog {}\n}\n```\n\n相当于：\n\n```tsx\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Zebra {}\n  export class Dog {}\n}\n```\n\n这种命名空间合并的模式是一个有用的起点，但是我们还需要了解非导出成员的情况。非导出的成员只在原始（未合并的）命名空间中可见。这意味着在合并后，来自其他声明的合并成员不能看到非导出成员。\n\n我们可以在这个例子中更清楚地看到这一点：\n\n```tsx\nnamespace Animal {\n  let haveMuscles = true;\n  export function animalsHaveMuscles() {\n    return haveMuscles;\n  }\n}\nnamespace Animal {\n  export function doAnimalsHaveMuscles() {\n    return haveMuscles; // 错误，因为这里无法访问haveMuscles。\n  }\n}\n```\n\n因为 `haveMuscles` 没有被导出，所以只有共享同一未合并命名空间的 `animalsHaveMuscles` 函数可以看到这个符号。`doAnimalsHaveMuscles` 函数，即使它是合并后的 `Animal` 命名空间的一部分，也不能看到这个未输出的成员。\n\n### 16.4.1 将命名空间与类、函数和枚举合并起来\n\n命名空间足够灵活，也可以与其他类型的声明合并。要做到这一点，命名空间声明必须跟在它要合并的声明后面。由此产生的声明具有两种声明类型的属性。TypeScript使用这种能力来模拟JavaScript以及其他编程语言中的一些模式。\n\n### 16.4.2 将命名空间与类合并\n\n这给了用户一种描述内部类的方法。\n\n```tsx\nclass Album {\n  label: Album.AlbumLabel;\n}\nnamespace Album {\n  export class AlbumLabel {}\n}\n```\n\n合并成员的可见性规则与[合并命名空间 ](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces)一节中描述的相同，所以我们必须导出 `AlbumLabel` 类，以便合并后的类能看到它。最终的结果是一个类在另一个类里面管理。你也可以使用命名空间来为现有的类添加更多的静态成员。\n\n除了内部类的模式外，你可能也熟悉JavaScript的做法，即创建一个函数，然后通过在函数上添加属性来进一步扩展该函数。TypeScript使用声明合并，以类型安全的方式建立这样的定义。\n\n```tsx\nfunction buildLabel(name: string): string {\n  return buildLabel.prefix + name + buildLabel.suffix;\n}\nnamespace buildLabel {\n  export let suffix = \"\";\n  export let prefix = \"Hello, \";\n}\nconsole.log(buildLabel(\"Sam Smith\"));\n```\n\n同样地，命名空间可以用来扩展具有静态成员的枚举。\n\n```tsx\nenum Color {\n  red = 1,\n  green = 2,\n  blue = 4,\n}\nnamespace Color {\n  export function mixColor(colorName: string) {\n    if (colorName == \"yellow\") {\n      return Color.red + Color.green;\n    } else if (colorName == \"white\") {\n      return Color.red + Color.green + Color.blue;\n    } else if (colorName == \"magenta\") {\n      return Color.red + Color.blue;\n    } else if (colorName == \"cyan\") {\n      return Color.green + Color.blue;\n    }\n  }\n}\n```\n\n### 16.4.3 不被允许的合并\n\n不是所有的合并在TypeScript中都是允许的。目前，类不能与其他类或变量合并。关于模仿类合并的信息，请参阅 [Mixins in TypeScript](https://www.typescriptlang.org/docs/handbook/mixins.html) 部分。\n\n## 16.5 模块增强\n\n虽然JavaScript模块不支持合并，但你可以通过导入然后更新现有对象来打补丁。让我们来看看一个玩具`Observable`的例子：\n\n```tsx\n// observable.ts\nexport class Observable<T> {\n  // ...\n}\n// map.ts\nimport { Observable } from \"./observable\";\nObservable.prototype.map = function (f) {\n  // ...\n};\n```\n\n这在TypeScript中也能正常工作，但编译器不知道 `Observable.prototype.map`。你可以使用模块增强来告诉编译器它的存在。\n\n```tsx\n// observable.ts\nexport class Observable<T> {\n  // ... implementation left as an exercise for the reader ...\n}\n// map.ts\nimport { Observable } from \"./observable\";\ndeclare module \"./observable\" {\n  interface Observable<T> {\n    map<U>(f: (x: T) => U): Observable<U>;\n  }\n}\nObservable.prototype.map = function (f) {\n  // ... another exercise for the reader\n};\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable<number>;\no.map((x) => x.toFixed());\n```\n\n模块名称的解析方式与 `import`/`export` 中的模块指定器相同。更多信息请参见 [Modules](https://www.typescriptlang.org/docs/handbook/modules.html) 。然后，增量中的声明被合并，就像它们与原始文件在同一个文件中声明一样。\n\n然而，有两个限制需要记住：\n\n1. 你不能在扩增中声明新的顶层声明--只是对现有声明的补丁。\n2. 默认出口也不能被增强，只能是命名的出口（因为你需要用出口的名字来增强出口，而 `default` 是一个保留词--详见 [#14080](https://github.com/Microsoft/TypeScript/issues/14080) )\n\n## 16.6 全局增强\n\n你也可以从一个模块内部向全局范围添加声明。\n\n```tsx\n// observable.ts\nexport class Observable<T> {\n  // ... still no implementation ...\n}\ndeclare global {\n  interface Array<T> {\n    toObservable(): Observable<T>;\n  }\n}\nArray.prototype.toObservable = function () {\n  // ...\n};\n```\n\n全局增强的行为和限制与模块增强相同。\n\n——高级篇完——\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/3-7、高级篇：声明合并",
        "published": 1,
        "updated": "2024-01-28T13:46:42.268Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjaod002g94v3gorrdo8t",
        "content": "<h1 id=\"十六、声明合并\"><a href=\"#十六、声明合并\" class=\"headerlink\" title=\"十六、声明合并\"></a>十六、声明合并</h1><h2 id=\"16-1-简介\"><a href=\"#16-1-简介\" class=\"headerlink\" title=\"16.1 简介\"></a>16.1 简介</h2><p>TypeScript中的一些独特概念在类型层面上描述了JavaScript对象的形状。一个对TypeScript来说特别独特的例子是 “声明合并 “的概念。理解这个概念会让你在处理现有的JavaScript时有一个优势。它还打开了通往更高级抽象概念的大门。</p>\n<p>就本文而言，”声明合并 “意味着编译器将两个以相同名称声明的独立声明合并为一个定义。这个合并的定义具有两个原始声明的特征。任何数量的声明都可以被合并；它并不局限于两个声明。</p>\n<h2 id=\"16-2-基本概念\"><a href=\"#16-2-基本概念\" class=\"headerlink\" title=\"16.2 基本概念\"></a>16.2 基本概念</h2><p>在TypeScript中，声明至少在三组中的一组创建实体：命名空间、类型或值。创建命名空间的声明创建了一个命名空间，其中包含使用点阵符号访问的名称。创建类型的声明就是这样做的：它们创建了一个类型，这个类型在声明的形状下是可见的，并与给定的名称绑定。最后，创建值的声明会创建在输出的JavaScript中可见的值。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Declaration Type</th>\n<th align=\"left\">Namespace</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Namespace</td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Class</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Enum</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Interface</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Type Alias</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Variable</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n</tbody></table>\n<p>了解每个声明所创建的内容将有助于你理解当你执行声明合并时被合并的内容。</p>\n<h2 id=\"16-3-合并接口\"><a href=\"#16-3-合并接口\" class=\"headerlink\" title=\"16.3 合并接口\"></a>16.3 合并接口</h2><p>最简单的，也许也是最常见的声明合并类型是接口合并。在最基本的层面上，合并是将两个声明中的成员机械地连接到一个具有相同名称的单一接口中。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">height</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">width</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">scale</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">box</span>: <span class=\"title class_\">Box</span> = &#123; <span class=\"attr\">height</span>: <span class=\"number\">5</span>, <span class=\"attr\">width</span>: <span class=\"number\">6</span>, <span class=\"attr\">scale</span>: <span class=\"number\">10</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接口的非功能成员应该是唯一的。如果它们不是唯一的，它们必须是同一类型的。如果接口都声明了同名的非功能成员，但类型不同，编译器会发出错误。</p>\n<p>对于函数成员，每个同名的函数成员都被视为描述同一个函数的重载。同样值得注意的是，在接口 <code>A</code> 与后来的接口 <code>A</code> 合并的情况下，第二个接口将比第一个接口有更高的优先权。</p>\n<p>就是说，在这个例子中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cloner</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Animal</span>): <span class=\"title class_\">Animal</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cloner</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Sheep</span>): <span class=\"title class_\">Sheep</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cloner</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Dog</span>): <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Cat</span>): <span class=\"title class_\">Cat</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这三个接口将合并成一个单一的声明，如下：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cloner</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Dog</span>): <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Cat</span>): <span class=\"title class_\">Cat</span>;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Sheep</span>): <span class=\"title class_\">Sheep</span>;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Animal</span>): <span class=\"title class_\">Animal</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，每个组的元素保持相同的顺序，但组本身是合并的，后来的重载组先排序。</p>\n<p>这一规则的一个例外是专门的签名。如果一个签名有一个参数的类型是单一的字符串字面类型（例如，不是字符串字面的联合），那么它将被泡在其合并的重载列表的顶部。</p>\n<p>例如，以下接口将合并在一起：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"built_in\">any</span>): <span class=\"title class_\">Element</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;div&quot;</span>): <span class=\"title class_\">HTMLDivElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;span&quot;</span>): <span class=\"title class_\">HTMLSpanElement</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">HTMLElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;canvas&quot;</span>): <span class=\"title class_\">HTMLCanvasElement</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>合并后的 <code>document</code> 声明将如下：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;canvas&quot;</span>): <span class=\"title class_\">HTMLCanvasElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;div&quot;</span>): <span class=\"title class_\">HTMLDivElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;span&quot;</span>): <span class=\"title class_\">HTMLSpanElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">HTMLElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"built_in\">any</span>): <span class=\"title class_\">Element</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-4-合并命名空间\"><a href=\"#16-4-合并命名空间\" class=\"headerlink\" title=\"16.4 合并命名空间\"></a>16.4 合并命名空间</h2><p>与接口类似，同名的命名空间也会合并其成员。由于命名空间同时创建了一个命名空间和一个值，我们需要了解两者是如何合并的。</p>\n<p>为了合并命名空间，每个命名空间中声明的导出接口的类型定义本身也被合并，形成一个单一的命名空间，里面有合并的接口定义。</p>\n<p>为了合并名字空间的值，在每个声明地点，如果已经存在一个给定名字的名字空间，那么它将被进一步扩展，方法是利用现有的名字空间，将第二个名字空间的导出成员添加到第一个名字空间中。</p>\n<p>在这个例子中，<code>Animals</code> 的声明合并：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animals</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Zebra</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animals</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Legged</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">numberOfLegs</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相当于：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animals</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Legged</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">numberOfLegs</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Zebra</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种命名空间合并的模式是一个有用的起点，但是我们还需要了解非导出成员的情况。非导出的成员只在原始（未合并的）命名空间中可见。这意味着在合并后，来自其他声明的合并成员不能看到非导出成员。</p>\n<p>我们可以在这个例子中更清楚地看到这一点：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> haveMuscles = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">animalsHaveMuscles</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> haveMuscles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doAnimalsHaveMuscles</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> haveMuscles; <span class=\"comment\">// 错误，因为这里无法访问haveMuscles。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为 <code>haveMuscles</code> 没有被导出，所以只有共享同一未合并命名空间的 <code>animalsHaveMuscles</code> 函数可以看到这个符号。<code>doAnimalsHaveMuscles</code> 函数，即使它是合并后的 <code>Animal</code> 命名空间的一部分，也不能看到这个未输出的成员。</p>\n<h3 id=\"16-4-1-将命名空间与类、函数和枚举合并起来\"><a href=\"#16-4-1-将命名空间与类、函数和枚举合并起来\" class=\"headerlink\" title=\"16.4.1 将命名空间与类、函数和枚举合并起来\"></a>16.4.1 将命名空间与类、函数和枚举合并起来</h3><p>命名空间足够灵活，也可以与其他类型的声明合并。要做到这一点，命名空间声明必须跟在它要合并的声明后面。由此产生的声明具有两种声明类型的属性。TypeScript使用这种能力来模拟JavaScript以及其他编程语言中的一些模式。</p>\n<h3 id=\"16-4-2-将命名空间与类合并\"><a href=\"#16-4-2-将命名空间与类合并\" class=\"headerlink\" title=\"16.4.2 将命名空间与类合并\"></a>16.4.2 将命名空间与类合并</h3><p>这给了用户一种描述内部类的方法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Album</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">label</span>: <span class=\"title class_\">Album</span>.<span class=\"property\">AlbumLabel</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Album</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AlbumLabel</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>合并成员的可见性规则与<a href=\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces\">合并命名空间 </a>一节中描述的相同，所以我们必须导出 <code>AlbumLabel</code> 类，以便合并后的类能看到它。最终的结果是一个类在另一个类里面管理。你也可以使用命名空间来为现有的类添加更多的静态成员。</p>\n<p>除了内部类的模式外，你可能也熟悉JavaScript的做法，即创建一个函数，然后通过在函数上添加属性来进一步扩展该函数。TypeScript使用声明合并，以类型安全的方式建立这样的定义。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">buildLabel</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buildLabel.<span class=\"property\">prefix</span> + name + buildLabel.<span class=\"property\">suffix</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">buildLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> suffix = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> prefix = <span class=\"string\">&quot;Hello, &quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">buildLabel</span>(<span class=\"string\">&quot;Sam Smith&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>同样地，命名空间可以用来扩展具有静态成员的枚举。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">  red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  green = <span class=\"number\">2</span>,</span><br><span class=\"line\">  blue = <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mixColor</span>(<span class=\"params\"><span class=\"attr\">colorName</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (colorName == <span class=\"string\">&quot;yellow&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Color</span>.<span class=\"property\">red</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">green</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName == <span class=\"string\">&quot;white&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Color</span>.<span class=\"property\">red</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">green</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">blue</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName == <span class=\"string\">&quot;magenta&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Color</span>.<span class=\"property\">red</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">blue</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName == <span class=\"string\">&quot;cyan&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Color</span>.<span class=\"property\">green</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">blue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-4-3-不被允许的合并\"><a href=\"#16-4-3-不被允许的合并\" class=\"headerlink\" title=\"16.4.3 不被允许的合并\"></a>16.4.3 不被允许的合并</h3><p>不是所有的合并在TypeScript中都是允许的。目前，类不能与其他类或变量合并。关于模仿类合并的信息，请参阅 <a href=\"https://www.typescriptlang.org/docs/handbook/mixins.html\">Mixins in TypeScript</a> 部分。</p>\n<h2 id=\"16-5-模块增强\"><a href=\"#16-5-模块增强\" class=\"headerlink\" title=\"16.5 模块增强\"></a>16.5 模块增强</h2><p>虽然JavaScript模块不支持合并，但你可以通过导入然后更新现有对象来打补丁。让我们来看看一个玩具<code>Observable</code>的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// map.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">map</span> = <span class=\"keyword\">function</span> (<span class=\"params\">f</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这在TypeScript中也能正常工作，但编译器不知道 <code>Observable.prototype.map</code>。你可以使用模块增强来告诉编译器它的存在。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... implementation left as an exercise for the reader ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// map.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;./observable&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    map&lt;U&gt;(<span class=\"attr\">f</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: T</span>) =&gt;</span> U): <span class=\"title class_\">Observable</span>&lt;U&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">map</span> = <span class=\"keyword\">function</span> (<span class=\"params\">f</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... another exercise for the reader</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// consumer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./map&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">o</span>: <span class=\"title class_\">Observable</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">o.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x.<span class=\"title function_\">toFixed</span>());</span><br></pre></td></tr></table></figure>\n\n<p>模块名称的解析方式与 <code>import</code>&#x2F;<code>export</code> 中的模块指定器相同。更多信息请参见 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html\">Modules</a> 。然后，增量中的声明被合并，就像它们与原始文件在同一个文件中声明一样。</p>\n<p>然而，有两个限制需要记住：</p>\n<ol>\n<li>你不能在扩增中声明新的顶层声明–只是对现有声明的补丁。</li>\n<li>默认出口也不能被增强，只能是命名的出口（因为你需要用出口的名字来增强出口，而 <code>default</code> 是一个保留词–详见 <a href=\"https://github.com/Microsoft/TypeScript/issues/14080\">#14080</a> )</li>\n</ol>\n<h2 id=\"16-6-全局增强\"><a href=\"#16-6-全局增强\" class=\"headerlink\" title=\"16.6 全局增强\"></a>16.6 全局增强</h2><p>你也可以从一个模块内部向全局范围添加声明。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... still no implementation ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">global</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">Array</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">toObservable</span>(): <span class=\"title class_\">Observable</span>&lt;T&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toObservable</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>全局增强的行为和限制与模块增强相同。</p>\n<p>——高级篇完——</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"十六、声明合并\"><a href=\"#十六、声明合并\" class=\"headerlink\" title=\"十六、声明合并\"></a>十六、声明合并</h1><h2 id=\"16-1-简介\"><a href=\"#16-1-简介\" class=\"headerlink\" title=\"16.1 简介\"></a>16.1 简介</h2><p>TypeScript中的一些独特概念在类型层面上描述了JavaScript对象的形状。一个对TypeScript来说特别独特的例子是 “声明合并 “的概念。理解这个概念会让你在处理现有的JavaScript时有一个优势。它还打开了通往更高级抽象概念的大门。</p>\n<p>就本文而言，”声明合并 “意味着编译器将两个以相同名称声明的独立声明合并为一个定义。这个合并的定义具有两个原始声明的特征。任何数量的声明都可以被合并；它并不局限于两个声明。</p>\n<h2 id=\"16-2-基本概念\"><a href=\"#16-2-基本概念\" class=\"headerlink\" title=\"16.2 基本概念\"></a>16.2 基本概念</h2><p>在TypeScript中，声明至少在三组中的一组创建实体：命名空间、类型或值。创建命名空间的声明创建了一个命名空间，其中包含使用点阵符号访问的名称。创建类型的声明就是这样做的：它们创建了一个类型，这个类型在声明的形状下是可见的，并与给定的名称绑定。最后，创建值的声明会创建在输出的JavaScript中可见的值。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Declaration Type</th>\n<th align=\"left\">Namespace</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Namespace</td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Class</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Enum</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Interface</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Type Alias</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Function</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Variable</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n</tbody></table>\n<p>了解每个声明所创建的内容将有助于你理解当你执行声明合并时被合并的内容。</p>\n<h2 id=\"16-3-合并接口\"><a href=\"#16-3-合并接口\" class=\"headerlink\" title=\"16.3 合并接口\"></a>16.3 合并接口</h2><p>最简单的，也许也是最常见的声明合并类型是接口合并。在最基本的层面上，合并是将两个声明中的成员机械地连接到一个具有相同名称的单一接口中。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">height</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"attr\">width</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Box</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">scale</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">box</span>: <span class=\"title class_\">Box</span> = &#123; <span class=\"attr\">height</span>: <span class=\"number\">5</span>, <span class=\"attr\">width</span>: <span class=\"number\">6</span>, <span class=\"attr\">scale</span>: <span class=\"number\">10</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接口的非功能成员应该是唯一的。如果它们不是唯一的，它们必须是同一类型的。如果接口都声明了同名的非功能成员，但类型不同，编译器会发出错误。</p>\n<p>对于函数成员，每个同名的函数成员都被视为描述同一个函数的重载。同样值得注意的是，在接口 <code>A</code> 与后来的接口 <code>A</code> 合并的情况下，第二个接口将比第一个接口有更高的优先权。</p>\n<p>就是说，在这个例子中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cloner</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Animal</span>): <span class=\"title class_\">Animal</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cloner</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Sheep</span>): <span class=\"title class_\">Sheep</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cloner</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Dog</span>): <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Cat</span>): <span class=\"title class_\">Cat</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这三个接口将合并成一个单一的声明，如下：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Cloner</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Dog</span>): <span class=\"title class_\">Dog</span>;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Cat</span>): <span class=\"title class_\">Cat</span>;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Sheep</span>): <span class=\"title class_\">Sheep</span>;</span><br><span class=\"line\">  <span class=\"title function_\">clone</span>(<span class=\"attr\">animal</span>: <span class=\"title class_\">Animal</span>): <span class=\"title class_\">Animal</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，每个组的元素保持相同的顺序，但组本身是合并的，后来的重载组先排序。</p>\n<p>这一规则的一个例外是专门的签名。如果一个签名有一个参数的类型是单一的字符串字面类型（例如，不是字符串字面的联合），那么它将被泡在其合并的重载列表的顶部。</p>\n<p>例如，以下接口将合并在一起：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"built_in\">any</span>): <span class=\"title class_\">Element</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;div&quot;</span>): <span class=\"title class_\">HTMLDivElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;span&quot;</span>): <span class=\"title class_\">HTMLSpanElement</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">HTMLElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;canvas&quot;</span>): <span class=\"title class_\">HTMLCanvasElement</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>合并后的 <code>document</code> 声明将如下：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Document</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;canvas&quot;</span>): <span class=\"title class_\">HTMLCanvasElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;div&quot;</span>): <span class=\"title class_\">HTMLDivElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"string\">&quot;span&quot;</span>): <span class=\"title class_\">HTMLSpanElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"built_in\">string</span>): <span class=\"title class_\">HTMLElement</span>;</span><br><span class=\"line\">  <span class=\"title function_\">createElement</span>(<span class=\"attr\">tagName</span>: <span class=\"built_in\">any</span>): <span class=\"title class_\">Element</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-4-合并命名空间\"><a href=\"#16-4-合并命名空间\" class=\"headerlink\" title=\"16.4 合并命名空间\"></a>16.4 合并命名空间</h2><p>与接口类似，同名的命名空间也会合并其成员。由于命名空间同时创建了一个命名空间和一个值，我们需要了解两者是如何合并的。</p>\n<p>为了合并命名空间，每个命名空间中声明的导出接口的类型定义本身也被合并，形成一个单一的命名空间，里面有合并的接口定义。</p>\n<p>为了合并名字空间的值，在每个声明地点，如果已经存在一个给定名字的名字空间，那么它将被进一步扩展，方法是利用现有的名字空间，将第二个名字空间的导出成员添加到第一个名字空间中。</p>\n<p>在这个例子中，<code>Animals</code> 的声明合并：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animals</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Zebra</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animals</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Legged</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">numberOfLegs</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相当于：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animals</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Legged</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">numberOfLegs</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Zebra</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种命名空间合并的模式是一个有用的起点，但是我们还需要了解非导出成员的情况。非导出的成员只在原始（未合并的）命名空间中可见。这意味着在合并后，来自其他声明的合并成员不能看到非导出成员。</p>\n<p>我们可以在这个例子中更清楚地看到这一点：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> haveMuscles = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">animalsHaveMuscles</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> haveMuscles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doAnimalsHaveMuscles</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> haveMuscles; <span class=\"comment\">// 错误，因为这里无法访问haveMuscles。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为 <code>haveMuscles</code> 没有被导出，所以只有共享同一未合并命名空间的 <code>animalsHaveMuscles</code> 函数可以看到这个符号。<code>doAnimalsHaveMuscles</code> 函数，即使它是合并后的 <code>Animal</code> 命名空间的一部分，也不能看到这个未输出的成员。</p>\n<h3 id=\"16-4-1-将命名空间与类、函数和枚举合并起来\"><a href=\"#16-4-1-将命名空间与类、函数和枚举合并起来\" class=\"headerlink\" title=\"16.4.1 将命名空间与类、函数和枚举合并起来\"></a>16.4.1 将命名空间与类、函数和枚举合并起来</h3><p>命名空间足够灵活，也可以与其他类型的声明合并。要做到这一点，命名空间声明必须跟在它要合并的声明后面。由此产生的声明具有两种声明类型的属性。TypeScript使用这种能力来模拟JavaScript以及其他编程语言中的一些模式。</p>\n<h3 id=\"16-4-2-将命名空间与类合并\"><a href=\"#16-4-2-将命名空间与类合并\" class=\"headerlink\" title=\"16.4.2 将命名空间与类合并\"></a>16.4.2 将命名空间与类合并</h3><p>这给了用户一种描述内部类的方法。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Album</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">label</span>: <span class=\"title class_\">Album</span>.<span class=\"property\">AlbumLabel</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Album</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AlbumLabel</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>合并成员的可见性规则与<a href=\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces\">合并命名空间 </a>一节中描述的相同，所以我们必须导出 <code>AlbumLabel</code> 类，以便合并后的类能看到它。最终的结果是一个类在另一个类里面管理。你也可以使用命名空间来为现有的类添加更多的静态成员。</p>\n<p>除了内部类的模式外，你可能也熟悉JavaScript的做法，即创建一个函数，然后通过在函数上添加属性来进一步扩展该函数。TypeScript使用声明合并，以类型安全的方式建立这样的定义。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">buildLabel</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buildLabel.<span class=\"property\">prefix</span> + name + buildLabel.<span class=\"property\">suffix</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">buildLabel</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> suffix = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> prefix = <span class=\"string\">&quot;Hello, &quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">buildLabel</span>(<span class=\"string\">&quot;Sam Smith&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>同样地，命名空间可以用来扩展具有静态成员的枚举。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">  red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  green = <span class=\"number\">2</span>,</span><br><span class=\"line\">  blue = <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mixColor</span>(<span class=\"params\"><span class=\"attr\">colorName</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (colorName == <span class=\"string\">&quot;yellow&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Color</span>.<span class=\"property\">red</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">green</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName == <span class=\"string\">&quot;white&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Color</span>.<span class=\"property\">red</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">green</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">blue</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName == <span class=\"string\">&quot;magenta&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Color</span>.<span class=\"property\">red</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">blue</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName == <span class=\"string\">&quot;cyan&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Color</span>.<span class=\"property\">green</span> + <span class=\"title class_\">Color</span>.<span class=\"property\">blue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-4-3-不被允许的合并\"><a href=\"#16-4-3-不被允许的合并\" class=\"headerlink\" title=\"16.4.3 不被允许的合并\"></a>16.4.3 不被允许的合并</h3><p>不是所有的合并在TypeScript中都是允许的。目前，类不能与其他类或变量合并。关于模仿类合并的信息，请参阅 <a href=\"https://www.typescriptlang.org/docs/handbook/mixins.html\">Mixins in TypeScript</a> 部分。</p>\n<h2 id=\"16-5-模块增强\"><a href=\"#16-5-模块增强\" class=\"headerlink\" title=\"16.5 模块增强\"></a>16.5 模块增强</h2><p>虽然JavaScript模块不支持合并，但你可以通过导入然后更新现有对象来打补丁。让我们来看看一个玩具<code>Observable</code>的例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// map.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">map</span> = <span class=\"keyword\">function</span> (<span class=\"params\">f</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这在TypeScript中也能正常工作，但编译器不知道 <code>Observable.prototype.map</code>。你可以使用模块增强来告诉编译器它的存在。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... implementation left as an exercise for the reader ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// map.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">module</span> <span class=\"string\">&quot;./observable&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    map&lt;U&gt;(<span class=\"attr\">f</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">x</span>: T</span>) =&gt;</span> U): <span class=\"title class_\">Observable</span>&lt;U&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Observable</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">map</span> = <span class=\"keyword\">function</span> (<span class=\"params\">f</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... another exercise for the reader</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// consumer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./map&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">o</span>: <span class=\"title class_\">Observable</span>&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">o.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x.<span class=\"title function_\">toFixed</span>());</span><br></pre></td></tr></table></figure>\n\n<p>模块名称的解析方式与 <code>import</code>&#x2F;<code>export</code> 中的模块指定器相同。更多信息请参见 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html\">Modules</a> 。然后，增量中的声明被合并，就像它们与原始文件在同一个文件中声明一样。</p>\n<p>然而，有两个限制需要记住：</p>\n<ol>\n<li>你不能在扩增中声明新的顶层声明–只是对现有声明的补丁。</li>\n<li>默认出口也不能被增强，只能是命名的出口（因为你需要用出口的名字来增强出口，而 <code>default</code> 是一个保留词–详见 <a href=\"https://github.com/Microsoft/TypeScript/issues/14080\">#14080</a> )</li>\n</ol>\n<h2 id=\"16-6-全局增强\"><a href=\"#16-6-全局增强\" class=\"headerlink\" title=\"16.6 全局增强\"></a>16.6 全局增强</h2><p>你也可以从一个模块内部向全局范围添加声明。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... still no implementation ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable language_\">global</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> <span class=\"title class_\">Array</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">toObservable</span>(): <span class=\"title class_\">Observable</span>&lt;T&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toObservable</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>全局增强的行为和限制与模块增强相同。</p>\n<p>——高级篇完——</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      },
      {
        "title": "3-4、高级篇：模块解析",
        "toc": true,
        "abbrlink": 3652,
        "date": "2024-01-28T13:11:21.000Z",
        "author": null,
        "img": null,
        "coverImg": null,
        "top": null,
        "cover": "/img/cover/cover_03.jpg",
        "mathjax": null,
        "password": null,
        "summary": null,
        "_content": "\n# 十三、模块解析\n\n*模块解析*是编译器用来分析一个导入什么的过程。考虑一个导入语句，如 `import { a } from \"moduleA\"；`为了检查对 `a` 的任何使用，编译器需要知道它到底代表什么，并需要检查它的定义 `moduleA`。\n\n在这一点上，编译器会问 \"`moduleA`的形状是什么？\" 虽然这听起来很简单，但 `moduleA` 可能被定义在你自己的一个`.ts`/`.tsx`文件中，或者在你的代码所依赖的一个 `.d.ts` 中。\n\n首先，编译器将试图找到一个代表导入模块的文件。为了做到这一点，编译器遵循两种不同的策略之一。 [Classic](https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic) or [Node](https://www.typescriptlang.org/docs/handbook/module-resolution.html#node)。这些策略告诉编译器去哪里寻找模块A。\n\n如果这没有用，并且如果模块名称是非相对的（在 `\"moduleA\"`的情况下，它是相对的），那么编译器将尝试定位一个环境模块的声明。我们接下来会讨论非相对导入。\n\n最后，如果编译器不能解决该模块，它将记录一个错误。在这种情况下，错误会是这样的：`error TS2307: Cannot find module 'moduleA'`。\n\n## 13.1 相对与非相对的模块导入\n\n模块导入是根据模块引用是相对的还是非相对的来解析的。\n\n相对导入是以`/`、`./`或`./`开头的导入。一些例子包括：\n\n- `import Entry from \"./components/Entry\";`\n- `import { DefaultHeaders } from \"../constants/http\";`\n- `import \"/mod\";`\n\n任何其他的导入都被认为是**不相关**的。一些例子包括：\n\n- `import * as $ from \"jquery\";`\n- `import { Component } from \"@angular/core\";`\n\n相对导入是相对于导入文件进行解析的，不能解析为环境模块的声明。你应该为你自己的模块使用相对导入，以保证在运行时保持其相对位置。\n\n非相对导入可以相对于 [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)来解析，也可以通过路径映射来解析，我们将在下面介绍。它们也可以解析为 [环境模块声明](https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules)。当导入你的任何外部依赖时，使用非相对路径。\n\n## 13.2 模块解析策略\n\n有两种可能的模块解析策略。 [Node](https://www.typescriptlang.org/docs/handbook/module-resolution.html#node) 和 [Classic](https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic)。你可以使用 [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution) 选项来指定模块解析策略。如果没有指定，对于`--module commonjs`，默认为 [Node](https://www.typescriptlang.org/docs/handbook/module-resolution.html#node) ，否则为 [Classic](https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic)（包括 [`module`](https://www.typescriptlang.org/tsconfig#module) 设置为 `amd`、`system`、`umd`、`es2015`、`esnext`等时）。\n\n> 注意： node 模块解析是TypeScript社区中最常用的，并被推荐用于大多数项目。如果你在TypeScript的导入和导出中遇到解析问题，可以尝试设置 `moduleResolution：\"node\"`，看看是否能解决这个问题。\n\n### 13.2.1 Classic\n\n这曾经是TypeScript的默认解析策略。现在，这个策略主要是为了向后兼容而存在。\n\n一个相对导入将被解析为相对于导入文件。所以在源文件`/root/src/folder/A.ts中从\"./moduleB \"导入{ b }会导致以下查找。\n\n所以在源文件 `/root/src/folder/A.ts` 中的 `import { b } from \"./moduleB\"` 查找路径如下：\n\n1. `/root/src/folder/moduleB.ts`\n2. `/root/src/folder/moduleB.d.ts`\n\n然而，对于非相对的模块导入，编译器从包含导入文件的目录开始沿着目录树向上走，试图找到一个匹配的定义文件。\n\n例如：\n\n在源文件`/root/src/folder/A.ts`中，对于 `import { b } from \"moduleB\"`，会导致尝试在以下位置找到 `\"moduleB\"`:\n\n1. `/root/src/folder/moduleB.ts`\n2. `/root/src/folder/moduleB.d.ts`\n3. `/root/src/moduleB.ts`\n4. `/root/src/moduleB.d.ts`\n5. `/root/moduleB.ts`\n6. `/root/moduleB.d.ts`\n7. `/moduleB.ts`\n8. `/moduleB.d.ts`\n\n### 13.2.2 Node\n\n这种解析策略试图在运行时模仿 [Node.js](https://nodejs.org/) 的模块解析机制。完整的Node.js解析算法在[Node.js模块文档](https://nodejs.org/api/modules.html#modules_all_together)中概述。\n\n- **Node.js如何解析模块**\n\n为了理解TS编译器将遵循哪些步骤，有必要对Node.js模块进行一些说明。传统上，Node.js的导入是通过调用一个名为`require`的函数来完成的。Node.js采取的行为会有所不同，这取决于require是给出相对路径还是非相对路径。\n\n相对路径是相当直接的。举个例子，让我们考虑一个位于 `/root/src/moduleA.js` 的文件，其中包含 `import var x = require(\"./moduleB\"); `的模块导入，Node.js 按照以下顺序解析：\n\n1. 询问名为 `/root/src/moduleB.js` 的是否存在。\n2. 询问文件夹 `/root/src/moduleB` 是否包含一个名为 `package.json` 的文件，其中指定了一个 `\"main\"` 模块。在我们的例子中，如果Node.js发现文件 `/root/src/moduleB/package.json`包含 `{ \"main\": \"lib/mainModule.js\" }`，那么Node.js将引用 `/root/src/moduleB/lib/mainModule.js`。\n3. 询问文件夹`/root/src/moduleB`是否包含一个名为`index.js`的文件。该文件被隐含地视为该文件夹的 \"主\"模块。\n\n你可以在Node.js文档中阅读更多关于 [file 模块](https://nodejs.org/api/modules.html#modules_file_modules) 模块 [folder 模块](https://nodejs.org/api/modules.html#modules_folders_as_modules)的内容。\n\n然而，非相关模块名称的解析是以不同方式进行的。Node将在名为 `node_modules` 的特殊文件夹中寻找你的模块。一个 `node_modules` 文件夹可以和当前文件在同一级别，也可以在目录链中更高的位置。Node将沿着目录链向上走，寻找每个 `node_modules`，直到找到你试图加载的模块。\n\n继续我们上面的例子，考虑一下如果 `/root/src/moduleA.js` 使用了一个非相对路径，并且有导入 `var x = require(\"moduleB\");`。然后，Node会尝试将 `moduleB` 解析到每一个位置，直到有一个成功：\n\n1. `/root/src/node_modules/moduleB.js`\n\n2. `/root/src/node_modules/moduleB/package.json` (如果 `\"main\"` 属性存在)\n\n3. `/root/src/node_modules/moduleB/index.js`\n\n4. `/root/node_modules/moduleB.js`\n\n5. `/root/node_modules/moduleB/package.json` (如果 `\"main\"` 属性存在)\n\n6. `/root/node_modules/moduleB/index.js`\n\n7. `/node_modules/moduleB.js`\n\n8. `/node_modules/moduleB/package.json` (如果 `\"main\" `属性存在)\n\n9. `/node_modules/moduleB/index.js`\n\n注意，Node.js在步骤（4）和（7）中跳出了本目录。\n\n你可以在Node.js文档中阅读更多关于 [从`node_modules`加载模块的过程](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders)。\n\n- **TypeScript如何解决模块**\n\nTypeScript将模仿Node.js的运行时解析策略，以便在编译时找到模块的定义文件。为了实现这一点，TypeScript在Node的解析逻辑上叠加了TypeScript源文件扩展名（`.ts`、`.tsx`和`.d.ts`）。TypeScript还将使用`package.json`中一个名为`types`的字段来达到 `\"main\"`的目的——编译器将使用它来找到 \"main \"定义文件来查阅。\n\n例如，在 `/root/src/moduleA.ts` 中的 `import { b } from \"./moduleB\"`，这样的导入语句会导致尝试在以下位置定位`\"./moduleB\"`。\n\n1. `/root/src/moduleB.ts`\n2. `/root/src/moduleB.tsx`\n3. `/root/src/moduleB.d.ts`\n4. `/root/src/moduleB/package.json` (如果 `types`属性存在)\n5. `/root/src/moduleB/index.ts`\n6. `/root/src/moduleB/index.tsx`\n7. `/root/src/moduleB/index.d.ts`\n\n回顾一下，Node.js寻找一个名为 `moduleB.js` 的文件，然后寻找一个适用的 `package.json`，然后寻找一个`index.js`。\n\n同样地，一个非相对的导入将遵循Node.js的解析逻辑，首先查找一个文件，然后查找一个适用的文件夹。因此，在源文件`/root/src/moduleA.ts`中的 `import { b } from \"moduleB\"`导致以下查找：\n\n1. `/root/src/node_modules/moduleB.ts`\n\n2. `/root/src/node_modules/moduleB.tsx`\n\n3. `/root/src/node_modules/moduleB.d.ts`\n\n4. `/root/src/node_modules/moduleB/package.json` (如果 `types` 属性存在)\n\n5. `/root/src/node_modules/@types/moduleB.d.ts`\n\n6. `/root/src/node_modules/moduleB/index.ts`\n\n7. `/root/src/node_modules/moduleB/index.tsx`\n\n8. `/root/src/node_modules/moduleB/index.d.ts`\n\n9. `/root/node_modules/moduleB.ts`\n\n10. `/root/node_modules/moduleB.tsx`\n\n11. `/root/node_modules/moduleB.d.ts`\n\n12. `/root/node_modules/moduleB/package.json` (如果 `types` 属性存在)\n\n13. `/root/node_modules/@types/moduleB.d.ts`\n\n14. `/root/node_modules/moduleB/index.ts`\n\n15. `/root/node_modules/moduleB/index.tsx`\n\n16. `/root/node_modules/moduleB/index.d.ts`\n\n17. `/node_modules/moduleB.ts`\n\n18. `/node_modules/moduleB.tsx`\n\n19. `/node_modules/moduleB.d.ts`\n\n20. `/node_modules/moduleB/package.json` (如果 `types` 属性存在)\n\n21. `/node_modules/@types/moduleB.d.ts`\n\n22. `/node_modules/moduleB/index.ts`\n\n23. `/node_modules/moduleB/index.tsx`\n\n24. `/node_modules/moduleB/index.d.ts`\n\n不要被这里的步骤数量所吓倒——TypeScript仍然只是在步骤(9)和(17)上跳了两次目录。这其实并不比Node.js本身所做的更复杂。\n\n## 13.3 额外的模块解析标志\n\n一个项目的源代码内容有时与输出的内容不一致。通常情况下，一组构建步骤会产生最终的输出。这些步骤包括将 `.ts`文件编译成`.js`，并将不同的源文件位置的依赖关系复制到一个单一的输出位置。最终的结果是，模块在运行时的名称可能与包含其定义的源文件不同。或者最终输出中的模块路径可能与编译时对应的源文件路径不一致。\n\nTypeScript编译器有一组额外的标志，以*告知*编译器预计将发生在源文件上的转换，以生成最终的输出。\n\n值得注意的是，编译器*不会*执行任何这些转换；它只是使用这些信息来指导解析模块，导入到其定义文件的过程。\n\n### 13.3.1 Base URL\n\n在使用AMD模块加载器的应用程序中，使用 `baseUrl` 是一种常见的做法，模块在运行时被 \"部署\"到一个文件夹。这些模块的来源可以在不同的目录中，但构建脚本会把它们放在一起。\n\n设置 `baseUrl` 会通知编译器在哪里找到模块。所有非相对名称的模块导入都被认为是相对于 `baseUr`的。\n\n_baseUrl_ 的值由以下两种情况决定：\n\n- _baseUrl_ 命令行参数的值（如果给定的路径是相对的，它是基于当前目录计算的）\n- `tsconfig.json` 中的 _baseUrl_ 属性值（如果给定的路径是相对的，则根据 `'tsconfig.json'` 的位置计算）\n\n请注意，相对模块的导入不受设置 baseUrl 的影响，因为它们总是相对于其导入文件进行解析。\n\n你可以在 [RequireJS](http://requirejs.org/docs/api.html#config-baseUrl) 和 [SystemJS](https://github.com/systemjs/systemjs/blob/main/docs/api.md) 文档中找到更多关于 baseUrl 的文档。\n\n### 13.3.2 路径映射\n\n有时模块并不直接位于*baseUrl*下。例如，对模块 `\"jquery \"`的导入会在运行时被翻译成 `\"node_modules/jquery/dist/jquery.slim.min.js\"`。装载器使用映射配置在运行时将模块名称映射到文件，见 [RequireJs 文档](http://requirejs.org/docs/api.html#config-paths)和 [SystemJS 文档](https://github.com/systemjs/systemjs/blob/main/docs/import-maps.md)。\n\nTypeScript编译器支持使用 `tsconfig.json` 文件中的 [`paths`](https://www.typescriptlang.org/tsconfig#paths) 属性来声明这种映射关系。下面是一个例子，说明如何为`jquery`指定 [`paths`](https://www.typescriptlang.org/tsconfig#paths) 属性。\n\n```tsx\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // 如果设置 \"paths\"，这个必须指定。\n    \"paths\": {\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"] // 这种映射是相对于 \"baseUrl\"而指定的。\n    }\n  }\n}\n```\n\nPlease notice that [`paths`](https://www.typescriptlang.org/tsconfig#paths) are resolved relative to [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl). When setting [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl) to another value than `\".\"`, i.e. the directory of `tsconfig.json`, the mappings must be changed accordingly. Say, you set `\"baseUrl\": \"./src\"` in the above example, then jquery should be mapped to `\"../node_modules/jquery/dist/jquery\"`.\n\nUsing [`paths`](https://www.typescriptlang.org/tsconfig#paths) also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:\n\n请注意，`paths` 是相对于 `baseUrl` 解析的。当设置 `baseUrl` 为 `\".\"` 以外的其他值时，即 `tsconfig.json` 的目录，映射必须相应改变。比如，你把 `\"baseUrl \"`设置为` \"./src\"`，那么jquery应该被映射到`\"../node_modules/jquery/dist/jquery\"`。\n\n使用 `paths` 还可以实现更复杂的映射，包括多个回退位置。考虑一个项目的配置，其中只有一些模块在一个地方可用，而其他的在另一个地方。一个构建步骤会把它们放在一个地方。项目布局可能看起来像：\n\n```\nprojectRoot\n├── folder1\n│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json\n```\n\n相应的 `tsconfig.json` 将看起来像：\n\n```\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"*\": [\"*\", \"generated/*\"]\n    }\n  }\n}\n```\n\n这告诉编译器对于任何符合 `\"*\"` 模式的模块导入（即所有值），要在两个地方寻找：\n\n1. `\"*\"`: 意思是相同的名字不变，所以映射 `<moduleName>` => `<baseUrl>/<moduleName>`。\n2. `\"generated/*\"`：意思是模块名称有一个附加的前缀 \"generated\"，所以` <moduleName>` => `<baseUrl>/generated/<moduleName>`。\n\n按照这个逻辑，编译器将试图将这两个导入解析为这样：\n\n`import ‘folder1/file2’:`\n\n1. 模式`'*'`被匹配，通配符捕获了整个模块的名称\n2. 尝试列表中的第一个替换：`'*'` -> `folder1/file2`\n3. 替换的结果是非相对名称——与 _baseUrl_ 结合 -> `projectRoot/folder1/file2.ts`。\n4. 文件存在。完成了。\n\n`import ‘folder2/file3’:`\n\n1. 模式`'*'`被匹配，通配符捕获了整个模块的名称\n2. 尝试列表中的第一个替换。`'*' `-> `folder2/file3`\n3. 替换的结果是非相对名称 - 与 _baseUrl_ 结合 -> `projectRoot/folder2/file3.ts`\n4. 文件不存在，移到第二个替换项\n5. 第二个替换 `'generated/*'` -> `generated/folder2/file3`\n6. 替换的结果是非相对名称 - 与baseUrl结合 -> projectRoot/generated/folder2/file3.ts\n7. 文件存在。完成了。\n\n### 13.3.3 带有`rootDirs`的虚拟目录\n\n有时，在编译时来自多个目录的项目源都会被合并，以生成一个单一的输出目录。这可以被看作是一组源目录创建了一个 \"虚拟 \"目录。\n\n使用`rootDirs`，你可以告知编译器构成这个 \"虚拟 \"目录的根；因此，编译器可以在这些 \"虚拟 \"目录中解决相对模块的导入，就像它们被合并在一个目录中一样。\n\n例如，考虑这个项目结构：\n\n```\nsrc\n └── views\n     └── view1.ts (imports './template1')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports './view2')\n```\n\n`src/views`中的文件是一些UI控件的用户代码。`generated/templates`中的文件是由模板生成器作为构建的一部分，自动生成的UI模板绑定代码。构建步骤会将`/src/views`和`/generated/templates/views`中的文件复制到输出的同一个目录中。在运行时，一个视图可以期望它的模板存在于它的旁边，因此应该使用 `\"./template \"`这样的相对名称来导入它。\n\n为了向编译器指定这种关系，可以使用 `rootDirs`。`rootDirs`指定了一个根的列表，这些根的内容在运行时被期望合并。所以按照我们的例子，`tsconfig.json`文件应该看起来像：\n\n```tsx\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}\n```\n\n每当编译器在其中一个 `rootDirs` 的子文件夹中看到一个相对的模块导入，它就会尝试在 `rootDirs` 的每个条目中寻找这个导入。\n\n`rootDirs`的灵活性并不局限于，指定一个在逻辑上合并的物理源代码目录的列表。提供的数组可以包括任何数量的特别的、任意的目录名称，不管它们是否存在。这允许编译器以类型安全的方式捕获复杂的捆绑和运行时特征，如条件性包含和项目特定的加载器插件。\n\n考虑一个国际化的场景，构建工具通过插值一个特殊的路径标记，例如`#{locale}`，作为相对模块路径的一部分，如`./#{locale}/messages`，自动生成特定地域的捆绑。在这个假设的设置中，工具列举了支持的语言，将抽象的路径映射为`./zh/messages`，`./de/messages`，等等。\n\n假设这些模块中的每一个都导出一个字符串数组。例如，`./zh/messages`可能包含：\n\n```tsx\nexport default [\"您好吗\", \"很高兴认识你\"];\n```\n\n通过利用 [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs) ，我们可以告知编译器这种映射，从而允许它安全地解析`./#{locale}/messages`，即使该目录永远不存在。例如，在下面的`tsconfig.json`中：\n\n```tsx\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/zh\", \"src/de\", \"src/#{locale}\"]\n  }\n}\n```\n\n编译器现在会将`import messages from './#{locale}/messages'` 解析为 `import messages from './zh/messages'` ，以便于在不影响设计时间支持的情况下，以与地区无关的方式开发。\n\n## 13.4 追踪模块的解析\n\n如前所述，编译器在解析一个模块时可以访问当前文件夹以外的文件。这在诊断为什么一个模块没有被解析，或者被解析为一个不正确的定义时可能会很困难。使用 [`traceResolution`](https://www.typescriptlang.org/tsconfig#traceResolution) 启用编译器模块解析跟踪，可以深入了解模块解析过程中发生了什么。\n\n假设我们有一个使用 `typescript` 模块的示例应用程序。`app.ts` 有一个类似 `import * as ts from \"typescript \"`的导入。\n\n```tsx\n│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts\n```\n\n用 [`traceResolution`](https://www.typescriptlang.org/tsconfig#traceResolution)调用编译器\n\n```shell\ntsc --traceResolution\n```\n\n输出结果如下：\n\n```tsx\n======== Resolving module 'typescript' from 'src/app.ts'. ========\nModule resolution kind is not specified, using 'NodeJs'.\nLoading module 'typescript' from 'node_modules' folder.\nFile 'src/node_modules/typescript.ts' does not exist.\nFile 'src/node_modules/typescript.tsx' does not exist.\nFile 'src/node_modules/typescript.d.ts' does not exist.\nFile 'src/node_modules/typescript/package.json' does not exist.\nFile 'node_modules/typescript.ts' does not exist.\nFile 'node_modules/typescript.tsx' does not exist.\nFile 'node_modules/typescript.d.ts' does not exist.\nFound 'package.json' at 'node_modules/typescript/package.json'.\n'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.\nFile 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.\n======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========\n```\n\n需要注意的事项:\n\n- 导入的名称和位置\n\n```\n======== 从'src/app.ts'中解析模块'typescript'。 ========\n```\n\n- 编译器所遵循的策略是\n\n```\n未指定模块解析种类，使用'NodeJs'。\n```\n\n- 从npm包中加载类型\n\n```\npackage.json'有'typescript'字段'./lib/typescript.d.ts'，引用'node_modules/typescript/lib/typescript.d.ts'。\n```\n\n- 最终结果\n\n```\n======== 模块名称'typescript'已成功解析为'node_modules/typescript/lib/typescript.d.ts'。========\n```\n\n## 13.5 应用`--noResolve`\n\n通常情况下，编译器在开始编译过程之前会尝试解析所有模块的导入。每当它成功地解析了一个文件的导入，该文件就被添加到编译器以后要处理的文件集合中。\n\n[`noResolve`](https://www.typescriptlang.org/tsconfig#noResolve) 编译器选项指示编译器不要 \"添加 \"任何未在命令行中传递的文件到编译中。它仍然会尝试将模块解析为文件，但如果没有指定文件，它将不会被包括在内。\n\n举个例子：\n\n**app.ts**\n\n```tsx\nimport * as A from \"moduleA\"; // 正确，'moduleA'在命令行上通过了\nimport * as B from \"moduleB\"; // 错误 TS2307: 无法找到模块'moduleB'\n```\n\n```shell\ntsc app.ts moduleA.ts --noResolve\n```\n\n使用 `noResolve` 编译` app.t` 将导致：\n\n- 正确地找到模块A，因为它是在命令行上传递的。\n- 没有找到模块B，因为它没有被传递，所以出现错误。\n\n## 13.6 常见问题\n\n**为什么排除列表中的模块仍然会被编译器选中？**\n\n`tsconfig.json`将一个文件夹变成一个 \"项目\"。如果不指定任何` \"exclude \"`或 `\"files \"`条目，包含`tsconfig.json`的文件夹及其所有子目录中的所有文件都会包括在你的编译中。如果你想排除某些文件，使用 `\"exclude\"`，如果你想指定所有的文件，而不是让编译器去查找它们，使用 `\"files\"`。\n\n那是`tsconfig.json`的自动包含。这并没有嵌入上面讨论的模块解析。如果编译器将一个文件识别为模块导入的目标，它将被包含在编译中，不管它是否在前面的步骤中被排除。\n\n所以要从编译中排除一个文件，你需要排除它和所有有`import`或`/// <reference path=\"...\" />`指令的文件。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "source": "_posts/简体中文/TypeScript/3-4、高级篇：模块解析.md",
        "raw": "---\ntitle: 3-4、高级篇：模块解析\ntoc: true\ncategories:\n  - 简体中文\n  - TypeScript\ntags:\n  - 前端\n  - TypeScript\nabbrlink: 3652\ndate: 2024-01-28 21:11:21\nauthor:\nimg:\ncoverImg:\ntop:\ncover:\nmathjax:\npassword:\nsummary:\n---\n\n# 十三、模块解析\n\n*模块解析*是编译器用来分析一个导入什么的过程。考虑一个导入语句，如 `import { a } from \"moduleA\"；`为了检查对 `a` 的任何使用，编译器需要知道它到底代表什么，并需要检查它的定义 `moduleA`。\n\n在这一点上，编译器会问 \"`moduleA`的形状是什么？\" 虽然这听起来很简单，但 `moduleA` 可能被定义在你自己的一个`.ts`/`.tsx`文件中，或者在你的代码所依赖的一个 `.d.ts` 中。\n\n首先，编译器将试图找到一个代表导入模块的文件。为了做到这一点，编译器遵循两种不同的策略之一。 [Classic](https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic) or [Node](https://www.typescriptlang.org/docs/handbook/module-resolution.html#node)。这些策略告诉编译器去哪里寻找模块A。\n\n如果这没有用，并且如果模块名称是非相对的（在 `\"moduleA\"`的情况下，它是相对的），那么编译器将尝试定位一个环境模块的声明。我们接下来会讨论非相对导入。\n\n最后，如果编译器不能解决该模块，它将记录一个错误。在这种情况下，错误会是这样的：`error TS2307: Cannot find module 'moduleA'`。\n\n## 13.1 相对与非相对的模块导入\n\n模块导入是根据模块引用是相对的还是非相对的来解析的。\n\n相对导入是以`/`、`./`或`./`开头的导入。一些例子包括：\n\n- `import Entry from \"./components/Entry\";`\n- `import { DefaultHeaders } from \"../constants/http\";`\n- `import \"/mod\";`\n\n任何其他的导入都被认为是**不相关**的。一些例子包括：\n\n- `import * as $ from \"jquery\";`\n- `import { Component } from \"@angular/core\";`\n\n相对导入是相对于导入文件进行解析的，不能解析为环境模块的声明。你应该为你自己的模块使用相对导入，以保证在运行时保持其相对位置。\n\n非相对导入可以相对于 [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl)来解析，也可以通过路径映射来解析，我们将在下面介绍。它们也可以解析为 [环境模块声明](https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules)。当导入你的任何外部依赖时，使用非相对路径。\n\n## 13.2 模块解析策略\n\n有两种可能的模块解析策略。 [Node](https://www.typescriptlang.org/docs/handbook/module-resolution.html#node) 和 [Classic](https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic)。你可以使用 [`moduleResolution`](https://www.typescriptlang.org/tsconfig#moduleResolution) 选项来指定模块解析策略。如果没有指定，对于`--module commonjs`，默认为 [Node](https://www.typescriptlang.org/docs/handbook/module-resolution.html#node) ，否则为 [Classic](https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic)（包括 [`module`](https://www.typescriptlang.org/tsconfig#module) 设置为 `amd`、`system`、`umd`、`es2015`、`esnext`等时）。\n\n> 注意： node 模块解析是TypeScript社区中最常用的，并被推荐用于大多数项目。如果你在TypeScript的导入和导出中遇到解析问题，可以尝试设置 `moduleResolution：\"node\"`，看看是否能解决这个问题。\n\n### 13.2.1 Classic\n\n这曾经是TypeScript的默认解析策略。现在，这个策略主要是为了向后兼容而存在。\n\n一个相对导入将被解析为相对于导入文件。所以在源文件`/root/src/folder/A.ts中从\"./moduleB \"导入{ b }会导致以下查找。\n\n所以在源文件 `/root/src/folder/A.ts` 中的 `import { b } from \"./moduleB\"` 查找路径如下：\n\n1. `/root/src/folder/moduleB.ts`\n2. `/root/src/folder/moduleB.d.ts`\n\n然而，对于非相对的模块导入，编译器从包含导入文件的目录开始沿着目录树向上走，试图找到一个匹配的定义文件。\n\n例如：\n\n在源文件`/root/src/folder/A.ts`中，对于 `import { b } from \"moduleB\"`，会导致尝试在以下位置找到 `\"moduleB\"`:\n\n1. `/root/src/folder/moduleB.ts`\n2. `/root/src/folder/moduleB.d.ts`\n3. `/root/src/moduleB.ts`\n4. `/root/src/moduleB.d.ts`\n5. `/root/moduleB.ts`\n6. `/root/moduleB.d.ts`\n7. `/moduleB.ts`\n8. `/moduleB.d.ts`\n\n### 13.2.2 Node\n\n这种解析策略试图在运行时模仿 [Node.js](https://nodejs.org/) 的模块解析机制。完整的Node.js解析算法在[Node.js模块文档](https://nodejs.org/api/modules.html#modules_all_together)中概述。\n\n- **Node.js如何解析模块**\n\n为了理解TS编译器将遵循哪些步骤，有必要对Node.js模块进行一些说明。传统上，Node.js的导入是通过调用一个名为`require`的函数来完成的。Node.js采取的行为会有所不同，这取决于require是给出相对路径还是非相对路径。\n\n相对路径是相当直接的。举个例子，让我们考虑一个位于 `/root/src/moduleA.js` 的文件，其中包含 `import var x = require(\"./moduleB\"); `的模块导入，Node.js 按照以下顺序解析：\n\n1. 询问名为 `/root/src/moduleB.js` 的是否存在。\n2. 询问文件夹 `/root/src/moduleB` 是否包含一个名为 `package.json` 的文件，其中指定了一个 `\"main\"` 模块。在我们的例子中，如果Node.js发现文件 `/root/src/moduleB/package.json`包含 `{ \"main\": \"lib/mainModule.js\" }`，那么Node.js将引用 `/root/src/moduleB/lib/mainModule.js`。\n3. 询问文件夹`/root/src/moduleB`是否包含一个名为`index.js`的文件。该文件被隐含地视为该文件夹的 \"主\"模块。\n\n你可以在Node.js文档中阅读更多关于 [file 模块](https://nodejs.org/api/modules.html#modules_file_modules) 模块 [folder 模块](https://nodejs.org/api/modules.html#modules_folders_as_modules)的内容。\n\n然而，非相关模块名称的解析是以不同方式进行的。Node将在名为 `node_modules` 的特殊文件夹中寻找你的模块。一个 `node_modules` 文件夹可以和当前文件在同一级别，也可以在目录链中更高的位置。Node将沿着目录链向上走，寻找每个 `node_modules`，直到找到你试图加载的模块。\n\n继续我们上面的例子，考虑一下如果 `/root/src/moduleA.js` 使用了一个非相对路径，并且有导入 `var x = require(\"moduleB\");`。然后，Node会尝试将 `moduleB` 解析到每一个位置，直到有一个成功：\n\n1. `/root/src/node_modules/moduleB.js`\n\n2. `/root/src/node_modules/moduleB/package.json` (如果 `\"main\"` 属性存在)\n\n3. `/root/src/node_modules/moduleB/index.js`\n\n4. `/root/node_modules/moduleB.js`\n\n5. `/root/node_modules/moduleB/package.json` (如果 `\"main\"` 属性存在)\n\n6. `/root/node_modules/moduleB/index.js`\n\n7. `/node_modules/moduleB.js`\n\n8. `/node_modules/moduleB/package.json` (如果 `\"main\" `属性存在)\n\n9. `/node_modules/moduleB/index.js`\n\n注意，Node.js在步骤（4）和（7）中跳出了本目录。\n\n你可以在Node.js文档中阅读更多关于 [从`node_modules`加载模块的过程](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders)。\n\n- **TypeScript如何解决模块**\n\nTypeScript将模仿Node.js的运行时解析策略，以便在编译时找到模块的定义文件。为了实现这一点，TypeScript在Node的解析逻辑上叠加了TypeScript源文件扩展名（`.ts`、`.tsx`和`.d.ts`）。TypeScript还将使用`package.json`中一个名为`types`的字段来达到 `\"main\"`的目的——编译器将使用它来找到 \"main \"定义文件来查阅。\n\n例如，在 `/root/src/moduleA.ts` 中的 `import { b } from \"./moduleB\"`，这样的导入语句会导致尝试在以下位置定位`\"./moduleB\"`。\n\n1. `/root/src/moduleB.ts`\n2. `/root/src/moduleB.tsx`\n3. `/root/src/moduleB.d.ts`\n4. `/root/src/moduleB/package.json` (如果 `types`属性存在)\n5. `/root/src/moduleB/index.ts`\n6. `/root/src/moduleB/index.tsx`\n7. `/root/src/moduleB/index.d.ts`\n\n回顾一下，Node.js寻找一个名为 `moduleB.js` 的文件，然后寻找一个适用的 `package.json`，然后寻找一个`index.js`。\n\n同样地，一个非相对的导入将遵循Node.js的解析逻辑，首先查找一个文件，然后查找一个适用的文件夹。因此，在源文件`/root/src/moduleA.ts`中的 `import { b } from \"moduleB\"`导致以下查找：\n\n1. `/root/src/node_modules/moduleB.ts`\n\n2. `/root/src/node_modules/moduleB.tsx`\n\n3. `/root/src/node_modules/moduleB.d.ts`\n\n4. `/root/src/node_modules/moduleB/package.json` (如果 `types` 属性存在)\n\n5. `/root/src/node_modules/@types/moduleB.d.ts`\n\n6. `/root/src/node_modules/moduleB/index.ts`\n\n7. `/root/src/node_modules/moduleB/index.tsx`\n\n8. `/root/src/node_modules/moduleB/index.d.ts`\n\n9. `/root/node_modules/moduleB.ts`\n\n10. `/root/node_modules/moduleB.tsx`\n\n11. `/root/node_modules/moduleB.d.ts`\n\n12. `/root/node_modules/moduleB/package.json` (如果 `types` 属性存在)\n\n13. `/root/node_modules/@types/moduleB.d.ts`\n\n14. `/root/node_modules/moduleB/index.ts`\n\n15. `/root/node_modules/moduleB/index.tsx`\n\n16. `/root/node_modules/moduleB/index.d.ts`\n\n17. `/node_modules/moduleB.ts`\n\n18. `/node_modules/moduleB.tsx`\n\n19. `/node_modules/moduleB.d.ts`\n\n20. `/node_modules/moduleB/package.json` (如果 `types` 属性存在)\n\n21. `/node_modules/@types/moduleB.d.ts`\n\n22. `/node_modules/moduleB/index.ts`\n\n23. `/node_modules/moduleB/index.tsx`\n\n24. `/node_modules/moduleB/index.d.ts`\n\n不要被这里的步骤数量所吓倒——TypeScript仍然只是在步骤(9)和(17)上跳了两次目录。这其实并不比Node.js本身所做的更复杂。\n\n## 13.3 额外的模块解析标志\n\n一个项目的源代码内容有时与输出的内容不一致。通常情况下，一组构建步骤会产生最终的输出。这些步骤包括将 `.ts`文件编译成`.js`，并将不同的源文件位置的依赖关系复制到一个单一的输出位置。最终的结果是，模块在运行时的名称可能与包含其定义的源文件不同。或者最终输出中的模块路径可能与编译时对应的源文件路径不一致。\n\nTypeScript编译器有一组额外的标志，以*告知*编译器预计将发生在源文件上的转换，以生成最终的输出。\n\n值得注意的是，编译器*不会*执行任何这些转换；它只是使用这些信息来指导解析模块，导入到其定义文件的过程。\n\n### 13.3.1 Base URL\n\n在使用AMD模块加载器的应用程序中，使用 `baseUrl` 是一种常见的做法，模块在运行时被 \"部署\"到一个文件夹。这些模块的来源可以在不同的目录中，但构建脚本会把它们放在一起。\n\n设置 `baseUrl` 会通知编译器在哪里找到模块。所有非相对名称的模块导入都被认为是相对于 `baseUr`的。\n\n_baseUrl_ 的值由以下两种情况决定：\n\n- _baseUrl_ 命令行参数的值（如果给定的路径是相对的，它是基于当前目录计算的）\n- `tsconfig.json` 中的 _baseUrl_ 属性值（如果给定的路径是相对的，则根据 `'tsconfig.json'` 的位置计算）\n\n请注意，相对模块的导入不受设置 baseUrl 的影响，因为它们总是相对于其导入文件进行解析。\n\n你可以在 [RequireJS](http://requirejs.org/docs/api.html#config-baseUrl) 和 [SystemJS](https://github.com/systemjs/systemjs/blob/main/docs/api.md) 文档中找到更多关于 baseUrl 的文档。\n\n### 13.3.2 路径映射\n\n有时模块并不直接位于*baseUrl*下。例如，对模块 `\"jquery \"`的导入会在运行时被翻译成 `\"node_modules/jquery/dist/jquery.slim.min.js\"`。装载器使用映射配置在运行时将模块名称映射到文件，见 [RequireJs 文档](http://requirejs.org/docs/api.html#config-paths)和 [SystemJS 文档](https://github.com/systemjs/systemjs/blob/main/docs/import-maps.md)。\n\nTypeScript编译器支持使用 `tsconfig.json` 文件中的 [`paths`](https://www.typescriptlang.org/tsconfig#paths) 属性来声明这种映射关系。下面是一个例子，说明如何为`jquery`指定 [`paths`](https://www.typescriptlang.org/tsconfig#paths) 属性。\n\n```tsx\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // 如果设置 \"paths\"，这个必须指定。\n    \"paths\": {\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"] // 这种映射是相对于 \"baseUrl\"而指定的。\n    }\n  }\n}\n```\n\nPlease notice that [`paths`](https://www.typescriptlang.org/tsconfig#paths) are resolved relative to [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl). When setting [`baseUrl`](https://www.typescriptlang.org/tsconfig#baseUrl) to another value than `\".\"`, i.e. the directory of `tsconfig.json`, the mappings must be changed accordingly. Say, you set `\"baseUrl\": \"./src\"` in the above example, then jquery should be mapped to `\"../node_modules/jquery/dist/jquery\"`.\n\nUsing [`paths`](https://www.typescriptlang.org/tsconfig#paths) also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:\n\n请注意，`paths` 是相对于 `baseUrl` 解析的。当设置 `baseUrl` 为 `\".\"` 以外的其他值时，即 `tsconfig.json` 的目录，映射必须相应改变。比如，你把 `\"baseUrl \"`设置为` \"./src\"`，那么jquery应该被映射到`\"../node_modules/jquery/dist/jquery\"`。\n\n使用 `paths` 还可以实现更复杂的映射，包括多个回退位置。考虑一个项目的配置，其中只有一些模块在一个地方可用，而其他的在另一个地方。一个构建步骤会把它们放在一个地方。项目布局可能看起来像：\n\n```\nprojectRoot\n├── folder1\n│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json\n```\n\n相应的 `tsconfig.json` 将看起来像：\n\n```\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"*\": [\"*\", \"generated/*\"]\n    }\n  }\n}\n```\n\n这告诉编译器对于任何符合 `\"*\"` 模式的模块导入（即所有值），要在两个地方寻找：\n\n1. `\"*\"`: 意思是相同的名字不变，所以映射 `<moduleName>` => `<baseUrl>/<moduleName>`。\n2. `\"generated/*\"`：意思是模块名称有一个附加的前缀 \"generated\"，所以` <moduleName>` => `<baseUrl>/generated/<moduleName>`。\n\n按照这个逻辑，编译器将试图将这两个导入解析为这样：\n\n`import ‘folder1/file2’:`\n\n1. 模式`'*'`被匹配，通配符捕获了整个模块的名称\n2. 尝试列表中的第一个替换：`'*'` -> `folder1/file2`\n3. 替换的结果是非相对名称——与 _baseUrl_ 结合 -> `projectRoot/folder1/file2.ts`。\n4. 文件存在。完成了。\n\n`import ‘folder2/file3’:`\n\n1. 模式`'*'`被匹配，通配符捕获了整个模块的名称\n2. 尝试列表中的第一个替换。`'*' `-> `folder2/file3`\n3. 替换的结果是非相对名称 - 与 _baseUrl_ 结合 -> `projectRoot/folder2/file3.ts`\n4. 文件不存在，移到第二个替换项\n5. 第二个替换 `'generated/*'` -> `generated/folder2/file3`\n6. 替换的结果是非相对名称 - 与baseUrl结合 -> projectRoot/generated/folder2/file3.ts\n7. 文件存在。完成了。\n\n### 13.3.3 带有`rootDirs`的虚拟目录\n\n有时，在编译时来自多个目录的项目源都会被合并，以生成一个单一的输出目录。这可以被看作是一组源目录创建了一个 \"虚拟 \"目录。\n\n使用`rootDirs`，你可以告知编译器构成这个 \"虚拟 \"目录的根；因此，编译器可以在这些 \"虚拟 \"目录中解决相对模块的导入，就像它们被合并在一个目录中一样。\n\n例如，考虑这个项目结构：\n\n```\nsrc\n └── views\n     └── view1.ts (imports './template1')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports './view2')\n```\n\n`src/views`中的文件是一些UI控件的用户代码。`generated/templates`中的文件是由模板生成器作为构建的一部分，自动生成的UI模板绑定代码。构建步骤会将`/src/views`和`/generated/templates/views`中的文件复制到输出的同一个目录中。在运行时，一个视图可以期望它的模板存在于它的旁边，因此应该使用 `\"./template \"`这样的相对名称来导入它。\n\n为了向编译器指定这种关系，可以使用 `rootDirs`。`rootDirs`指定了一个根的列表，这些根的内容在运行时被期望合并。所以按照我们的例子，`tsconfig.json`文件应该看起来像：\n\n```tsx\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}\n```\n\n每当编译器在其中一个 `rootDirs` 的子文件夹中看到一个相对的模块导入，它就会尝试在 `rootDirs` 的每个条目中寻找这个导入。\n\n`rootDirs`的灵活性并不局限于，指定一个在逻辑上合并的物理源代码目录的列表。提供的数组可以包括任何数量的特别的、任意的目录名称，不管它们是否存在。这允许编译器以类型安全的方式捕获复杂的捆绑和运行时特征，如条件性包含和项目特定的加载器插件。\n\n考虑一个国际化的场景，构建工具通过插值一个特殊的路径标记，例如`#{locale}`，作为相对模块路径的一部分，如`./#{locale}/messages`，自动生成特定地域的捆绑。在这个假设的设置中，工具列举了支持的语言，将抽象的路径映射为`./zh/messages`，`./de/messages`，等等。\n\n假设这些模块中的每一个都导出一个字符串数组。例如，`./zh/messages`可能包含：\n\n```tsx\nexport default [\"您好吗\", \"很高兴认识你\"];\n```\n\n通过利用 [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs) ，我们可以告知编译器这种映射，从而允许它安全地解析`./#{locale}/messages`，即使该目录永远不存在。例如，在下面的`tsconfig.json`中：\n\n```tsx\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/zh\", \"src/de\", \"src/#{locale}\"]\n  }\n}\n```\n\n编译器现在会将`import messages from './#{locale}/messages'` 解析为 `import messages from './zh/messages'` ，以便于在不影响设计时间支持的情况下，以与地区无关的方式开发。\n\n## 13.4 追踪模块的解析\n\n如前所述，编译器在解析一个模块时可以访问当前文件夹以外的文件。这在诊断为什么一个模块没有被解析，或者被解析为一个不正确的定义时可能会很困难。使用 [`traceResolution`](https://www.typescriptlang.org/tsconfig#traceResolution) 启用编译器模块解析跟踪，可以深入了解模块解析过程中发生了什么。\n\n假设我们有一个使用 `typescript` 模块的示例应用程序。`app.ts` 有一个类似 `import * as ts from \"typescript \"`的导入。\n\n```tsx\n│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts\n```\n\n用 [`traceResolution`](https://www.typescriptlang.org/tsconfig#traceResolution)调用编译器\n\n```shell\ntsc --traceResolution\n```\n\n输出结果如下：\n\n```tsx\n======== Resolving module 'typescript' from 'src/app.ts'. ========\nModule resolution kind is not specified, using 'NodeJs'.\nLoading module 'typescript' from 'node_modules' folder.\nFile 'src/node_modules/typescript.ts' does not exist.\nFile 'src/node_modules/typescript.tsx' does not exist.\nFile 'src/node_modules/typescript.d.ts' does not exist.\nFile 'src/node_modules/typescript/package.json' does not exist.\nFile 'node_modules/typescript.ts' does not exist.\nFile 'node_modules/typescript.tsx' does not exist.\nFile 'node_modules/typescript.d.ts' does not exist.\nFound 'package.json' at 'node_modules/typescript/package.json'.\n'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.\nFile 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.\n======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========\n```\n\n需要注意的事项:\n\n- 导入的名称和位置\n\n```\n======== 从'src/app.ts'中解析模块'typescript'。 ========\n```\n\n- 编译器所遵循的策略是\n\n```\n未指定模块解析种类，使用'NodeJs'。\n```\n\n- 从npm包中加载类型\n\n```\npackage.json'有'typescript'字段'./lib/typescript.d.ts'，引用'node_modules/typescript/lib/typescript.d.ts'。\n```\n\n- 最终结果\n\n```\n======== 模块名称'typescript'已成功解析为'node_modules/typescript/lib/typescript.d.ts'。========\n```\n\n## 13.5 应用`--noResolve`\n\n通常情况下，编译器在开始编译过程之前会尝试解析所有模块的导入。每当它成功地解析了一个文件的导入，该文件就被添加到编译器以后要处理的文件集合中。\n\n[`noResolve`](https://www.typescriptlang.org/tsconfig#noResolve) 编译器选项指示编译器不要 \"添加 \"任何未在命令行中传递的文件到编译中。它仍然会尝试将模块解析为文件，但如果没有指定文件，它将不会被包括在内。\n\n举个例子：\n\n**app.ts**\n\n```tsx\nimport * as A from \"moduleA\"; // 正确，'moduleA'在命令行上通过了\nimport * as B from \"moduleB\"; // 错误 TS2307: 无法找到模块'moduleB'\n```\n\n```shell\ntsc app.ts moduleA.ts --noResolve\n```\n\n使用 `noResolve` 编译` app.t` 将导致：\n\n- 正确地找到模块A，因为它是在命令行上传递的。\n- 没有找到模块B，因为它没有被传递，所以出现错误。\n\n## 13.6 常见问题\n\n**为什么排除列表中的模块仍然会被编译器选中？**\n\n`tsconfig.json`将一个文件夹变成一个 \"项目\"。如果不指定任何` \"exclude \"`或 `\"files \"`条目，包含`tsconfig.json`的文件夹及其所有子目录中的所有文件都会包括在你的编译中。如果你想排除某些文件，使用 `\"exclude\"`，如果你想指定所有的文件，而不是让编译器去查找它们，使用 `\"files\"`。\n\n那是`tsconfig.json`的自动包含。这并没有嵌入上面讨论的模块解析。如果编译器将一个文件识别为模块导入的目标，它将被包含在编译中，不管它是否在前面的步骤中被排除。\n\n所以要从编译中排除一个文件，你需要排除它和所有有`import`或`/// <reference path=\"...\" />`指令的文件。\n\n### 特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。\n",
        "slug": "简体中文/TypeScript/3-4、高级篇：模块解析",
        "published": 1,
        "updated": "2024-01-28T13:46:42.267Z",
        "comments": 1,
        "layout": "post",
        "photos": [],
        "_id": "cmesvjaod002i94v36cesfnt9",
        "content": "<h1 id=\"十三、模块解析\"><a href=\"#十三、模块解析\" class=\"headerlink\" title=\"十三、模块解析\"></a>十三、模块解析</h1><p><em>模块解析</em>是编译器用来分析一个导入什么的过程。考虑一个导入语句，如 <code>import &#123; a &#125; from &quot;moduleA&quot;；</code>为了检查对 <code>a</code> 的任何使用，编译器需要知道它到底代表什么，并需要检查它的定义 <code>moduleA</code>。</p>\n<p>在这一点上，编译器会问 “<code>moduleA</code>的形状是什么？” 虽然这听起来很简单，但 <code>moduleA</code> 可能被定义在你自己的一个<code>.ts</code>&#x2F;<code>.tsx</code>文件中，或者在你的代码所依赖的一个 <code>.d.ts</code> 中。</p>\n<p>首先，编译器将试图找到一个代表导入模块的文件。为了做到这一点，编译器遵循两种不同的策略之一。 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic\">Classic</a> or <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#node\">Node</a>。这些策略告诉编译器去哪里寻找模块A。</p>\n<p>如果这没有用，并且如果模块名称是非相对的（在 <code>&quot;moduleA&quot;</code>的情况下，它是相对的），那么编译器将尝试定位一个环境模块的声明。我们接下来会讨论非相对导入。</p>\n<p>最后，如果编译器不能解决该模块，它将记录一个错误。在这种情况下，错误会是这样的：<code>error TS2307: Cannot find module &#39;moduleA&#39;</code>。</p>\n<h2 id=\"13-1-相对与非相对的模块导入\"><a href=\"#13-1-相对与非相对的模块导入\" class=\"headerlink\" title=\"13.1 相对与非相对的模块导入\"></a>13.1 相对与非相对的模块导入</h2><p>模块导入是根据模块引用是相对的还是非相对的来解析的。</p>\n<p>相对导入是以<code>/</code>、<code>./</code>或<code>./</code>开头的导入。一些例子包括：</p>\n<ul>\n<li><code>import Entry from &quot;./components/Entry&quot;;</code></li>\n<li><code>import &#123; DefaultHeaders &#125; from &quot;../constants/http&quot;;</code></li>\n<li><code>import &quot;/mod&quot;;</code></li>\n</ul>\n<p>任何其他的导入都被认为是<strong>不相关</strong>的。一些例子包括：</p>\n<ul>\n<li><code>import * as $ from &quot;jquery&quot;;</code></li>\n<li><code>import &#123; Component &#125; from &quot;@angular/core&quot;;</code></li>\n</ul>\n<p>相对导入是相对于导入文件进行解析的，不能解析为环境模块的声明。你应该为你自己的模块使用相对导入，以保证在运行时保持其相对位置。</p>\n<p>非相对导入可以相对于 <a href=\"https://www.typescriptlang.org/tsconfig#baseUrl\"><code>baseUrl</code></a>来解析，也可以通过路径映射来解析，我们将在下面介绍。它们也可以解析为 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules\">环境模块声明</a>。当导入你的任何外部依赖时，使用非相对路径。</p>\n<h2 id=\"13-2-模块解析策略\"><a href=\"#13-2-模块解析策略\" class=\"headerlink\" title=\"13.2 模块解析策略\"></a>13.2 模块解析策略</h2><p>有两种可能的模块解析策略。 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#node\">Node</a> 和 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic\">Classic</a>。你可以使用 <a href=\"https://www.typescriptlang.org/tsconfig#moduleResolution\"><code>moduleResolution</code></a> 选项来指定模块解析策略。如果没有指定，对于<code>--module commonjs</code>，默认为 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#node\">Node</a> ，否则为 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic\">Classic</a>（包括 <a href=\"https://www.typescriptlang.org/tsconfig#module\"><code>module</code></a> 设置为 <code>amd</code>、<code>system</code>、<code>umd</code>、<code>es2015</code>、<code>esnext</code>等时）。</p>\n<blockquote>\n<p>注意： node 模块解析是TypeScript社区中最常用的，并被推荐用于大多数项目。如果你在TypeScript的导入和导出中遇到解析问题，可以尝试设置 <code>moduleResolution：&quot;node&quot;</code>，看看是否能解决这个问题。</p>\n</blockquote>\n<h3 id=\"13-2-1-Classic\"><a href=\"#13-2-1-Classic\" class=\"headerlink\" title=\"13.2.1 Classic\"></a>13.2.1 Classic</h3><p>这曾经是TypeScript的默认解析策略。现在，这个策略主要是为了向后兼容而存在。</p>\n<p>一个相对导入将被解析为相对于导入文件。所以在源文件&#96;&#x2F;root&#x2F;src&#x2F;folder&#x2F;A.ts中从”.&#x2F;moduleB “导入{ b }会导致以下查找。</p>\n<p>所以在源文件 <code>/root/src/folder/A.ts</code> 中的 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code> 查找路径如下：</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n</ol>\n<p>然而，对于非相对的模块导入，编译器从包含导入文件的目录开始沿着目录树向上走，试图找到一个匹配的定义文件。</p>\n<p>例如：</p>\n<p>在源文件<code>/root/src/folder/A.ts</code>中，对于 <code>import &#123; b &#125; from &quot;moduleB&quot;</code>，会导致尝试在以下位置找到 <code>&quot;moduleB&quot;</code>:</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/moduleB.ts</code></li>\n<li><code>/root/moduleB.d.ts</code></li>\n<li><code>/moduleB.ts</code></li>\n<li><code>/moduleB.d.ts</code></li>\n</ol>\n<h3 id=\"13-2-2-Node\"><a href=\"#13-2-2-Node\" class=\"headerlink\" title=\"13.2.2 Node\"></a>13.2.2 Node</h3><p>这种解析策略试图在运行时模仿 <a href=\"https://nodejs.org/\">Node.js</a> 的模块解析机制。完整的Node.js解析算法在<a href=\"https://nodejs.org/api/modules.html#modules_all_together\">Node.js模块文档</a>中概述。</p>\n<ul>\n<li><strong>Node.js如何解析模块</strong></li>\n</ul>\n<p>为了理解TS编译器将遵循哪些步骤，有必要对Node.js模块进行一些说明。传统上，Node.js的导入是通过调用一个名为<code>require</code>的函数来完成的。Node.js采取的行为会有所不同，这取决于require是给出相对路径还是非相对路径。</p>\n<p>相对路径是相当直接的。举个例子，让我们考虑一个位于 <code>/root/src/moduleA.js</code> 的文件，其中包含 <code>import var x = require(&quot;./moduleB&quot;); </code>的模块导入，Node.js 按照以下顺序解析：</p>\n<ol>\n<li>询问名为 <code>/root/src/moduleB.js</code> 的是否存在。</li>\n<li>询问文件夹 <code>/root/src/moduleB</code> 是否包含一个名为 <code>package.json</code> 的文件，其中指定了一个 <code>&quot;main&quot;</code> 模块。在我们的例子中，如果Node.js发现文件 <code>/root/src/moduleB/package.json</code>包含 <code>&#123; &quot;main&quot;: &quot;lib/mainModule.js&quot; &#125;</code>，那么Node.js将引用 <code>/root/src/moduleB/lib/mainModule.js</code>。</li>\n<li>询问文件夹<code>/root/src/moduleB</code>是否包含一个名为<code>index.js</code>的文件。该文件被隐含地视为该文件夹的 “主”模块。</li>\n</ol>\n<p>你可以在Node.js文档中阅读更多关于 <a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">file 模块</a> 模块 <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">folder 模块</a>的内容。</p>\n<p>然而，非相关模块名称的解析是以不同方式进行的。Node将在名为 <code>node_modules</code> 的特殊文件夹中寻找你的模块。一个 <code>node_modules</code> 文件夹可以和当前文件在同一级别，也可以在目录链中更高的位置。Node将沿着目录链向上走，寻找每个 <code>node_modules</code>，直到找到你试图加载的模块。</p>\n<p>继续我们上面的例子，考虑一下如果 <code>/root/src/moduleA.js</code> 使用了一个非相对路径，并且有导入 <code>var x = require(&quot;moduleB&quot;);</code>。然后，Node会尝试将 <code>moduleB</code> 解析到每一个位置，直到有一个成功：</p>\n<ol>\n<li><p><code>/root/src/node_modules/moduleB.js</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/package.json</code> (如果 <code>&quot;main&quot;</code> 属性存在)</p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/index.js</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB.js</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/package.json</code> (如果 <code>&quot;main&quot;</code> 属性存在)</p>\n</li>\n<li><p><code>/root/node_modules/moduleB/index.js</code></p>\n</li>\n<li><p><code>/node_modules/moduleB.js</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/package.json</code> (如果 <code>&quot;main&quot; </code>属性存在)</p>\n</li>\n<li><p><code>/node_modules/moduleB/index.js</code></p>\n</li>\n</ol>\n<p>注意，Node.js在步骤（4）和（7）中跳出了本目录。</p>\n<p>你可以在Node.js文档中阅读更多关于 <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\">从<code>node_modules</code>加载模块的过程</a>。</p>\n<ul>\n<li><strong>TypeScript如何解决模块</strong></li>\n</ul>\n<p>TypeScript将模仿Node.js的运行时解析策略，以便在编译时找到模块的定义文件。为了实现这一点，TypeScript在Node的解析逻辑上叠加了TypeScript源文件扩展名（<code>.ts</code>、<code>.tsx</code>和<code>.d.ts</code>）。TypeScript还将使用<code>package.json</code>中一个名为<code>types</code>的字段来达到 <code>&quot;main&quot;</code>的目的——编译器将使用它来找到 “main “定义文件来查阅。</p>\n<p>例如，在 <code>/root/src/moduleA.ts</code> 中的 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code>，这样的导入语句会导致尝试在以下位置定位<code>&quot;./moduleB&quot;</code>。</p>\n<ol>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.tsx</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB/package.json</code> (如果 <code>types</code>属性存在)</li>\n<li><code>/root/src/moduleB/index.ts</code></li>\n<li><code>/root/src/moduleB/index.tsx</code></li>\n<li><code>/root/src/moduleB/index.d.ts</code></li>\n</ol>\n<p>回顾一下，Node.js寻找一个名为 <code>moduleB.js</code> 的文件，然后寻找一个适用的 <code>package.json</code>，然后寻找一个<code>index.js</code>。</p>\n<p>同样地，一个非相对的导入将遵循Node.js的解析逻辑，首先查找一个文件，然后查找一个适用的文件夹。因此，在源文件<code>/root/src/moduleA.ts</code>中的 <code>import &#123; b &#125; from &quot;moduleB&quot;</code>导致以下查找：</p>\n<ol>\n<li><p><code>/root/src/node_modules/moduleB.ts</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB.tsx</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/package.json</code> (如果 <code>types</code> 属性存在)</p>\n</li>\n<li><p><code>/root/src/node_modules/@types/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/index.ts</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/index.tsx</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/index.d.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB.tsx</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/package.json</code> (如果 <code>types</code> 属性存在)</p>\n</li>\n<li><p><code>/root/node_modules/@types/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/index.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/index.tsx</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/index.d.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB.tsx</code></p>\n</li>\n<li><p><code>/node_modules/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/package.json</code> (如果 <code>types</code> 属性存在)</p>\n</li>\n<li><p><code>/node_modules/@types/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/index.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/index.tsx</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/index.d.ts</code></p>\n</li>\n</ol>\n<p>不要被这里的步骤数量所吓倒——TypeScript仍然只是在步骤(9)和(17)上跳了两次目录。这其实并不比Node.js本身所做的更复杂。</p>\n<h2 id=\"13-3-额外的模块解析标志\"><a href=\"#13-3-额外的模块解析标志\" class=\"headerlink\" title=\"13.3 额外的模块解析标志\"></a>13.3 额外的模块解析标志</h2><p>一个项目的源代码内容有时与输出的内容不一致。通常情况下，一组构建步骤会产生最终的输出。这些步骤包括将 <code>.ts</code>文件编译成<code>.js</code>，并将不同的源文件位置的依赖关系复制到一个单一的输出位置。最终的结果是，模块在运行时的名称可能与包含其定义的源文件不同。或者最终输出中的模块路径可能与编译时对应的源文件路径不一致。</p>\n<p>TypeScript编译器有一组额外的标志，以<em>告知</em>编译器预计将发生在源文件上的转换，以生成最终的输出。</p>\n<p>值得注意的是，编译器<em>不会</em>执行任何这些转换；它只是使用这些信息来指导解析模块，导入到其定义文件的过程。</p>\n<h3 id=\"13-3-1-Base-URL\"><a href=\"#13-3-1-Base-URL\" class=\"headerlink\" title=\"13.3.1 Base URL\"></a>13.3.1 Base URL</h3><p>在使用AMD模块加载器的应用程序中，使用 <code>baseUrl</code> 是一种常见的做法，模块在运行时被 “部署”到一个文件夹。这些模块的来源可以在不同的目录中，但构建脚本会把它们放在一起。</p>\n<p>设置 <code>baseUrl</code> 会通知编译器在哪里找到模块。所有非相对名称的模块导入都被认为是相对于 <code>baseUr</code>的。</p>\n<p><em>baseUrl</em> 的值由以下两种情况决定：</p>\n<ul>\n<li><em>baseUrl</em> 命令行参数的值（如果给定的路径是相对的，它是基于当前目录计算的）</li>\n<li><code>tsconfig.json</code> 中的 <em>baseUrl</em> 属性值（如果给定的路径是相对的，则根据 <code>&#39;tsconfig.json&#39;</code> 的位置计算）</li>\n</ul>\n<p>请注意，相对模块的导入不受设置 baseUrl 的影响，因为它们总是相对于其导入文件进行解析。</p>\n<p>你可以在 <a href=\"http://requirejs.org/docs/api.html#config-baseUrl\">RequireJS</a> 和 <a href=\"https://github.com/systemjs/systemjs/blob/main/docs/api.md\">SystemJS</a> 文档中找到更多关于 baseUrl 的文档。</p>\n<h3 id=\"13-3-2-路径映射\"><a href=\"#13-3-2-路径映射\" class=\"headerlink\" title=\"13.3.2 路径映射\"></a>13.3.2 路径映射</h3><p>有时模块并不直接位于<em>baseUrl</em>下。例如，对模块 <code>&quot;jquery &quot;</code>的导入会在运行时被翻译成 <code>&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;</code>。装载器使用映射配置在运行时将模块名称映射到文件，见 <a href=\"http://requirejs.org/docs/api.html#config-paths\">RequireJs 文档</a>和 <a href=\"https://github.com/systemjs/systemjs/blob/main/docs/import-maps.md\">SystemJS 文档</a>。</p>\n<p>TypeScript编译器支持使用 <code>tsconfig.json</code> 文件中的 <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a> 属性来声明这种映射关系。下面是一个例子，说明如何为<code>jquery</code>指定 <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a> 属性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;baseUrl&quot;</span>: <span class=\"string\">&quot;.&quot;</span>, <span class=\"comment\">// 如果设置 &quot;paths&quot;，这个必须指定。</span></span><br><span class=\"line\">    <span class=\"string\">&quot;paths&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;jquery&quot;</span>: [<span class=\"string\">&quot;node_modules/jquery/dist/jquery&quot;</span>] <span class=\"comment\">// 这种映射是相对于 &quot;baseUrl&quot;而指定的。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Please notice that <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a> are resolved relative to <a href=\"https://www.typescriptlang.org/tsconfig#baseUrl\"><code>baseUrl</code></a>. When setting <a href=\"https://www.typescriptlang.org/tsconfig#baseUrl\"><code>baseUrl</code></a> to another value than <code>&quot;.&quot;</code>, i.e. the directory of <code>tsconfig.json</code>, the mappings must be changed accordingly. Say, you set <code>&quot;baseUrl&quot;: &quot;./src&quot;</code> in the above example, then jquery should be mapped to <code>&quot;../node_modules/jquery/dist/jquery&quot;</code>.</p>\n<p>Using <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a> also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:</p>\n<p>请注意，<code>paths</code> 是相对于 <code>baseUrl</code> 解析的。当设置 <code>baseUrl</code> 为 <code>&quot;.&quot;</code> 以外的其他值时，即 <code>tsconfig.json</code> 的目录，映射必须相应改变。比如，你把 <code>&quot;baseUrl &quot;</code>设置为<code> &quot;./src&quot;</code>，那么jquery应该被映射到<code>&quot;../node_modules/jquery/dist/jquery&quot;</code>。</p>\n<p>使用 <code>paths</code> 还可以实现更复杂的映射，包括多个回退位置。考虑一个项目的配置，其中只有一些模块在一个地方可用，而其他的在另一个地方。一个构建步骤会把它们放在一个地方。项目布局可能看起来像：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">projectRoot</span><br><span class=\"line\">├── folder1</span><br><span class=\"line\">│   ├── file1.ts (imports &#x27;folder1/file2&#x27; and &#x27;folder2/file3&#x27;)</span><br><span class=\"line\">│   └── file2.ts</span><br><span class=\"line\">├── generated</span><br><span class=\"line\">│   ├── folder1</span><br><span class=\"line\">│   └── folder2</span><br><span class=\"line\">│       └── file3.ts</span><br><span class=\"line\">└── tsconfig.json</span><br></pre></td></tr></table></figure>\n\n<p>相应的 <code>tsconfig.json</code> 将看起来像：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class=\"line\">    &quot;paths&quot;: &#123;</span><br><span class=\"line\">      &quot;*&quot;: [&quot;*&quot;, &quot;generated/*&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这告诉编译器对于任何符合 <code>&quot;*&quot;</code> 模式的模块导入（即所有值），要在两个地方寻找：</p>\n<ol>\n<li><code>&quot;*&quot;</code>: 意思是相同的名字不变，所以映射 <code>&lt;moduleName&gt;</code> &#x3D;&gt; <code>&lt;baseUrl&gt;/&lt;moduleName&gt;</code>。</li>\n<li><code>&quot;generated/*&quot;</code>：意思是模块名称有一个附加的前缀 “generated”，所以<code> &lt;moduleName&gt;</code> &#x3D;&gt; <code>&lt;baseUrl&gt;/generated/&lt;moduleName&gt;</code>。</li>\n</ol>\n<p>按照这个逻辑，编译器将试图将这两个导入解析为这样：</p>\n<p><code>import ‘folder1/file2’:</code></p>\n<ol>\n<li>模式<code>&#39;*&#39;</code>被匹配，通配符捕获了整个模块的名称</li>\n<li>尝试列表中的第一个替换：<code>&#39;*&#39;</code> -&gt; <code>folder1/file2</code></li>\n<li>替换的结果是非相对名称——与 <em>baseUrl</em> 结合 -&gt; <code>projectRoot/folder1/file2.ts</code>。</li>\n<li>文件存在。完成了。</li>\n</ol>\n<p><code>import ‘folder2/file3’:</code></p>\n<ol>\n<li>模式<code>&#39;*&#39;</code>被匹配，通配符捕获了整个模块的名称</li>\n<li>尝试列表中的第一个替换。<code>&#39;*&#39; </code>-&gt; <code>folder2/file3</code></li>\n<li>替换的结果是非相对名称 - 与 <em>baseUrl</em> 结合 -&gt; <code>projectRoot/folder2/file3.ts</code></li>\n<li>文件不存在，移到第二个替换项</li>\n<li>第二个替换 <code>&#39;generated/*&#39;</code> -&gt; <code>generated/folder2/file3</code></li>\n<li>替换的结果是非相对名称 - 与baseUrl结合 -&gt; projectRoot&#x2F;generated&#x2F;folder2&#x2F;file3.ts</li>\n<li>文件存在。完成了。</li>\n</ol>\n<h3 id=\"13-3-3-带有rootDirs的虚拟目录\"><a href=\"#13-3-3-带有rootDirs的虚拟目录\" class=\"headerlink\" title=\"13.3.3 带有rootDirs的虚拟目录\"></a>13.3.3 带有<code>rootDirs</code>的虚拟目录</h3><p>有时，在编译时来自多个目录的项目源都会被合并，以生成一个单一的输出目录。这可以被看作是一组源目录创建了一个 “虚拟 “目录。</p>\n<p>使用<code>rootDirs</code>，你可以告知编译器构成这个 “虚拟 “目录的根；因此，编译器可以在这些 “虚拟 “目录中解决相对模块的导入，就像它们被合并在一个目录中一样。</p>\n<p>例如，考虑这个项目结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src</span><br><span class=\"line\"> └── views</span><br><span class=\"line\">     └── view1.ts (imports &#x27;./template1&#x27;)</span><br><span class=\"line\">     └── view2.ts</span><br><span class=\"line\"></span><br><span class=\"line\"> generated</span><br><span class=\"line\"> └── templates</span><br><span class=\"line\">         └── views</span><br><span class=\"line\">             └── template1.ts (imports &#x27;./view2&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><code>src/views</code>中的文件是一些UI控件的用户代码。<code>generated/templates</code>中的文件是由模板生成器作为构建的一部分，自动生成的UI模板绑定代码。构建步骤会将<code>/src/views</code>和<code>/generated/templates/views</code>中的文件复制到输出的同一个目录中。在运行时，一个视图可以期望它的模板存在于它的旁边，因此应该使用 <code>&quot;./template &quot;</code>这样的相对名称来导入它。</p>\n<p>为了向编译器指定这种关系，可以使用 <code>rootDirs</code>。<code>rootDirs</code>指定了一个根的列表，这些根的内容在运行时被期望合并。所以按照我们的例子，<code>tsconfig.json</code>文件应该看起来像：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;rootDirs&quot;</span>: [<span class=\"string\">&quot;src/views&quot;</span>, <span class=\"string\">&quot;generated/templates/views&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每当编译器在其中一个 <code>rootDirs</code> 的子文件夹中看到一个相对的模块导入，它就会尝试在 <code>rootDirs</code> 的每个条目中寻找这个导入。</p>\n<p><code>rootDirs</code>的灵活性并不局限于，指定一个在逻辑上合并的物理源代码目录的列表。提供的数组可以包括任何数量的特别的、任意的目录名称，不管它们是否存在。这允许编译器以类型安全的方式捕获复杂的捆绑和运行时特征，如条件性包含和项目特定的加载器插件。</p>\n<p>考虑一个国际化的场景，构建工具通过插值一个特殊的路径标记，例如<code>#&#123;locale&#125;</code>，作为相对模块路径的一部分，如<code>./#&#123;locale&#125;/messages</code>，自动生成特定地域的捆绑。在这个假设的设置中，工具列举了支持的语言，将抽象的路径映射为<code>./zh/messages</code>，<code>./de/messages</code>，等等。</p>\n<p>假设这些模块中的每一个都导出一个字符串数组。例如，<code>./zh/messages</code>可能包含：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> [<span class=\"string\">&quot;您好吗&quot;</span>, <span class=\"string\">&quot;很高兴认识你&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>通过利用 <a href=\"https://www.typescriptlang.org/tsconfig#rootDirs\"><code>rootDirs</code></a> ，我们可以告知编译器这种映射，从而允许它安全地解析<code>./#&#123;locale&#125;/messages</code>，即使该目录永远不存在。例如，在下面的<code>tsconfig.json</code>中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;rootDirs&quot;</span>: [<span class=\"string\">&quot;src/zh&quot;</span>, <span class=\"string\">&quot;src/de&quot;</span>, <span class=\"string\">&quot;src/#&#123;locale&#125;&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器现在会将<code>import messages from &#39;./#&#123;locale&#125;/messages&#39;</code> 解析为 <code>import messages from &#39;./zh/messages&#39;</code> ，以便于在不影响设计时间支持的情况下，以与地区无关的方式开发。</p>\n<h2 id=\"13-4-追踪模块的解析\"><a href=\"#13-4-追踪模块的解析\" class=\"headerlink\" title=\"13.4 追踪模块的解析\"></a>13.4 追踪模块的解析</h2><p>如前所述，编译器在解析一个模块时可以访问当前文件夹以外的文件。这在诊断为什么一个模块没有被解析，或者被解析为一个不正确的定义时可能会很困难。使用 <a href=\"https://www.typescriptlang.org/tsconfig#traceResolution\"><code>traceResolution</code></a> 启用编译器模块解析跟踪，可以深入了解模块解析过程中发生了什么。</p>\n<p>假设我们有一个使用 <code>typescript</code> 模块的示例应用程序。<code>app.ts</code> 有一个类似 <code>import * as ts from &quot;typescript &quot;</code>的导入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   tsconfig.<span class=\"property\">json</span></span><br><span class=\"line\">├───node_modules</span><br><span class=\"line\">│   └───typescript</span><br><span class=\"line\">│       └───lib</span><br><span class=\"line\">│               typescript.<span class=\"property\">d</span>.<span class=\"property\">ts</span></span><br><span class=\"line\">└───src</span><br><span class=\"line\">        app.<span class=\"property\">ts</span></span><br></pre></td></tr></table></figure>\n\n<p>用 <a href=\"https://www.typescriptlang.org/tsconfig#traceResolution\"><code>traceResolution</code></a>调用编译器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --traceResolution</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">======== <span class=\"title class_\">Resolving</span> <span class=\"variable language_\">module</span> <span class=\"string\">&#x27;typescript&#x27;</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;src/app.ts&#x27;</span>. ========</span><br><span class=\"line\"><span class=\"title class_\">Module</span> resolution kind is not specified, <span class=\"keyword\">using</span> <span class=\"string\">&#x27;NodeJs&#x27;</span>.</span><br><span class=\"line\"><span class=\"title class_\">Loading</span> <span class=\"variable language_\">module</span> <span class=\"string\">&#x27;typescript&#x27;</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node_modules&#x27;</span> folder.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;src/node_modules/typescript.ts&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;src/node_modules/typescript.tsx&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;src/node_modules/typescript.d.ts&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;src/node_modules/typescript/package.json&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;node_modules/typescript.ts&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;node_modules/typescript.tsx&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;node_modules/typescript.d.ts&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">Found</span> <span class=\"string\">&#x27;package.json&#x27;</span> at <span class=\"string\">&#x27;node_modules/typescript/package.json&#x27;</span>.</span><br><span class=\"line\"><span class=\"string\">&#x27;package.json&#x27;</span> has <span class=\"string\">&#x27;types&#x27;</span> field <span class=\"string\">&#x27;./lib/typescript.d.ts&#x27;</span> that references <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span>.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span> exist - use it <span class=\"keyword\">as</span> a <span class=\"variable language_\">module</span> resolution result.</span><br><span class=\"line\">======== <span class=\"title class_\">Module</span> name <span class=\"string\">&#x27;typescript&#x27;</span> was successfully resolved to <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span>. ========</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的事项:</p>\n<ul>\n<li>导入的名称和位置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">======== 从&#x27;src/app.ts&#x27;中解析模块&#x27;typescript&#x27;。 ========</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器所遵循的策略是</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">未指定模块解析种类，使用&#x27;NodeJs&#x27;。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>从npm包中加载类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package.json&#x27;有&#x27;typescript&#x27;字段&#x27;./lib/typescript.d.ts&#x27;，引用&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>最终结果</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">======== 模块名称&#x27;typescript&#x27;已成功解析为&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;。========</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-5-应用-noResolve\"><a href=\"#13-5-应用-noResolve\" class=\"headerlink\" title=\"13.5 应用--noResolve\"></a>13.5 应用<code>--noResolve</code></h2><p>通常情况下，编译器在开始编译过程之前会尝试解析所有模块的导入。每当它成功地解析了一个文件的导入，该文件就被添加到编译器以后要处理的文件集合中。</p>\n<p><a href=\"https://www.typescriptlang.org/tsconfig#noResolve\"><code>noResolve</code></a> 编译器选项指示编译器不要 “添加 “任何未在命令行中传递的文件到编译中。它仍然会尝试将模块解析为文件，但如果没有指定文件，它将不会被包括在内。</p>\n<p>举个例子：</p>\n<p><strong>app.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> A <span class=\"keyword\">from</span> <span class=\"string\">&quot;moduleA&quot;</span>; <span class=\"comment\">// 正确，&#x27;moduleA&#x27;在命令行上通过了</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> B <span class=\"keyword\">from</span> <span class=\"string\">&quot;moduleB&quot;</span>; <span class=\"comment\">// 错误 TS2307: 无法找到模块&#x27;moduleB&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc app.ts moduleA.ts --noResolve</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>noResolve</code> 编译<code> app.t</code> 将导致：</p>\n<ul>\n<li>正确地找到模块A，因为它是在命令行上传递的。</li>\n<li>没有找到模块B，因为它没有被传递，所以出现错误。</li>\n</ul>\n<h2 id=\"13-6-常见问题\"><a href=\"#13-6-常见问题\" class=\"headerlink\" title=\"13.6 常见问题\"></a>13.6 常见问题</h2><p><strong>为什么排除列表中的模块仍然会被编译器选中？</strong></p>\n<p><code>tsconfig.json</code>将一个文件夹变成一个 “项目”。如果不指定任何<code> &quot;exclude &quot;</code>或 <code>&quot;files &quot;</code>条目，包含<code>tsconfig.json</code>的文件夹及其所有子目录中的所有文件都会包括在你的编译中。如果你想排除某些文件，使用 <code>&quot;exclude&quot;</code>，如果你想指定所有的文件，而不是让编译器去查找它们，使用 <code>&quot;files&quot;</code>。</p>\n<p>那是<code>tsconfig.json</code>的自动包含。这并没有嵌入上面讨论的模块解析。如果编译器将一个文件识别为模块导入的目标，它将被包含在编译中，不管它是否在前面的步骤中被排除。</p>\n<p>所以要从编译中排除一个文件，你需要排除它和所有有<code>import</code>或<code>/// &lt;reference path=&quot;...&quot; /&gt;</code>指令的文件。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>",
        "cover_type": "img",
        "excerpt": "",
        "more": "<h1 id=\"十三、模块解析\"><a href=\"#十三、模块解析\" class=\"headerlink\" title=\"十三、模块解析\"></a>十三、模块解析</h1><p><em>模块解析</em>是编译器用来分析一个导入什么的过程。考虑一个导入语句，如 <code>import &#123; a &#125; from &quot;moduleA&quot;；</code>为了检查对 <code>a</code> 的任何使用，编译器需要知道它到底代表什么，并需要检查它的定义 <code>moduleA</code>。</p>\n<p>在这一点上，编译器会问 “<code>moduleA</code>的形状是什么？” 虽然这听起来很简单，但 <code>moduleA</code> 可能被定义在你自己的一个<code>.ts</code>&#x2F;<code>.tsx</code>文件中，或者在你的代码所依赖的一个 <code>.d.ts</code> 中。</p>\n<p>首先，编译器将试图找到一个代表导入模块的文件。为了做到这一点，编译器遵循两种不同的策略之一。 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic\">Classic</a> or <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#node\">Node</a>。这些策略告诉编译器去哪里寻找模块A。</p>\n<p>如果这没有用，并且如果模块名称是非相对的（在 <code>&quot;moduleA&quot;</code>的情况下，它是相对的），那么编译器将尝试定位一个环境模块的声明。我们接下来会讨论非相对导入。</p>\n<p>最后，如果编译器不能解决该模块，它将记录一个错误。在这种情况下，错误会是这样的：<code>error TS2307: Cannot find module &#39;moduleA&#39;</code>。</p>\n<h2 id=\"13-1-相对与非相对的模块导入\"><a href=\"#13-1-相对与非相对的模块导入\" class=\"headerlink\" title=\"13.1 相对与非相对的模块导入\"></a>13.1 相对与非相对的模块导入</h2><p>模块导入是根据模块引用是相对的还是非相对的来解析的。</p>\n<p>相对导入是以<code>/</code>、<code>./</code>或<code>./</code>开头的导入。一些例子包括：</p>\n<ul>\n<li><code>import Entry from &quot;./components/Entry&quot;;</code></li>\n<li><code>import &#123; DefaultHeaders &#125; from &quot;../constants/http&quot;;</code></li>\n<li><code>import &quot;/mod&quot;;</code></li>\n</ul>\n<p>任何其他的导入都被认为是<strong>不相关</strong>的。一些例子包括：</p>\n<ul>\n<li><code>import * as $ from &quot;jquery&quot;;</code></li>\n<li><code>import &#123; Component &#125; from &quot;@angular/core&quot;;</code></li>\n</ul>\n<p>相对导入是相对于导入文件进行解析的，不能解析为环境模块的声明。你应该为你自己的模块使用相对导入，以保证在运行时保持其相对位置。</p>\n<p>非相对导入可以相对于 <a href=\"https://www.typescriptlang.org/tsconfig#baseUrl\"><code>baseUrl</code></a>来解析，也可以通过路径映射来解析，我们将在下面介绍。它们也可以解析为 <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules\">环境模块声明</a>。当导入你的任何外部依赖时，使用非相对路径。</p>\n<h2 id=\"13-2-模块解析策略\"><a href=\"#13-2-模块解析策略\" class=\"headerlink\" title=\"13.2 模块解析策略\"></a>13.2 模块解析策略</h2><p>有两种可能的模块解析策略。 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#node\">Node</a> 和 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic\">Classic</a>。你可以使用 <a href=\"https://www.typescriptlang.org/tsconfig#moduleResolution\"><code>moduleResolution</code></a> 选项来指定模块解析策略。如果没有指定，对于<code>--module commonjs</code>，默认为 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#node\">Node</a> ，否则为 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#classic\">Classic</a>（包括 <a href=\"https://www.typescriptlang.org/tsconfig#module\"><code>module</code></a> 设置为 <code>amd</code>、<code>system</code>、<code>umd</code>、<code>es2015</code>、<code>esnext</code>等时）。</p>\n<blockquote>\n<p>注意： node 模块解析是TypeScript社区中最常用的，并被推荐用于大多数项目。如果你在TypeScript的导入和导出中遇到解析问题，可以尝试设置 <code>moduleResolution：&quot;node&quot;</code>，看看是否能解决这个问题。</p>\n</blockquote>\n<h3 id=\"13-2-1-Classic\"><a href=\"#13-2-1-Classic\" class=\"headerlink\" title=\"13.2.1 Classic\"></a>13.2.1 Classic</h3><p>这曾经是TypeScript的默认解析策略。现在，这个策略主要是为了向后兼容而存在。</p>\n<p>一个相对导入将被解析为相对于导入文件。所以在源文件&#96;&#x2F;root&#x2F;src&#x2F;folder&#x2F;A.ts中从”.&#x2F;moduleB “导入{ b }会导致以下查找。</p>\n<p>所以在源文件 <code>/root/src/folder/A.ts</code> 中的 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code> 查找路径如下：</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n</ol>\n<p>然而，对于非相对的模块导入，编译器从包含导入文件的目录开始沿着目录树向上走，试图找到一个匹配的定义文件。</p>\n<p>例如：</p>\n<p>在源文件<code>/root/src/folder/A.ts</code>中，对于 <code>import &#123; b &#125; from &quot;moduleB&quot;</code>，会导致尝试在以下位置找到 <code>&quot;moduleB&quot;</code>:</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/moduleB.ts</code></li>\n<li><code>/root/moduleB.d.ts</code></li>\n<li><code>/moduleB.ts</code></li>\n<li><code>/moduleB.d.ts</code></li>\n</ol>\n<h3 id=\"13-2-2-Node\"><a href=\"#13-2-2-Node\" class=\"headerlink\" title=\"13.2.2 Node\"></a>13.2.2 Node</h3><p>这种解析策略试图在运行时模仿 <a href=\"https://nodejs.org/\">Node.js</a> 的模块解析机制。完整的Node.js解析算法在<a href=\"https://nodejs.org/api/modules.html#modules_all_together\">Node.js模块文档</a>中概述。</p>\n<ul>\n<li><strong>Node.js如何解析模块</strong></li>\n</ul>\n<p>为了理解TS编译器将遵循哪些步骤，有必要对Node.js模块进行一些说明。传统上，Node.js的导入是通过调用一个名为<code>require</code>的函数来完成的。Node.js采取的行为会有所不同，这取决于require是给出相对路径还是非相对路径。</p>\n<p>相对路径是相当直接的。举个例子，让我们考虑一个位于 <code>/root/src/moduleA.js</code> 的文件，其中包含 <code>import var x = require(&quot;./moduleB&quot;); </code>的模块导入，Node.js 按照以下顺序解析：</p>\n<ol>\n<li>询问名为 <code>/root/src/moduleB.js</code> 的是否存在。</li>\n<li>询问文件夹 <code>/root/src/moduleB</code> 是否包含一个名为 <code>package.json</code> 的文件，其中指定了一个 <code>&quot;main&quot;</code> 模块。在我们的例子中，如果Node.js发现文件 <code>/root/src/moduleB/package.json</code>包含 <code>&#123; &quot;main&quot;: &quot;lib/mainModule.js&quot; &#125;</code>，那么Node.js将引用 <code>/root/src/moduleB/lib/mainModule.js</code>。</li>\n<li>询问文件夹<code>/root/src/moduleB</code>是否包含一个名为<code>index.js</code>的文件。该文件被隐含地视为该文件夹的 “主”模块。</li>\n</ol>\n<p>你可以在Node.js文档中阅读更多关于 <a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">file 模块</a> 模块 <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">folder 模块</a>的内容。</p>\n<p>然而，非相关模块名称的解析是以不同方式进行的。Node将在名为 <code>node_modules</code> 的特殊文件夹中寻找你的模块。一个 <code>node_modules</code> 文件夹可以和当前文件在同一级别，也可以在目录链中更高的位置。Node将沿着目录链向上走，寻找每个 <code>node_modules</code>，直到找到你试图加载的模块。</p>\n<p>继续我们上面的例子，考虑一下如果 <code>/root/src/moduleA.js</code> 使用了一个非相对路径，并且有导入 <code>var x = require(&quot;moduleB&quot;);</code>。然后，Node会尝试将 <code>moduleB</code> 解析到每一个位置，直到有一个成功：</p>\n<ol>\n<li><p><code>/root/src/node_modules/moduleB.js</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/package.json</code> (如果 <code>&quot;main&quot;</code> 属性存在)</p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/index.js</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB.js</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/package.json</code> (如果 <code>&quot;main&quot;</code> 属性存在)</p>\n</li>\n<li><p><code>/root/node_modules/moduleB/index.js</code></p>\n</li>\n<li><p><code>/node_modules/moduleB.js</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/package.json</code> (如果 <code>&quot;main&quot; </code>属性存在)</p>\n</li>\n<li><p><code>/node_modules/moduleB/index.js</code></p>\n</li>\n</ol>\n<p>注意，Node.js在步骤（4）和（7）中跳出了本目录。</p>\n<p>你可以在Node.js文档中阅读更多关于 <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\">从<code>node_modules</code>加载模块的过程</a>。</p>\n<ul>\n<li><strong>TypeScript如何解决模块</strong></li>\n</ul>\n<p>TypeScript将模仿Node.js的运行时解析策略，以便在编译时找到模块的定义文件。为了实现这一点，TypeScript在Node的解析逻辑上叠加了TypeScript源文件扩展名（<code>.ts</code>、<code>.tsx</code>和<code>.d.ts</code>）。TypeScript还将使用<code>package.json</code>中一个名为<code>types</code>的字段来达到 <code>&quot;main&quot;</code>的目的——编译器将使用它来找到 “main “定义文件来查阅。</p>\n<p>例如，在 <code>/root/src/moduleA.ts</code> 中的 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code>，这样的导入语句会导致尝试在以下位置定位<code>&quot;./moduleB&quot;</code>。</p>\n<ol>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.tsx</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB/package.json</code> (如果 <code>types</code>属性存在)</li>\n<li><code>/root/src/moduleB/index.ts</code></li>\n<li><code>/root/src/moduleB/index.tsx</code></li>\n<li><code>/root/src/moduleB/index.d.ts</code></li>\n</ol>\n<p>回顾一下，Node.js寻找一个名为 <code>moduleB.js</code> 的文件，然后寻找一个适用的 <code>package.json</code>，然后寻找一个<code>index.js</code>。</p>\n<p>同样地，一个非相对的导入将遵循Node.js的解析逻辑，首先查找一个文件，然后查找一个适用的文件夹。因此，在源文件<code>/root/src/moduleA.ts</code>中的 <code>import &#123; b &#125; from &quot;moduleB&quot;</code>导致以下查找：</p>\n<ol>\n<li><p><code>/root/src/node_modules/moduleB.ts</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB.tsx</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/package.json</code> (如果 <code>types</code> 属性存在)</p>\n</li>\n<li><p><code>/root/src/node_modules/@types/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/index.ts</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/index.tsx</code></p>\n</li>\n<li><p><code>/root/src/node_modules/moduleB/index.d.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB.tsx</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/package.json</code> (如果 <code>types</code> 属性存在)</p>\n</li>\n<li><p><code>/root/node_modules/@types/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/index.ts</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/index.tsx</code></p>\n</li>\n<li><p><code>/root/node_modules/moduleB/index.d.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB.tsx</code></p>\n</li>\n<li><p><code>/node_modules/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/package.json</code> (如果 <code>types</code> 属性存在)</p>\n</li>\n<li><p><code>/node_modules/@types/moduleB.d.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/index.ts</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/index.tsx</code></p>\n</li>\n<li><p><code>/node_modules/moduleB/index.d.ts</code></p>\n</li>\n</ol>\n<p>不要被这里的步骤数量所吓倒——TypeScript仍然只是在步骤(9)和(17)上跳了两次目录。这其实并不比Node.js本身所做的更复杂。</p>\n<h2 id=\"13-3-额外的模块解析标志\"><a href=\"#13-3-额外的模块解析标志\" class=\"headerlink\" title=\"13.3 额外的模块解析标志\"></a>13.3 额外的模块解析标志</h2><p>一个项目的源代码内容有时与输出的内容不一致。通常情况下，一组构建步骤会产生最终的输出。这些步骤包括将 <code>.ts</code>文件编译成<code>.js</code>，并将不同的源文件位置的依赖关系复制到一个单一的输出位置。最终的结果是，模块在运行时的名称可能与包含其定义的源文件不同。或者最终输出中的模块路径可能与编译时对应的源文件路径不一致。</p>\n<p>TypeScript编译器有一组额外的标志，以<em>告知</em>编译器预计将发生在源文件上的转换，以生成最终的输出。</p>\n<p>值得注意的是，编译器<em>不会</em>执行任何这些转换；它只是使用这些信息来指导解析模块，导入到其定义文件的过程。</p>\n<h3 id=\"13-3-1-Base-URL\"><a href=\"#13-3-1-Base-URL\" class=\"headerlink\" title=\"13.3.1 Base URL\"></a>13.3.1 Base URL</h3><p>在使用AMD模块加载器的应用程序中，使用 <code>baseUrl</code> 是一种常见的做法，模块在运行时被 “部署”到一个文件夹。这些模块的来源可以在不同的目录中，但构建脚本会把它们放在一起。</p>\n<p>设置 <code>baseUrl</code> 会通知编译器在哪里找到模块。所有非相对名称的模块导入都被认为是相对于 <code>baseUr</code>的。</p>\n<p><em>baseUrl</em> 的值由以下两种情况决定：</p>\n<ul>\n<li><em>baseUrl</em> 命令行参数的值（如果给定的路径是相对的，它是基于当前目录计算的）</li>\n<li><code>tsconfig.json</code> 中的 <em>baseUrl</em> 属性值（如果给定的路径是相对的，则根据 <code>&#39;tsconfig.json&#39;</code> 的位置计算）</li>\n</ul>\n<p>请注意，相对模块的导入不受设置 baseUrl 的影响，因为它们总是相对于其导入文件进行解析。</p>\n<p>你可以在 <a href=\"http://requirejs.org/docs/api.html#config-baseUrl\">RequireJS</a> 和 <a href=\"https://github.com/systemjs/systemjs/blob/main/docs/api.md\">SystemJS</a> 文档中找到更多关于 baseUrl 的文档。</p>\n<h3 id=\"13-3-2-路径映射\"><a href=\"#13-3-2-路径映射\" class=\"headerlink\" title=\"13.3.2 路径映射\"></a>13.3.2 路径映射</h3><p>有时模块并不直接位于<em>baseUrl</em>下。例如，对模块 <code>&quot;jquery &quot;</code>的导入会在运行时被翻译成 <code>&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;</code>。装载器使用映射配置在运行时将模块名称映射到文件，见 <a href=\"http://requirejs.org/docs/api.html#config-paths\">RequireJs 文档</a>和 <a href=\"https://github.com/systemjs/systemjs/blob/main/docs/import-maps.md\">SystemJS 文档</a>。</p>\n<p>TypeScript编译器支持使用 <code>tsconfig.json</code> 文件中的 <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a> 属性来声明这种映射关系。下面是一个例子，说明如何为<code>jquery</code>指定 <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a> 属性。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;baseUrl&quot;</span>: <span class=\"string\">&quot;.&quot;</span>, <span class=\"comment\">// 如果设置 &quot;paths&quot;，这个必须指定。</span></span><br><span class=\"line\">    <span class=\"string\">&quot;paths&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;jquery&quot;</span>: [<span class=\"string\">&quot;node_modules/jquery/dist/jquery&quot;</span>] <span class=\"comment\">// 这种映射是相对于 &quot;baseUrl&quot;而指定的。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Please notice that <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a> are resolved relative to <a href=\"https://www.typescriptlang.org/tsconfig#baseUrl\"><code>baseUrl</code></a>. When setting <a href=\"https://www.typescriptlang.org/tsconfig#baseUrl\"><code>baseUrl</code></a> to another value than <code>&quot;.&quot;</code>, i.e. the directory of <code>tsconfig.json</code>, the mappings must be changed accordingly. Say, you set <code>&quot;baseUrl&quot;: &quot;./src&quot;</code> in the above example, then jquery should be mapped to <code>&quot;../node_modules/jquery/dist/jquery&quot;</code>.</p>\n<p>Using <a href=\"https://www.typescriptlang.org/tsconfig#paths\"><code>paths</code></a> also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:</p>\n<p>请注意，<code>paths</code> 是相对于 <code>baseUrl</code> 解析的。当设置 <code>baseUrl</code> 为 <code>&quot;.&quot;</code> 以外的其他值时，即 <code>tsconfig.json</code> 的目录，映射必须相应改变。比如，你把 <code>&quot;baseUrl &quot;</code>设置为<code> &quot;./src&quot;</code>，那么jquery应该被映射到<code>&quot;../node_modules/jquery/dist/jquery&quot;</code>。</p>\n<p>使用 <code>paths</code> 还可以实现更复杂的映射，包括多个回退位置。考虑一个项目的配置，其中只有一些模块在一个地方可用，而其他的在另一个地方。一个构建步骤会把它们放在一个地方。项目布局可能看起来像：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">projectRoot</span><br><span class=\"line\">├── folder1</span><br><span class=\"line\">│   ├── file1.ts (imports &#x27;folder1/file2&#x27; and &#x27;folder2/file3&#x27;)</span><br><span class=\"line\">│   └── file2.ts</span><br><span class=\"line\">├── generated</span><br><span class=\"line\">│   ├── folder1</span><br><span class=\"line\">│   └── folder2</span><br><span class=\"line\">│       └── file3.ts</span><br><span class=\"line\">└── tsconfig.json</span><br></pre></td></tr></table></figure>\n\n<p>相应的 <code>tsconfig.json</code> 将看起来像：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class=\"line\">    &quot;paths&quot;: &#123;</span><br><span class=\"line\">      &quot;*&quot;: [&quot;*&quot;, &quot;generated/*&quot;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这告诉编译器对于任何符合 <code>&quot;*&quot;</code> 模式的模块导入（即所有值），要在两个地方寻找：</p>\n<ol>\n<li><code>&quot;*&quot;</code>: 意思是相同的名字不变，所以映射 <code>&lt;moduleName&gt;</code> &#x3D;&gt; <code>&lt;baseUrl&gt;/&lt;moduleName&gt;</code>。</li>\n<li><code>&quot;generated/*&quot;</code>：意思是模块名称有一个附加的前缀 “generated”，所以<code> &lt;moduleName&gt;</code> &#x3D;&gt; <code>&lt;baseUrl&gt;/generated/&lt;moduleName&gt;</code>。</li>\n</ol>\n<p>按照这个逻辑，编译器将试图将这两个导入解析为这样：</p>\n<p><code>import ‘folder1/file2’:</code></p>\n<ol>\n<li>模式<code>&#39;*&#39;</code>被匹配，通配符捕获了整个模块的名称</li>\n<li>尝试列表中的第一个替换：<code>&#39;*&#39;</code> -&gt; <code>folder1/file2</code></li>\n<li>替换的结果是非相对名称——与 <em>baseUrl</em> 结合 -&gt; <code>projectRoot/folder1/file2.ts</code>。</li>\n<li>文件存在。完成了。</li>\n</ol>\n<p><code>import ‘folder2/file3’:</code></p>\n<ol>\n<li>模式<code>&#39;*&#39;</code>被匹配，通配符捕获了整个模块的名称</li>\n<li>尝试列表中的第一个替换。<code>&#39;*&#39; </code>-&gt; <code>folder2/file3</code></li>\n<li>替换的结果是非相对名称 - 与 <em>baseUrl</em> 结合 -&gt; <code>projectRoot/folder2/file3.ts</code></li>\n<li>文件不存在，移到第二个替换项</li>\n<li>第二个替换 <code>&#39;generated/*&#39;</code> -&gt; <code>generated/folder2/file3</code></li>\n<li>替换的结果是非相对名称 - 与baseUrl结合 -&gt; projectRoot&#x2F;generated&#x2F;folder2&#x2F;file3.ts</li>\n<li>文件存在。完成了。</li>\n</ol>\n<h3 id=\"13-3-3-带有rootDirs的虚拟目录\"><a href=\"#13-3-3-带有rootDirs的虚拟目录\" class=\"headerlink\" title=\"13.3.3 带有rootDirs的虚拟目录\"></a>13.3.3 带有<code>rootDirs</code>的虚拟目录</h3><p>有时，在编译时来自多个目录的项目源都会被合并，以生成一个单一的输出目录。这可以被看作是一组源目录创建了一个 “虚拟 “目录。</p>\n<p>使用<code>rootDirs</code>，你可以告知编译器构成这个 “虚拟 “目录的根；因此，编译器可以在这些 “虚拟 “目录中解决相对模块的导入，就像它们被合并在一个目录中一样。</p>\n<p>例如，考虑这个项目结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src</span><br><span class=\"line\"> └── views</span><br><span class=\"line\">     └── view1.ts (imports &#x27;./template1&#x27;)</span><br><span class=\"line\">     └── view2.ts</span><br><span class=\"line\"></span><br><span class=\"line\"> generated</span><br><span class=\"line\"> └── templates</span><br><span class=\"line\">         └── views</span><br><span class=\"line\">             └── template1.ts (imports &#x27;./view2&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p><code>src/views</code>中的文件是一些UI控件的用户代码。<code>generated/templates</code>中的文件是由模板生成器作为构建的一部分，自动生成的UI模板绑定代码。构建步骤会将<code>/src/views</code>和<code>/generated/templates/views</code>中的文件复制到输出的同一个目录中。在运行时，一个视图可以期望它的模板存在于它的旁边，因此应该使用 <code>&quot;./template &quot;</code>这样的相对名称来导入它。</p>\n<p>为了向编译器指定这种关系，可以使用 <code>rootDirs</code>。<code>rootDirs</code>指定了一个根的列表，这些根的内容在运行时被期望合并。所以按照我们的例子，<code>tsconfig.json</code>文件应该看起来像：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;rootDirs&quot;</span>: [<span class=\"string\">&quot;src/views&quot;</span>, <span class=\"string\">&quot;generated/templates/views&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每当编译器在其中一个 <code>rootDirs</code> 的子文件夹中看到一个相对的模块导入，它就会尝试在 <code>rootDirs</code> 的每个条目中寻找这个导入。</p>\n<p><code>rootDirs</code>的灵活性并不局限于，指定一个在逻辑上合并的物理源代码目录的列表。提供的数组可以包括任何数量的特别的、任意的目录名称，不管它们是否存在。这允许编译器以类型安全的方式捕获复杂的捆绑和运行时特征，如条件性包含和项目特定的加载器插件。</p>\n<p>考虑一个国际化的场景，构建工具通过插值一个特殊的路径标记，例如<code>#&#123;locale&#125;</code>，作为相对模块路径的一部分，如<code>./#&#123;locale&#125;/messages</code>，自动生成特定地域的捆绑。在这个假设的设置中，工具列举了支持的语言，将抽象的路径映射为<code>./zh/messages</code>，<code>./de/messages</code>，等等。</p>\n<p>假设这些模块中的每一个都导出一个字符串数组。例如，<code>./zh/messages</code>可能包含：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> [<span class=\"string\">&quot;您好吗&quot;</span>, <span class=\"string\">&quot;很高兴认识你&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>通过利用 <a href=\"https://www.typescriptlang.org/tsconfig#rootDirs\"><code>rootDirs</code></a> ，我们可以告知编译器这种映射，从而允许它安全地解析<code>./#&#123;locale&#125;/messages</code>，即使该目录永远不存在。例如，在下面的<code>tsconfig.json</code>中：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;rootDirs&quot;</span>: [<span class=\"string\">&quot;src/zh&quot;</span>, <span class=\"string\">&quot;src/de&quot;</span>, <span class=\"string\">&quot;src/#&#123;locale&#125;&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器现在会将<code>import messages from &#39;./#&#123;locale&#125;/messages&#39;</code> 解析为 <code>import messages from &#39;./zh/messages&#39;</code> ，以便于在不影响设计时间支持的情况下，以与地区无关的方式开发。</p>\n<h2 id=\"13-4-追踪模块的解析\"><a href=\"#13-4-追踪模块的解析\" class=\"headerlink\" title=\"13.4 追踪模块的解析\"></a>13.4 追踪模块的解析</h2><p>如前所述，编译器在解析一个模块时可以访问当前文件夹以外的文件。这在诊断为什么一个模块没有被解析，或者被解析为一个不正确的定义时可能会很困难。使用 <a href=\"https://www.typescriptlang.org/tsconfig#traceResolution\"><code>traceResolution</code></a> 启用编译器模块解析跟踪，可以深入了解模块解析过程中发生了什么。</p>\n<p>假设我们有一个使用 <code>typescript</code> 模块的示例应用程序。<code>app.ts</code> 有一个类似 <code>import * as ts from &quot;typescript &quot;</code>的导入。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   tsconfig.<span class=\"property\">json</span></span><br><span class=\"line\">├───node_modules</span><br><span class=\"line\">│   └───typescript</span><br><span class=\"line\">│       └───lib</span><br><span class=\"line\">│               typescript.<span class=\"property\">d</span>.<span class=\"property\">ts</span></span><br><span class=\"line\">└───src</span><br><span class=\"line\">        app.<span class=\"property\">ts</span></span><br></pre></td></tr></table></figure>\n\n<p>用 <a href=\"https://www.typescriptlang.org/tsconfig#traceResolution\"><code>traceResolution</code></a>调用编译器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc --traceResolution</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">======== <span class=\"title class_\">Resolving</span> <span class=\"variable language_\">module</span> <span class=\"string\">&#x27;typescript&#x27;</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;src/app.ts&#x27;</span>. ========</span><br><span class=\"line\"><span class=\"title class_\">Module</span> resolution kind is not specified, <span class=\"keyword\">using</span> <span class=\"string\">&#x27;NodeJs&#x27;</span>.</span><br><span class=\"line\"><span class=\"title class_\">Loading</span> <span class=\"variable language_\">module</span> <span class=\"string\">&#x27;typescript&#x27;</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node_modules&#x27;</span> folder.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;src/node_modules/typescript.ts&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;src/node_modules/typescript.tsx&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;src/node_modules/typescript.d.ts&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;src/node_modules/typescript/package.json&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;node_modules/typescript.ts&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;node_modules/typescript.tsx&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;node_modules/typescript.d.ts&#x27;</span> does not exist.</span><br><span class=\"line\"><span class=\"title class_\">Found</span> <span class=\"string\">&#x27;package.json&#x27;</span> at <span class=\"string\">&#x27;node_modules/typescript/package.json&#x27;</span>.</span><br><span class=\"line\"><span class=\"string\">&#x27;package.json&#x27;</span> has <span class=\"string\">&#x27;types&#x27;</span> field <span class=\"string\">&#x27;./lib/typescript.d.ts&#x27;</span> that references <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span>.</span><br><span class=\"line\"><span class=\"title class_\">File</span> <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span> exist - use it <span class=\"keyword\">as</span> a <span class=\"variable language_\">module</span> resolution result.</span><br><span class=\"line\">======== <span class=\"title class_\">Module</span> name <span class=\"string\">&#x27;typescript&#x27;</span> was successfully resolved to <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span>. ========</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的事项:</p>\n<ul>\n<li>导入的名称和位置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">======== 从&#x27;src/app.ts&#x27;中解析模块&#x27;typescript&#x27;。 ========</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器所遵循的策略是</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">未指定模块解析种类，使用&#x27;NodeJs&#x27;。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>从npm包中加载类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package.json&#x27;有&#x27;typescript&#x27;字段&#x27;./lib/typescript.d.ts&#x27;，引用&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>最终结果</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">======== 模块名称&#x27;typescript&#x27;已成功解析为&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;。========</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-5-应用-noResolve\"><a href=\"#13-5-应用-noResolve\" class=\"headerlink\" title=\"13.5 应用--noResolve\"></a>13.5 应用<code>--noResolve</code></h2><p>通常情况下，编译器在开始编译过程之前会尝试解析所有模块的导入。每当它成功地解析了一个文件的导入，该文件就被添加到编译器以后要处理的文件集合中。</p>\n<p><a href=\"https://www.typescriptlang.org/tsconfig#noResolve\"><code>noResolve</code></a> 编译器选项指示编译器不要 “添加 “任何未在命令行中传递的文件到编译中。它仍然会尝试将模块解析为文件，但如果没有指定文件，它将不会被包括在内。</p>\n<p>举个例子：</p>\n<p><strong>app.ts</strong></p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> A <span class=\"keyword\">from</span> <span class=\"string\">&quot;moduleA&quot;</span>; <span class=\"comment\">// 正确，&#x27;moduleA&#x27;在命令行上通过了</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> B <span class=\"keyword\">from</span> <span class=\"string\">&quot;moduleB&quot;</span>; <span class=\"comment\">// 错误 TS2307: 无法找到模块&#x27;moduleB&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tsc app.ts moduleA.ts --noResolve</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>noResolve</code> 编译<code> app.t</code> 将导致：</p>\n<ul>\n<li>正确地找到模块A，因为它是在命令行上传递的。</li>\n<li>没有找到模块B，因为它没有被传递，所以出现错误。</li>\n</ul>\n<h2 id=\"13-6-常见问题\"><a href=\"#13-6-常见问题\" class=\"headerlink\" title=\"13.6 常见问题\"></a>13.6 常见问题</h2><p><strong>为什么排除列表中的模块仍然会被编译器选中？</strong></p>\n<p><code>tsconfig.json</code>将一个文件夹变成一个 “项目”。如果不指定任何<code> &quot;exclude &quot;</code>或 <code>&quot;files &quot;</code>条目，包含<code>tsconfig.json</code>的文件夹及其所有子目录中的所有文件都会包括在你的编译中。如果你想排除某些文件，使用 <code>&quot;exclude&quot;</code>，如果你想指定所有的文件，而不是让编译器去查找它们，使用 <code>&quot;files&quot;</code>。</p>\n<p>那是<code>tsconfig.json</code>的自动包含。这并没有嵌入上面讨论的模块解析。如果编译器将一个文件识别为模块导入的目标，它将被包含在编译中，不管它是否在前面的步骤中被排除。</p>\n<p>所以要从编译中排除一个文件，你需要排除它和所有有<code>import</code>或<code>/// &lt;reference path=&quot;...&quot; /&gt;</code>指令的文件。</p>\n<h3 id=\"特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\"><a href=\"#特别声明-本文转自-古艺散人老师-，如有需要可前往原文预览查看。\" class=\"headerlink\" title=\"特别声明: 本文转自  古艺散人老师 ，如有需要可前往原文预览查看。\"></a>特别声明: 本文转自 <a href=\"https://github.com/lurongtao/TypeScript\"> 古艺散人老师 </a>，如有需要可前往原文预览查看。</h3>"
      }
    ],
    "PostAsset": [],
    "PostCategory": [
      {
        "post_id": "cmesvjany000894v3c4n6f43f",
        "category_id": "cmesvjanv000494v36d0yamuu",
        "_id": "cmesvjao4000v94v36kx29pqt"
      },
      {
        "post_id": "cmesvjany000894v3c4n6f43f",
        "category_id": "cmesvjao2000j94v3ghyv99qm",
        "_id": "cmesvjao5000y94v36pib4zup"
      },
      {
        "post_id": "cmesvjans000194v3cdfvfhsx",
        "category_id": "cmesvjanv000494v36d0yamuu",
        "_id": "cmesvjao5001194v3aykf3502"
      },
      {
        "post_id": "cmesvjans000194v3cdfvfhsx",
        "category_id": "cmesvjao2000j94v3ghyv99qm",
        "_id": "cmesvjao6001494v333j477fw"
      },
      {
        "post_id": "cmesvjany000994v3aur521wh",
        "category_id": "cmesvjanv000494v36d0yamuu",
        "_id": "cmesvjao6001794v3g59g5oox"
      },
      {
        "post_id": "cmesvjany000994v3aur521wh",
        "category_id": "cmesvjao2000j94v3ghyv99qm",
        "_id": "cmesvjao7001c94v3c2zy2j40"
      },
      {
        "post_id": "cmesvjanu000394v31brw0skq",
        "category_id": "cmesvjanv000494v36d0yamuu",
        "_id": "cmesvjao8001n94v307q431my"
      },
      {
        "post_id": "cmesvjanu000394v31brw0skq",
        "category_id": "cmesvjao2000j94v3ghyv99qm",
        "_id": "cmesvjao9001r94v33wv0fppj"
      },
      {
        "post_id": "cmesvjanx000794v315qwgjgv",
        "category_id": "cmesvjanv000494v36d0yamuu",
        "_id": "cmesvjaoc002794v30a7k4kvd"
      },
      {
        "post_id": "cmesvjanx000794v315qwgjgv",
        "category_id": "cmesvjao9001u94v3bt383u33",
        "_id": "cmesvjaoc002b94v3e3rrdixg"
      },
      {
        "post_id": "cmesvjao5001394v30prr82sy",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaof003994v36ix35phv"
      },
      {
        "post_id": "cmesvjao5001394v30prr82sy",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaof003c94v31z3y21j4"
      },
      {
        "post_id": "cmesvjanz000c94v3ctvv98jf",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaog003g94v38tu76v6z"
      },
      {
        "post_id": "cmesvjanz000c94v3ctvv98jf",
        "category_id": "cmesvjaof003594v33nhf7eh8",
        "_id": "cmesvjaog003i94v39j0mf6yc"
      },
      {
        "post_id": "cmesvjao6001694v33sws3l2v",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaog003m94v34duwfnvg"
      },
      {
        "post_id": "cmesvjao6001694v33sws3l2v",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaog003o94v33i6787eb"
      },
      {
        "post_id": "cmesvjao6001b94v3fqbkcj16",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaog003r94v37oym3ban"
      },
      {
        "post_id": "cmesvjao6001b94v3fqbkcj16",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaog003t94v301wl07ly"
      },
      {
        "post_id": "cmesvjao7001e94v3f2xe2ueb",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaog003w94v30gly88qu"
      },
      {
        "post_id": "cmesvjao7001e94v3f2xe2ueb",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaog003y94v32249cgc4"
      },
      {
        "post_id": "cmesvjao7001i94v375br1p4u",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoh004194v335zud3c9"
      },
      {
        "post_id": "cmesvjao7001i94v375br1p4u",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoh004394v395h575wv"
      },
      {
        "post_id": "cmesvjao0000d94v3ggi9et19",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoh004694v3fmmg8q6s"
      },
      {
        "post_id": "cmesvjao0000d94v3ggi9et19",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoh004894v3e7pc8hs9"
      },
      {
        "post_id": "cmesvjao8001k94v3ef8rbu5l",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoh004b94v336st4eo4"
      },
      {
        "post_id": "cmesvjao8001k94v3ef8rbu5l",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoh004d94v3a79l0s7m"
      },
      {
        "post_id": "cmesvjao8001p94v3cyyz8uyf",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoh004g94v30dxf5ehj"
      },
      {
        "post_id": "cmesvjao8001p94v3cyyz8uyf",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoh004i94v3cib97sw3"
      },
      {
        "post_id": "cmesvjao1000g94v317xp8scm",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoh004l94v37mwzfewz"
      },
      {
        "post_id": "cmesvjao1000g94v317xp8scm",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoh004n94v379lpfc1u"
      },
      {
        "post_id": "cmesvjao9001s94v345t85zx6",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoh004q94v3hgkyhijs"
      },
      {
        "post_id": "cmesvjao9001s94v345t85zx6",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoh004s94v3hhlyf04d"
      },
      {
        "post_id": "cmesvjao9001w94v35dngd4vo",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoi004v94v34rdd52qd"
      },
      {
        "post_id": "cmesvjao9001w94v35dngd4vo",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoi004x94v3a7882t64"
      },
      {
        "post_id": "cmesvjaoa001y94v35arw9as9",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoi005094v390x0ee0c"
      },
      {
        "post_id": "cmesvjaoa001y94v35arw9as9",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoi005294v33f825j9v"
      },
      {
        "post_id": "cmesvjaob002294v38bxi4enl",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoi005594v34n3mf3xv"
      },
      {
        "post_id": "cmesvjaob002294v38bxi4enl",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoi005794v3cvfzdmng"
      },
      {
        "post_id": "cmesvjao1000i94v37jpj8r7h",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoi005a94v3gvbkdl1h"
      },
      {
        "post_id": "cmesvjao1000i94v37jpj8r7h",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoi005c94v34so94kh9"
      },
      {
        "post_id": "cmesvjaob002494v3a6ishczd",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoi005f94v3gzw73eoz"
      },
      {
        "post_id": "cmesvjaob002494v3a6ishczd",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoi005g94v38wl17n1t"
      },
      {
        "post_id": "cmesvjaoc002994v3h48oc78u",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoi005i94v3606o35tc"
      },
      {
        "post_id": "cmesvjaoc002994v3h48oc78u",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoi005j94v32lhza013"
      },
      {
        "post_id": "cmesvjao2000m94v3120kdai9",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj005l94v3g3vtdcre"
      },
      {
        "post_id": "cmesvjao2000m94v3120kdai9",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj005m94v3fg2lc7hf"
      },
      {
        "post_id": "cmesvjaoc002c94v3hpc42qgc",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj005o94v334kk4rlk"
      },
      {
        "post_id": "cmesvjaoc002c94v3hpc42qgc",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj005p94v3hikn637r"
      },
      {
        "post_id": "cmesvjaod002g94v3gorrdo8t",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj005r94v38n4m0rsq"
      },
      {
        "post_id": "cmesvjaod002g94v3gorrdo8t",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj005s94v30pxb88k1"
      },
      {
        "post_id": "cmesvjao3000n94v3hfofdvv1",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj005u94v3dz264vp4"
      },
      {
        "post_id": "cmesvjao3000n94v3hfofdvv1",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj005v94v3abf8303i"
      },
      {
        "post_id": "cmesvjaod002i94v36cesfnt9",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj005x94v3a7t93whw"
      },
      {
        "post_id": "cmesvjaod002i94v36cesfnt9",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj005y94v3ha2u1pte"
      },
      {
        "post_id": "cmesvjao3000q94v31nwr0uli",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj006094v3dejmfv76"
      },
      {
        "post_id": "cmesvjao3000q94v31nwr0uli",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj006194v3d5zs8ls6"
      },
      {
        "post_id": "cmesvjao4000s94v3969ceik2",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj006394v3gmat6al5"
      },
      {
        "post_id": "cmesvjao4000s94v3969ceik2",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj006494v3fym09t4u"
      },
      {
        "post_id": "cmesvjao4000x94v30fobhc9a",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj006594v38va1hrof"
      },
      {
        "post_id": "cmesvjao4000x94v30fobhc9a",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj006694v35e1p5wma"
      },
      {
        "post_id": "cmesvjao5000z94v393mm5n9z",
        "category_id": "cmesvjao5001094v32emrf46y",
        "_id": "cmesvjaoj006794v3e3uq6ksn"
      },
      {
        "post_id": "cmesvjao5000z94v393mm5n9z",
        "category_id": "cmesvjaof003094v3ab8t1oso",
        "_id": "cmesvjaoj006894v38ls52l8d"
      }
    ],
    "PostTag": [
      {
        "post_id": "cmesvjans000194v3cdfvfhsx",
        "tag_id": "cmesvjanw000594v3dd5wb4w3",
        "_id": "cmesvjao1000h94v31l9n0qr3"
      },
      {
        "post_id": "cmesvjans000194v3cdfvfhsx",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjao2000k94v363rz7dbt"
      },
      {
        "post_id": "cmesvjanu000394v31brw0skq",
        "tag_id": "cmesvjanw000594v3dd5wb4w3",
        "_id": "cmesvjao4000r94v36wi74s66"
      },
      {
        "post_id": "cmesvjanu000394v31brw0skq",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjao4000t94v30fgdhdyc"
      },
      {
        "post_id": "cmesvjanx000794v315qwgjgv",
        "tag_id": "cmesvjao3000p94v3brog30yl",
        "_id": "cmesvjao6001594v36et8bx7f"
      },
      {
        "post_id": "cmesvjanx000794v315qwgjgv",
        "tag_id": "cmesvjanw000594v3dd5wb4w3",
        "_id": "cmesvjao6001894v36qngeo1o"
      },
      {
        "post_id": "cmesvjany000894v3c4n6f43f",
        "tag_id": "cmesvjanw000594v3dd5wb4w3",
        "_id": "cmesvjao7001d94v3hn403f5f"
      },
      {
        "post_id": "cmesvjany000894v3c4n6f43f",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjao7001f94v3c7q3fzno"
      },
      {
        "post_id": "cmesvjany000994v3aur521wh",
        "tag_id": "cmesvjanw000594v3dd5wb4w3",
        "_id": "cmesvjao8001j94v3g6t8b2hb"
      },
      {
        "post_id": "cmesvjany000994v3aur521wh",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjao8001l94v3gdmh31z2"
      },
      {
        "post_id": "cmesvjao7001i94v375br1p4u",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjao9001q94v34039hic2"
      },
      {
        "post_id": "cmesvjao7001i94v375br1p4u",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjao9001t94v3eqts2nbx"
      },
      {
        "post_id": "cmesvjao8001k94v3ef8rbu5l",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoa001x94v34z0xb0ma"
      },
      {
        "post_id": "cmesvjao8001k94v3ef8rbu5l",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoa001z94v3db5x8w1u"
      },
      {
        "post_id": "cmesvjao8001p94v3cyyz8uyf",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaob002394v313ldbxkp"
      },
      {
        "post_id": "cmesvjao8001p94v3cyyz8uyf",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaob002594v31hxscozp"
      },
      {
        "post_id": "cmesvjanz000c94v3ctvv98jf",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoc002a94v3dsrs7hqn"
      },
      {
        "post_id": "cmesvjanz000c94v3ctvv98jf",
        "tag_id": "cmesvjao3000p94v3brog30yl",
        "_id": "cmesvjaod002d94v3ctfvdg5l"
      },
      {
        "post_id": "cmesvjao9001s94v345t85zx6",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaod002h94v349zj4zap"
      },
      {
        "post_id": "cmesvjao9001s94v345t85zx6",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoe002j94v38p8oglhu"
      },
      {
        "post_id": "cmesvjao9001w94v35dngd4vo",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoe002m94v3h3u49vow"
      },
      {
        "post_id": "cmesvjao9001w94v35dngd4vo",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoe002n94v3f72c81h3"
      },
      {
        "post_id": "cmesvjao0000d94v3ggi9et19",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoe002q94v3cwgl6369"
      },
      {
        "post_id": "cmesvjao0000d94v3ggi9et19",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoe002r94v3hxquhrc1"
      },
      {
        "post_id": "cmesvjaoa001y94v35arw9as9",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoe002u94v3emakcnc5"
      },
      {
        "post_id": "cmesvjaoa001y94v35arw9as9",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoe002v94v32z94es3m"
      },
      {
        "post_id": "cmesvjaob002294v38bxi4enl",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaof002y94v3gjzy4myt"
      },
      {
        "post_id": "cmesvjaob002294v38bxi4enl",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaof002z94v3acljfkas"
      },
      {
        "post_id": "cmesvjao1000g94v317xp8scm",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaof003294v3g5wp55sz"
      },
      {
        "post_id": "cmesvjao1000g94v317xp8scm",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaof003394v35dh6di2q"
      },
      {
        "post_id": "cmesvjaob002494v3a6ishczd",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaof003694v39q9a03ch"
      },
      {
        "post_id": "cmesvjaob002494v3a6ishczd",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaof003794v3cpkp2537"
      },
      {
        "post_id": "cmesvjaoc002994v3h48oc78u",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaof003b94v34n5s0lbb"
      },
      {
        "post_id": "cmesvjaoc002994v3h48oc78u",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaof003d94v3b8zi3imr"
      },
      {
        "post_id": "cmesvjao1000i94v37jpj8r7h",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaog003h94v32i3sbqmp"
      },
      {
        "post_id": "cmesvjao1000i94v37jpj8r7h",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaog003j94v31nqw0yk6"
      },
      {
        "post_id": "cmesvjaoc002c94v3hpc42qgc",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaog003n94v3b4ppfec8"
      },
      {
        "post_id": "cmesvjaoc002c94v3hpc42qgc",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaog003p94v33kn0e2bt"
      },
      {
        "post_id": "cmesvjaod002g94v3gorrdo8t",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaog003s94v32feg8t4j"
      },
      {
        "post_id": "cmesvjaod002g94v3gorrdo8t",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaog003u94v35qaggjss"
      },
      {
        "post_id": "cmesvjao2000m94v3120kdai9",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaog003x94v360azdtwj"
      },
      {
        "post_id": "cmesvjao2000m94v3120kdai9",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaog003z94v3fr2s3pjo"
      },
      {
        "post_id": "cmesvjaod002i94v36cesfnt9",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoh004294v39q0wdtng"
      },
      {
        "post_id": "cmesvjaod002i94v36cesfnt9",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoh004494v3gqah9c8h"
      },
      {
        "post_id": "cmesvjao3000n94v3hfofdvv1",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoh004794v3c799am6b"
      },
      {
        "post_id": "cmesvjao3000n94v3hfofdvv1",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoh004994v3e4mi5z9z"
      },
      {
        "post_id": "cmesvjao3000q94v31nwr0uli",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoh004c94v35y3zfitv"
      },
      {
        "post_id": "cmesvjao3000q94v31nwr0uli",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoh004e94v3e8127ic4"
      },
      {
        "post_id": "cmesvjao4000s94v3969ceik2",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoh004h94v3hnj405m5"
      },
      {
        "post_id": "cmesvjao4000s94v3969ceik2",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoh004j94v3hkm23dfs"
      },
      {
        "post_id": "cmesvjao4000x94v30fobhc9a",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoh004m94v37pdx0v5n"
      },
      {
        "post_id": "cmesvjao4000x94v30fobhc9a",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoh004o94v3hhtv1by9"
      },
      {
        "post_id": "cmesvjao5000z94v393mm5n9z",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoh004r94v3g6dmaa1e"
      },
      {
        "post_id": "cmesvjao5000z94v393mm5n9z",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoi004t94v34flvgp5q"
      },
      {
        "post_id": "cmesvjao5001394v30prr82sy",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoi004w94v33sniary8"
      },
      {
        "post_id": "cmesvjao5001394v30prr82sy",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoi004y94v3g3lifggp"
      },
      {
        "post_id": "cmesvjao6001694v33sws3l2v",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoi005194v3h8ma6ard"
      },
      {
        "post_id": "cmesvjao6001694v33sws3l2v",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoi005394v3f9llh2ha"
      },
      {
        "post_id": "cmesvjao6001b94v3fqbkcj16",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoi005694v32sq63vjl"
      },
      {
        "post_id": "cmesvjao6001b94v3fqbkcj16",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoi005894v31t3uepw4"
      },
      {
        "post_id": "cmesvjao7001e94v3f2xe2ueb",
        "tag_id": "cmesvjao7001h94v3cqtz9mne",
        "_id": "cmesvjaoi005b94v3g62k0so0"
      },
      {
        "post_id": "cmesvjao7001e94v3f2xe2ueb",
        "tag_id": "cmesvjanz000b94v3fugi3he0",
        "_id": "cmesvjaoi005d94v33yft5e1p"
      }
    ],
    "Tag": [
      { "name": "フロントエンド", "_id": "cmesvjanw000594v3dd5wb4w3" },
      { "name": "TypeScript", "_id": "cmesvjanz000b94v3fugi3he0" },
      { "name": "Css", "_id": "cmesvjao3000p94v3brog30yl" },
      { "name": "前端", "_id": "cmesvjao7001h94v3cqtz9mne" }
    ]
  }
}
