# @anmx/request 包文档

## 1. 包简介

`@anmx/request` 是一个轻量级、功能丰富的 HTTP 请求库，基于浏览器原生 `fetch` API 封装，提供了拦截器、缓存、重试、请求去重等增强功能。

## 2. 目录结构

```
packages/request/
├── CHANGELOG.md
├── README.md
├── package.json
├── src/
│   ├── core.ts           # 核心请求实现
│   ├── index.ts          # 导出入口
│   ├── interceptors.ts   # 拦截器管理
│   ├── plugins/
│   │   ├── auth.ts       # 认证插件
│   │   ├── cache.ts      # 缓存插件
│   │   ├── errorHandler.ts # 错误处理插件
│   │   ├── logger.ts     # 日志插件
│   │   └── retry.ts      # 重试插件
│   └── types.ts          # 类型定义
└── tests/                # 测试文件
```

## 3. 核心功能

### 3.1 基础请求功能

提供了一个通用的 `request` 函数，封装了 `fetch` API，支持丰富的配置选项。

```typescript
import { request } from '@anmx/request';

const data = await request<UserData>('/api/users', {
  method: 'GET',
  timeout: 5000,
  cacheTime: 60000, // 缓存 1 分钟
  retry: 3, // 重试 3 次
});
```

### 3.2 HTTP 方法快捷函数

提供了常用 HTTP 方法的快捷调用方式：

- `http.get`
- `http.post`
- `http.put`
- `http.delete`

```typescript
import { http } from '@anmx/request';

// GET 请求
const users = await http.get<User[]>('/api/users');

// POST 请求（自动设置 Content-Type 和 JSON 序列化）
const createdUser = await http.post<User>('/api/users', { name: 'John', age: 30 });
```

### 3.3 拦截器系统

支持请求拦截和响应拦截，可用于统一处理请求头、身份验证、错误处理等。

```typescript
import { requestInterceptors, responseInterceptors } from '@anmx/request';

// 请求拦截器
requestInterceptors.use(async (url, options) => {
  // 修改 URL 或选项
  return [url, { ...options, headers: { ...options.headers, 'X-Custom': 'value' } }];
});

// 响应拦截器
responseInterceptors.use(async (response, url, options) => {
  // 处理响应数据
  return response;
});
```

## 4. 插件系统

### 4.1 认证插件 (auth)

自动为请求添加认证令牌，并在令牌过期时自动刷新。

```typescript
import { setupAuthPlugin } from '@anmx/request';

// 设置认证插件，提供刷新令牌的函数
setupAuthPlugin(async () => {
  // 从后端获取新的令牌
  const res = await fetch('/api/refresh-token');
  const data = await res.json();
  return data.token;
});
```

### 4.2 缓存插件 (cache)

提供请求缓存功能，可手动操作缓存。

```typescript
import { cacheAPI } from '@anmx/request';

// 手动获取缓存
const cachedData = cacheAPI.get<UserData>('user-123');

// 手动设置缓存（TTL 为 5 分钟）
cacheAPI.set('user-123', userData, 5 * 60 * 1000);

// 清除特定缓存
cacheAPI.clear('user-123');

// 清除所有缓存
cacheAPI.clear();
```

### 4.3 日志插件 (logger)

记录请求和响应信息，便于调试。

```typescript
import { setupLoggerPlugin } from '@anmx/request';

// 设置日志插件，可选配置日志级别
setupLoggerPlugin({ level: 'debug' }); // 'info' | 'debug' | 'warn' | 'error'
```

### 4.4 重试插件 (retry)

提供请求失败自动重试功能。

```typescript
import { retry } from '@anmx/request';

// 使用重试功能包装任意异步函数
const result = await retry(() => fetchData(), {
  retries: 3,
  delay: 300,
  factor: 2,
  shouldRetry: (error) => {
    // 只对网络错误重试
    return error instanceof Error && error.message.includes('Network');
  },
  onRetry: (error, attempt) => {
    console.log(`Retry attempt ${attempt}: ${error.message}`);
  },
});
```

### 4.5 错误处理插件 (errorHandler)

标准化错误处理，自动处理特定格式的错误响应。

```typescript
import { setupErrorHandlerPlugin } from '@anmx/request';

// 设置错误处理插件
setupErrorHandlerPlugin();
// 会自动处理返回 { error: true, message: '错误信息' } 或 { success: false } 格式的响应
```

## 5. 类型定义

### 5.1 RequestOptions

请求配置选项，扩展了原生的 `RequestInit`：

| 属性          | 类型          | 描述                 |
| ------------- | ------------- | -------------------- |
| baseURL       | string        | 请求基础 URL         |
| timeout       | number        | 超时时间（毫秒）     |
| cacheKey      | string        | 缓存键名             |
| cacheTime     | number        | 缓存时间（毫秒）     |
| cacheStrategy | CacheStrategy | 缓存策略             |
| forceRefresh  | boolean       | 是否强制刷新缓存     |
| dedupe        | boolean       | 是否启用请求去重     |
| retry         | number        | 重试次数             |
| retryDelay    | number        | 初始重试延迟（毫秒） |
| dedupeKey     | string        | 自定义去重键         |
| method        | string        | HTTP 方法            |
| body          | any           | 请求体               |

### 5.2 CacheStrategy

```typescript
export type CacheStrategy = 'no-cache' | 'cache-first' | 'network-first' | 'stale-while-revalidate';
```

### 5.3 拦截器类型

```typescript
// 请求拦截器类型
export type RequestInterceptor = (
  url: string,
  options: RequestOptions,
) => Promise<[string, RequestOptions]> | [string, RequestOptions];

// 响应拦截器类型
export type ResponseInterceptor<T = unknown> = (
  response: T,
  url: string,
  options: RequestOptions,
) => Promise<T> | T;
```

### 5.4 重试配置

```typescript
export interface RetryOptions {
  retries?: number; // 最大重试次数
  delay?: number; // 初始延迟 (ms)
  factor?: number; // 延迟增长因子
  shouldRetry?: (error: unknown) => boolean; // 判断是否重试
  onRetry?: (error: unknown, attempt: number) => void; // 每次重试回调
}
```

### 5.5 错误类型

```typescript
export interface SDKError extends Error {
  status?: number;
  url?: string;
  data?: unknown;
}
```

## 6. 高级功能

### 6.1 请求去重

自动合并短时间内相同的请求，避免重复请求服务器。

```typescript
// 短时间内发送相同的请求会被自动合并
const promise1 = request('/api/users');
const promise2 = request('/api/users');
// promise1 和 promise2 指向同一个 Promise 对象
```

### 6.2 超时处理

支持设置请求超时时间，超时后自动取消请求。

```typescript
request('/api/slow-endpoint', {
  timeout: 5000, // 5 秒后超时
});
```

### 6.3 指数退避重试

失败重试时使用指数退避算法，避免短时间内频繁重试。

```typescript
request('/api/unstable-endpoint', {
  retry: 3, // 重试 3 次
  retryDelay: 300, // 初始延迟 300ms
});
// 实际延迟时间: 300ms, 600ms, 1200ms
```

## 7. 使用示例

### 7.1 基础配置

```typescript
import { request, requestInterceptors } from '@anmx/request';

// 设置全局请求拦截器，添加基础 URL 和认证头
requestInterceptors.use((url, options) => {
  const baseURL = 'https://api.example.com';
  const token = localStorage.getItem('token');

  return [
    `${baseURL}${url}`,
    {
      ...options,
      headers: {
        ...options.headers,
        Authorization: token ? `Bearer ${token}` : '',
        'Content-Type': 'application/json',
      },
      timeout: 10000, // 全局超时设置
    },
  ];
});
```

### 7.2 完整使用流程

```typescript
import { http, setupAuthPlugin, setupLoggerPlugin, setupErrorHandlerPlugin } from '@anmx/request';

// 初始化插件
s.setupLoggerPlugin({ level: 'info' });
s.setupErrorHandlerPlugin();
s.setupAuthPlugin(async () => {
  const res = await fetch('/api/refresh-token');
  const data = await res.json();
  return data.token;
});

// 业务请求函数
async function fetchUserData(userId: string) {
  try {
    const user = await http.get<UserData>(`/api/users/${userId}`, {
      cacheTime: 60000, // 缓存 1 分钟
      retry: 2, // 重试 2 次
    });
    return user;
  } catch (error) {
    console.error('获取用户数据失败:', error);
    throw error;
  }
}

// 调用示例
async function updateUserProfile(userId: string, profile: Partial<UserData>) {
  try {
    const updatedUser = await http.put<UserData>(`/api/users/${userId}`, profile, { retry: 3 });
    // 更新成功后清除缓存
    cacheAPI.clear(`GET:/api/users/${userId}:{}`);
    return updatedUser;
  } catch (error) {
    console.error('更新用户资料失败:', error);
    throw error;
  }
}
```

## 8. API 参考

### 8.1 request 函数

```typescript
function request<T = unknown>(inputUrl: string, options?: RequestOptions): Promise<T>;
```

参数：

- `inputUrl`: 请求 URL
- `options`: 请求选项

返回值：

- `Promise<T>`: 解析为指定类型的 Promise

### 8.2 http 对象

```typescript
const http = {
  get: <T = unknown>(url: string, options?: RequestOptions) => Promise<T>,
  post: <T = unknown>(url: string, body?: unknown, options?: RequestOptions) => Promise<T>,
  put: <T = unknown>(url: string, body?: unknown, options?: RequestOptions) => Promise<T>,
  delete: <T = unknown>(url: string, options?: RequestOptions) => Promise<T>,
};
```

### 8.3 InterceptorManager 类

```typescript
class InterceptorManager<T> {
  use(handler: T): void;
  getHandlers(): T[];
  clear(): void;
}
```

### 8.4 插件函数

```typescript
// 认证插件
function setupAuthPlugin(refreshFn: () => Promise<string>): void

// 日志插件
function setupLoggerPlugin(opts?: { level?: 'info' | 'debug' | 'warn' | 'error' }): void

// 错误处理插件
function setupErrorHandlerPlugin(): void

// 重试函数
function retry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>

// 缓存 API
const cacheAPI = {
  get: <T = unknown>(key: string) => T | undefined,
  set: <T = unknown>(key: string, data: T, ttl: number) => void,
  clear: (key?: string) => void
}
```

## 9. 注意事项与最佳实践

1. **错误处理**：始终使用 try/catch 包装请求调用，以妥善处理网络错误、超时和后端返回的错误。

2. **认证管理**：使用 auth 插件统一管理认证令牌，并实现自动刷新机制，避免手动处理令牌逻辑。

3. **缓存策略**：合理设置缓存时间，对于频繁变化的数据应避免长时间缓存，或使用 `stale-while-revalidate` 策略。

4. **性能优化**：
   - 对频繁请求使用请求去重功能
   - 为网络不稳定的场景设置合理的重试次数和延迟
   - 避免设置过短的超时时间，以免误杀正常请求

5. **环境适配**：在不同环境中（开发/测试/生产）配置不同的基础 URL 和日志级别。

6. **类型安全**：充分利用 TypeScript 类型系统，为请求和响应定义明确的类型，提高代码的可维护性。
