name: CI/CD

on:
  pull_request:
    branches: [master]
  push:
    branches: [master]
  workflow_dispatch: # 手动触发部署

# 同一分支上的重复运行自动取消，更快
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  # 1) 变更分析：判断本次提交改了哪些目录
  changes:
    runs-on: ubuntu-latest
    outputs:
      web: ${{ steps.filter.outputs.web }}
      app1: ${{ steps.filter.outputs.app1 }}
      app2: ${{ steps.filter.outputs.app2 }}
      packages: ${{ steps.filter.outputs.packages }}
      has_changes: ${{ steps.filter.outputs.web == 'true' || steps.filter.outputs.app1 == 'true' || steps.filter.outputs.app2 == 'true' || steps.filter.outputs.packages == 'true' }}
    steps:
      - uses: actions/checkout@v4

      - name: Detect changed paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          filters: |
            web:
              - 'apps/web/**'
            app1:
              - 'apps/app1/**'
            app2:
              - 'apps/app2/**'
            packages:
              - 'packages/**'
              - 'pnpm-workspace.yaml'
              - 'package.json'
              - 'turbo.json'
              - 'tsconfig*.json'

  # 2) CI 验证 - 智能增量构建
  ci:
    needs: changes
    # 跳过没有实际变更的情况
    if: needs.changes.outputs.has_changes == 'true' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        include:
          - name: web
            condition: ${{ needs.changes.outputs.web == 'true' || needs.changes.outputs.packages == 'true' || github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
            filters: --filter web
            cache_key: turbo-web
            artifact: web-dist
            artifact_path: apps/web/dist
          - name: app1
            condition: ${{ needs.changes.outputs.app1 == 'true' || needs.changes.outputs.packages == 'true' || github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
            filters: --filter app1
            cache_key: turbo-app1
            artifact: app1-remote
            artifact_path: apps/app1/dist
          - name: app2
            condition: ${{ needs.changes.outputs.app2 == 'true' || needs.changes.outputs.packages == 'true' || github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
            filters: --filter app2
            cache_key: turbo-app2
            artifact: app2-remote
            artifact_path: apps/app2/dist
          - name: all
            condition: ${{ (needs.changes.outputs.app1 == 'true' && needs.changes.outputs.app2 == 'true') || (needs.changes.outputs.web == 'true' && (needs.changes.outputs.app1 == 'true' || needs.changes.outputs.app2 == 'true')) || github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
            filters: ''
            cache_key: turbo-all
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Enable Corepack (for pnpm)
        run: corepack enable

      - name: Install
        run: pnpm install --frozen-lockfile

      - name: Turbo cache
        uses: actions/cache@v4
        with:
          path: node_modules/.cache/turbo
          key: ${{ matrix.cache_key }}-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ matrix.cache_key }}-${{ runner.os }}-

      - name: Determine build scope
        id: scope
        run: |
          # PR 事件且不是全量构建时，使用矩阵中的 filters
          if [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ matrix.name }}" != "all" ]; then
            echo "BUILD_SCOPE=${{ matrix.filters }}" >> $GITHUB_OUTPUT
          else
            # push 事件或手动触发或需要全量构建时，构建所有
            echo "BUILD_SCOPE=" >> $GITHUB_OUTPUT
          fi

      - name: Lint
        run: pnpm lint ${{ steps.scope.outputs.BUILD_SCOPE }}

      - name: Typecheck
        run: pnpm typecheck ${{ steps.scope.outputs.BUILD_SCOPE }}

      - name: Build
        run: pnpm build ${{ steps.scope.outputs.BUILD_SCOPE }}

      - name: Test
        run: pnpm test ${{ steps.scope.outputs.BUILD_SCOPE }}

      - name: Upload artifacts
        if: matrix.artifact != '' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: ${{ matrix.artifact_path }}
          if-no-files-found: warn
          retention-days: 7

  # 3) Docker 打包 & 推送（仅手动触发）
  docker:
    runs-on: ubuntu-latest
    needs: [changes, ci]
    if: github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Enable Corepack (for pnpm)
        run: corepack enable

      - name: Install (for Docker build context)
        run: pnpm install --frozen-lockfile

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker images
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/web/Dockerfile
          tags: myorg/web:latest
          push: true
          build-args: |
            NODE_ENV=production
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push app1
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/app1/Dockerfile
          tags: myorg/app1:latest
          push: true
          build-args: |
            NODE_ENV=production

      - name: Build and push app2
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/app2/Dockerfile
          tags: myorg/app2:latest
          push: true
          build-args: |
            NODE_ENV=production
